(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        //Allow using this built library as an AMD module
        //in another project. That other project will only
        //see this AMD call, not the internal modules in
        //the closure below.
        define([], factory);
    } else {
        //Browser globals case. Just assign the
        //result to a property on the global.
        root.NavMesh = factory();
    }
}(this, function () {
    //almond, and your modules will be inlined here
/**
 * @license almond 0.3.0 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                name = baseParts.concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("../tools/build/almond", function(){});

/*! poly2tri v1.3.5 | (c) 2009-2014 Poly2Tri Contributors */
!function(t){if("object"==typeof exports)module.exports=t();else if("function"==typeof define&&define.amd)define('lib/poly2tri',t);else{var n;"undefined"!=typeof window?n=window:"undefined"!=typeof global?n=global:"undefined"!=typeof self&&(n=self),n.poly2tri=t()}}(function(){return function t(n,e,i){function o(s,p){if(!e[s]){if(!n[s]){var a="function"==typeof require&&require;if(!p&&a)return a(s,!0);if(r)return r(s,!0);throw new Error("Cannot find module '"+s+"'")}var h=e[s]={exports:{}};n[s][0].call(h.exports,function(t){var e=n[s][1][t];return o(e?e:t)},h,h.exports,t,n,e,i)}return e[s].exports}for(var r="function"==typeof require&&require,s=0;s<i.length;s++)o(i[s]);return o}({1:[function(t,n){n.exports={version:"1.3.5"}},{}],2:[function(t,n){var e=function(t,n){this.point=t,this.triangle=n||null,this.next=null,this.prev=null,this.value=t.x},i=function(t,n){this.head_=t,this.tail_=n,this.search_node_=t};i.prototype.head=function(){return this.head_},i.prototype.setHead=function(t){this.head_=t},i.prototype.tail=function(){return this.tail_},i.prototype.setTail=function(t){this.tail_=t},i.prototype.search=function(){return this.search_node_},i.prototype.setSearch=function(t){this.search_node_=t},i.prototype.findSearchNode=function(){return this.search_node_},i.prototype.locateNode=function(t){var n=this.search_node_;if(t<n.value){for(;n=n.prev;)if(t>=n.value)return this.search_node_=n,n}else for(;n=n.next;)if(t<n.value)return this.search_node_=n.prev,n.prev;return null},i.prototype.locatePoint=function(t){var n=t.x,e=this.findSearchNode(n),i=e.point.x;if(n===i){if(t!==e.point)if(t===e.prev.point)e=e.prev;else{if(t!==e.next.point)throw new Error("poly2tri Invalid AdvancingFront.locatePoint() call");e=e.next}}else if(i>n)for(;(e=e.prev)&&t!==e.point;);else for(;(e=e.next)&&t!==e.point;);return e&&(this.search_node_=e),e},n.exports=i,n.exports.Node=e},{}],3:[function(t,n){function e(t,n){if(!t)throw new Error(n||"Assert Failed")}n.exports=e},{}],4:[function(t,n){var e=t("./xy"),i=function(t,n){this.x=+t||0,this.y=+n||0,this._p2t_edge_list=null};i.prototype.toString=function(){return e.toStringBase(this)},i.prototype.toJSON=function(){return{x:this.x,y:this.y}},i.prototype.clone=function(){return new i(this.x,this.y)},i.prototype.set_zero=function(){return this.x=0,this.y=0,this},i.prototype.set=function(t,n){return this.x=+t||0,this.y=+n||0,this},i.prototype.negate=function(){return this.x=-this.x,this.y=-this.y,this},i.prototype.add=function(t){return this.x+=t.x,this.y+=t.y,this},i.prototype.sub=function(t){return this.x-=t.x,this.y-=t.y,this},i.prototype.mul=function(t){return this.x*=t,this.y*=t,this},i.prototype.length=function(){return Math.sqrt(this.x*this.x+this.y*this.y)},i.prototype.normalize=function(){var t=this.length();return this.x/=t,this.y/=t,t},i.prototype.equals=function(t){return this.x===t.x&&this.y===t.y},i.negate=function(t){return new i(-t.x,-t.y)},i.add=function(t,n){return new i(t.x+n.x,t.y+n.y)},i.sub=function(t,n){return new i(t.x-n.x,t.y-n.y)},i.mul=function(t,n){return new i(t*n.x,t*n.y)},i.cross=function(t,n){return"number"==typeof t?"number"==typeof n?t*n:new i(-t*n.y,t*n.x):"number"==typeof n?new i(n*t.y,-n*t.x):t.x*n.y-t.y*n.x},i.toString=e.toString,i.compare=e.compare,i.cmp=e.compare,i.equals=e.equals,i.dot=function(t,n){return t.x*n.x+t.y*n.y},n.exports=i},{"./xy":11}],5:[function(t,n){var e=t("./xy"),i=function(t,n){this.name="PointError",this.points=n=n||[],this.message=t||"Invalid Points!";for(var i=0;i<n.length;i++)this.message+=" "+e.toString(n[i])};i.prototype=new Error,i.prototype.constructor=i,n.exports=i},{"./xy":11}],6:[function(t,n,e){(function(n){var i=n.poly2tri;e.noConflict=function(){return n.poly2tri=i,e},e.VERSION=t("../dist/version.json").version,e.PointError=t("./pointerror"),e.Point=t("./point"),e.Triangle=t("./triangle"),e.SweepContext=t("./sweepcontext");var o=t("./sweep");e.triangulate=o.triangulate,e.sweep={Triangulate:o.triangulate}}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"../dist/version.json":1,"./point":4,"./pointerror":5,"./sweep":7,"./sweepcontext":8,"./triangle":9}],7:[function(t,n,e){function i(t){t.initTriangulation(),t.createAdvancingFront(),o(t),r(t)}function o(t){var n,e=t.pointCount();for(n=1;e>n;++n)for(var i=t.getPoint(n),o=s(t,i),r=i._p2t_edge_list,a=0;r&&a<r.length;++a)p(t,r[a],o)}function r(t){for(var n=t.front().head().next.triangle,e=t.front().head().next.point;!n.getConstrainedEdgeCW(e);)n=n.neighborCCW(e);t.meshClean(n)}function s(t,n){var e=t.locateNode(n),i=u(t,n,e);return n.x<=e.point.x+F&&d(t,e),g(t,i),i}function p(t,n,e){t.edge_event.constrained_edge=n,t.edge_event.right=n.p.x>n.q.x,h(e.triangle,n.p,n.q)||(C(t,n,e),a(t,n.p,n.q,e.triangle,n.q))}function a(t,n,e,i,o){if(!h(i,n,e)){var r=i.pointCCW(o),s=z(e,r,n);if(s===M.COLLINEAR)throw new D("poly2tri EdgeEvent: Collinear not supported!",[e,r,n]);var p=i.pointCW(o),u=z(e,p,n);if(u===M.COLLINEAR)throw new D("poly2tri EdgeEvent: Collinear not supported!",[e,p,n]);s===u?(i=s===M.CW?i.neighborCCW(o):i.neighborCW(o),a(t,n,e,i,o)):q(t,n,e,i,o)}}function h(t,n,e){var i=t.edgeIndex(n,e);if(-1!==i){t.markConstrainedEdgeByIndex(i);var o=t.getNeighbor(i);return o&&o.markConstrainedEdgeByPoints(n,e),!0}return!1}function u(t,n,e){var i=new O(n,e.point,e.next.point);i.markNeighbor(e.triangle),t.addToMap(i);var o=new B(n);return o.next=e.next,o.prev=e,e.next.prev=o,e.next=o,l(t,i)||t.mapTriangleToNodes(i),o}function d(t,n){var e=new O(n.prev.point,n.point,n.next.point);e.markNeighbor(n.prev.triangle),e.markNeighbor(n.triangle),t.addToMap(e),n.prev.next=n.next,n.next.prev=n.prev,l(t,e)||t.mapTriangleToNodes(e)}function g(t,n){for(var e=n.next;e.next&&!j(e.point,e.next.point,e.prev.point);)d(t,e),e=e.next;for(e=n.prev;e.prev&&!j(e.point,e.next.point,e.prev.point);)d(t,e),e=e.prev;n.next&&n.next.next&&f(n)&&y(t,n)}function f(t){var n=t.point.x-t.next.next.point.x,e=t.point.y-t.next.next.point.y;return S(e>=0,"unordered y"),n>=0||Math.abs(n)<e}function l(t,n){for(var e=0;3>e;++e)if(!n.delaunay_edge[e]){var i=n.getNeighbor(e);if(i){var o=n.getPoint(e),r=i.oppositePoint(n,o),s=i.index(r);if(i.constrained_edge[s]||i.delaunay_edge[s]){n.constrained_edge[e]=i.constrained_edge[s];continue}var p=c(o,n.pointCCW(o),n.pointCW(o),r);if(p){n.delaunay_edge[e]=!0,i.delaunay_edge[s]=!0,_(n,o,i,r);var a=!l(t,n);return a&&t.mapTriangleToNodes(n),a=!l(t,i),a&&t.mapTriangleToNodes(i),n.delaunay_edge[e]=!1,i.delaunay_edge[s]=!1,!0}}}return!1}function c(t,n,e,i){var o=t.x-i.x,r=t.y-i.y,s=n.x-i.x,p=n.y-i.y,a=o*p,h=s*r,u=a-h;if(0>=u)return!1;var d=e.x-i.x,g=e.y-i.y,f=d*r,l=o*g,c=f-l;if(0>=c)return!1;var _=s*g,y=d*p,x=o*o+r*r,v=s*s+p*p,C=d*d+g*g,b=x*(_-y)+v*c+C*u;return b>0}function _(t,n,e,i){var o,r,s,p;o=t.neighborCCW(n),r=t.neighborCW(n),s=e.neighborCCW(i),p=e.neighborCW(i);var a,h,u,d;a=t.getConstrainedEdgeCCW(n),h=t.getConstrainedEdgeCW(n),u=e.getConstrainedEdgeCCW(i),d=e.getConstrainedEdgeCW(i);var g,f,l,c;g=t.getDelaunayEdgeCCW(n),f=t.getDelaunayEdgeCW(n),l=e.getDelaunayEdgeCCW(i),c=e.getDelaunayEdgeCW(i),t.legalize(n,i),e.legalize(i,n),e.setDelaunayEdgeCCW(n,g),t.setDelaunayEdgeCW(n,f),t.setDelaunayEdgeCCW(i,l),e.setDelaunayEdgeCW(i,c),e.setConstrainedEdgeCCW(n,a),t.setConstrainedEdgeCW(n,h),t.setConstrainedEdgeCCW(i,u),e.setConstrainedEdgeCW(i,d),t.clearNeighbors(),e.clearNeighbors(),o&&e.markNeighbor(o),r&&t.markNeighbor(r),s&&t.markNeighbor(s),p&&e.markNeighbor(p),t.markNeighbor(e)}function y(t,n){for(t.basin.left_node=z(n.point,n.next.point,n.next.next.point)===M.CCW?n.next.next:n.next,t.basin.bottom_node=t.basin.left_node;t.basin.bottom_node.next&&t.basin.bottom_node.point.y>=t.basin.bottom_node.next.point.y;)t.basin.bottom_node=t.basin.bottom_node.next;if(t.basin.bottom_node!==t.basin.left_node){for(t.basin.right_node=t.basin.bottom_node;t.basin.right_node.next&&t.basin.right_node.point.y<t.basin.right_node.next.point.y;)t.basin.right_node=t.basin.right_node.next;t.basin.right_node!==t.basin.bottom_node&&(t.basin.width=t.basin.right_node.point.x-t.basin.left_node.point.x,t.basin.left_highest=t.basin.left_node.point.y>t.basin.right_node.point.y,x(t,t.basin.bottom_node))}}function x(t,n){if(!v(t,n)){d(t,n);var e;if(n.prev!==t.basin.left_node||n.next!==t.basin.right_node){if(n.prev===t.basin.left_node){if(e=z(n.point,n.next.point,n.next.next.point),e===M.CW)return;n=n.next}else if(n.next===t.basin.right_node){if(e=z(n.point,n.prev.point,n.prev.prev.point),e===M.CCW)return;n=n.prev}else n=n.prev.point.y<n.next.point.y?n.prev:n.next;x(t,n)}}}function v(t,n){var e;return e=t.basin.left_highest?t.basin.left_node.point.y-n.point.y:t.basin.right_node.point.y-n.point.y,t.basin.width>e?!0:!1}function C(t,n,e){t.edge_event.right?b(t,n,e):E(t,n,e)}function b(t,n,e){for(;e.next.point.x<n.p.x;)z(n.q,e.next.point,n.p)===M.CCW?m(t,n,e):e=e.next}function m(t,n,e){e.point.x<n.p.x&&(z(e.point,e.next.point,e.next.next.point)===M.CCW?W(t,n,e):(w(t,n,e),m(t,n,e)))}function W(t,n,e){d(t,e.next),e.next.point!==n.p&&z(n.q,e.next.point,n.p)===M.CCW&&z(e.point,e.next.point,e.next.next.point)===M.CCW&&W(t,n,e)}function w(t,n,e){z(e.next.point,e.next.next.point,e.next.next.next.point)===M.CCW?W(t,n,e.next):z(n.q,e.next.next.point,n.p)===M.CCW&&w(t,n,e.next)}function E(t,n,e){for(;e.prev.point.x>n.p.x;)z(n.q,e.prev.point,n.p)===M.CW?P(t,n,e):e=e.prev}function P(t,n,e){e.point.x>n.p.x&&(z(e.point,e.prev.point,e.prev.prev.point)===M.CW?T(t,n,e):(N(t,n,e),P(t,n,e)))}function N(t,n,e){z(e.prev.point,e.prev.prev.point,e.prev.prev.prev.point)===M.CW?T(t,n,e.prev):z(n.q,e.prev.prev.point,n.p)===M.CW&&N(t,n,e.prev)}function T(t,n,e){d(t,e.prev),e.prev.point!==n.p&&z(n.q,e.prev.point,n.p)===M.CW&&z(e.point,e.prev.point,e.prev.prev.point)===M.CW&&T(t,n,e)}function q(t,n,e,i,o){var r=i.neighborAcross(o);S(r,"FLIP failed due to missing triangle!");var s=r.oppositePoint(i,o);if(i.getConstrainedEdgeAcross(o)){var p=i.index(o);throw new D("poly2tri Intersecting Constraints",[o,s,i.getPoint((p+1)%3),i.getPoint((p+2)%3)])}if(H(o,i.pointCCW(o),i.pointCW(o),s))if(_(i,o,r,s),t.mapTriangleToNodes(i),t.mapTriangleToNodes(r),o===e&&s===n)e===t.edge_event.constrained_edge.q&&n===t.edge_event.constrained_edge.p&&(i.markConstrainedEdgeByPoints(n,e),r.markConstrainedEdgeByPoints(n,e),l(t,i),l(t,r));else{var h=z(e,s,n);i=I(t,h,i,r,o,s),q(t,n,e,i,o)}else{var u=k(n,e,r,s);A(t,n,e,i,r,u),a(t,n,e,i,o)}}function I(t,n,e,i,o,r){var s;return n===M.CCW?(s=i.edgeIndex(o,r),i.delaunay_edge[s]=!0,l(t,i),i.clearDelaunayEdges(),e):(s=e.edgeIndex(o,r),e.delaunay_edge[s]=!0,l(t,e),e.clearDelaunayEdges(),i)}function k(t,n,e,i){var o=z(n,i,t);if(o===M.CW)return e.pointCCW(i);if(o===M.CCW)return e.pointCW(i);throw new D("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!",[n,i,t])}function A(t,n,e,i,o,r){var s=o.neighborAcross(r);S(s,"FLIP failed due to missing triangle");var p=s.oppositePoint(o,r);if(H(e,i.pointCCW(e),i.pointCW(e),p))q(t,e,p,s,p);else{var a=k(n,e,s,p);A(t,n,e,i,s,a)}}var S=t("./assert"),D=t("./pointerror"),O=t("./triangle"),B=t("./advancingfront").Node,L=t("./utils"),F=L.EPSILON,M=L.Orientation,z=L.orient2d,H=L.inScanArea,j=L.isAngleObtuse;e.triangulate=i},{"./advancingfront":2,"./assert":3,"./pointerror":5,"./triangle":9,"./utils":10}],8:[function(t,n){var e=t("./pointerror"),i=t("./point"),o=t("./triangle"),r=t("./sweep"),s=t("./advancingfront"),p=s.Node,a=.3,h=function(t,n){if(this.p=t,this.q=n,t.y>n.y)this.q=t,this.p=n;else if(t.y===n.y)if(t.x>n.x)this.q=t,this.p=n;else if(t.x===n.x)throw new e("poly2tri Invalid Edge constructor: repeated points!",[t]);this.q._p2t_edge_list||(this.q._p2t_edge_list=[]),this.q._p2t_edge_list.push(this)},u=function(){this.left_node=null,this.bottom_node=null,this.right_node=null,this.width=0,this.left_highest=!1};u.prototype.clear=function(){this.left_node=null,this.bottom_node=null,this.right_node=null,this.width=0,this.left_highest=!1};var d=function(){this.constrained_edge=null,this.right=!1},g=function(t,n){n=n||{},this.triangles_=[],this.map_=[],this.points_=n.cloneArrays?t.slice(0):t,this.edge_list=[],this.pmin_=this.pmax_=null,this.front_=null,this.head_=null,this.tail_=null,this.af_head_=null,this.af_middle_=null,this.af_tail_=null,this.basin=new u,this.edge_event=new d,this.initEdges(this.points_)};g.prototype.addHole=function(t){this.initEdges(t);var n,e=t.length;for(n=0;e>n;n++)this.points_.push(t[n]);return this},g.prototype.AddHole=g.prototype.addHole,g.prototype.addHoles=function(t){var n,e=t.length;for(n=0;e>n;n++)this.initEdges(t[n]);return this.points_=this.points_.concat.apply(this.points_,t),this},g.prototype.addPoint=function(t){return this.points_.push(t),this},g.prototype.AddPoint=g.prototype.addPoint,g.prototype.addPoints=function(t){return this.points_=this.points_.concat(t),this},g.prototype.triangulate=function(){return r.triangulate(this),this},g.prototype.getBoundingBox=function(){return{min:this.pmin_,max:this.pmax_}},g.prototype.getTriangles=function(){return this.triangles_},g.prototype.GetTriangles=g.prototype.getTriangles,g.prototype.front=function(){return this.front_},g.prototype.pointCount=function(){return this.points_.length},g.prototype.head=function(){return this.head_},g.prototype.setHead=function(t){this.head_=t},g.prototype.tail=function(){return this.tail_},g.prototype.setTail=function(t){this.tail_=t},g.prototype.getMap=function(){return this.map_},g.prototype.initTriangulation=function(){var t,n=this.points_[0].x,e=this.points_[0].x,o=this.points_[0].y,r=this.points_[0].y,s=this.points_.length;for(t=1;s>t;t++){var p=this.points_[t];p.x>n&&(n=p.x),p.x<e&&(e=p.x),p.y>o&&(o=p.y),p.y<r&&(r=p.y)}this.pmin_=new i(e,r),this.pmax_=new i(n,o);var h=a*(n-e),u=a*(o-r);this.head_=new i(n+h,r-u),this.tail_=new i(e-h,r-u),this.points_.sort(i.compare)},g.prototype.initEdges=function(t){var n,e=t.length;for(n=0;e>n;++n)this.edge_list.push(new h(t[n],t[(n+1)%e]))},g.prototype.getPoint=function(t){return this.points_[t]},g.prototype.addToMap=function(t){this.map_.push(t)},g.prototype.locateNode=function(t){return this.front_.locateNode(t.x)},g.prototype.createAdvancingFront=function(){var t,n,e,i=new o(this.points_[0],this.tail_,this.head_);this.map_.push(i),t=new p(i.getPoint(1),i),n=new p(i.getPoint(0),i),e=new p(i.getPoint(2)),this.front_=new s(t,e),t.next=n,n.next=e,n.prev=t,e.prev=n},g.prototype.removeNode=function(){},g.prototype.mapTriangleToNodes=function(t){for(var n=0;3>n;++n)if(!t.getNeighbor(n)){var e=this.front_.locatePoint(t.pointCW(t.getPoint(n)));e&&(e.triangle=t)}},g.prototype.removeFromMap=function(t){var n,e=this.map_,i=e.length;for(n=0;i>n;n++)if(e[n]===t){e.splice(n,1);break}},g.prototype.meshClean=function(t){for(var n,e,i=[t];n=i.pop();)if(!n.isInterior())for(n.setInterior(!0),this.triangles_.push(n),e=0;3>e;e++)n.constrained_edge[e]||i.push(n.getNeighbor(e))},n.exports=g},{"./advancingfront":2,"./point":4,"./pointerror":5,"./sweep":7,"./triangle":9}],9:[function(t,n){var e=t("./xy"),i=function(t,n,e){this.points_=[t,n,e],this.neighbors_=[null,null,null],this.interior_=!1,this.constrained_edge=[!1,!1,!1],this.delaunay_edge=[!1,!1,!1]},o=e.toString;i.prototype.toString=function(){return"["+o(this.points_[0])+o(this.points_[1])+o(this.points_[2])+"]"},i.prototype.getPoint=function(t){return this.points_[t]},i.prototype.GetPoint=i.prototype.getPoint,i.prototype.getPoints=function(){return this.points_},i.prototype.getNeighbor=function(t){return this.neighbors_[t]},i.prototype.containsPoint=function(t){var n=this.points_;return t===n[0]||t===n[1]||t===n[2]},i.prototype.containsEdge=function(t){return this.containsPoint(t.p)&&this.containsPoint(t.q)},i.prototype.containsPoints=function(t,n){return this.containsPoint(t)&&this.containsPoint(n)},i.prototype.isInterior=function(){return this.interior_},i.prototype.setInterior=function(t){return this.interior_=t,this},i.prototype.markNeighborPointers=function(t,n,e){var i=this.points_;if(t===i[2]&&n===i[1]||t===i[1]&&n===i[2])this.neighbors_[0]=e;else if(t===i[0]&&n===i[2]||t===i[2]&&n===i[0])this.neighbors_[1]=e;else{if(!(t===i[0]&&n===i[1]||t===i[1]&&n===i[0]))throw new Error("poly2tri Invalid Triangle.markNeighborPointers() call");this.neighbors_[2]=e}},i.prototype.markNeighbor=function(t){var n=this.points_;t.containsPoints(n[1],n[2])?(this.neighbors_[0]=t,t.markNeighborPointers(n[1],n[2],this)):t.containsPoints(n[0],n[2])?(this.neighbors_[1]=t,t.markNeighborPointers(n[0],n[2],this)):t.containsPoints(n[0],n[1])&&(this.neighbors_[2]=t,t.markNeighborPointers(n[0],n[1],this))},i.prototype.clearNeighbors=function(){this.neighbors_[0]=null,this.neighbors_[1]=null,this.neighbors_[2]=null},i.prototype.clearDelaunayEdges=function(){this.delaunay_edge[0]=!1,this.delaunay_edge[1]=!1,this.delaunay_edge[2]=!1},i.prototype.pointCW=function(t){var n=this.points_;return t===n[0]?n[2]:t===n[1]?n[0]:t===n[2]?n[1]:null},i.prototype.pointCCW=function(t){var n=this.points_;return t===n[0]?n[1]:t===n[1]?n[2]:t===n[2]?n[0]:null},i.prototype.neighborCW=function(t){return t===this.points_[0]?this.neighbors_[1]:t===this.points_[1]?this.neighbors_[2]:this.neighbors_[0]},i.prototype.neighborCCW=function(t){return t===this.points_[0]?this.neighbors_[2]:t===this.points_[1]?this.neighbors_[0]:this.neighbors_[1]},i.prototype.getConstrainedEdgeCW=function(t){return t===this.points_[0]?this.constrained_edge[1]:t===this.points_[1]?this.constrained_edge[2]:this.constrained_edge[0]},i.prototype.getConstrainedEdgeCCW=function(t){return t===this.points_[0]?this.constrained_edge[2]:t===this.points_[1]?this.constrained_edge[0]:this.constrained_edge[1]},i.prototype.getConstrainedEdgeAcross=function(t){return t===this.points_[0]?this.constrained_edge[0]:t===this.points_[1]?this.constrained_edge[1]:this.constrained_edge[2]},i.prototype.setConstrainedEdgeCW=function(t,n){t===this.points_[0]?this.constrained_edge[1]=n:t===this.points_[1]?this.constrained_edge[2]=n:this.constrained_edge[0]=n},i.prototype.setConstrainedEdgeCCW=function(t,n){t===this.points_[0]?this.constrained_edge[2]=n:t===this.points_[1]?this.constrained_edge[0]=n:this.constrained_edge[1]=n},i.prototype.getDelaunayEdgeCW=function(t){return t===this.points_[0]?this.delaunay_edge[1]:t===this.points_[1]?this.delaunay_edge[2]:this.delaunay_edge[0]},i.prototype.getDelaunayEdgeCCW=function(t){return t===this.points_[0]?this.delaunay_edge[2]:t===this.points_[1]?this.delaunay_edge[0]:this.delaunay_edge[1]},i.prototype.setDelaunayEdgeCW=function(t,n){t===this.points_[0]?this.delaunay_edge[1]=n:t===this.points_[1]?this.delaunay_edge[2]=n:this.delaunay_edge[0]=n},i.prototype.setDelaunayEdgeCCW=function(t,n){t===this.points_[0]?this.delaunay_edge[2]=n:t===this.points_[1]?this.delaunay_edge[0]=n:this.delaunay_edge[1]=n},i.prototype.neighborAcross=function(t){return t===this.points_[0]?this.neighbors_[0]:t===this.points_[1]?this.neighbors_[1]:this.neighbors_[2]},i.prototype.oppositePoint=function(t,n){var e=t.pointCW(n);return this.pointCW(e)},i.prototype.legalize=function(t,n){var e=this.points_;if(t===e[0])e[1]=e[0],e[0]=e[2],e[2]=n;else if(t===e[1])e[2]=e[1],e[1]=e[0],e[0]=n;else{if(t!==e[2])throw new Error("poly2tri Invalid Triangle.legalize() call");e[0]=e[2],e[2]=e[1],e[1]=n}},i.prototype.index=function(t){var n=this.points_;if(t===n[0])return 0;if(t===n[1])return 1;if(t===n[2])return 2;throw new Error("poly2tri Invalid Triangle.index() call")},i.prototype.edgeIndex=function(t,n){var e=this.points_;if(t===e[0]){if(n===e[1])return 2;if(n===e[2])return 1}else if(t===e[1]){if(n===e[2])return 0;if(n===e[0])return 2}else if(t===e[2]){if(n===e[0])return 1;if(n===e[1])return 0}return-1},i.prototype.markConstrainedEdgeByIndex=function(t){this.constrained_edge[t]=!0},i.prototype.markConstrainedEdgeByEdge=function(t){this.markConstrainedEdgeByPoints(t.p,t.q)},i.prototype.markConstrainedEdgeByPoints=function(t,n){var e=this.points_;n===e[0]&&t===e[1]||n===e[1]&&t===e[0]?this.constrained_edge[2]=!0:n===e[0]&&t===e[2]||n===e[2]&&t===e[0]?this.constrained_edge[1]=!0:(n===e[1]&&t===e[2]||n===e[2]&&t===e[1])&&(this.constrained_edge[0]=!0)},n.exports=i},{"./xy":11}],10:[function(t,n,e){function i(t,n,e){var i=(t.x-e.x)*(n.y-e.y),o=(t.y-e.y)*(n.x-e.x),r=i-o;return r>-s&&s>r?p.COLLINEAR:r>0?p.CCW:p.CW}function o(t,n,e,i){var o=(t.x-n.x)*(i.y-n.y)-(i.x-n.x)*(t.y-n.y);if(o>=-s)return!1;var r=(t.x-e.x)*(i.y-e.y)-(i.x-e.x)*(t.y-e.y);return s>=r?!1:!0}function r(t,n,e){var i=n.x-t.x,o=n.y-t.y,r=e.x-t.x,s=e.y-t.y;return 0>i*r+o*s}var s=1e-12;e.EPSILON=s;var p={CW:1,CCW:-1,COLLINEAR:0};e.Orientation=p,e.orient2d=i,e.inScanArea=o,e.isAngleObtuse=r},{}],11:[function(t,n){function e(t){return"("+t.x+";"+t.y+")"}function i(t){var n=t.toString();return"[object Object]"===n?e(t):n}function o(t,n){return t.y===n.y?t.x-n.x:t.y-n.y}function r(t,n){return t.x===n.x&&t.y===n.y}n.exports={toString:i,toStringBase:e,compare:o,equals:r}},{}]},{},[6])(6)});

define('polypartition',["./lib/poly2tri"],
function(poly2tri) {
  // Adapted/copied from https://code.google.com/p/polypartition/
  var exports = {};
  /*
   * A point represents a vertex in a 2d environment.
   */
  Point = function(x, y) {
    this.x = x;
    this.y = y;
  }
  exports.Point = Point;

  /**
   * Takes a point or scalar and adds slotwise in the case of another
   * point, or to each parameter in the case of a scalar.
   * @param {(Point|number)} - The Point, or scalar, to add to this
   *   point.
   */
  Point.prototype.add = function(p) {
    if (typeof p == "number")
      return new Point(this.x + p, this.y + p);
    return new Point(this.x + p.x, this.y + p.y);
  }

  /**
   * Takes a point or scalar and subtracts slotwise in the case of
   * another point or from each parameter in the case of a scalar.
   * @param {(Point|number)} - The Point, or scalar, to subtract from
   *   this point.
   */
  Point.prototype.sub = function(p) {
    if (typeof p == "number")
      return new Point(this.x - p, this.y - p);
    return new Point(this.x - p.x, this.y - p.y);
  }

  Point.prototype.mul = function(f) {
    return new Point(this.x * f, this.y * f);
  }

  Point.prototype.div = function(f) {
    return new Point(this.x / f, this.y / f);
  }

  Point.prototype.eq = function(p) {
    return (this.x == p.x && this.y == p.y);
  }

  Point.prototype.neq = function(p) {
    return (this.x != p.x || this.y != p.y);
  }

  // Given another point, returns the dot product.
  Point.prototype.dot = function(p) {
    return (this.x * p.x + this.y * p.y);
  }

  // Given another point, returns the 'cross product', or at least the 2d
  // equivalent.
  Point.prototype.cross = function(p) {
    return (this.x * p.y - this.y * p.x);
  }

  // Given another point, returns the distance to that point.
  Point.prototype.dist = function(p) {
    var diff = this.sub(p);
    return Math.sqrt(diff.dot(diff));
  }

  // Given another point, returns the squared distance to that point.
  Point.prototype.dist2 = function(p) {
    var diff = this.sub(p);
    return diff.dot(diff);
  }

  /**
   * Returns true if the point is (0, 0).
   * @return {boolean} - Whether or not the point is (0, 0).
   */
  Point.prototype.zero = function() {
    return this.x == 0 && this.y == 0;
  }

  Point.prototype.len = function() {
    return this.dist(new Point(0, 0));
  }

  Point.prototype.normalize = function() {
    var n = this.dist(new Point(0, 0));
    if (n > 0) return this.div(n);
    return new Point(0, 0);
  }

  Point.prototype.toString = function() {
    return 'x' + this.x + 'y' + this.y;
  }

  //// EDGE ////
  // Edges are used to represent the border between two adjacent
  // polygons.
  Edge = function(p1, p2) {
    this.p1 = p1;
    this.p2 = p2;
    this.center = p1.add(p2.sub(p1).div(2));
    this.points = [this.p1, this.center, this.p2];
  }
  exports.Edge = Edge;

  Edge.prototype._CCW = function(p1, p2, p3) {
    a = p1.x; b = p1.y;
    c = p2.x; d = p2.y;
    e = p3.x; f = p3.y;
    return (f - b) * (c - a) > (d - b) * (e - a);
  }

  // from http://stackoverflow.com/a/16725715
  Edge.prototype.intersects = function(edge) {
    var q1 = edge.p1, q2 = edge.p2;
    if (q1.eq(this.p1) || q1.eq(this.p2) || q2.eq(this.p1) || q2.eq(this.p2)) return false;
    return (this._CCW(this.p1, q1, q2) != this._CCW(this.p2, q1, q2)) && (this._CCW(this.p1, this.p2, q1) != this._CCW(this.p1, this.p2, q2));
  }


  //// POLY ////
  Poly = function() {
    this.hole = false;
    this.points = null;
    this.numpoints = 0;
  }
  exports.Poly = Poly;

  Poly.prototype.init = function(n) {
    this.points = new Array(n);
    this.numpoints = n;
  }

  Poly.prototype.update = function() {
    this.numpoints = this.points.length;
  }

  Poly.prototype.triangle = function(p1, p2, p3) {
    this.init(3);
    this.points[0] = p1;
    this.points[1] = p2;
    this.points[2] = p3;
  }

  // Takes an index and returns the point at that index, or null.
  Poly.prototype.getPoint = function(n) {
    if (this.points && this.numpoints > n)
      return this.points[n];
    return null;
  }

  // Set a point, fails silently otherwise. TODO: replace with bracket notation.
  Poly.prototype.setPoint = function(i, p) {
    if (this.points && this.points.length > i) {
      this.points[i] = p;
    }
  }

  // Given an index i, return the index of the next point.
  Poly.prototype.getNextI = function(i) {
    return (i + 1) % this.numpoints;
  }

  Poly.prototype.getPrevI = function(i) {
    if (i == 0)
      return (this.numpoints - 1);
    return i - 1;
  }

  // Returns the signed area of a polygon, if the vertices are given in
  // CCW order then the area will be > 0, < 0 otherwise.
  Poly.prototype.getArea = function() {
    var area = 0;
    for (var i = 0; i < this.numpoints; i++) {
      var i2 = this.getNextI(i);
      area += this.points[i].x * this.points[i2].y - this.points[i].y * this.points[i2].x;
    }
    return area;
  }

  Poly.prototype.getOrientation = function() {
    var area = this.getArea();
    if (area > 0) return "CCW";
    if (area < 0) return "CW";
    return 0;
  }

  Poly.prototype.setOrientation = function(orientation) {
    var current_orientation = this.getOrientation();
    if (current_orientation && (current_orientation !== orientation)) {
      this.invert();
    }
  }

  Poly.prototype.invert = function() {
    var newpoints = new Array(this.numpoints);
    for (var i = 0; i < this.numpoints; i++) {
      newpoints[i] = this.points[this.numpoints - i - 1];
    }
    this.points = newpoints;
  }

  Poly.prototype.getCenter = function() {
    var x = this.points.map(function(p) { return p.x });
    var y = this.points.map(function(p) { return p.y });
    var minX = Math.min.apply(null, x);
    var maxX = Math.max.apply(null, x);
    var minY = Math.min.apply(null, y);
    var maxY = Math.max.apply(null, y);
    return new Point((minX + maxX)/2, (minY + maxY)/2);
  }

  // Adapted from http://stackoverflow.com/a/16283349
  Poly.prototype.centroid = function() {
    var x = 0,
        y = 0,
        i,
        j,
        f,
        point1,
        point2;

    for (i = 0, j = this.points.length - 1; i < this.points.length; j = i, i += 1) {
      point1 = this.points[i];
      point2 = this.points[j];
      f = point1.x * point2.y - point2.x * point1.y;
      x += (point1.x + point2.x) * f;
      y += (point1.y + point2.y) * f;
    }

    f = this.getArea() * 3;
    x = Math.abs(x);
    y = Math.abs(y);
    return new Point(x / f, y / f);
  }

  // Print list of points. csep is coordinate separator, psep is point
  // separator, default is space and newline, respectively.
  Poly.prototype.toPointString = function(csep, psep) {
    csep = csep || ' ';
    psep = psep || '\n';
    var out = "";
    this.points.forEach(function(p) {
      out = out + p.x + csep + p.y + psep;
    });
    return out;
  }

  Poly.prototype.toString = function() {
    var center = this.centroid();
    return "" + center.x + " " + center.y;
  }

  /**
   * Checks if the given point is contained within the Polygon.
   * Adapted from http://stackoverflow.com/a/8721483
   *
   * @param {Point} p - The point to check.
   * @return {boolean} - Whether or not the point is contained within
   *   the polygon.
   */
  Poly.prototype.containsPoint = function(p) {
    var result = false;
    for (var i = 0, j = this.numpoints - 1; i < this.numpoints; j = i++) {
      var p1 = this.points[j], p2 = this.points[i];
      if ((p2.y > p.y) != (p1.y > p.y) &&
          (p.x < (p1.x - p2.x) * (p.y - p2.y) / (p1.y - p2.y) + p2.x)) {
        result = !result;
      }
    }
    return result;
  }

  //// PARTITION ////
  Partition = function() {
    this.drawCallback = null;
  };
  exports.Partition = Partition;

  Partition.prototype.convertTrianglesToPolys = function(triangles) {
    var polys = triangles.map(function(triangle) {
      var poly = new Poly();
      poly.init(3);
      triangle.getPoints().forEach(function(p, i) {
        poly.setPoint(i, new Point(p.x, p.y));
      });
      return poly;
    });
    return polys;
  }

  /**
   * Partition a polygon with (optional) holes into a set of convex
   * polygons. The vertices of the polygon must be given in CW order,
   * and the vertices of the holes must be in CCW order. Uses poly2tri
   * for the initial triangulation and Hertel-Mehlhorn to combine them
   * into convex polygons.
   * @param {Poly} poly - The polygon to use as the outline.
   * @param {Array.<Poly>} [holes] - An array of holes present in the
   *   polygon.
   * @param {number} [minArea=5] - An optional parameter that filters
   *   out polygons in the partition smaller than this value.
   * @return {Array.<Poly>} - The set of polygons defining the
   *   partition of the provided polygon.
   */
  Partition.prototype.convexPartition = function(poly, holes, minArea) {
    if (typeof holes == 'undefined') holes = false;
    if (typeof minArea == 'undefined') minArea = 5;

    var i11, i12, i13, i21, i22, i23;
    var parts = new Array();

    // Check if poly is already convex only if there are no holes.
    if (!holes) {
      var reflex = false;
      // Check if already convex.
      for (var i = 0; i < poly.numpoints; i++) {
        var prev = poly.getPrevI(i);
        var next = poly.getNextI(i);
        if (!PolyUtils.isConvex(poly.getPoint(prev), poly.getPoint(i), poly.getPoint(next))) {
          reflex = true;
          break;
        }
      }
      if (!reflex) {
        parts.push(poly);
        return parts;
      }
    }

    // Convert polygon into format required by poly2tri.
    var contour = poly.points.map(function(p) {
      return new poly2tri.Point(p.x, p.y);
    });

    if (holes) {
      // Convert holes into format required by poly2tri.
      holes = holes.map(function(poly) {
        return poly.points.map(function(p) {
          return new poly2tri.Point(p.x, p.y);
        });
      });
    }

    var swctx = new poly2tri.SweepContext(contour);
    if (holes) {
      swctx.addHoles(holes);
    }
    var triangles = swctx.triangulate().getTriangles();
    
    // Convert poly2tri triangles back into polygons and filter out the
    // ones too small to be relevant.
    triangles = this.convertTrianglesToPolys(triangles).filter(function(poly) {
      return poly.getArea() >= minArea;
    });

    for (var s1 = 0; s1 < triangles.length; s1++) {
      var poly1 = triangles[s1];
      var s2_index = null;
      for (i11 = 0; i11 < poly1.numpoints; i11++) {
        var d1 = poly1.getPoint(i11);
        i12 = poly1.getNextI(i11);
        var d2 = poly1.getPoint(i12);

        var isdiagonal = false;
        for (var s2 = s1; s2 < triangles.length; s2++) {
          if (s1 == s2) continue;
          var poly2 = triangles[s2];
          for (i21 = 0; i21 < poly2.numpoints; i21++) {
            if (d2.neq(poly2.getPoint(i21))) continue;
            i22 = poly2.getNextI(i21);
            if (d1.neq(poly2.getPoint(i22))) continue;
            isdiagonal = true;
            object_2_index = s2;
            break;
          }
          if (isdiagonal) break;
        }

        if (!isdiagonal) continue;
        var p1, p2, p3;
        p2 = poly1.getPoint(i11);
        i13 = poly1.getPrevI(i11);
        p1 = poly1.getPoint(i13);
        i23 = poly2.getNextI(i22);
        p3 = poly2.getPoint(i23);

        if (!PolyUtils.isConvex(p1, p2, p3)) continue;

        p2 = poly1.getPoint(i12);
        i13 = poly1.getNextI(i12);
        p3 = poly1.getPoint(i13);
        i23 = poly2.getPrevI(i21);
        p1 = poly2.getPoint(i23);

        if (!PolyUtils.isConvex(p1, p2, p3)) continue;

        var newpoly = new Poly();
        newpoly.init(poly1.numpoints + poly2.numpoints - 2);
        var k = 0;
        for (var j = i12; j != i11; j = poly1.getNextI(j)) {
          newpoly.setPoint(k, poly1.getPoint(j));
          k++;
        }
        for (var j = i22; j != i21; j = poly2.getNextI(j)) {
          newpoly.setPoint(k, poly2.getPoint(j));
          k++;
        }

        if (s1 > object_2_index) {
          triangles[s1] = newpoly;
          poly1 = triangles[s1];
          triangles.splice(object_2_index, 1);
        } else {
          triangles.splice(object_2_index, 1);
          triangles[s1] = newpoly;
          poly1 = triangles[s1];
        }
        i11 = -1;
      }
    }
    return triangles;
  }

  var PolyUtils = {};

  PolyUtils.isConvex = function(p1, p2, p3) {
    var tmp = (p3.y - p1.y) * (p2.x - p1.x) - (p3.x - p1.x) * (p2.y - p1.y);
    return (tmp > 0);
  }

  /**
   * Given an array of polygons, returns the one that contains the point.
   * If no polygon is found, null is returned.
   * @param {Point} p - The point to find the polygon for.
   * @param {Array.<Poly>} polys - The polygons to search for the point.
   * @return {?Polygon} - The polygon containing the point.
   */
  PolyUtils.findPolyForPoint = function(p, polys) {
    var i, poly;
    for (i in polys) {
      poly = polys[i];
      if (poly.containsPoint(p)) {
        return poly;
      }
    }
    return null;
  }
  /**
   * Holds the properties of a collision, if one occurred.
   * @typedef Collision
   * @type {object}
   * @property {boolean} collides - Whether there is a collision.
   * @property {boolean} inside - Whether one object is inside the other.
   * @property {?Point} point - The point of collision, if collision
   *   occurs, and if `inside` is false.
   * @property {?Point} normal - A unit vector normal to the point
   *   of collision, if it occurs and if `inside` is false.
   */
  /**
   * If the ray intersects the circle, the distance to the intersection
   * along the ray is returned, otherwise false is returned.
   * @param {Point} p - The start of the ray.
   * @param {Point} ray - Unit vector extending from `p`.
   * @param {Point} c - The center of the circle for the object being
   *   checked for intersection.
   * @param {number} radius - The radius of the circle.
   * @return {Collision} - The collision information.
   */
  PolyUtils.lineCircleIntersection = function(p, ray, c, radius) {
    var collision = {
      collides: false,
      inside: false,
      point: null,
      normal: null
    }
    var vpc = c.sub(p);

    if (vpc.len() <= radius) {
      // Point is inside obstacle.
      collision.collides = true;
      collision.inside = (vpc.len() !== radius);
    } else if (ray.dot(vpc) >= 0) {
      // Circle is ahead of point.
      // Projection of center point onto ray.
      var pc = p.add(ray.mul(ray.dot(vpc)));
      // Length from c to its projection on the ray.
      var len_c_pc = c.sub(pc).len();

      if (len_c_pc <= radius) {
        collision.collides = true;

        // Distance from projected point to intersection.
        var len_intersection = Math.sqrt(len_c_pc * len_c_pc + radius * radius);
        collision.point = pc.sub(ray.mul(len_intersection));
        collision.normal = collision.point.sub(c).normalize();
      }
    }
    return collision;
  }
  exports.PolyUtils = PolyUtils;

  return exports;
});


/* 
 * These action values correspond to the 256 states possible given empty
 * tiles, diagonal tiles, and square tiles. Generated using diagonals.js.
 * There are two possible forms for an action value. One is as a single object.
 * If an item has only a single object, then there is only one possible entrance/
 * exit possible from that arrangement of tiles. If an item has an array of
 * objects then there are multiple entrance/exits possible. Each of the objects
 * in an array of this sort has a 'loc' property that itself is an object with
 * properties 'in_dir' and 'out_dir' corresponding to the values to get into the
 * cell and the value that should be taken to get out of it. Each of the objects
 * also has a property 'v' which is a boolean corresponding to whether there is 
 * a vertex at a tile with this arrangement. The locations can be n, e, s, w, ne,
 * nw, se, sw.
 * The keys of this object are strings generated using the number values of a
 * contour tile starting from the top left and moving clockwise, separated by hyphens.
 */
define('action-values',[],function() {
  return {"0-0-0-0":{"v":false,"loc":"none"},"1-0-0-0":{"v":true,"loc":"w"},"2-0-0-0":{"v":true,"loc":"w"},"3-0-0-0":{"v":true,"loc":"nw"},"0-1-0-0":{"v":true,"loc":"n"},"1-1-0-0":{"v":false,"loc":"w"},"2-1-0-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}}],"3-1-0-0":{"v":true,"loc":"nw"},"0-2-0-0":{"v":true,"loc":"ne"},"1-2-0-0":[{"v":true,"loc":{"in_dir":"s","out_dir":"w"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"2-2-0-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"3-2-0-0":[{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-0-0":{"v":true,"loc":"n"},"1-3-0-0":{"v":true,"loc":"w"},"2-3-0-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}}],"3-3-0-0":{"v":true,"loc":"nw"},"0-0-1-0":{"v":true,"loc":"e"},"1-0-1-0":[{"v":true,"loc":{"in_dir":"s","out_dir":"w"}},{"v":true,"loc":{"in_dir":"n","out_dir":"e"}}],"2-0-1-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"n","out_dir":"e"}}],"3-0-1-0":[{"v":true,"loc":{"in_dir":"n","out_dir":"e"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-1-0":{"v":false,"loc":"n"},"1-1-1-0":{"v":true,"loc":"w"},"2-1-1-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":false,"loc":{"in_dir":"n","out_dir":"n"}}],"3-1-1-0":{"v":true,"loc":"nw"},"0-2-1-0":{"v":true,"loc":"ne"},"1-2-1-0":[{"v":true,"loc":{"in_dir":"n","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"w"}}],"2-2-1-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"n","out_dir":"ne"}}],"3-2-1-0":[{"v":true,"loc":{"in_dir":"n","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-1-0":[{"v":true,"loc":{"in_dir":"n","out_dir":"e"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}}],"1-3-1-0":[{"v":true,"loc":{"in_dir":"n","out_dir":"e"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}}],"2-3-1-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"n","out_dir":"e"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}}],"3-3-1-0":[{"v":true,"loc":{"in_dir":"n","out_dir":"e"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}}],"0-0-2-0":{"v":true,"loc":"se"},"1-0-2-0":[{"v":true,"loc":{"in_dir":"s","out_dir":"w"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"2-0-2-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"3-0-2-0":[{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"0-1-2-0":[{"v":true,"loc":{"in_dir":"w","out_dir":"n"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"1-1-2-0":[{"v":false,"loc":{"in_dir":"w","out_dir":"w"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"2-1-2-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"3-1-2-0":[{"v":true,"loc":{"in_dir":"w","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"0-2-2-0":[{"v":true,"loc":{"in_dir":"n","out_dir":"se"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"1-2-2-0":[{"v":true,"loc":{"in_dir":"s","out_dir":"w"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"2-2-2-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"3-2-2-0":[{"v":true,"loc":{"in_dir":"n","out_dir":"se"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"0-3-2-0":[{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"1-3-2-0":[{"v":true,"loc":{"in_dir":"sw","out_dir":"w"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"2-3-2-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"3-3-2-0":[{"v":true,"loc":{"in_dir":"sw","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"0-0-3-0":{"v":true,"loc":"e"},"1-0-3-0":[{"v":true,"loc":{"in_dir":"s","out_dir":"w"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"2-0-3-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"3-0-3-0":[{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-3-0":{"v":true,"loc":"n"},"1-1-3-0":{"v":true,"loc":"w"},"2-1-3-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"n"}}],"3-1-3-0":{"v":false,"loc":"nw"},"0-2-3-0":{"v":true,"loc":"ne"},"1-2-3-0":[{"v":true,"loc":{"in_dir":"nw","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"w"}}],"2-2-3-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"ne"}}],"3-2-3-0":[{"v":true,"loc":{"in_dir":"nw","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-3-0":[{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"1-3-3-0":[{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"2-3-3-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"3-3-3-0":[{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"0-0-0-1":{"v":true,"loc":"s"},"1-0-0-1":{"v":false,"loc":"s"},"2-0-0-1":{"v":true,"loc":"s"},"3-0-0-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-0-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}}],"1-1-0-1":{"v":true,"loc":"s"},"2-1-0-1":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}}],"3-1-0-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"w","out_dir":"nw"}}],"0-2-0-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"1-2-0-1":[{"v":false,"loc":{"in_dir":"s","out_dir":"s"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"2-2-0-1":[{"v":true,"loc":{"in_dir":"se","out_dir":"s"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"3-2-0-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-0-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}}],"1-3-0-1":{"v":true,"loc":"s"},"2-3-0-1":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}}],"3-3-0-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"nw"}}],"0-0-1-1":{"v":false,"loc":"e"},"1-0-1-1":{"v":true,"loc":"e"},"2-0-1-1":{"v":true,"loc":"e"},"3-0-1-1":[{"v":false,"loc":{"in_dir":"e","out_dir":"e"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-1-1":{"v":true,"loc":"n"},"1-1-1-1":{"v":false,"loc":"none"},"2-1-1-1":{"v":true,"loc":"n"},"3-1-1-1":{"v":true,"loc":"nw"},"0-2-1-1":{"v":true,"loc":"ne"},"1-2-1-1":{"v":true,"loc":"ne"},"2-2-1-1":{"v":true,"loc":"ne"},"3-2-1-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-1-1":[{"v":false,"loc":{"in_dir":"e","out_dir":"e"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}}],"1-3-1-1":{"v":true,"loc":"e"},"2-3-1-1":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}}],"3-3-1-1":[{"v":false,"loc":{"in_dir":"e","out_dir":"e"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}}],"0-0-2-1":{"v":true,"loc":"se"},"1-0-2-1":{"v":true,"loc":"se"},"2-0-2-1":{"v":false,"loc":"se"},"3-0-2-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"se"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-2-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"se"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}}],"1-1-2-1":{"v":true,"loc":"se"},"2-1-2-1":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}}],"3-1-2-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"se"}},{"v":true,"loc":{"in_dir":"w","out_dir":"nw"}}],"0-2-2-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"se"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"1-2-2-1":[{"v":true,"loc":{"in_dir":"s","out_dir":"se"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"2-2-2-1":[{"v":false,"loc":{"in_dir":"se","out_dir":"se"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"3-2-2-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"se"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"0-3-2-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"se"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}}],"1-3-2-1":{"v":true,"loc":"se"},"2-3-2-1":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}}],"3-3-2-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"se"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"nw"}}],"0-0-3-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"1-0-3-1":[{"v":false,"loc":{"in_dir":"s","out_dir":"s"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"2-0-3-1":[{"v":true,"loc":{"in_dir":"se","out_dir":"s"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"3-0-3-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-3-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"1-1-3-1":{"v":true,"loc":"s"},"2-1-3-1":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"3-1-3-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"0-2-3-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"1-2-3-1":[{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}},{"v":false,"loc":{"in_dir":"s","out_dir":"s"}}],"2-2-3-1":[{"v":true,"loc":{"in_dir":"se","out_dir":"s"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"3-2-3-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-3-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"1-3-3-1":[{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"2-3-3-1":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"3-3-3-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"0-0-0-2":{"v":true,"loc":"s"},"1-0-0-2":[{"v":true,"loc":{"in_dir":"s","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"2-0-0-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-0-0-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-0-2":[{"v":true,"loc":{"in_dir":"w","out_dir":"n"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}}],"1-1-0-2":[{"v":false,"loc":{"in_dir":"w","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"2-1-0-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-1-0-2":[{"v":true,"loc":{"in_dir":"w","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}}],"0-2-0-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"1-2-0-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}},{"v":true,"loc":{"in_dir":"s","out_dir":"w"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"2-2-0-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"3-2-0-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-0-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}}],"1-3-0-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"2-3-0-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-3-0-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}}],"0-0-1-2":{"v":true,"loc":"e"},"1-0-1-2":[{"v":true,"loc":{"in_dir":"s","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"2-0-1-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-0-1-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"e"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-1-2":{"v":true,"loc":"n"},"1-1-1-2":{"v":true,"loc":"w"},"2-1-1-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-1-1-2":{"v":true,"loc":"nw"},"0-2-1-2":{"v":false,"loc":"ne"},"1-2-1-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}},{"v":true,"loc":{"in_dir":"s","out_dir":"w"}}],"2-2-1-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-2-1-2":[{"v":false,"loc":{"in_dir":"ne","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-1-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"e"}}],"1-3-1-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"2-3-1-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-3-1-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"e"}}],"0-0-2-2":{"v":true,"loc":"se"},"1-0-2-2":[{"v":true,"loc":{"in_dir":"s","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"2-0-2-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-0-2-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"se"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-2-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"se"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}}],"1-1-2-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}},{"v":false,"loc":{"in_dir":"w","out_dir":"w"}}],"2-1-2-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}}],"3-1-2-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"se"}},{"v":true,"loc":{"in_dir":"w","out_dir":"nw"}}],"0-2-2-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"se"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"1-2-2-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}},{"v":true,"loc":{"in_dir":"s","out_dir":"w"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"2-2-2-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"3-2-2-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"se"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"0-3-2-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"se"}}],"1-3-2-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"2-3-2-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-3-2-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"se"}}],"0-0-3-2":[{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}}],"1-0-3-2":[{"v":true,"loc":{"in_dir":"s","out_dir":"w"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"2-0-3-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-0-3-2":[{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-3-2":[{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}}],"1-1-3-2":[{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"2-1-3-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-1-3-2":[{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}}],"0-2-3-2":[{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}}],"1-2-3-2":[{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}},{"v":true,"loc":{"in_dir":"s","out_dir":"w"}}],"2-2-3-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-2-3-2":[{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-3-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}}],"1-3-3-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"2-3-3-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-3-3-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}}],"0-0-0-3":{"v":true,"loc":"sw"},"1-0-0-3":{"v":true,"loc":"sw"},"2-0-0-3":{"v":true,"loc":"sw"},"3-0-0-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-0-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}}],"1-1-0-3":{"v":true,"loc":"sw"},"2-1-0-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}}],"3-1-0-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"nw"}}],"0-2-0-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"1-2-0-3":[{"v":true,"loc":{"in_dir":"s","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"2-2-0-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"3-2-0-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-0-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}}],"1-3-0-3":{"v":false,"loc":"sw"},"2-3-0-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}}],"3-3-0-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"nw"}}],"0-0-1-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"e"}}],"1-0-1-3":[{"v":true,"loc":{"in_dir":"s","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"e"}}],"2-0-1-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"e"}}],"3-0-1-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"e"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-1-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":false,"loc":{"in_dir":"n","out_dir":"n"}}],"1-1-1-3":{"v":true,"loc":"sw"},"2-1-1-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":false,"loc":{"in_dir":"n","out_dir":"n"}}],"3-1-1-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"nw"}}],"0-2-1-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"ne"}}],"1-2-1-3":[{"v":true,"loc":{"in_dir":"s","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"ne"}}],"2-2-1-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"ne"}}],"3-2-1-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-1-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"n","out_dir":"e"}}],"1-3-1-3":[{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"n","out_dir":"e"}}],"2-3-1-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"n","out_dir":"e"}}],"3-3-1-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"n","out_dir":"e"}}],"0-0-2-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"1-0-2-3":[{"v":true,"loc":{"in_dir":"s","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"2-0-2-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"3-0-2-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"0-1-2-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"1-1-2-3":[{"v":true,"loc":{"in_dir":"w","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"2-1-2-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"3-1-2-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"0-2-2-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"1-2-2-3":[{"v":true,"loc":{"in_dir":"s","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"2-2-2-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"3-2-2-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"0-3-2-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"1-3-2-3":[{"v":false,"loc":{"in_dir":"sw","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"2-3-2-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"3-3-2-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"0-0-3-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"1-0-3-3":[{"v":true,"loc":{"in_dir":"s","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"2-0-3-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"3-0-3-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-3-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"n"}}],"1-1-3-3":{"v":true,"loc":"sw"},"2-1-3-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"n"}}],"3-1-3-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":false,"loc":{"in_dir":"nw","out_dir":"nw"}}],"0-2-3-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"ne"}}],"1-2-3-3":[{"v":true,"loc":{"in_dir":"nw","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"sw"}}],"2-2-3-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"ne"}}],"3-2-3-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-3-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"1-3-3-3":[{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"2-3-3-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"3-3-3-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}]};
});

/**
 * @module map/parse
 */
define('parse-map',['./action-values', './polypartition'],
function(  ActionValues,      pp) {
  var Point = pp.Point;
  var Poly = pp.Poly;

  /**
   * Contains utilities for generating usable map representations from
   * map tiles.
   */
  var MapParser = {};

  /**
   * An object with x and y properties that represents a coordinate pair.
   * @typedef MPPoint
   * @type {object}
   * @property {number} x - The x coordinate of the location.
   * @property {number} y - The y coordinate of the location.
   */

  /**
   * A Shape is an array of points, where points are objects with x and y properties which represent coordinates on the map.
   * @typedef MPShape
   * @type {Array.<MPPoint>}
   */

  /**
   * An object with r and c properties that represents a row/column
   * location in a 2d array.
   * @typedef ArrayLoc
   * @type {object}
   * @property {integer} r - The row number of the array location.
   * @property {integer} c - The column number of the array location.
   */

  /**
   * The 2d tile grid from `tagpro.map`, or a similar 2d grid resulting
   * from an operation on the original.
   * @typedef MapTiles
   * @type {Array.<Array.<number>>}
   */

  /**
   * A Cell is just an array that holds the values of the four adjacent
   * cells in a 2d array, recorded in CCW order starting from the upper-
   * left quadrant. For example, given a 2d array:
   * [[1, 0, 1],
   *  [1, 0, 0],
   *  [1, 1, 1]]
   * we would generate the representation using the cells:
   * [1, 0,  [0, 1,  [1, 0,  [0, 0  
   *  1, 0]   0, 0]   1, 1]   1, 1].
   * These correspond to the parts of a tile that would be covered if
   * placed at the intersection of 4 tiles. The value 0 represents a
   * blank location, 1 indicates that the quadrant is covered.
   * To represent how such tiles would be covered in the case of diagonal
   * tiles, we use 2 to indicate that the lower diagonal of a quadrant is
   * filled, and 3 to indicate that the upper diagonal of a quadrant is
   * filled. The tiles available force the diagonals of each quadrant to
   * point to the center, so this is sufficient for describing all
   * possible overlappings.
   * @typedef Cell
   * @type {Array.<number>}
   */

  /**
   * Callback that receives each of the elements in the 2d map function.
   * @callback mapCallback
   * @param {*} - The element from the 2d array.
   * @return {*} - The transformed element.
   */

  /**
   * Applies `fn` to every individual element of the 2d array `arr`.
   * @param {Array.<Array.<*>>} arr - The 2d array to use.
   * @param {mapCallback} fn - The function to apply to each element.
   * @return {Array.<Array.<*>>} - The 2d array after the function
   *   has been applied to each element.
   */
  function map2d(arr, fn) {
    return arr.map(function(row) {
      return row.map(fn);
    });
  }

  /**
   * Returns 1 if a tile value is one that we want to consider as
   * a wall (we consider empty space to be a wall), or the tile value
   * itself for diagonal walls. 0 is returned otherwise.
   * @param {number} elt - The tile value at a row/column location
   * @return {number} - The number to insert in place of the tile value.
   */
  function isBadCell(elt) {
    var bad_cells = [1, 1.1, 1.2, 1.3, 1.4];
    if(bad_cells.indexOf(elt) !== -1) {
      // Ensure empty spaces get mapped to full tiles so outside of
      // map isn't traced.
      if (elt == 0) {
        return 1;
      } else {
        return elt;
      }
      return elt;
    } else {
      return 0;
    }
  }

  /**
   * Converts the provided array into its equivalent representation
   * using cells.
   * @param {MapTiles} arr - 
   * @param {Array.<Array.<Cell>>} - The converted array.
   */
  function generateContourGrid(arr) {
    // Generate grid for holding values.
    var contour_grid = new Array(arr.length - 1);
    for (var n = 0; n < contour_grid.length; n++) {
      contour_grid[n] = new Array(arr[0].length - 1);
    }
    var corners = [1.1, 1.2, 1.3, 1.4];
    // Specifies the resulting values for the above corner values. The index
    // of the objects in this array corresponds to the proper values for the
    // quadrant of the same index.
    var corner_values = [
      {1.1: 3, 1.2: 0, 1.3: 2, 1.4: 1},
      {1.1: 0, 1.2: 3, 1.3: 1, 1.4: 2},
      {1.1: 3, 1.2: 1, 1.3: 2, 1.4: 0},
      {1.1: 1, 1.2: 3, 1.3: 0, 1.4: 2}
    ];
    for (var i = 0; i < (arr.length - 1); i++) {
      for (var j = 0; j < (arr[0].length - 1); j++) {
        var cell = [arr[i][j], arr[i][j+1], arr[i+1][j+1], arr[i+1][j]];
        // Convert corner tiles to appropriate representation.
        cell.forEach(function(val, i, cell) {
          if (corners.indexOf(val) !== -1) {
            cell[i] = corner_values[i][val];
          }
        });

        contour_grid[i][j] = cell;
      }
    }
    return contour_grid;
  }

  /**
   * Callback function for testing equality of items.
   * @callback comparisonCallback
   * @param {*} - The first item.
   * @param {*} - The second item.
   * @return {boolean} - Whether or not the items are equal.
   */

  /**
   * Returns the location of obj in arr with equality determined by cmp.
   * @param {Array.<*>} arr - The array to be searched.
   * @param {*} obj - The item to find a match for.
   * @param {comparisonCallback} cmp - The callback that defines
   *   whether `obj` matches.
   * @return {integer} - The index of the first element to match `obj`,
   *   or -1 if no such element was located.
   */
  function find(arr, obj, cmp) {
    if (typeof cmp !== 'undefined') {
      for (var i = 0; i < arr.length; i++) {
        if (cmp(arr[i], obj)) {
          return i;
        }
      }
      return -1;
    }
  }

  /**
   * Compare two objects defining row/col locations in an array
   * and return true if they represent the same row/col location.
   * @param {ArrayLoc} elt1
   * @param {ArrayLoc} elt2
   * @return {boolean} - Whether or not these two array locations
   *   represent the same row/column.
   */
  function eltCompare(elt1, elt2) {
    return (elt1.c == elt2.c && elt1.r == elt2.r);
  }

  /**
   * Takes in the vertex/action information and returns an array of arrays,
   * where each array corresponds to a shape and each element of the array is
   * a vertex which is connected to it's previous and next neighbor (circular).
   * @param {} actionInfo
   * @return {Array.<Array<ArrayLoc>>} - Array of vertex locations in 
   */
  function generateShapes(actionInfo) {
    // Total number of cells.
    var total = actionInfo.length * actionInfo[0].length;
    var directions = {
      "n": [-1, 0],
      "e": [0, 1],
      "s": [1, 0],
      "w": [0, -1],
      "ne": [-1, 1],
      "se": [1, 1],
      "sw": [1, -1],
      "nw": [-1, -1]
    };
    // Takes the current location and direction at this point and
    // returns the next location to check. Returns null if this cell is
    // not part of a shape.
    function nextNeighbor(elt, dir) {
      var drow = 0, dcol = 0;
      if (dir == "none") {
        return null;
      } else {
        var offset = directions[dir];
        return {r: elt.r + offset[0], c: elt.c + offset[1]};
      }
    }

    // Get the next cell, from left to right, top to bottom. Returns null
    // if last element in array reached.
    function nextCell(elt) {
      if (elt.c + 1 < actionInfo[elt.r].length) {
        return {r: elt.r, c: elt.c + 1};
      } else if (elt.r + 1 < actionInfo.length) {
        return {r: elt.r + 1, c: 0};
      }
      return null;
    }

    // Get identifier for given node and direction
    function getIdentifier(node, dir) {
      return "r" + node.r + "c" + node.c + "d" + dir;
    }
    
    var discovered = [];
    var node = {r: 0, c: 0};
    var shapes = [];
    var current_shape = [];
    var shape_node_start = null;
    var last_action = null;
    // Object to track location + actions that have been taken.
    var taken_actions = {};
    var iterations = 0;

    // Iterate until all nodes have been visited.
    while (discovered.length !== total) {
      if (!node) {
        // Reached end.
        break;
      }
      if (iterations > total * 4) {
        // Sanity check on number of iterations. Maximum number of
        // times a single tile would be visited is 4 for a fan-like
        // pattern of triangle wall tiles.
        break;
      } else {
        iterations++;
      }
      // It's okay to be in a discovered node if shapes are adjacent,
      // we just want to keep track of the ones we've seen.
      if (find(discovered, node, eltCompare) == -1) {
        discovered.push(node);
      }

      var action = actionInfo[node.r][node.c];
      var dir;
      // If action has multiple possibilities.
      if (action instanceof Array) {
        // Part of a shape, find the info with that previous action as
        // in_dir.
        if (last_action !== "none") {
          var action_found = false;
          for (var i = 0; i < action.length; i++) {
            var this_action = action[i];
            if (this_action["loc"]["in_dir"] == last_action) {
              action = this_action;
              dir = this_action["loc"]["out_dir"];
              action_found = true;
              break;
            }
          }

          if (!action_found) {
            throw "Error!";
          }
        } else {
          // Find the first action that has not been taken previously.
          var action_found = false;
          for (var i = 0; i < action.length; i++) {
            var this_action = action[i];
            if (!taken_actions[getIdentifier(node, this_action["loc"]["out_dir"])]) {
              action = this_action
              dir = this_action["loc"]["out_dir"];
              action_found = true;
              break;
            }
          }
          if (!action_found) {
            throw "Error!";
          }
        }
      } else { // Action only has single possibility.
        dir = action.loc;
      }

      // Set node/action as having been visited.
      taken_actions[getIdentifier(node, dir)] = true;

      last_action = dir;
      var next = nextNeighbor(node, dir);
      if (next) { // Part of a shape.
        // Save location for restarting after this shape has been defined.
        var first = false;
        if (current_shape.length == 0) {
          first = true;
          shape_node_start = node;
          shape_node_start_action = last_action;
        }
        
        // Current node and direction is same as at start of shape,
        // shape has been explored.
        if (!first && eltCompare(node, shape_node_start) && last_action == shape_node_start_action) {
          shapes.push(current_shape);
          current_shape = [];
          // Get the next undiscovered node.
          node = nextCell(shape_node_start);
          while (node && (find(discovered, node, eltCompare) !== -1)) {
            node = nextCell(node);
          }
          shape_node_start = null;
        } else {
          if (action.v || first) {
            current_shape.push(node);
          }
          node = next;
        }
      } else { // Not part of a shape.
        node = nextCell(node);
        // Get the next undiscovered node.
        while (node && (find(discovered, node, eltCompare) !== -1)) {
          node = nextCell(node);
        }
      }
    } // end while

    if (discovered.length == total) {
      return shapes;
    } else {
      return null;
    }
  }

  /**
   * Pre-processes the map to remove external diagonal tiles. This
   * side-steps an issue where the system is unable to parse maps
   * that have diagonal tiles on the outside of the map outline.
   * @param {Array.<Array.<Cell>>} arr - The 2d array output of 
   * @return {Array.<Array.<Cell>>} - The
   */
  function preprocess(arr) {
    function identifier(cell) {
      var str = cell[0] + "-" + cell[1] + "-" + cell[2] + "-" + cell[3];
      return str;
    }
    var bad_arrangements = new Set();
    bad_arrangements.add(identifier([1, 1, 1.4, 1]));
    bad_arrangements.add(identifier([1, 1, 1, 1.3]));
    bad_arrangements.add(identifier([1, 1.1, 1, 1]));
    bad_arrangements.add(identifier([1.2, 1, 1, 1]));
    for (var i = 0; i < (arr.length - 1); i++) {
      for (var j = 0; j < (arr[0].length - 1); j++) {
        var cell = [arr[i][j], arr[i][j+1], arr[i+1][j+1], arr[i+1][j]];
        // Check if in bad arrangements.
        if (bad_arrangements.has(identifier(cell))) {
          arr[i][j] = 1;
          arr[i][j+1] = 1;
          arr[i+1][j+1] = 1;
          arr[i+1][j] = 1;
        }
      }
    }
    return arr;
  }

  // Return whether there should be a vertex at the given location and
  // which location to go next, if any.
  // Value returned is an object with properties 'v' and 'loc'. 'v' is a boolean
  // indicating whether there is a vertex, and 'loc' gives the next location to move, if any.
  // loc is a string, of none, down, left, right, up, down corresponding to
  // tracing out a shape clockwise (or the interior of a shape CCW), or a function
  // that takes a string corresponding to the direction taken to get to the current
  // cell.
  // There will never be a vertex without a next direction.
  function getAction(cell) {
    var str = cell[0] + "-" + cell[1] + "-" + cell[2] + "-" + cell[3];
    return ActionValues[str];
  }

  /**
   * Convert an array location to a point representing the top-left
   * corner of the tile in global coordinates.
   * @param {ArrayLoc} location - The array location to get the
   *   coordinates for.
   * @return {MPPoint} - The coordinates of the tile.
   */
  function getCoordinates(location) {
    var tile_width = 40;
    var x = location.r * tile_width;
    var y = location.c * tile_width;
    return {x: x, y: y};
  }

  /**
   * Takes in an array of shapes and converts from contour grid layout
   * to actual coordinates.
   * @param {Array.<Array.<ArrayLoc>>} shapes - output from generateShapes
   * @return {Array.<Array.<{{x: number, y: number}}>>}
   */
  function convertShapesToCoords(shapes) {
    var tile_width = 40;

    var new_shapes = map2d(shapes, function(loc) {
      // It would be loc.r + 1 and loc.c + 1 but that has been removed
      // to account for the one-tile width of padding added in doParse.
      var row = loc.r * tile_width;
      var col = loc.c * tile_width;
      return {x: row, y: col}
    });
    return new_shapes;
  }

  // Given an x and y value, return a polygon (octagon) that approximates
  // a spike at the tile given by that x, y location. Points in CW order.
  function getSpikeShape(coord) {
    var x = coord.x + 20, y = coord.y + 20;
    var spike_radius = 14;
    // almost = spike_radius * tan(pi/8) for the vertices of a regular octagon.
    var point_offset = 5.8;
    return [
      {x: x - spike_radius, y: y - point_offset},
      {x: x - spike_radius, y: y + point_offset},
      {x: x - point_offset, y: y + spike_radius},
      {x: x + point_offset, y: y + spike_radius},
      {x: x + spike_radius, y: y + point_offset},
      {x: x + spike_radius, y: y - point_offset},
      {x: x + point_offset, y: y - spike_radius},
      {x: x - point_offset, y: y - spike_radius}
    ];
  }

  /**
   * Returns an array of the array locations of the spikes contained
   * in the map tiles, replacing those array locations in the original
   * map tiles with 2, which corresponds to a floor tile.
   * @param {MapTiles} tiles - The map tiles.
   * @return {Array.<ArrayLoc>} - The array of locations that held
   *   spike tiles.
   */
  function extractSpikes(tiles) {
    var spike_locations = [];
    tiles.forEach(function(row, row_n) {
      row.forEach(function(cell_value, index, row) {
        if (cell_value == 7) {
          spike_locations.push({r: row_n, c: index});
          row[index] = 2;
        }
      });
    });
    return spike_locations;
  }

  /**
   * The returned value from the map parsing function.
   * @typedef ParsedMap
   * @type {object}
   * @property {Array.<MPShape} walls - The parsed walls.
   * @property {Array.<MPShape} obstacles - The parsed obstacles.
   */

  /**
   * Converts the 2d array defining a TagPro map into shapes.
   * @param {MapTiles} tiles - The tiles as retrieved from `tagpro.map`.
   * @return {?ParsedMap} - The result of converting the map into
   *   polygons, or null if there was an issue parsing the map.
   */
  MapParser.parse = function(tiles) {
    // Make copy of tiles to preserve original array
    tiles = JSON.parse(JSON.stringify(tiles));

    // Returns a list of the spike locations and removes them from
    // the tiles.
    var spike_locations = extractSpikes(tiles);

    // Pad tiles with a ring of wall tiles, to ensure the map is
    // closed.
    var empty_row = [];
    for (var i = 0; i < tiles[0].length + 2; i++) {
      empty_row.push(1);
    }
    tiles.forEach(function(row) {
      row.unshift(1);
      row.push(1);
    });
    tiles.unshift(empty_row);
    tiles.push(empty_row.slice());

    // Actually doing the conversion.
    // Get rid of tile values except those for the walls.
    var threshold_tiles = map2d(tiles, isBadCell);

    // Preprocess tiles to get rid of diagonal tiles that cause problems
    // outside bounds of map.
    var preprocessed_tiles = threshold_tiles;//preprocess(threshold_tiles);

    // Generate contour grid, essentially a grid whose cells are at the
    // intersection of every set of 4 cells in the original map.
    var contour_grid_2 = generateContourGrid(preprocessed_tiles);

    // Get tile vertex and actions for each cell in contour grid.
    var tile_actions = map2d(contour_grid_2, getAction);

    var generated_shapes = generateShapes(tile_actions);
    if (!generated_shapes) {
      return null;
    }

    var actual_shapes = generated_shapes.filter(function(elt) {
      return elt.length > 0;
    });

    var converted_shapes = convertShapesToCoords(actual_shapes);

    // Get spike-approximating shapes and add to list.
    var obstacles = spike_locations.map(function(spike) {
      return getSpikeShape(getCoordinates(spike));
    });

    return {
      walls: this.convertShapesToPolys(converted_shapes),
      obstacles: this.convertShapesToPolys(obstacles)
    };
  }

  /**
   * Convert shapes into polys.
   * @param {Array.<Shape>} shapes - The shapes to be converted.
   * @return {Array.<Poly>} - The converted shapes.
   */
  MapParser.convertShapesToPolys = function(shapes) {
    var polys = shapes.map(function(shape) {
      return MapParser.convertShapeToPoly(shape);
    });
    return polys;
  }

  
  /**
   * Convert a shape into a Poly.
   * @param {MPShape} shape - The shape to convert.
   * @return {Poly} - The converted shape.
   */
  MapParser.convertShapeToPoly = function(shape) {
    var poly = new Poly();
    poly.init(shape.length);
    for (var i = 0; i < shape.length; i++) {
      var point = new Point(shape[i].x, shape[i].y);
      poly.setPoint(i, point);
    }
    return poly;
  }

  return MapParser;
});

!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define('lib/priority-queue',[],t);else{var e;"undefined"!=typeof window?e=window:"undefined"!=typeof global?e=global:"undefined"!=typeof self&&(e=self),e.PriorityQueue=t()}}(function(){return function t(e,i,r){function o(n,s){if(!i[n]){if(!e[n]){var u="function"==typeof require&&require;if(!s&&u)return u(n,!0);if(a)return a(n,!0);var h=new Error("Cannot find module '"+n+"'");throw h.code="MODULE_NOT_FOUND",h}var p=i[n]={exports:{}};e[n][0].call(p.exports,function(t){var i=e[n][1][t];return o(i?i:t)},p,p.exports,t,e,i,r)}return i[n].exports}for(var a="function"==typeof require&&require,n=0;n<r.length;n++)o(r[n]);return o}({1:[function(t,e){var i,r,o,a,n,s={}.hasOwnProperty,u=function(t,e){function i(){this.constructor=t}for(var r in e)s.call(e,r)&&(t[r]=e[r]);return i.prototype=e.prototype,t.prototype=new i,t.__super__=e.prototype,t};i=t("./PriorityQueue/AbstractPriorityQueue"),r=t("./PriorityQueue/ArrayStrategy"),a=t("./PriorityQueue/BinaryHeapStrategy"),o=t("./PriorityQueue/BHeapStrategy"),n=function(t){function e(t){t||(t={}),t.strategy||(t.strategy=a),t.comparator||(t.comparator=function(t,e){return(t||0)-(e||0)}),e.__super__.constructor.call(this,t)}return u(e,t),e}(i),n.ArrayStrategy=r,n.BinaryHeapStrategy=a,n.BHeapStrategy=o,e.exports=n},{"./PriorityQueue/AbstractPriorityQueue":2,"./PriorityQueue/ArrayStrategy":3,"./PriorityQueue/BHeapStrategy":4,"./PriorityQueue/BinaryHeapStrategy":5}],2:[function(t,e){var i;e.exports=i=function(){function t(t){if(null==(null!=t?t.strategy:void 0))throw"Must pass options.strategy, a strategy";if(null==(null!=t?t.comparator:void 0))throw"Must pass options.comparator, a comparator";this.priv=new t.strategy(t),this.length=0}return t.prototype.queue=function(t){return this.length++,void this.priv.queue(t)},t.prototype.dequeue=function(){if(!this.length)throw"Empty queue";return this.length--,this.priv.dequeue()},t.prototype.peek=function(){if(!this.length)throw"Empty queue";return this.priv.peek()},t}()},{}],3:[function(t,e){var i,r;r=function(t,e,i){var r,o,a;for(o=0,r=t.length;r>o;)a=o+r>>>1,i(t[a],e)>=0?o=a+1:r=a;return o},e.exports=i=function(){function t(t){var e;this.options=t,this.comparator=this.options.comparator,this.data=(null!=(e=this.options.initialValues)?e.slice(0):void 0)||[],this.data.sort(this.comparator).reverse()}return t.prototype.queue=function(t){var e;return e=r(this.data,t,this.comparator),void this.data.splice(e,0,t)},t.prototype.dequeue=function(){return this.data.pop()},t.prototype.peek=function(){return this.data[this.data.length-1]},t}()},{}],4:[function(t,e){var i;e.exports=i=function(){function t(t){var e,i,r,o,a,n,s,u,h;for(this.comparator=(null!=t?t.comparator:void 0)||function(t,e){return t-e},this.pageSize=(null!=t?t.pageSize:void 0)||512,this.length=0,r=0;1<<r<this.pageSize;)r+=1;if(1<<r!==this.pageSize)throw"pageSize must be a power of two";for(this._shift=r,this._emptyMemoryPageTemplate=e=[],i=a=0,u=this.pageSize;u>=0?u>a:a>u;i=u>=0?++a:--a)e.push(null);if(this._memory=[],this._mask=this.pageSize-1,t.initialValues)for(h=t.initialValues,n=0,s=h.length;s>n;n++)o=h[n],this.queue(o)}return t.prototype.queue=function(t){return this.length+=1,this._write(this.length,t),void this._bubbleUp(this.length,t)},t.prototype.dequeue=function(){var t,e;return t=this._read(1),e=this._read(this.length),this.length-=1,this.length>0&&(this._write(1,e),this._bubbleDown(1,e)),t},t.prototype.peek=function(){return this._read(1)},t.prototype._write=function(t,e){var i;for(i=t>>this._shift;i>=this._memory.length;)this._memory.push(this._emptyMemoryPageTemplate.slice(0));return this._memory[i][t&this._mask]=e},t.prototype._read=function(t){return this._memory[t>>this._shift][t&this._mask]},t.prototype._bubbleUp=function(t,e){var i,r,o,a;for(i=this.comparator;t>1&&(r=t&this._mask,t<this.pageSize||r>3?o=t&~this._mask|r>>1:2>r?(o=t-this.pageSize>>this._shift,o+=o&~(this._mask>>1),o|=this.pageSize>>1):o=t-2,a=this._read(o),!(i(a,e)<0));)this._write(o,e),this._write(t,a),t=o;return void 0},t.prototype._bubbleDown=function(t,e){var i,r,o,a,n;for(n=this.comparator;t<this.length;)if(t>this._mask&&!(t&this._mask-1)?i=r=t+2:t&this.pageSize>>1?(i=(t&~this._mask)>>1,i|=t&this._mask>>1,i=i+1<<this._shift,r=i+1):(i=t+(t&this._mask),r=i+1),i!==r&&r<=this.length)if(o=this._read(i),a=this._read(r),n(o,e)<0&&n(o,a)<=0)this._write(i,e),this._write(t,o),t=i;else{if(!(n(a,e)<0))break;this._write(r,e),this._write(t,a),t=r}else{if(!(i<=this.length))break;if(o=this._read(i),!(n(o,e)<0))break;this._write(i,e),this._write(t,o),t=i}return void 0},t}()},{}],5:[function(t,e){var i;e.exports=i=function(){function t(t){var e;this.comparator=(null!=t?t.comparator:void 0)||function(t,e){return t-e},this.length=0,this.data=(null!=(e=t.initialValues)?e.slice(0):void 0)||[],this._heapify()}return t.prototype._heapify=function(){var t,e,i;if(this.data.length>0)for(t=e=1,i=this.data.length;i>=1?i>e:e>i;t=i>=1?++e:--e)this._bubbleUp(t);return void 0},t.prototype.queue=function(t){return this.data.push(t),void this._bubbleUp(this.data.length-1)},t.prototype.dequeue=function(){var t,e;return e=this.data[0],t=this.data.pop(),this.data.length>0&&(this.data[0]=t,this._bubbleDown(0)),e},t.prototype.peek=function(){return this.data[0]},t.prototype._bubbleUp=function(t){for(var e,i;t>0&&(e=t-1>>>1,this.comparator(this.data[t],this.data[e])<0);)i=this.data[e],this.data[e]=this.data[t],this.data[t]=i,t=e;return void 0},t.prototype._bubbleDown=function(t){var e,i,r,o,a;for(e=this.data.length-1;;){if(i=(t<<1)+1,o=i+1,r=t,e>=i&&this.comparator(this.data[i],this.data[r])<0&&(r=i),e>=o&&this.comparator(this.data[o],this.data[r])<0&&(r=o),r===t)break;a=this.data[r],this.data[r]=this.data[t],this.data[t]=a,t=r}return void 0},t}()},{}]},{},[1])(1)});
define('pathfinder',['./lib/priority-queue', './polypartition'],
function(   PriorityQueue,      pp) {
  var PolyUtils = pp.PolyUtils;

  /**
   * Pathfinder implements pathfinding on a navigation mesh.
   * @constructor
   * @param {Array.<Poly>} polys - The polygons defining the navigation mesh.
   * @param {boolean} [init=true] - Whether or not to initialize the pathfinder.
   */
  var Pathfinder = function(polys, init) {
    if (typeof init == "undefined") init = true;
    this.polys = polys;
    if (init) {
      this.init();
    }
  }

  Pathfinder.prototype.init = function() {
    this.grid = this.generateAdjacencyGrid(this.polys);
  }

  /**
   * Computes path from source to target, using sides and centers of the edges
   * between adjacent polygons. source and target are Points and polys should
   * be the final partitioned map.
   * @param {Point} source - The start location for the search.
   * @param {Point} target - The target location for the search.
   * @return {?Array.<Point>} - A series of points representing the path from
   *   the source to the target. If a path is not found, `null` is returned.
   */
  Pathfinder.prototype.aStar = function(source, target) {
    // Compares the value of two nodes.
    function nodeValue(node1, node2) {
      return (node1.dist + heuristic(node1.point)) - (node2.dist + heuristic(node2.point));
    }

    // Distance between polygons.
    function euclideanDistance(p1, p2) {
      return p1.dist(p2);
    }

    // Distance between polygons. todo: update
    function manhattanDistance(elt1, elt2) {
      return (elt1.r - elt2.r) + (elt1.c - elt2.c);
    }

    // Takes Point and returns value.
    function heuristic(p) {
      return euclideanDistance(p, target);
    }

    var sourcePoly = PolyUtils.findPolyForPoint(source, this.polys);

    // We're outside of the mesh somehow. Try a few nearby points.
    if (!sourcePoly) {
      var offsetSource = [new Point(5, 0), new Point(-5, 0), new Point(0, -5), new Point(0, 5)];
      for (var i = 0; i < offsetSource.length; i++) {
        // Make new point.
        var point = source.add(offsetSource[i]);
        sourcePoly = PolyUtils.findPolyForPoint(point, this.polys);
        if (sourcePoly) {
          source = point;
          break;
        }
      }
      if (!sourcePoly) {
        return null;
      }
    }
    var targetPoly = PolyUtils.findPolyForPoint(target, this.polys);

    // Handle trivial case.
    if (sourcePoly == targetPoly) {
      return [source, target];
    }

    // Warning, may have compatibility issues.
    var discoveredPolys = new WeakSet();
    var discoveredPoints = new WeakSet();
    var pq = new PriorityQueue({ comparator: nodeValue });
    var found = null;
    // Initialize with start location.
    pq.queue({dist: 0, poly: sourcePoly, point: source, parent: null});
    while (pq.length > 0) {
      var node = pq.dequeue();
      if (node.poly == targetPoly) {
        found = node;
        break;
      } else {
        discoveredPolys.add(node.poly);
        discoveredPoints.add(node.point);
      }
      // This may be undefined if there was no polygon found.
      var neighbors = this.grid.get(node.poly);
      for (var i = 0; i < neighbors.length; i++) {
        var elt = neighbors[i];
        var neighborFound = discoveredPolys.has(elt.poly);

        for (var j = 0; j < elt.edge.points.length; j++) {
          var p = elt.edge.points[j];
          if (!neighborFound || !discoveredPoints.has(p))
            pq.queue({dist: node.dist + euclideanDistance(p, node.point), poly: elt.poly, point: p, parent: node});
        }
      }
    }

    if (found) {
      var path = [];
      var current = found;
      while (current.parent) {
        path.unshift(current.point);
        current = current.parent;
      }
      path.unshift(current.point);
      // Add end point to path.
      path.push(target);
      return path;
    } else {
      return null;
    }
  }

  /**
   * Holds the "neighbor" relationship of Poly objects in the partition
   * using the Poly's themselves as keys, and an array of Poly's as
   * values, where the Polys in the array are neighbors of the Poly
   * that was the key.
   * @typedef AdjacencyGrid
   * @type {Object.<Poly, Array<Poly>>}
   */

  /**
   * Given an array of Poly objects, find all neighboring polygons for
   * each polygon.
   * @private
   * @param {Array.<Poly>} polys - The array of polys to find neighbors
   *   among.
   * @return {AdjacencyGrid} - The "neighbor" relationships.
   */
  Pathfinder.prototype.generateAdjacencyGrid = function(polys) {
    var neighbors = new WeakMap();
    polys.forEach(function(poly, polyI, polys) {
      if (neighbors.has(poly)) {
        // Maximum number of neighbors already found.
        if (neighbors.get(poly).length == poly.numpoints) {
          return;
        }
      } else {
        // Initialize array.
        neighbors.set(poly, new Array());
      }
      // Of remaining polygons, find some that are adjacent.
      poly.points.forEach(function(p1, i, points) {
        // Next point.
        var p2 = points[poly.getNextI(i)];
        for (var polyJ = polyI + 1; polyJ < polys.length; polyJ++) {
          var poly2 = polys[polyJ];
          // Iterate over points until match is found.
          poly2.points.some(function(q1, j, points2) {
            var q2 = points2[poly2.getNextI(j)];
            var match = p1.eq(q2) && p2.eq(q1);
            if (match) {
              var edge = new Edge(p1, p2);
              neighbors.get(poly).push({ poly: poly2, edge: edge });
              if (!neighbors.has(poly2)) {
                neighbors.set(poly2, new Array());
              }
              neighbors.get(poly2).push({ poly: poly, edge: edge });
            }
            return match;
          });
          if (neighbors.get(poly).length == poly.numpoints) break;
        }
      });
    });
    return neighbors;
  }

  return Pathfinder;
});

// rev 452
/********************************************************************************
 *                                                                              *
 * Author    :  Angus Johnson                                                   *
 * Version   :  6.1.3a                                                          *
 * Date      :  22 January 2014                                                 *
 * Website   :  http://www.angusj.com                                           *
 * Copyright :  Angus Johnson 2010-2014                                         *
 *                                                                              *
 * License:                                                                     *
 * Use, modification & distribution is subject to Boost Software License Ver 1. *
 * http://www.boost.org/LICENSE_1_0.txt                                         *
 *                                                                              *
 * Attributions:                                                                *
 * The code in this library is an extension of Bala Vatti's clipping algorithm: *
 * "A generic solution to polygon clipping"                                     *
 * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *
 * http://portal.acm.org/citation.cfm?id=129906                                 *
 *                                                                              *
 * Computer graphics and geometric modeling: implementation and algorithms      *
 * By Max K. Agoston                                                            *
 * Springer; 1 edition (January 4, 2005)                                        *
 * http://books.google.com/books?q=vatti+clipping+agoston                       *
 *                                                                              *
 * See also:                                                                    *
 * "Polygon Offsetting by Computing Winding Numbers"                            *
 * Paper no. DETC2005-85513 pp. 565-575                                         *
 * ASME 2005 International Design Engineering Technical Conferences             *
 * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *
 * September 24-28, 2005 , Long Beach, California, USA                          *
 * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *
 *                                                                              *
 *******************************************************************************/
/*******************************************************************************
 *                                                                              *
 * Author    :  Timo                                                            *
 * Version   :  6.1.3.2                                                         *
 * Date      :  1 February 2014                                                 *
 *                                                                              *
 * This is a translation of the C# Clipper library to Javascript.               *
 * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *
 * Because Javascript lacks support for 64-bit integers, the space              *
 * is a little more restricted than in C# version.                              *
 *                                                                              *
 * C# version has support for coordinate space:                                 *
 * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *
 * while Javascript version has support for space:                              *
 * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *
 *                                                                              *
 * Tom Wu's JSBN proved to be the fastest big integer library:                  *
 * http://jsperf.com/big-integer-library-test                                   *
 *                                                                              *
 * This class can be made simpler when (if ever) 64-bit integer support comes.  *
 *                                                                              *
 *******************************************************************************/
/*******************************************************************************
 *                                                                              *
 * Basic JavaScript BN library - subset useful for RSA encryption.              *
 * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *
 * Copyright (c) 2005  Tom Wu                                                   *
 * All Rights Reserved.                                                         *
 * See "LICENSE" for details:                                                   *
 * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *
 *                                                                              *
 *******************************************************************************/
define('lib/clipper',[],function(){function m(a,b,c){e.biginteger_used=1,null!=a&&("number"==typeof a&&"undefined"==typeof b?this.fromInt(a):"number"==typeof a?this.fromNumber(a,b,c):null==b&&"string"!=typeof a?this.fromString(a,256):this.fromString(a,b))}function n(){return new m(null)}function o(a,b,c,d,e,f){for(;--f>=0;){var g=b*this[a++]+c[d]+e;e=Math.floor(g/67108864),c[d++]=67108863&g}return e}function p(a,b,c,d,e,f){for(var g=32767&b,h=b>>15;--f>=0;){var i=32767&this[a],j=this[a++]>>15,k=h*i+j*g;i=g*i+((32767&k)<<15)+c[d]+(1073741823&e),e=(i>>>30)+(k>>>15)+h*j+(e>>>30),c[d++]=1073741823&i}return e}function q(a,b,c,d,e,f){for(var g=16383&b,h=b>>14;--f>=0;){var i=16383&this[a],j=this[a++]>>14,k=h*i+j*g;i=g*i+((16383&k)<<14)+c[d]+e,e=(i>>28)+(k>>14)+h*j,c[d++]=268435455&i}return e}function w(a){return s.charAt(a)}function x(a,b){var c=t[a.charCodeAt(b)];return null==c?-1:c}function y(a){for(var b=this.t-1;b>=0;--b)a[b]=this[b];a.t=this.t,a.s=this.s}function z(a){this.t=1,this.s=0>a?-1:0,a>0?this[0]=a:-1>a?this[0]=a+this.DV:this.t=0}function A(a){var b=n();return b.fromInt(a),b}function B(a,b){var c;if(16==b)c=4;else if(8==b)c=3;else if(256==b)c=8;else if(2==b)c=1;else if(32==b)c=5;else{if(4!=b)return this.fromRadix(a,b),void 0;c=2}this.t=0,this.s=0;for(var d=a.length,e=!1,f=0;--d>=0;){var g=8==c?255&a[d]:x(a,d);0>g?"-"==a.charAt(d)&&(e=!0):(e=!1,0==f?this[this.t++]=g:f+c>this.DB?(this[this.t-1]|=(g&(1<<this.DB-f)-1)<<f,this[this.t++]=g>>this.DB-f):this[this.t-1]|=g<<f,f+=c,f>=this.DB&&(f-=this.DB))}8==c&&0!=(128&a[0])&&(this.s=-1,f>0&&(this[this.t-1]|=(1<<this.DB-f)-1<<f)),this.clamp(),e&&m.ZERO.subTo(this,this)}function C(){for(var a=this.s&this.DM;this.t>0&&this[this.t-1]==a;)--this.t}function D(a){if(this.s<0)return"-"+this.negate().toString(a);var b;if(16==a)b=4;else if(8==a)b=3;else if(2==a)b=1;else if(32==a)b=5;else{if(4!=a)return this.toRadix(a);b=2}var d,c=(1<<b)-1,e=!1,f="",g=this.t,h=this.DB-g*this.DB%b;if(g-->0)for(h<this.DB&&(d=this[g]>>h)>0&&(e=!0,f=w(d));g>=0;)b>h?(d=(this[g]&(1<<h)-1)<<b-h,d|=this[--g]>>(h+=this.DB-b)):(d=this[g]>>(h-=b)&c,0>=h&&(h+=this.DB,--g)),d>0&&(e=!0),e&&(f+=w(d));return e?f:"0"}function E(){var a=n();return m.ZERO.subTo(this,a),a}function F(){return this.s<0?this.negate():this}function G(a){var b=this.s-a.s;if(0!=b)return b;var c=this.t;if(b=c-a.t,0!=b)return this.s<0?-b:b;for(;--c>=0;)if(0!=(b=this[c]-a[c]))return b;return 0}function H(a){var c,b=1;return 0!=(c=a>>>16)&&(a=c,b+=16),0!=(c=a>>8)&&(a=c,b+=8),0!=(c=a>>4)&&(a=c,b+=4),0!=(c=a>>2)&&(a=c,b+=2),0!=(c=a>>1)&&(a=c,b+=1),b}function I(){return this.t<=0?0:this.DB*(this.t-1)+H(this[this.t-1]^this.s&this.DM)}function J(a,b){var c;for(c=this.t-1;c>=0;--c)b[c+a]=this[c];for(c=a-1;c>=0;--c)b[c]=0;b.t=this.t+a,b.s=this.s}function K(a,b){for(var c=a;c<this.t;++c)b[c-a]=this[c];b.t=Math.max(this.t-a,0),b.s=this.s}function L(a,b){var h,c=a%this.DB,d=this.DB-c,e=(1<<d)-1,f=Math.floor(a/this.DB),g=this.s<<c&this.DM;for(h=this.t-1;h>=0;--h)b[h+f+1]=this[h]>>d|g,g=(this[h]&e)<<c;for(h=f-1;h>=0;--h)b[h]=0;b[f]=g,b.t=this.t+f+1,b.s=this.s,b.clamp()}function M(a,b){b.s=this.s;var c=Math.floor(a/this.DB);if(c>=this.t)return b.t=0,void 0;var d=a%this.DB,e=this.DB-d,f=(1<<d)-1;b[0]=this[c]>>d;for(var g=c+1;g<this.t;++g)b[g-c-1]|=(this[g]&f)<<e,b[g-c]=this[g]>>d;d>0&&(b[this.t-c-1]|=(this.s&f)<<e),b.t=this.t-c,b.clamp()}function N(a,b){for(var c=0,d=0,e=Math.min(a.t,this.t);e>c;)d+=this[c]-a[c],b[c++]=d&this.DM,d>>=this.DB;if(a.t<this.t){for(d-=a.s;c<this.t;)d+=this[c],b[c++]=d&this.DM,d>>=this.DB;d+=this.s}else{for(d+=this.s;c<a.t;)d-=a[c],b[c++]=d&this.DM,d>>=this.DB;d-=a.s}b.s=0>d?-1:0,-1>d?b[c++]=this.DV+d:d>0&&(b[c++]=d),b.t=c,b.clamp()}function O(a,b){var c=this.abs(),d=a.abs(),e=c.t;for(b.t=e+d.t;--e>=0;)b[e]=0;for(e=0;e<d.t;++e)b[e+c.t]=c.am(0,d[e],b,e,0,c.t);b.s=0,b.clamp(),this.s!=a.s&&m.ZERO.subTo(b,b)}function P(a){for(var b=this.abs(),c=a.t=2*b.t;--c>=0;)a[c]=0;for(c=0;c<b.t-1;++c){var d=b.am(c,b[c],a,2*c,0,1);(a[c+b.t]+=b.am(c+1,2*b[c],a,2*c+1,d,b.t-c-1))>=b.DV&&(a[c+b.t]-=b.DV,a[c+b.t+1]=1)}a.t>0&&(a[a.t-1]+=b.am(c,b[c],a,2*c,0,1)),a.s=0,a.clamp()}function Q(a,b,c){var d=a.abs();if(!(d.t<=0)){var e=this.abs();if(e.t<d.t)return null!=b&&b.fromInt(0),null!=c&&this.copyTo(c),void 0;null==c&&(c=n());var f=n(),g=this.s,h=a.s,i=this.DB-H(d[d.t-1]);i>0?(d.lShiftTo(i,f),e.lShiftTo(i,c)):(d.copyTo(f),e.copyTo(c));var j=f.t,k=f[j-1];if(0!=k){var l=k*(1<<this.F1)+(j>1?f[j-2]>>this.F2:0),o=this.FV/l,p=(1<<this.F1)/l,q=1<<this.F2,r=c.t,s=r-j,t=null==b?n():b;for(f.dlShiftTo(s,t),c.compareTo(t)>=0&&(c[c.t++]=1,c.subTo(t,c)),m.ONE.dlShiftTo(j,t),t.subTo(f,f);f.t<j;)f[f.t++]=0;for(;--s>=0;){var u=c[--r]==k?this.DM:Math.floor(c[r]*o+(c[r-1]+q)*p);if((c[r]+=f.am(0,u,c,s,0,j))<u)for(f.dlShiftTo(s,t),c.subTo(t,c);c[r]<--u;)c.subTo(t,c)}null!=b&&(c.drShiftTo(j,b),g!=h&&m.ZERO.subTo(b,b)),c.t=j,c.clamp(),i>0&&c.rShiftTo(i,c),0>g&&m.ZERO.subTo(c,c)}}}function R(a){var b=n();return this.abs().divRemTo(a,null,b),this.s<0&&b.compareTo(m.ZERO)>0&&a.subTo(b,b),b}function S(a){this.m=a}function T(a){return a.s<0||a.compareTo(this.m)>=0?a.mod(this.m):a}function U(a){return a}function V(a){a.divRemTo(this.m,null,a)}function W(a,b,c){a.multiplyTo(b,c),this.reduce(c)}function X(a,b){a.squareTo(b),this.reduce(b)}function Y(){if(this.t<1)return 0;var a=this[0];if(0==(1&a))return 0;var b=3&a;return b=15&b*(2-(15&a)*b),b=255&b*(2-(255&a)*b),b=65535&b*(2-(65535&(65535&a)*b)),b=b*(2-a*b%this.DV)%this.DV,b>0?this.DV-b:-b}function Z(a){this.m=a,this.mp=a.invDigit(),this.mpl=32767&this.mp,this.mph=this.mp>>15,this.um=(1<<a.DB-15)-1,this.mt2=2*a.t}function $(a){var b=n();return a.abs().dlShiftTo(this.m.t,b),b.divRemTo(this.m,null,b),a.s<0&&b.compareTo(m.ZERO)>0&&this.m.subTo(b,b),b}function _(a){var b=n();return a.copyTo(b),this.reduce(b),b}function ab(a){for(;a.t<=this.mt2;)a[a.t++]=0;for(var b=0;b<this.m.t;++b){var c=32767&a[b],d=c*this.mpl+((c*this.mph+(a[b]>>15)*this.mpl&this.um)<<15)&a.DM;for(c=b+this.m.t,a[c]+=this.m.am(0,d,a,b,0,this.m.t);a[c]>=a.DV;)a[c]-=a.DV,a[++c]++}a.clamp(),a.drShiftTo(this.m.t,a),a.compareTo(this.m)>=0&&a.subTo(this.m,a)}function bb(a,b){a.squareTo(b),this.reduce(b)}function cb(a,b,c){a.multiplyTo(b,c),this.reduce(c)}function db(){return 0==(this.t>0?1&this[0]:this.s)}function eb(a,b){if(a>4294967295||1>a)return m.ONE;var c=n(),d=n(),e=b.convert(this),f=H(a)-1;for(e.copyTo(c);--f>=0;)if(b.sqrTo(c,d),(a&1<<f)>0)b.mulTo(d,e,c);else{var g=c;c=d,d=g}return b.revert(c)}function fb(a,b){var c;return c=256>a||b.isEven()?new S(b):new Z(b),this.exp(a,c)}function gb(){var a=n();return this.copyTo(a),a}function hb(){if(this.s<0){if(1==this.t)return this[0]-this.DV;if(0==this.t)return-1}else{if(1==this.t)return this[0];if(0==this.t)return 0}return(this[1]&(1<<32-this.DB)-1)<<this.DB|this[0]}function ib(){return 0==this.t?this.s:this[0]<<24>>24}function jb(){return 0==this.t?this.s:this[0]<<16>>16}function kb(a){return Math.floor(Math.LN2*this.DB/Math.log(a))}function lb(){return this.s<0?-1:this.t<=0||1==this.t&&this[0]<=0?0:1}function mb(a){if(null==a&&(a=10),0==this.signum()||2>a||a>36)return"0";var b=this.chunkSize(a),c=Math.pow(a,b),d=A(c),e=n(),f=n(),g="";for(this.divRemTo(d,e,f);e.signum()>0;)g=(c+f.intValue()).toString(a).substr(1)+g,e.divRemTo(d,e,f);return f.intValue().toString(a)+g}function nb(a,b){this.fromInt(0),null==b&&(b=10);for(var c=this.chunkSize(b),d=Math.pow(b,c),e=!1,f=0,g=0,h=0;h<a.length;++h){var i=x(a,h);0>i?"-"==a.charAt(h)&&0==this.signum()&&(e=!0):(g=b*g+i,++f>=c&&(this.dMultiply(d),this.dAddOffset(g,0),f=0,g=0))}f>0&&(this.dMultiply(Math.pow(b,f)),this.dAddOffset(g,0)),e&&m.ZERO.subTo(this,this)}function ob(a,b,c){if("number"==typeof b)if(2>a)this.fromInt(1);else for(this.fromNumber(a,c),this.testBit(a-1)||this.bitwiseTo(m.ONE.shiftLeft(a-1),wb,this),this.isEven()&&this.dAddOffset(1,0);!this.isProbablePrime(b);)this.dAddOffset(2,0),this.bitLength()>a&&this.subTo(m.ONE.shiftLeft(a-1),this);else{var d=new Array,e=7&a;d.length=(a>>3)+1,b.nextBytes(d),e>0?d[0]&=(1<<e)-1:d[0]=0,this.fromString(d,256)}}function pb(){var a=this.t,b=new Array;b[0]=this.s;var d,c=this.DB-a*this.DB%8,e=0;if(a-->0)for(c<this.DB&&(d=this[a]>>c)!=(this.s&this.DM)>>c&&(b[e++]=d|this.s<<this.DB-c);a>=0;)8>c?(d=(this[a]&(1<<c)-1)<<8-c,d|=this[--a]>>(c+=this.DB-8)):(d=255&this[a]>>(c-=8),0>=c&&(c+=this.DB,--a)),0!=(128&d)&&(d|=-256),0==e&&(128&this.s)!=(128&d)&&++e,(e>0||d!=this.s)&&(b[e++]=d);return b}function qb(a){return 0==this.compareTo(a)}function rb(a){return this.compareTo(a)<0?this:a}function sb(a){return this.compareTo(a)>0?this:a}function tb(a,b,c){var d,e,f=Math.min(a.t,this.t);for(d=0;f>d;++d)c[d]=b(this[d],a[d]);if(a.t<this.t){for(e=a.s&this.DM,d=f;d<this.t;++d)c[d]=b(this[d],e);c.t=this.t}else{for(e=this.s&this.DM,d=f;d<a.t;++d)c[d]=b(e,a[d]);c.t=a.t}c.s=b(this.s,a.s),c.clamp()}function ub(a,b){return a&b}function vb(a){var b=n();return this.bitwiseTo(a,ub,b),b}function wb(a,b){return a|b}function xb(a){var b=n();return this.bitwiseTo(a,wb,b),b}function yb(a,b){return a^b}function zb(a){var b=n();return this.bitwiseTo(a,yb,b),b}function Ab(a,b){return a&~b}function Bb(a){var b=n();return this.bitwiseTo(a,Ab,b),b}function Cb(){for(var a=n(),b=0;b<this.t;++b)a[b]=this.DM&~this[b];return a.t=this.t,a.s=~this.s,a}function Db(a){var b=n();return 0>a?this.rShiftTo(-a,b):this.lShiftTo(a,b),b}function Eb(a){var b=n();return 0>a?this.lShiftTo(-a,b):this.rShiftTo(a,b),b}function Fb(a){if(0==a)return-1;var b=0;return 0==(65535&a)&&(a>>=16,b+=16),0==(255&a)&&(a>>=8,b+=8),0==(15&a)&&(a>>=4,b+=4),0==(3&a)&&(a>>=2,b+=2),0==(1&a)&&++b,b}function Gb(){for(var a=0;a<this.t;++a)if(0!=this[a])return a*this.DB+Fb(this[a]);return this.s<0?this.t*this.DB:-1}function Hb(a){for(var b=0;0!=a;)a&=a-1,++b;return b}function Ib(){for(var a=0,b=this.s&this.DM,c=0;c<this.t;++c)a+=Hb(this[c]^b);return a}function Jb(a){var b=Math.floor(a/this.DB);return b>=this.t?0!=this.s:0!=(this[b]&1<<a%this.DB)}function Kb(a,b){var c=m.ONE.shiftLeft(a);return this.bitwiseTo(c,b,c),c}function Lb(a){return this.changeBit(a,wb)}function Mb(a){return this.changeBit(a,Ab)}function Nb(a){return this.changeBit(a,yb)}function Ob(a,b){for(var c=0,d=0,e=Math.min(a.t,this.t);e>c;)d+=this[c]+a[c],b[c++]=d&this.DM,d>>=this.DB;if(a.t<this.t){for(d+=a.s;c<this.t;)d+=this[c],b[c++]=d&this.DM,d>>=this.DB;d+=this.s}else{for(d+=this.s;c<a.t;)d+=a[c],b[c++]=d&this.DM,d>>=this.DB;d+=a.s}b.s=0>d?-1:0,d>0?b[c++]=d:-1>d&&(b[c++]=this.DV+d),b.t=c,b.clamp()}function Pb(a){var b=n();return this.addTo(a,b),b}function Qb(a){var b=n();return this.subTo(a,b),b}function Rb(a){var b=n();return this.multiplyTo(a,b),b}function Sb(){var a=n();return this.squareTo(a),a}function Tb(a){var b=n();return this.divRemTo(a,b,null),b}function Ub(a){var b=n();return this.divRemTo(a,null,b),b}function Vb(a){var b=n(),c=n();return this.divRemTo(a,b,c),new Array(b,c)}function Wb(a){this[this.t]=this.am(0,a-1,this,0,0,this.t),++this.t,this.clamp()}function Xb(a,b){if(0!=a){for(;this.t<=b;)this[this.t++]=0;for(this[b]+=a;this[b]>=this.DV;)this[b]-=this.DV,++b>=this.t&&(this[this.t++]=0),++this[b]}}function Yb(){}function Zb(a){return a}function $b(a,b,c){a.multiplyTo(b,c)}function _b(a,b){a.squareTo(b)}function ac(a){return this.exp(a,new Yb)}function bc(a,b,c){var d=Math.min(this.t+a.t,b);for(c.s=0,c.t=d;d>0;)c[--d]=0;var e;for(e=c.t-this.t;e>d;++d)c[d+this.t]=this.am(0,a[d],c,d,0,this.t);for(e=Math.min(a.t,b);e>d;++d)this.am(0,a[d],c,d,0,b-d);c.clamp()}function cc(a,b,c){--b;var d=c.t=this.t+a.t-b;for(c.s=0;--d>=0;)c[d]=0;for(d=Math.max(b-this.t,0);d<a.t;++d)c[this.t+d-b]=this.am(b-d,a[d],c,0,0,this.t+d-b);c.clamp(),c.drShiftTo(1,c)}function dc(a){this.r2=n(),this.q3=n(),m.ONE.dlShiftTo(2*a.t,this.r2),this.mu=this.r2.divide(a),this.m=a}function ec(a){if(a.s<0||a.t>2*this.m.t)return a.mod(this.m);if(a.compareTo(this.m)<0)return a;var b=n();return a.copyTo(b),this.reduce(b),b}function fc(a){return a}function gc(a){for(a.drShiftTo(this.m.t-1,this.r2),a.t>this.m.t+1&&(a.t=this.m.t+1,a.clamp()),this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3),this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);a.compareTo(this.r2)<0;)a.dAddOffset(1,this.m.t+1);for(a.subTo(this.r2,a);a.compareTo(this.m)>=0;)a.subTo(this.m,a)}function hc(a,b){a.squareTo(b),this.reduce(b)}function ic(a,b,c){a.multiplyTo(b,c),this.reduce(c)}function jc(a,b){var d,f,c=a.bitLength(),e=A(1);if(0>=c)return e;d=18>c?1:48>c?3:144>c?4:768>c?5:6,f=8>c?new S(b):b.isEven()?new dc(b):new Z(b);var g=new Array,h=3,i=d-1,j=(1<<d)-1;if(g[1]=f.convert(this),d>1){var k=n();for(f.sqrTo(g[1],k);j>=h;)g[h]=n(),f.mulTo(k,g[h-2],g[h]),h+=2}var m,q,l=a.t-1,o=!0,p=n();for(c=H(a[l])-1;l>=0;){for(c>=i?m=a[l]>>c-i&j:(m=(a[l]&(1<<c+1)-1)<<i-c,l>0&&(m|=a[l-1]>>this.DB+c-i)),h=d;0==(1&m);)m>>=1,--h;if((c-=h)<0&&(c+=this.DB,--l),o)g[m].copyTo(e),o=!1;else{for(;h>1;)f.sqrTo(e,p),f.sqrTo(p,e),h-=2;h>0?f.sqrTo(e,p):(q=e,e=p,p=q),f.mulTo(p,g[m],e)}for(;l>=0&&0==(a[l]&1<<c);)f.sqrTo(e,p),q=e,e=p,p=q,--c<0&&(c=this.DB-1,--l)}return f.revert(e)}function kc(a){var b=this.s<0?this.negate():this.clone(),c=a.s<0?a.negate():a.clone();if(b.compareTo(c)<0){var d=b;b=c,c=d}var e=b.getLowestSetBit(),f=c.getLowestSetBit();if(0>f)return b;for(f>e&&(f=e),f>0&&(b.rShiftTo(f,b),c.rShiftTo(f,c));b.signum()>0;)(e=b.getLowestSetBit())>0&&b.rShiftTo(e,b),(e=c.getLowestSetBit())>0&&c.rShiftTo(e,c),b.compareTo(c)>=0?(b.subTo(c,b),b.rShiftTo(1,b)):(c.subTo(b,c),c.rShiftTo(1,c));return f>0&&c.lShiftTo(f,c),c}function lc(a){if(0>=a)return 0;var b=this.DV%a,c=this.s<0?a-1:0;if(this.t>0)if(0==b)c=this[0]%a;else for(var d=this.t-1;d>=0;--d)c=(b*c+this[d])%a;return c}function mc(a){var b=a.isEven();if(this.isEven()&&b||0==a.signum())return m.ZERO;for(var c=a.clone(),d=this.clone(),e=A(1),f=A(0),g=A(0),h=A(1);0!=c.signum();){for(;c.isEven();)c.rShiftTo(1,c),b?(e.isEven()&&f.isEven()||(e.addTo(this,e),f.subTo(a,f)),e.rShiftTo(1,e)):f.isEven()||f.subTo(a,f),f.rShiftTo(1,f);for(;d.isEven();)d.rShiftTo(1,d),b?(g.isEven()&&h.isEven()||(g.addTo(this,g),h.subTo(a,h)),g.rShiftTo(1,g)):h.isEven()||h.subTo(a,h),h.rShiftTo(1,h);c.compareTo(d)>=0?(c.subTo(d,c),b&&e.subTo(g,e),f.subTo(h,f)):(d.subTo(c,d),b&&g.subTo(e,g),h.subTo(f,h))}return 0!=d.compareTo(m.ONE)?m.ZERO:h.compareTo(a)>=0?h.subtract(a):h.signum()<0?(h.addTo(a,h),h.signum()<0?h.add(a):h):h}function pc(a){var b,c=this.abs();if(1==c.t&&c[0]<=nc[nc.length-1]){for(b=0;b<nc.length;++b)if(c[0]==nc[b])return!0;return!1}if(c.isEven())return!1;for(b=1;b<nc.length;){for(var d=nc[b],e=b+1;e<nc.length&&oc>d;)d*=nc[e++];for(d=c.modInt(d);e>b;)if(0==d%nc[b++])return!1}return c.millerRabin(a)}function qc(a){var b=this.subtract(m.ONE),c=b.getLowestSetBit();if(0>=c)return!1;var d=b.shiftRight(c);a=a+1>>1,a>nc.length&&(a=nc.length);for(var e=n(),f=0;a>f;++f){e.fromInt(nc[Math.floor(Math.random()*nc.length)]);var g=e.modPow(d,this);if(0!=g.compareTo(m.ONE)&&0!=g.compareTo(b)){for(var h=1;h++<c&&0!=g.compareTo(b);)if(g=g.modPowInt(2,this),0==g.compareTo(m.ONE))return!1;if(0!=g.compareTo(b))return!1}}return!0}var a=!1,b=!1,c=!0,d=!1,e={},f=!1;"undefined"!=typeof module&&module.exports?(module.exports=e,f=!0):"undefined"!=typeof document?window.ClipperLib=e:self.ClipperLib=e;var g;if(f){var h="chrome";g="Netscape"}else{var h=navigator.userAgent.toString().toLowerCase();g=navigator.appName}var i={};i.chrome=-1!=h.indexOf("chrome")&&-1==h.indexOf("chromium")?1:0,i.chromium=-1!=h.indexOf("chromium")?1:0,i.safari=-1!=h.indexOf("safari")&&-1==h.indexOf("chrome")&&-1==h.indexOf("chromium")?1:0,i.firefox=-1!=h.indexOf("firefox")?1:0,i.firefox17=-1!=h.indexOf("firefox/17")?1:0,i.firefox15=-1!=h.indexOf("firefox/15")?1:0,i.firefox3=-1!=h.indexOf("firefox/3")?1:0,i.opera=-1!=h.indexOf("opera")?1:0,i.msie10=-1!=h.indexOf("msie 10")?1:0,i.msie9=-1!=h.indexOf("msie 9")?1:0,i.msie8=-1!=h.indexOf("msie 8")?1:0,i.msie7=-1!=h.indexOf("msie 7")?1:0,i.msie=-1!=h.indexOf("msie ")?1:0,e.biginteger_used=null;var j,k=0xdeadbeefcafe,l=15715070==(16777215&k);l&&"Microsoft Internet Explorer"==g?(m.prototype.am=p,j=30):l&&"Netscape"!=g?(m.prototype.am=o,j=26):(m.prototype.am=q,j=28),m.prototype.DB=j,m.prototype.DM=(1<<j)-1,m.prototype.DV=1<<j;var r=52;m.prototype.FV=Math.pow(2,r),m.prototype.F1=r-j,m.prototype.F2=2*j-r;var u,v,s="0123456789abcdefghijklmnopqrstuvwxyz",t=new Array;for(u="0".charCodeAt(0),v=0;9>=v;++v)t[u++]=v;for(u="a".charCodeAt(0),v=10;36>v;++v)t[u++]=v;for(u="A".charCodeAt(0),v=10;36>v;++v)t[u++]=v;S.prototype.convert=T,S.prototype.revert=U,S.prototype.reduce=V,S.prototype.mulTo=W,S.prototype.sqrTo=X,Z.prototype.convert=$,Z.prototype.revert=_,Z.prototype.reduce=ab,Z.prototype.mulTo=cb,Z.prototype.sqrTo=bb,m.prototype.copyTo=y,m.prototype.fromInt=z,m.prototype.fromString=B,m.prototype.clamp=C,m.prototype.dlShiftTo=J,m.prototype.drShiftTo=K,m.prototype.lShiftTo=L,m.prototype.rShiftTo=M,m.prototype.subTo=N,m.prototype.multiplyTo=O,m.prototype.squareTo=P,m.prototype.divRemTo=Q,m.prototype.invDigit=Y,m.prototype.isEven=db,m.prototype.exp=eb,m.prototype.toString=D,m.prototype.negate=E,m.prototype.abs=F,m.prototype.compareTo=G,m.prototype.bitLength=I,m.prototype.mod=R,m.prototype.modPowInt=fb,m.ZERO=A(0),m.ONE=A(1),Yb.prototype.convert=Zb,Yb.prototype.revert=Zb,Yb.prototype.mulTo=$b,Yb.prototype.sqrTo=_b,dc.prototype.convert=ec,dc.prototype.revert=fc,dc.prototype.reduce=gc,dc.prototype.mulTo=ic,dc.prototype.sqrTo=hc;var nc=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997],oc=(1<<26)/nc[nc.length-1];m.prototype.chunkSize=kb,m.prototype.toRadix=mb,m.prototype.fromRadix=nb,m.prototype.fromNumber=ob,m.prototype.bitwiseTo=tb,m.prototype.changeBit=Kb,m.prototype.addTo=Ob,m.prototype.dMultiply=Wb,m.prototype.dAddOffset=Xb,m.prototype.multiplyLowerTo=bc,m.prototype.multiplyUpperTo=cc,m.prototype.modInt=lc,m.prototype.millerRabin=qc,m.prototype.clone=gb,m.prototype.intValue=hb,m.prototype.byteValue=ib,m.prototype.shortValue=jb,m.prototype.signum=lb,m.prototype.toByteArray=pb,m.prototype.equals=qb,m.prototype.min=rb,m.prototype.max=sb,m.prototype.and=vb,m.prototype.or=xb,m.prototype.xor=zb,m.prototype.andNot=Bb,m.prototype.not=Cb,m.prototype.shiftLeft=Db,m.prototype.shiftRight=Eb,m.prototype.getLowestSetBit=Gb,m.prototype.bitCount=Ib,m.prototype.testBit=Jb,m.prototype.setBit=Lb,m.prototype.clearBit=Mb,m.prototype.flipBit=Nb,m.prototype.add=Pb,m.prototype.subtract=Qb,m.prototype.multiply=Rb,m.prototype.divide=Tb,m.prototype.remainder=Ub,m.prototype.divideAndRemainder=Vb,m.prototype.modPow=jc,m.prototype.modInverse=mc,m.prototype.pow=ac,m.prototype.gcd=kc,m.prototype.isProbablePrime=pc,m.prototype.square=Sb;var rc=m;if(rc.prototype.IsNegative=function(){return-1==this.compareTo(rc.ZERO)?!0:!1},rc.op_Equality=function(a,b){return 0==a.compareTo(b)?!0:!1},rc.op_Inequality=function(a,b){return 0!=a.compareTo(b)?!0:!1},rc.op_GreaterThan=function(a,b){return a.compareTo(b)>0?!0:!1},rc.op_LessThan=function(a,b){return a.compareTo(b)<0?!0:!1},rc.op_Addition=function(a,b){return new rc(a).add(new rc(b))},rc.op_Subtraction=function(a,b){return new rc(a).subtract(new rc(b))},rc.Int128Mul=function(a,b){return new rc(a).multiply(new rc(b))},rc.op_Division=function(a,b){return a.divide(b)},rc.prototype.ToDouble=function(){return parseFloat(this.toString())},"undefined"==typeof sc)var sc=function(a,b){var c;if("undefined"==typeof Object.getOwnPropertyNames){for(c in b.prototype)("undefined"==typeof a.prototype[c]||a.prototype[c]==Object.prototype[c])&&(a.prototype[c]=b.prototype[c]);for(c in b)"undefined"==typeof a[c]&&(a[c]=b[c]);a.$baseCtor=b}else{for(var d=Object.getOwnPropertyNames(b.prototype),e=0;e<d.length;e++)"undefined"==typeof Object.getOwnPropertyDescriptor(a.prototype,d[e])&&Object.defineProperty(a.prototype,d[e],Object.getOwnPropertyDescriptor(b.prototype,d[e]));for(c in b)"undefined"==typeof a[c]&&(a[c]=b[c]);a.$baseCtor=b}};e.Path=function(){return[]},e.Paths=function(){return[]},e.DoublePoint=function(){var a=arguments;this.X=0,this.Y=0,1==a.length?(this.X=a[0].X,this.Y=a[0].Y):2==a.length&&(this.X=a[0],this.Y=a[1])},e.DoublePoint0=function(){this.X=0,this.Y=0},e.DoublePoint1=function(a){this.X=a.X,this.Y=a.Y},e.DoublePoint2=function(a,b){this.X=a,this.Y=b},e.PolyNode=function(){this.m_Parent=null,this.m_polygon=new e.Path,this.m_Index=0,this.m_jointype=0,this.m_endtype=0,this.m_Childs=[],this.IsOpen=!1},e.PolyNode.prototype.IsHoleNode=function(){for(var a=!0,b=this.m_Parent;null!==b;)a=!a,b=b.m_Parent;return a},e.PolyNode.prototype.ChildCount=function(){return this.m_Childs.length},e.PolyNode.prototype.Contour=function(){return this.m_polygon},e.PolyNode.prototype.AddChild=function(a){var b=this.m_Childs.length;this.m_Childs.push(a),a.m_Parent=this,a.m_Index=b},e.PolyNode.prototype.GetNext=function(){return this.m_Childs.length>0?this.m_Childs[0]:this.GetNextSiblingUp()},e.PolyNode.prototype.GetNextSiblingUp=function(){return null===this.m_Parent?null:this.m_Index==this.m_Parent.m_Childs.length-1?this.m_Parent.GetNextSiblingUp():this.m_Parent.m_Childs[this.m_Index+1]},e.PolyNode.prototype.Childs=function(){return this.m_Childs},e.PolyNode.prototype.Parent=function(){return this.m_Parent},e.PolyNode.prototype.IsHole=function(){return this.IsHoleNode()},e.PolyTree=function(){this.m_AllPolys=[],e.PolyNode.call(this)},e.PolyTree.prototype.Clear=function(){for(var a=0,b=this.m_AllPolys.length;b>a;a++)this.m_AllPolys[a]=null;this.m_AllPolys.length=0,this.m_Childs.length=0},e.PolyTree.prototype.GetFirst=function(){return this.m_Childs.length>0?this.m_Childs[0]:null},e.PolyTree.prototype.Total=function(){return this.m_AllPolys.length},sc(e.PolyTree,e.PolyNode),e.Math_Abs_Int64=e.Math_Abs_Int32=e.Math_Abs_Double=function(a){return Math.abs(a)},e.Math_Max_Int32_Int32=function(a,b){return Math.max(a,b)},e.Cast_Int32=i.msie||i.opera||i.safari?function(a){return 0|a}:function(a){return~~a},e.Cast_Int64=i.chrome?function(a){return-2147483648>a||a>2147483647?0>a?Math.ceil(a):Math.floor(a):~~a}:i.firefox&&"function"==typeof Number.toInteger?function(a){return Number.toInteger(a)}:i.msie7||i.msie8?function(a){return parseInt(a,10)}:i.msie?function(a){return-2147483648>a||a>2147483647?0>a?Math.ceil(a):Math.floor(a):0|a}:function(a){return 0>a?Math.ceil(a):Math.floor(a)},e.Clear=function(a){a.length=0},e.PI=3.141592653589793,e.PI2=6.283185307179586,e.IntPoint=function(){var a=arguments,c=a.length;if(this.X=0,this.Y=0,b)if(this.Z=0,3==c)this.X=a[0],this.Y=a[1],this.Z=a[2];else if(2==c)this.X=a[0],this.Y=a[1],this.Z=0;else if(1==c)if(a[0]instanceof e.DoublePoint){var d=a[0];this.X=e.Clipper.Round(d.X),this.Y=e.Clipper.Round(d.Y),this.Z=0}else{var f=a[0];"undefined"==typeof f.Z&&(f.Z=0),this.X=f.X,this.Y=f.Y,this.Z=f.Z}else this.X=0,this.Y=0,this.Z=0;else if(2==c)this.X=a[0],this.Y=a[1];else if(1==c)if(a[0]instanceof e.DoublePoint){var d=a[0];this.X=e.Clipper.Round(d.X),this.Y=e.Clipper.Round(d.Y)}else{var f=a[0];this.X=f.X,this.Y=f.Y}else this.X=0,this.Y=0},e.IntPoint.op_Equality=function(a,b){return a.X==b.X&&a.Y==b.Y},e.IntPoint.op_Inequality=function(a,b){return a.X!=b.X||a.Y!=b.Y},b?(e.IntPoint0=function(){this.X=0,this.Y=0,this.Z=0},e.IntPoint1=function(a){this.X=a.X,this.Y=a.Y,this.Z=a.Z},e.IntPoint1dp=function(a){this.X=e.Clipper.Round(a.X),this.Y=e.Clipper.Round(a.Y),this.Z=0},e.IntPoint2=function(a,b){this.X=a,this.Y=b,this.Z=0},e.IntPoint3=function(a,b,c){this.X=a,this.Y=b,this.Z=c}):(e.IntPoint0=function(){this.X=0,this.Y=0},e.IntPoint1=function(a){this.X=a.X,this.Y=a.Y},e.IntPoint1dp=function(a){this.X=e.Clipper.Round(a.X),this.Y=e.Clipper.Round(a.Y)},e.IntPoint2=function(a,b){this.X=a,this.Y=b}),e.IntRect=function(){var a=arguments,b=a.length;4==b?(this.left=a[0],this.top=a[1],this.right=a[2],this.bottom=a[3]):1==b?(this.left=ir.left,this.top=ir.top,this.right=ir.right,this.bottom=ir.bottom):(this.left=0,this.top=0,this.right=0,this.bottom=0)},e.IntRect0=function(){this.left=0,this.top=0,this.right=0,this.bottom=0},e.IntRect1=function(a){this.left=a.left,this.top=a.top,this.right=a.right,this.bottom=a.bottom},e.IntRect4=function(a,b,c,d){this.left=a,this.top=b,this.right=c,this.bottom=d},e.ClipType={ctIntersection:0,ctUnion:1,ctDifference:2,ctXor:3},e.PolyType={ptSubject:0,ptClip:1},e.PolyFillType={pftEvenOdd:0,pftNonZero:1,pftPositive:2,pftNegative:3},e.JoinType={jtSquare:0,jtRound:1,jtMiter:2},e.EndType={etOpenSquare:0,etOpenRound:1,etOpenButt:2,etClosedLine:3,etClosedPolygon:4},d&&(e.EndType_={etSquare:0,etRound:1,etButt:2,etClosed:3}),e.EdgeSide={esLeft:0,esRight:1},e.Direction={dRightToLeft:0,dLeftToRight:1},e.TEdge=function(){this.Bot=new e.IntPoint,this.Curr=new e.IntPoint,this.Top=new e.IntPoint,this.Delta=new e.IntPoint,this.Dx=0,this.PolyTyp=e.PolyType.ptSubject,this.Side=e.EdgeSide.esLeft,this.WindDelta=0,this.WindCnt=0,this.WindCnt2=0,this.OutIdx=0,this.Next=null,this.Prev=null,this.NextInLML=null,this.NextInAEL=null,this.PrevInAEL=null,this.NextInSEL=null,this.PrevInSEL=null},e.IntersectNode=function(){this.Edge1=null,this.Edge2=null,this.Pt=new e.IntPoint},e.MyIntersectNodeSort=function(){},e.MyIntersectNodeSort.Compare=function(a,b){return b.Pt.Y-a.Pt.Y},e.LocalMinima=function(){this.Y=0,this.LeftBound=null,this.RightBound=null,this.Next=null},e.Scanbeam=function(){this.Y=0,this.Next=null},e.OutRec=function(){this.Idx=0,this.IsHole=!1,this.IsOpen=!1,this.FirstLeft=null,this.Pts=null,this.BottomPt=null,this.PolyNode=null},e.OutPt=function(){this.Idx=0,this.Pt=new e.IntPoint,this.Next=null,this.Prev=null},e.Join=function(){this.OutPt1=null,this.OutPt2=null,this.OffPt=new e.IntPoint},e.ClipperBase=function(){this.m_MinimaList=null,this.m_CurrentLM=null,this.m_edges=new Array,this.m_UseFullRange=!1,this.m_HasOpenPaths=!1,this.PreserveCollinear=!1,this.m_MinimaList=null,this.m_CurrentLM=null,this.m_UseFullRange=!1,this.m_HasOpenPaths=!1},e.ClipperBase.horizontal=-9007199254740992,e.ClipperBase.Skip=-2,e.ClipperBase.Unassigned=-1,e.ClipperBase.tolerance=1e-20,a?(e.ClipperBase.loRange=46340,e.ClipperBase.hiRange=46340):(e.ClipperBase.loRange=47453132,e.ClipperBase.hiRange=0xfffffffffffff),e.ClipperBase.near_zero=function(a){return a>-e.ClipperBase.tolerance&&a<e.ClipperBase.tolerance},e.ClipperBase.IsHorizontal=function(a){return 0===a.Delta.Y},e.ClipperBase.prototype.PointIsVertex=function(a,b){var c=b;do{if(e.IntPoint.op_Equality(c.Pt,a))return!0;c=c.Next}while(c!=b);return!1},e.ClipperBase.prototype.PointOnLineSegment=function(a,b,c,d){return d?a.X==b.X&&a.Y==b.Y||a.X==c.X&&a.Y==c.Y||a.X>b.X==a.X<c.X&&a.Y>b.Y==a.Y<c.Y&&rc.op_Equality(rc.Int128Mul(a.X-b.X,c.Y-b.Y),rc.Int128Mul(c.X-b.X,a.Y-b.Y)):a.X==b.X&&a.Y==b.Y||a.X==c.X&&a.Y==c.Y||a.X>b.X==a.X<c.X&&a.Y>b.Y==a.Y<c.Y&&(a.X-b.X)*(c.Y-b.Y)==(c.X-b.X)*(a.Y-b.Y)},e.ClipperBase.prototype.PointOnPolygon=function(a,b,c){for(var d=b;;){if(this.PointOnLineSegment(a,d.Pt,d.Next.Pt,c))return!0;if(d=d.Next,d==b)break}return!1},e.ClipperBase.prototype.SlopesEqual=e.ClipperBase.SlopesEqual=function(){var c,d,f,g,h,i,j,a=arguments,b=a.length;return 3==b?(c=a[0],d=a[1],j=a[2],j?rc.op_Equality(rc.Int128Mul(c.Delta.Y,d.Delta.X),rc.Int128Mul(c.Delta.X,d.Delta.Y)):e.Cast_Int64(c.Delta.Y*d.Delta.X)==e.Cast_Int64(c.Delta.X*d.Delta.Y)):4==b?(f=a[0],g=a[1],h=a[2],j=a[3],j?rc.op_Equality(rc.Int128Mul(f.Y-g.Y,g.X-h.X),rc.Int128Mul(f.X-g.X,g.Y-h.Y)):0===e.Cast_Int64((f.Y-g.Y)*(g.X-h.X))-e.Cast_Int64((f.X-g.X)*(g.Y-h.Y))):(f=a[0],g=a[1],h=a[2],i=a[3],j=a[4],j?rc.op_Equality(rc.Int128Mul(f.Y-g.Y,h.X-i.X),rc.Int128Mul(f.X-g.X,h.Y-i.Y)):0===e.Cast_Int64((f.Y-g.Y)*(h.X-i.X))-e.Cast_Int64((f.X-g.X)*(h.Y-i.Y)))},e.ClipperBase.SlopesEqual3=function(a,b,c){return c?rc.op_Equality(rc.Int128Mul(a.Delta.Y,b.Delta.X),rc.Int128Mul(a.Delta.X,b.Delta.Y)):e.Cast_Int64(a.Delta.Y*b.Delta.X)==e.Cast_Int64(a.Delta.X*b.Delta.Y)},e.ClipperBase.SlopesEqual4=function(a,b,c,d){return d?rc.op_Equality(rc.Int128Mul(a.Y-b.Y,b.X-c.X),rc.Int128Mul(a.X-b.X,b.Y-c.Y)):0===e.Cast_Int64((a.Y-b.Y)*(b.X-c.X))-e.Cast_Int64((a.X-b.X)*(b.Y-c.Y))},e.ClipperBase.SlopesEqual5=function(a,b,c,d,f){return f?rc.op_Equality(rc.Int128Mul(a.Y-b.Y,c.X-d.X),rc.Int128Mul(a.X-b.X,c.Y-d.Y)):0===e.Cast_Int64((a.Y-b.Y)*(c.X-d.X))-e.Cast_Int64((a.X-b.X)*(c.Y-d.Y))},e.ClipperBase.prototype.Clear=function(){this.DisposeLocalMinimaList();for(var a=0,b=this.m_edges.length;b>a;++a){for(var c=0,d=this.m_edges[a].length;d>c;++c)this.m_edges[a][c]=null;e.Clear(this.m_edges[a])}e.Clear(this.m_edges),this.m_UseFullRange=!1,this.m_HasOpenPaths=!1},e.ClipperBase.prototype.DisposeLocalMinimaList=function(){for(;null!==this.m_MinimaList;){var a=this.m_MinimaList.Next;this.m_MinimaList=null,this.m_MinimaList=a}this.m_CurrentLM=null},e.ClipperBase.prototype.RangeTest=function(a,b){b.Value?(a.X>e.ClipperBase.hiRange||a.Y>e.ClipperBase.hiRange||-a.X>e.ClipperBase.hiRange||-a.Y>e.ClipperBase.hiRange)&&e.Error("Coordinate outside allowed range in RangeTest()."):(a.X>e.ClipperBase.loRange||a.Y>e.ClipperBase.loRange||-a.X>e.ClipperBase.loRange||-a.Y>e.ClipperBase.loRange)&&(b.Value=!0,this.RangeTest(a,b))},e.ClipperBase.prototype.InitEdge=function(a,b,c,d){a.Next=b,a.Prev=c,a.Curr.X=d.X,a.Curr.Y=d.Y,a.OutIdx=-1},e.ClipperBase.prototype.InitEdge2=function(a,b){a.Curr.Y>=a.Next.Curr.Y?(a.Bot.X=a.Curr.X,a.Bot.Y=a.Curr.Y,a.Top.X=a.Next.Curr.X,a.Top.Y=a.Next.Curr.Y):(a.Top.X=a.Curr.X,a.Top.Y=a.Curr.Y,a.Bot.X=a.Next.Curr.X,a.Bot.Y=a.Next.Curr.Y),this.SetDx(a),a.PolyTyp=b},e.ClipperBase.prototype.FindNextLocMin=function(a){for(var b;;){for(;e.IntPoint.op_Inequality(a.Bot,a.Prev.Bot)||e.IntPoint.op_Equality(a.Curr,a.Top);)a=a.Next;if(a.Dx!=e.ClipperBase.horizontal&&a.Prev.Dx!=e.ClipperBase.horizontal)break;for(;a.Prev.Dx==e.ClipperBase.horizontal;)a=a.Prev;for(b=a;a.Dx==e.ClipperBase.horizontal;)a=a.Next;if(a.Top.Y!=a.Prev.Bot.Y){b.Prev.Bot.X<a.Bot.X&&(a=b);break}}return a},e.ClipperBase.prototype.ProcessBound=function(a,b){var f,g,c=a,d=a;if(a.Dx==e.ClipperBase.horizontal&&(g=b?a.Prev.Bot.X:a.Next.Bot.X,a.Bot.X!=g&&this.ReverseHorizontal(a)),d.OutIdx!=e.ClipperBase.Skip)if(b){for(;d.Top.Y==d.Next.Bot.Y&&d.Next.OutIdx!=e.ClipperBase.Skip;)d=d.Next;if(d.Dx==e.ClipperBase.horizontal&&d.Next.OutIdx!=e.ClipperBase.Skip){for(f=d;f.Prev.Dx==e.ClipperBase.horizontal;)f=f.Prev;f.Prev.Top.X==d.Next.Top.X?b||(d=f.Prev):f.Prev.Top.X>d.Next.Top.X&&(d=f.Prev)}for(;a!=d;)a.NextInLML=a.Next,a.Dx==e.ClipperBase.horizontal&&a!=c&&a.Bot.X!=a.Prev.Top.X&&this.ReverseHorizontal(a),a=a.Next;a.Dx==e.ClipperBase.horizontal&&a!=c&&a.Bot.X!=a.Prev.Top.X&&this.ReverseHorizontal(a),d=d.Next}else{for(;d.Top.Y==d.Prev.Bot.Y&&d.Prev.OutIdx!=e.ClipperBase.Skip;)d=d.Prev;if(d.Dx==e.ClipperBase.horizontal&&d.Prev.OutIdx!=e.ClipperBase.Skip){for(f=d;f.Next.Dx==e.ClipperBase.horizontal;)f=f.Next;f.Next.Top.X==d.Prev.Top.X?b||(d=f.Next):f.Next.Top.X>d.Prev.Top.X&&(d=f.Next)}for(;a!=d;)a.NextInLML=a.Prev,a.Dx==e.ClipperBase.horizontal&&a!=c&&a.Bot.X!=a.Next.Top.X&&this.ReverseHorizontal(a),a=a.Prev;a.Dx==e.ClipperBase.horizontal&&a!=c&&a.Bot.X!=a.Next.Top.X&&this.ReverseHorizontal(a),d=d.Prev}if(d.OutIdx==e.ClipperBase.Skip){if(a=d,b){for(;a.Top.Y==a.Next.Bot.Y;)a=a.Next;for(;a!=d&&a.Dx==e.ClipperBase.horizontal;)a=a.Prev}else{for(;a.Top.Y==a.Prev.Bot.Y;)a=a.Prev;for(;a!=d&&a.Dx==e.ClipperBase.horizontal;)a=a.Next}if(a==d)d=b?a.Next:a.Prev;else{a=b?d.Next:d.Prev;var h=new e.LocalMinima;h.Next=null,h.Y=a.Bot.Y,h.LeftBound=null,h.RightBound=a,h.RightBound.WindDelta=0,d=this.ProcessBound(h.RightBound,b),this.InsertLocalMinima(h)}}return d},e.ClipperBase.prototype.AddPath=function(a,b,d){c?d||b!=e.PolyType.ptClip||e.Error("AddPath: Open paths must be subject."):d||e.Error("AddPath: Open paths have been disabled.");
var f=a.length-1;if(d)for(;f>0&&e.IntPoint.op_Equality(a[f],a[0]);)--f;for(;f>0&&e.IntPoint.op_Equality(a[f],a[f-1]);)--f;if(d&&2>f||!d&&1>f)return!1;for(var g=new Array,h=0;f>=h;h++)g.push(new e.TEdge);var i=!0;g[1].Curr.X=a[1].X,g[1].Curr.Y=a[1].Y;var j={Value:this.m_UseFullRange};this.RangeTest(a[0],j),this.m_UseFullRange=j.Value,j.Value=this.m_UseFullRange,this.RangeTest(a[f],j),this.m_UseFullRange=j.Value,this.InitEdge(g[0],g[1],g[f],a[0]),this.InitEdge(g[f],g[0],g[f-1],a[f]);for(var h=f-1;h>=1;--h)j.Value=this.m_UseFullRange,this.RangeTest(a[h],j),this.m_UseFullRange=j.Value,this.InitEdge(g[h],g[h+1],g[h-1],a[h]);for(var k=g[0],l=k,m=k;;)if(e.IntPoint.op_Equality(l.Curr,l.Next.Curr)){if(l==l.Next)break;l==k&&(k=l.Next),l=this.RemoveEdge(l),m=l}else{if(l.Prev==l.Next)break;if(!d||!e.ClipperBase.SlopesEqual(l.Prev.Curr,l.Curr,l.Next.Curr,this.m_UseFullRange)||this.PreserveCollinear&&this.Pt2IsBetweenPt1AndPt3(l.Prev.Curr,l.Curr,l.Next.Curr)){if(l=l.Next,l==m)break}else l==k&&(k=l.Next),l=this.RemoveEdge(l),l=l.Prev,m=l}if(!d&&l==l.Next||d&&l.Prev==l.Next)return!1;d||(this.m_HasOpenPaths=!0,k.Prev.OutIdx=e.ClipperBase.Skip),l=k;do this.InitEdge2(l,b),l=l.Next,i&&l.Curr.Y!=k.Curr.Y&&(i=!1);while(l!=k);if(i){if(d)return!1;l.Prev.OutIdx=e.ClipperBase.Skip,l.Prev.Bot.X<l.Prev.Top.X&&this.ReverseHorizontal(l.Prev);var o=new e.LocalMinima;for(o.Next=null,o.Y=l.Bot.Y,o.LeftBound=null,o.RightBound=l,o.RightBound.Side=e.EdgeSide.esRight,o.RightBound.WindDelta=0;l.Next.OutIdx!=e.ClipperBase.Skip;)l.NextInLML=l.Next,l.Bot.X!=l.Prev.Top.X&&this.ReverseHorizontal(l),l=l.Next;return this.InsertLocalMinima(o),this.m_edges.push(g),!0}this.m_edges.push(g);for(var p,q=null;l=this.FindNextLocMin(l),l!=q;){null==q&&(q=l);var o=new e.LocalMinima;o.Next=null,o.Y=l.Bot.Y,l.Dx<l.Prev.Dx?(o.LeftBound=l.Prev,o.RightBound=l,p=!1):(o.LeftBound=l,o.RightBound=l.Prev,p=!0),o.LeftBound.Side=e.EdgeSide.esLeft,o.RightBound.Side=e.EdgeSide.esRight,o.LeftBound.WindDelta=d?o.LeftBound.Next==o.RightBound?-1:1:0,o.RightBound.WindDelta=-o.LeftBound.WindDelta,l=this.ProcessBound(o.LeftBound,p);var r=this.ProcessBound(o.RightBound,!p);o.LeftBound.OutIdx==e.ClipperBase.Skip?o.LeftBound=null:o.RightBound.OutIdx==e.ClipperBase.Skip&&(o.RightBound=null),this.InsertLocalMinima(o),p||(l=r)}return!0},e.ClipperBase.prototype.AddPaths=function(a,b,c){for(var d=!1,e=0,f=a.length;f>e;++e)this.AddPath(a[e],b,c)&&(d=!0);return d},e.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3=function(a,b,c){return e.IntPoint.op_Equality(a,c)||e.IntPoint.op_Equality(a,b)||e.IntPoint.op_Equality(c,b)?!1:a.X!=c.X?b.X>a.X==b.X<c.X:b.Y>a.Y==b.Y<c.Y},e.ClipperBase.prototype.RemoveEdge=function(a){a.Prev.Next=a.Next,a.Next.Prev=a.Prev;var b=a.Next;return a.Prev=null,b},e.ClipperBase.prototype.SetDx=function(a){a.Delta.X=a.Top.X-a.Bot.X,a.Delta.Y=a.Top.Y-a.Bot.Y,a.Dx=0===a.Delta.Y?e.ClipperBase.horizontal:a.Delta.X/a.Delta.Y},e.ClipperBase.prototype.InsertLocalMinima=function(a){if(null===this.m_MinimaList)this.m_MinimaList=a;else if(a.Y>=this.m_MinimaList.Y)a.Next=this.m_MinimaList,this.m_MinimaList=a;else{for(var b=this.m_MinimaList;null!==b.Next&&a.Y<b.Next.Y;)b=b.Next;a.Next=b.Next,b.Next=a}},e.ClipperBase.prototype.PopLocalMinima=function(){null!==this.m_CurrentLM&&(this.m_CurrentLM=this.m_CurrentLM.Next)},e.ClipperBase.prototype.ReverseHorizontal=function(a){var c=a.Top.X;a.Top.X=a.Bot.X,a.Bot.X=c,b&&(c=a.Top.Z,a.Top.Z=a.Bot.Z,a.Bot.Z=c)},e.ClipperBase.prototype.Reset=function(){if(this.m_CurrentLM=this.m_MinimaList,null!=this.m_CurrentLM)for(var a=this.m_MinimaList;null!=a;){var b=a.LeftBound;null!=b&&(b.Curr.X=b.Bot.X,b.Curr.Y=b.Bot.Y,b.Side=e.EdgeSide.esLeft,b.OutIdx=e.ClipperBase.Unassigned),b=a.RightBound,null!=b&&(b.Curr.X=b.Bot.X,b.Curr.Y=b.Bot.Y,b.Side=e.EdgeSide.esRight,b.OutIdx=e.ClipperBase.Unassigned),a=a.Next}},e.Clipper=function(a){"undefined"==typeof a&&(a=0),this.m_PolyOuts=null,this.m_ClipType=e.ClipType.ctIntersection,this.m_Scanbeam=null,this.m_ActiveEdges=null,this.m_SortedEdges=null,this.m_IntersectList=null,this.m_IntersectNodeComparer=null,this.m_ExecuteLocked=!1,this.m_ClipFillType=e.PolyFillType.pftEvenOdd,this.m_SubjFillType=e.PolyFillType.pftEvenOdd,this.m_Joins=null,this.m_GhostJoins=null,this.m_UsingPolyTree=!1,this.ReverseSolution=!1,this.StrictlySimple=!1,e.ClipperBase.call(this),this.m_Scanbeam=null,this.m_ActiveEdges=null,this.m_SortedEdges=null,this.m_IntersectList=new Array,this.m_IntersectNodeComparer=e.MyIntersectNodeSort.Compare,this.m_ExecuteLocked=!1,this.m_UsingPolyTree=!1,this.m_PolyOuts=new Array,this.m_Joins=new Array,this.m_GhostJoins=new Array,this.ReverseSolution=0!==(1&a),this.StrictlySimple=0!==(2&a),this.PreserveCollinear=0!==(4&a),b&&(this.ZFillFunction=null)},e.Clipper.ioReverseSolution=1,e.Clipper.ioStrictlySimple=2,e.Clipper.ioPreserveCollinear=4,e.Clipper.prototype.Clear=function(){0!==this.m_edges.length&&(this.DisposeAllPolyPts(),e.ClipperBase.prototype.Clear.call(this))},e.Clipper.prototype.DisposeScanbeamList=function(){for(;null!==this.m_Scanbeam;){var a=this.m_Scanbeam.Next;this.m_Scanbeam=null,this.m_Scanbeam=a}},e.Clipper.prototype.Reset=function(){e.ClipperBase.prototype.Reset.call(this),this.m_Scanbeam=null,this.m_ActiveEdges=null,this.m_SortedEdges=null;for(var a=this.m_MinimaList;null!==a;)this.InsertScanbeam(a.Y),a=a.Next},e.Clipper.prototype.InsertScanbeam=function(a){if(null===this.m_Scanbeam)this.m_Scanbeam=new e.Scanbeam,this.m_Scanbeam.Next=null,this.m_Scanbeam.Y=a;else if(a>this.m_Scanbeam.Y){var b=new e.Scanbeam;b.Y=a,b.Next=this.m_Scanbeam,this.m_Scanbeam=b}else{for(var c=this.m_Scanbeam;null!==c.Next&&a<=c.Next.Y;)c=c.Next;if(a==c.Y)return;var b=new e.Scanbeam;b.Y=a,b.Next=c.Next,c.Next=b}},e.Clipper.prototype.Execute=function(){var a=arguments,b=a.length,c=a[1]instanceof e.PolyTree;if(4==b&&!c){var d=a[0],f=a[1],g=a[2],h=a[3];if(this.m_ExecuteLocked)return!1;this.m_HasOpenPaths&&e.Error("Error: PolyTree struct is need for open path clipping."),this.m_ExecuteLocked=!0,e.Clear(f),this.m_SubjFillType=g,this.m_ClipFillType=h,this.m_ClipType=d,this.m_UsingPolyTree=!1;try{var i=this.ExecuteInternal();i&&this.BuildResult(f)}finally{this.DisposeAllPolyPts(),this.m_ExecuteLocked=!1}return i}if(4==b&&c){var d=a[0],j=a[1],g=a[2],h=a[3];if(this.m_ExecuteLocked)return!1;this.m_ExecuteLocked=!0,this.m_SubjFillType=g,this.m_ClipFillType=h,this.m_ClipType=d,this.m_UsingPolyTree=!0;try{var i=this.ExecuteInternal();i&&this.BuildResult2(j)}finally{this.DisposeAllPolyPts(),this.m_ExecuteLocked=!1}return i}if(2==b&&!c){var d=a[0],f=a[1];return this.Execute(d,f,e.PolyFillType.pftEvenOdd,e.PolyFillType.pftEvenOdd)}if(2==b&&c){var d=a[0],j=a[1];return this.Execute(d,j,e.PolyFillType.pftEvenOdd,e.PolyFillType.pftEvenOdd)}},e.Clipper.prototype.FixHoleLinkage=function(a){if(null!==a.FirstLeft&&(a.IsHole==a.FirstLeft.IsHole||null===a.FirstLeft.Pts)){for(var b=a.FirstLeft;null!==b&&(b.IsHole==a.IsHole||null===b.Pts);)b=b.FirstLeft;a.FirstLeft=b}},e.Clipper.prototype.ExecuteInternal=function(){try{if(this.Reset(),null===this.m_CurrentLM)return!1;var a=this.PopScanbeam();do{if(this.InsertLocalMinimaIntoAEL(a),e.Clear(this.m_GhostJoins),this.ProcessHorizontals(!1),null===this.m_Scanbeam)break;var b=this.PopScanbeam();if(!this.ProcessIntersections(a,b))return!1;this.ProcessEdgesAtTopOfScanbeam(b),a=b}while(null!==this.m_Scanbeam||null!==this.m_CurrentLM);for(var c=0,d=this.m_PolyOuts.length;d>c;c++){var f=this.m_PolyOuts[c];null===f.Pts||f.IsOpen||(f.IsHole^this.ReverseSolution)==this.Area(f)>0&&this.ReversePolyPtLinks(f.Pts)}this.JoinCommonEdges();for(var c=0,d=this.m_PolyOuts.length;d>c;c++){var f=this.m_PolyOuts[c];null===f.Pts||f.IsOpen||this.FixupOutPolygon(f)}return this.StrictlySimple&&this.DoSimplePolygons(),!0}finally{e.Clear(this.m_Joins),e.Clear(this.m_GhostJoins)}},e.Clipper.prototype.PopScanbeam=function(){var a=this.m_Scanbeam.Y,b=this.m_Scanbeam;return this.m_Scanbeam=this.m_Scanbeam.Next,b=null,a},e.Clipper.prototype.DisposeAllPolyPts=function(){for(var a=0,b=this.m_PolyOuts.length;b>a;++a)this.DisposeOutRec(a);e.Clear(this.m_PolyOuts)},e.Clipper.prototype.DisposeOutRec=function(a){var b=this.m_PolyOuts[a];null!==b.Pts&&this.DisposeOutPts(b.Pts),b=null,this.m_PolyOuts[a]=null},e.Clipper.prototype.DisposeOutPts=function(a){if(null!==a){var b=null;for(a.Prev.Next=null;null!==a;)b=a,a=a.Next,b=null}},e.Clipper.prototype.AddJoin=function(a,b,c){var d=new e.Join;d.OutPt1=a,d.OutPt2=b,d.OffPt.X=c.X,d.OffPt.Y=c.Y,this.m_Joins.push(d)},e.Clipper.prototype.AddGhostJoin=function(a,b){var c=new e.Join;c.OutPt1=a,c.OffPt.X=b.X,c.OffPt.Y=b.Y,this.m_GhostJoins.push(c)},b&&(e.Clipper.prototype.SetZ=function(a,b){a.Z=0,null!==this.ZFillFunction&&(b.OutIdx<0?this.ZFillFunction(b.Bot,b.Top,a):this.ZFillFunction(b.Top,b.Bot,a))}),e.Clipper.prototype.InsertLocalMinimaIntoAEL=function(a){for(;null!==this.m_CurrentLM&&this.m_CurrentLM.Y==a;){var b=this.m_CurrentLM.LeftBound,c=this.m_CurrentLM.RightBound;this.PopLocalMinima();var d=null;if(null===b?(this.InsertEdgeIntoAEL(c,null),this.SetWindingCount(c),this.IsContributing(c)&&(d=this.AddOutPt(c,c.Bot))):null==c?(this.InsertEdgeIntoAEL(b,null),this.SetWindingCount(b),this.IsContributing(b)&&(d=this.AddOutPt(b,b.Bot)),this.InsertScanbeam(b.Top.Y)):(this.InsertEdgeIntoAEL(b,null),this.InsertEdgeIntoAEL(c,b),this.SetWindingCount(b),c.WindCnt=b.WindCnt,c.WindCnt2=b.WindCnt2,this.IsContributing(b)&&(d=this.AddLocalMinPoly(b,c,b.Bot)),this.InsertScanbeam(b.Top.Y)),null!=c&&(e.ClipperBase.IsHorizontal(c)?this.AddEdgeToSEL(c):this.InsertScanbeam(c.Top.Y)),null!=b&&null!=c){if(null!==d&&e.ClipperBase.IsHorizontal(c)&&this.m_GhostJoins.length>0&&0!==c.WindDelta)for(var f=0,g=this.m_GhostJoins.length;g>f;f++){var h=this.m_GhostJoins[f];this.HorzSegmentsOverlap(h.OutPt1.Pt,h.OffPt,c.Bot,c.Top)&&this.AddJoin(h.OutPt1,d,h.OffPt)}if(b.OutIdx>=0&&null!==b.PrevInAEL&&b.PrevInAEL.Curr.X==b.Bot.X&&b.PrevInAEL.OutIdx>=0&&e.ClipperBase.SlopesEqual(b.PrevInAEL,b,this.m_UseFullRange)&&0!==b.WindDelta&&0!==b.PrevInAEL.WindDelta){var i=this.AddOutPt(b.PrevInAEL,b.Bot);this.AddJoin(d,i,b.Top)}if(b.NextInAEL!=c){if(c.OutIdx>=0&&c.PrevInAEL.OutIdx>=0&&e.ClipperBase.SlopesEqual(c.PrevInAEL,c,this.m_UseFullRange)&&0!==c.WindDelta&&0!==c.PrevInAEL.WindDelta){var i=this.AddOutPt(c.PrevInAEL,c.Bot);this.AddJoin(d,i,c.Top)}var j=b.NextInAEL;if(null!==j)for(;j!=c;)this.IntersectEdges(c,j,b.Curr,!1),j=j.NextInAEL}}}},e.Clipper.prototype.InsertEdgeIntoAEL=function(a,b){if(null===this.m_ActiveEdges)a.PrevInAEL=null,a.NextInAEL=null,this.m_ActiveEdges=a;else if(null===b&&this.E2InsertsBeforeE1(this.m_ActiveEdges,a))a.PrevInAEL=null,a.NextInAEL=this.m_ActiveEdges,this.m_ActiveEdges.PrevInAEL=a,this.m_ActiveEdges=a;else{for(null===b&&(b=this.m_ActiveEdges);null!==b.NextInAEL&&!this.E2InsertsBeforeE1(b.NextInAEL,a);)b=b.NextInAEL;a.NextInAEL=b.NextInAEL,null!==b.NextInAEL&&(b.NextInAEL.PrevInAEL=a),a.PrevInAEL=b,b.NextInAEL=a}},e.Clipper.prototype.E2InsertsBeforeE1=function(a,b){return b.Curr.X==a.Curr.X?b.Top.Y>a.Top.Y?b.Top.X<e.Clipper.TopX(a,b.Top.Y):a.Top.X>e.Clipper.TopX(b,a.Top.Y):b.Curr.X<a.Curr.X},e.Clipper.prototype.IsEvenOddFillType=function(a){return a.PolyTyp==e.PolyType.ptSubject?this.m_SubjFillType==e.PolyFillType.pftEvenOdd:this.m_ClipFillType==e.PolyFillType.pftEvenOdd},e.Clipper.prototype.IsEvenOddAltFillType=function(a){return a.PolyTyp==e.PolyType.ptSubject?this.m_ClipFillType==e.PolyFillType.pftEvenOdd:this.m_SubjFillType==e.PolyFillType.pftEvenOdd},e.Clipper.prototype.IsContributing=function(a){var b,c;switch(a.PolyTyp==e.PolyType.ptSubject?(b=this.m_SubjFillType,c=this.m_ClipFillType):(b=this.m_ClipFillType,c=this.m_SubjFillType),b){case e.PolyFillType.pftEvenOdd:if(0===a.WindDelta&&1!=a.WindCnt)return!1;break;case e.PolyFillType.pftNonZero:if(1!=Math.abs(a.WindCnt))return!1;break;case e.PolyFillType.pftPositive:if(1!=a.WindCnt)return!1;break;default:if(-1!=a.WindCnt)return!1}switch(this.m_ClipType){case e.ClipType.ctIntersection:switch(c){case e.PolyFillType.pftEvenOdd:case e.PolyFillType.pftNonZero:return 0!==a.WindCnt2;case e.PolyFillType.pftPositive:return a.WindCnt2>0;default:return a.WindCnt2<0}case e.ClipType.ctUnion:switch(c){case e.PolyFillType.pftEvenOdd:case e.PolyFillType.pftNonZero:return 0===a.WindCnt2;case e.PolyFillType.pftPositive:return a.WindCnt2<=0;default:return a.WindCnt2>=0}case e.ClipType.ctDifference:if(a.PolyTyp==e.PolyType.ptSubject)switch(c){case e.PolyFillType.pftEvenOdd:case e.PolyFillType.pftNonZero:return 0===a.WindCnt2;case e.PolyFillType.pftPositive:return a.WindCnt2<=0;default:return a.WindCnt2>=0}else switch(c){case e.PolyFillType.pftEvenOdd:case e.PolyFillType.pftNonZero:return 0!==a.WindCnt2;case e.PolyFillType.pftPositive:return a.WindCnt2>0;default:return a.WindCnt2<0}case e.ClipType.ctXor:if(0!==a.WindDelta)return!0;switch(c){case e.PolyFillType.pftEvenOdd:case e.PolyFillType.pftNonZero:return 0===a.WindCnt2;case e.PolyFillType.pftPositive:return a.WindCnt2<=0;default:return a.WindCnt2>=0}}return!0},e.Clipper.prototype.SetWindingCount=function(a){for(var b=a.PrevInAEL;null!==b&&(b.PolyTyp!=a.PolyTyp||0===b.WindDelta);)b=b.PrevInAEL;if(null===b)a.WindCnt=0===a.WindDelta?1:a.WindDelta,a.WindCnt2=0,b=this.m_ActiveEdges;else if(0===a.WindDelta&&this.m_ClipType!=e.ClipType.ctUnion)a.WindCnt=1,a.WindCnt2=b.WindCnt2,b=b.NextInAEL;else if(this.IsEvenOddFillType(a)){if(0===a.WindDelta){for(var c=!0,d=b.PrevInAEL;null!==d;)d.PolyTyp==b.PolyTyp&&0!==d.WindDelta&&(c=!c),d=d.PrevInAEL;a.WindCnt=c?0:1}else a.WindCnt=a.WindDelta;a.WindCnt2=b.WindCnt2,b=b.NextInAEL}else a.WindCnt=b.WindCnt*b.WindDelta<0?Math.abs(b.WindCnt)>1?b.WindDelta*a.WindDelta<0?b.WindCnt:b.WindCnt+a.WindDelta:0===a.WindDelta?1:a.WindDelta:0===a.WindDelta?b.WindCnt<0?b.WindCnt-1:b.WindCnt+1:b.WindDelta*a.WindDelta<0?b.WindCnt:b.WindCnt+a.WindDelta,a.WindCnt2=b.WindCnt2,b=b.NextInAEL;if(this.IsEvenOddAltFillType(a))for(;b!=a;)0!==b.WindDelta&&(a.WindCnt2=0===a.WindCnt2?1:0),b=b.NextInAEL;else for(;b!=a;)a.WindCnt2+=b.WindDelta,b=b.NextInAEL},e.Clipper.prototype.AddEdgeToSEL=function(a){null===this.m_SortedEdges?(this.m_SortedEdges=a,a.PrevInSEL=null,a.NextInSEL=null):(a.NextInSEL=this.m_SortedEdges,a.PrevInSEL=null,this.m_SortedEdges.PrevInSEL=a,this.m_SortedEdges=a)},e.Clipper.prototype.CopyAELToSEL=function(){var a=this.m_ActiveEdges;for(this.m_SortedEdges=a;null!==a;)a.PrevInSEL=a.PrevInAEL,a.NextInSEL=a.NextInAEL,a=a.NextInAEL},e.Clipper.prototype.SwapPositionsInAEL=function(a,b){if(a.NextInAEL!=a.PrevInAEL&&b.NextInAEL!=b.PrevInAEL){if(a.NextInAEL==b){var c=b.NextInAEL;null!==c&&(c.PrevInAEL=a);var d=a.PrevInAEL;null!==d&&(d.NextInAEL=b),b.PrevInAEL=d,b.NextInAEL=a,a.PrevInAEL=b,a.NextInAEL=c}else if(b.NextInAEL==a){var c=a.NextInAEL;null!==c&&(c.PrevInAEL=b);var d=b.PrevInAEL;null!==d&&(d.NextInAEL=a),a.PrevInAEL=d,a.NextInAEL=b,b.PrevInAEL=a,b.NextInAEL=c}else{var c=a.NextInAEL,d=a.PrevInAEL;a.NextInAEL=b.NextInAEL,null!==a.NextInAEL&&(a.NextInAEL.PrevInAEL=a),a.PrevInAEL=b.PrevInAEL,null!==a.PrevInAEL&&(a.PrevInAEL.NextInAEL=a),b.NextInAEL=c,null!==b.NextInAEL&&(b.NextInAEL.PrevInAEL=b),b.PrevInAEL=d,null!==b.PrevInAEL&&(b.PrevInAEL.NextInAEL=b)}null===a.PrevInAEL?this.m_ActiveEdges=a:null===b.PrevInAEL&&(this.m_ActiveEdges=b)}},e.Clipper.prototype.SwapPositionsInSEL=function(a,b){if(!(null===a.NextInSEL&&null===a.PrevInSEL||null===b.NextInSEL&&null===b.PrevInSEL)){if(a.NextInSEL==b){var c=b.NextInSEL;null!==c&&(c.PrevInSEL=a);var d=a.PrevInSEL;null!==d&&(d.NextInSEL=b),b.PrevInSEL=d,b.NextInSEL=a,a.PrevInSEL=b,a.NextInSEL=c}else if(b.NextInSEL==a){var c=a.NextInSEL;null!==c&&(c.PrevInSEL=b);var d=b.PrevInSEL;null!==d&&(d.NextInSEL=a),a.PrevInSEL=d,a.NextInSEL=b,b.PrevInSEL=a,b.NextInSEL=c}else{var c=a.NextInSEL,d=a.PrevInSEL;a.NextInSEL=b.NextInSEL,null!==a.NextInSEL&&(a.NextInSEL.PrevInSEL=a),a.PrevInSEL=b.PrevInSEL,null!==a.PrevInSEL&&(a.PrevInSEL.NextInSEL=a),b.NextInSEL=c,null!==b.NextInSEL&&(b.NextInSEL.PrevInSEL=b),b.PrevInSEL=d,null!==b.PrevInSEL&&(b.PrevInSEL.NextInSEL=b)}null===a.PrevInSEL?this.m_SortedEdges=a:null===b.PrevInSEL&&(this.m_SortedEdges=b)}},e.Clipper.prototype.AddLocalMaxPoly=function(a,b,c){this.AddOutPt(a,c),0==b.WindDelta&&this.AddOutPt(b,c),a.OutIdx==b.OutIdx?(a.OutIdx=-1,b.OutIdx=-1):a.OutIdx<b.OutIdx?this.AppendPolygon(a,b):this.AppendPolygon(b,a)},e.Clipper.prototype.AddLocalMinPoly=function(a,b,c){var d,f,g;if(e.ClipperBase.IsHorizontal(b)||a.Dx>b.Dx?(d=this.AddOutPt(a,c),b.OutIdx=a.OutIdx,a.Side=e.EdgeSide.esLeft,b.Side=e.EdgeSide.esRight,f=a,g=f.PrevInAEL==b?b.PrevInAEL:f.PrevInAEL):(d=this.AddOutPt(b,c),a.OutIdx=b.OutIdx,a.Side=e.EdgeSide.esRight,b.Side=e.EdgeSide.esLeft,f=b,g=f.PrevInAEL==a?a.PrevInAEL:f.PrevInAEL),null!==g&&g.OutIdx>=0&&e.Clipper.TopX(g,c.Y)==e.Clipper.TopX(f,c.Y)&&e.ClipperBase.SlopesEqual(f,g,this.m_UseFullRange)&&0!==f.WindDelta&&0!==g.WindDelta){var h=this.AddOutPt(g,c);this.AddJoin(d,h,f.Top)}return d},e.Clipper.prototype.CreateOutRec=function(){var a=new e.OutRec;return a.Idx=-1,a.IsHole=!1,a.IsOpen=!1,a.FirstLeft=null,a.Pts=null,a.BottomPt=null,a.PolyNode=null,this.m_PolyOuts.push(a),a.Idx=this.m_PolyOuts.length-1,a},e.Clipper.prototype.AddOutPt=function(a,c){var d=a.Side==e.EdgeSide.esLeft;if(a.OutIdx<0){var f=this.CreateOutRec();f.IsOpen=0===a.WindDelta;var g=new e.OutPt;return f.Pts=g,g.Idx=f.Idx,g.Pt.X=c.X,g.Pt.Y=c.Y,g.Next=g,g.Prev=g,f.IsOpen||this.SetHoleState(a,f),b&&(e.IntPoint.op_Equality(c,a.Bot)?(g.Pt.X=a.Bot.X,g.Pt.Y=a.Bot.Y,g.Pt.Z=a.Bot.Z):e.IntPoint.op_Equality(c,a.Top)?(g.Pt.X=a.Top.X,g.Pt.Y=a.Top.Y,g.Pt.Z=a.Top.Z):this.SetZ(g.Pt,a)),a.OutIdx=f.Idx,g}var f=this.m_PolyOuts[a.OutIdx],h=f.Pts;if(d&&e.IntPoint.op_Equality(c,h.Pt))return h;if(!d&&e.IntPoint.op_Equality(c,h.Prev.Pt))return h.Prev;var g=new e.OutPt;return g.Idx=f.Idx,g.Pt.X=c.X,g.Pt.Y=c.Y,g.Next=h,g.Prev=h.Prev,g.Prev.Next=g,h.Prev=g,d&&(f.Pts=g),b&&(e.IntPoint.op_Equality(c,a.Bot)?(g.Pt.X=a.Bot.X,g.Pt.Y=a.Bot.Y,g.Pt.Z=a.Bot.Z):e.IntPoint.op_Equality(c,a.Top)?(g.Pt.X=a.Top.X,g.Pt.Y=a.Top.Y,g.Pt.Z=a.Top.Z):this.SetZ(g.Pt,a)),g},e.Clipper.prototype.SwapPoints=function(a,b){var c=new e.IntPoint(a.Value);a.Value.X=b.Value.X,a.Value.Y=b.Value.Y,b.Value.X=c.X,b.Value.Y=c.Y},e.Clipper.prototype.HorzSegmentsOverlap=function(a,b,c,d){return a.X>c.X==a.X<d.X?!0:b.X>c.X==b.X<d.X?!0:c.X>a.X==c.X<b.X?!0:d.X>a.X==d.X<b.X?!0:a.X==c.X&&b.X==d.X?!0:a.X==d.X&&b.X==c.X?!0:!1},e.Clipper.prototype.InsertPolyPtBetween=function(a,b,c){var d=new e.OutPt;return d.Pt.X=c.X,d.Pt.Y=c.Y,b==a.Next?(a.Next=d,b.Prev=d,d.Next=b,d.Prev=a):(b.Next=d,a.Prev=d,d.Next=a,d.Prev=b),d},e.Clipper.prototype.SetHoleState=function(a,b){for(var c=!1,d=a.PrevInAEL;null!==d;)d.OutIdx>=0&&0!=d.WindDelta&&(c=!c,null===b.FirstLeft&&(b.FirstLeft=this.m_PolyOuts[d.OutIdx])),d=d.PrevInAEL;c&&(b.IsHole=!0)},e.Clipper.prototype.GetDx=function(a,b){return a.Y==b.Y?e.ClipperBase.horizontal:(b.X-a.X)/(b.Y-a.Y)},e.Clipper.prototype.FirstIsBottomPt=function(a,b){for(var c=a.Prev;e.IntPoint.op_Equality(c.Pt,a.Pt)&&c!=a;)c=c.Prev;var d=Math.abs(this.GetDx(a.Pt,c.Pt));for(c=a.Next;e.IntPoint.op_Equality(c.Pt,a.Pt)&&c!=a;)c=c.Next;var f=Math.abs(this.GetDx(a.Pt,c.Pt));for(c=b.Prev;e.IntPoint.op_Equality(c.Pt,b.Pt)&&c!=b;)c=c.Prev;var g=Math.abs(this.GetDx(b.Pt,c.Pt));for(c=b.Next;e.IntPoint.op_Equality(c.Pt,b.Pt)&&c!=b;)c=c.Next;var h=Math.abs(this.GetDx(b.Pt,c.Pt));return d>=g&&d>=h||f>=g&&f>=h},e.Clipper.prototype.GetBottomPt=function(a){for(var b=null,c=a.Next;c!=a;)c.Pt.Y>a.Pt.Y?(a=c,b=null):c.Pt.Y==a.Pt.Y&&c.Pt.X<=a.Pt.X&&(c.Pt.X<a.Pt.X?(b=null,a=c):c.Next!=a&&c.Prev!=a&&(b=c)),c=c.Next;if(null!==b)for(;b!=c;)for(this.FirstIsBottomPt(c,b)||(a=b),b=b.Next;e.IntPoint.op_Inequality(b.Pt,a.Pt);)b=b.Next;return a},e.Clipper.prototype.GetLowermostRec=function(a,b){null===a.BottomPt&&(a.BottomPt=this.GetBottomPt(a.Pts)),null===b.BottomPt&&(b.BottomPt=this.GetBottomPt(b.Pts));var c=a.BottomPt,d=b.BottomPt;return c.Pt.Y>d.Pt.Y?a:c.Pt.Y<d.Pt.Y?b:c.Pt.X<d.Pt.X?a:c.Pt.X>d.Pt.X?b:c.Next==c?b:d.Next==d?a:this.FirstIsBottomPt(c,d)?a:b},e.Clipper.prototype.Param1RightOfParam2=function(a,b){do if(a=a.FirstLeft,a==b)return!0;while(null!==a);return!1},e.Clipper.prototype.GetOutRec=function(a){for(var b=this.m_PolyOuts[a];b!=this.m_PolyOuts[b.Idx];)b=this.m_PolyOuts[b.Idx];return b},e.Clipper.prototype.AppendPolygon=function(a,b){var f,c=this.m_PolyOuts[a.OutIdx],d=this.m_PolyOuts[b.OutIdx];f=this.Param1RightOfParam2(c,d)?d:this.Param1RightOfParam2(d,c)?c:this.GetLowermostRec(c,d);var k,g=c.Pts,h=g.Prev,i=d.Pts,j=i.Prev;a.Side==e.EdgeSide.esLeft?(b.Side==e.EdgeSide.esLeft?(this.ReversePolyPtLinks(i),i.Next=g,g.Prev=i,h.Next=j,j.Prev=h,c.Pts=j):(j.Next=g,g.Prev=j,i.Prev=h,h.Next=i,c.Pts=i),k=e.EdgeSide.esLeft):(b.Side==e.EdgeSide.esRight?(this.ReversePolyPtLinks(i),h.Next=j,j.Prev=h,i.Next=g,g.Prev=i):(h.Next=i,i.Prev=h,g.Prev=j,j.Next=g),k=e.EdgeSide.esRight),c.BottomPt=null,f==d&&(d.FirstLeft!=c&&(c.FirstLeft=d.FirstLeft),c.IsHole=d.IsHole),d.Pts=null,d.BottomPt=null,d.FirstLeft=c;var l=a.OutIdx,m=b.OutIdx;a.OutIdx=-1,b.OutIdx=-1;for(var n=this.m_ActiveEdges;null!==n;){if(n.OutIdx==m){n.OutIdx=l,n.Side=k;break}n=n.NextInAEL}d.Idx=c.Idx},e.Clipper.prototype.ReversePolyPtLinks=function(a){if(null!==a){var b,c;b=a;do c=b.Next,b.Next=b.Prev,b.Prev=c,b=c;while(b!=a)}},e.Clipper.SwapSides=function(a,b){var c=a.Side;a.Side=b.Side,b.Side=c},e.Clipper.SwapPolyIndexes=function(a,b){var c=a.OutIdx;a.OutIdx=b.OutIdx,b.OutIdx=c},e.Clipper.prototype.IntersectEdges=function(a,b,d,f){var g=!f&&null===a.NextInLML&&a.Top.X==d.X&&a.Top.Y==d.Y,h=!f&&null===b.NextInLML&&b.Top.X==d.X&&b.Top.Y==d.Y,i=a.OutIdx>=0,j=b.OutIdx>=0;if(c&&(0===a.WindDelta||0===b.WindDelta))return 0===a.WindDelta&&0===b.WindDelta?(g||h)&&i&&j&&this.AddLocalMaxPoly(a,b,d):a.PolyTyp==b.PolyTyp&&a.WindDelta!=b.WindDelta&&this.m_ClipType==e.ClipType.ctUnion?0===a.WindDelta?j&&(this.AddOutPt(a,d),i&&(a.OutIdx=-1)):i&&(this.AddOutPt(b,d),j&&(b.OutIdx=-1)):a.PolyTyp!=b.PolyTyp&&(0!==a.WindDelta||1!=Math.abs(b.WindCnt)||this.m_ClipType==e.ClipType.ctUnion&&0!==b.WindCnt2?0!==b.WindDelta||1!=Math.abs(a.WindCnt)||this.m_ClipType==e.ClipType.ctUnion&&0!==a.WindCnt2||(this.AddOutPt(b,d),j&&(b.OutIdx=-1)):(this.AddOutPt(a,d),i&&(a.OutIdx=-1))),g&&(a.OutIdx<0?this.DeleteFromAEL(a):e.Error("Error intersecting polylines")),h&&(b.OutIdx<0?this.DeleteFromAEL(b):e.Error("Error intersecting polylines")),void 0;if(a.PolyTyp==b.PolyTyp)if(this.IsEvenOddFillType(a)){var k=a.WindCnt;a.WindCnt=b.WindCnt,b.WindCnt=k}else 0===a.WindCnt+b.WindDelta?a.WindCnt=-a.WindCnt:a.WindCnt+=b.WindDelta,0===b.WindCnt-a.WindDelta?b.WindCnt=-b.WindCnt:b.WindCnt-=a.WindDelta;else this.IsEvenOddFillType(b)?a.WindCnt2=0===a.WindCnt2?1:0:a.WindCnt2+=b.WindDelta,this.IsEvenOddFillType(a)?b.WindCnt2=0===b.WindCnt2?1:0:b.WindCnt2-=a.WindDelta;var l,m,n,o;a.PolyTyp==e.PolyType.ptSubject?(l=this.m_SubjFillType,n=this.m_ClipFillType):(l=this.m_ClipFillType,n=this.m_SubjFillType),b.PolyTyp==e.PolyType.ptSubject?(m=this.m_SubjFillType,o=this.m_ClipFillType):(m=this.m_ClipFillType,o=this.m_SubjFillType);var p,q;switch(l){case e.PolyFillType.pftPositive:p=a.WindCnt;break;case e.PolyFillType.pftNegative:p=-a.WindCnt;break;default:p=Math.abs(a.WindCnt)}switch(m){case e.PolyFillType.pftPositive:q=b.WindCnt;break;case e.PolyFillType.pftNegative:q=-b.WindCnt;break;default:q=Math.abs(b.WindCnt)}if(i&&j)g||h||0!==p&&1!=p||0!==q&&1!=q||a.PolyTyp!=b.PolyTyp&&this.m_ClipType!=e.ClipType.ctXor?this.AddLocalMaxPoly(a,b,d):(this.AddOutPt(a,d),this.AddOutPt(b,d),e.Clipper.SwapSides(a,b),e.Clipper.SwapPolyIndexes(a,b));else if(i)(0===q||1==q)&&(this.AddOutPt(a,d),e.Clipper.SwapSides(a,b),e.Clipper.SwapPolyIndexes(a,b));else if(j)(0===p||1==p)&&(this.AddOutPt(b,d),e.Clipper.SwapSides(a,b),e.Clipper.SwapPolyIndexes(a,b));else if(!(0!==p&&1!=p||0!==q&&1!=q||g||h)){var r,s;switch(n){case e.PolyFillType.pftPositive:r=a.WindCnt2;break;case e.PolyFillType.pftNegative:r=-a.WindCnt2;break;default:r=Math.abs(a.WindCnt2)}switch(o){case e.PolyFillType.pftPositive:s=b.WindCnt2;break;case e.PolyFillType.pftNegative:s=-b.WindCnt2;break;default:s=Math.abs(b.WindCnt2)}if(a.PolyTyp!=b.PolyTyp)this.AddLocalMinPoly(a,b,d);else if(1==p&&1==q)switch(this.m_ClipType){case e.ClipType.ctIntersection:r>0&&s>0&&this.AddLocalMinPoly(a,b,d);break;case e.ClipType.ctUnion:0>=r&&0>=s&&this.AddLocalMinPoly(a,b,d);break;case e.ClipType.ctDifference:(a.PolyTyp==e.PolyType.ptClip&&r>0&&s>0||a.PolyTyp==e.PolyType.ptSubject&&0>=r&&0>=s)&&this.AddLocalMinPoly(a,b,d);break;case e.ClipType.ctXor:this.AddLocalMinPoly(a,b,d)}else e.Clipper.SwapSides(a,b)}g!=h&&(g&&a.OutIdx>=0||h&&b.OutIdx>=0)&&(e.Clipper.SwapSides(a,b),e.Clipper.SwapPolyIndexes(a,b)),g&&this.DeleteFromAEL(a),h&&this.DeleteFromAEL(b)},e.Clipper.prototype.DeleteFromAEL=function(a){var b=a.PrevInAEL,c=a.NextInAEL;(null!==b||null!==c||a==this.m_ActiveEdges)&&(null!==b?b.NextInAEL=c:this.m_ActiveEdges=c,null!==c&&(c.PrevInAEL=b),a.NextInAEL=null,a.PrevInAEL=null)},e.Clipper.prototype.DeleteFromSEL=function(a){var b=a.PrevInSEL,c=a.NextInSEL;(null!==b||null!==c||a==this.m_SortedEdges)&&(null!==b?b.NextInSEL=c:this.m_SortedEdges=c,null!==c&&(c.PrevInSEL=b),a.NextInSEL=null,a.PrevInSEL=null)},e.Clipper.prototype.UpdateEdgeIntoAEL=function(a){null===a.NextInLML&&e.Error("UpdateEdgeIntoAEL: invalid call");var b=a.PrevInAEL,c=a.NextInAEL;return a.NextInLML.OutIdx=a.OutIdx,null!==b?b.NextInAEL=a.NextInLML:this.m_ActiveEdges=a.NextInLML,null!==c&&(c.PrevInAEL=a.NextInLML),a.NextInLML.Side=a.Side,a.NextInLML.WindDelta=a.WindDelta,a.NextInLML.WindCnt=a.WindCnt,a.NextInLML.WindCnt2=a.WindCnt2,a=a.NextInLML,a.Curr.X=a.Bot.X,a.Curr.Y=a.Bot.Y,a.PrevInAEL=b,a.NextInAEL=c,e.ClipperBase.IsHorizontal(a)||this.InsertScanbeam(a.Top.Y),a},e.Clipper.prototype.ProcessHorizontals=function(a){for(var b=this.m_SortedEdges;null!==b;)this.DeleteFromSEL(b),this.ProcessHorizontal(b,a),b=this.m_SortedEdges},e.Clipper.prototype.GetHorzDirection=function(a,b){a.Bot.X<a.Top.X?(b.Left=a.Bot.X,b.Right=a.Top.X,b.Dir=e.Direction.dLeftToRight):(b.Left=a.Top.X,b.Right=a.Bot.X,b.Dir=e.Direction.dRightToLeft)},e.Clipper.prototype.PrepareHorzJoins=function(a,b){var c=this.m_PolyOuts[a.OutIdx].Pts;a.Side!=e.EdgeSide.esLeft&&(c=c.Prev),b&&(e.IntPoint.op_Equality(c.Pt,a.Top)?this.AddGhostJoin(c,a.Bot):this.AddGhostJoin(c,a.Top))},e.Clipper.prototype.ProcessHorizontal=function(a,b){var c={Dir:null,Left:null,Right:null};this.GetHorzDirection(a,c);for(var d=c.Dir,f=c.Left,g=c.Right,h=a,i=null;null!==h.NextInLML&&e.ClipperBase.IsHorizontal(h.NextInLML);)h=h.NextInLML;for(null===h.NextInLML&&(i=this.GetMaximaPair(h));;){for(var j=a==h,k=this.GetNextInAEL(a,d);null!==k&&!(k.Curr.X==a.Top.X&&null!==a.NextInLML&&k.Dx<a.NextInLML.Dx);){var l=this.GetNextInAEL(k,d);if(d==e.Direction.dLeftToRight&&k.Curr.X<=g||d==e.Direction.dRightToLeft&&k.Curr.X>=f){if(a.OutIdx>=0&&0!=a.WindDelta&&this.PrepareHorzJoins(a,b),k==i&&j)return d==e.Direction.dLeftToRight?this.IntersectEdges(a,k,k.Top,!1):this.IntersectEdges(k,a,k.Top,!1),i.OutIdx>=0&&e.Error("ProcessHorizontal error"),void 0;if(d==e.Direction.dLeftToRight){var m=new e.IntPoint(k.Curr.X,a.Curr.Y);this.IntersectEdges(a,k,m,!0)}else{var m=new e.IntPoint(k.Curr.X,a.Curr.Y);this.IntersectEdges(k,a,m,!0)}this.SwapPositionsInAEL(a,k)}else if(d==e.Direction.dLeftToRight&&k.Curr.X>=g||d==e.Direction.dRightToLeft&&k.Curr.X<=f)break;k=l}if(a.OutIdx>=0&&0!==a.WindDelta&&this.PrepareHorzJoins(a,b),null===a.NextInLML||!e.ClipperBase.IsHorizontal(a.NextInLML))break;a=this.UpdateEdgeIntoAEL(a),a.OutIdx>=0&&this.AddOutPt(a,a.Bot);var c={Dir:d,Left:f,Right:g};this.GetHorzDirection(a,c),d=c.Dir,f=c.Left,g=c.Right}if(null!==a.NextInLML)if(a.OutIdx>=0){var n=this.AddOutPt(a,a.Top);if(a=this.UpdateEdgeIntoAEL(a),0===a.WindDelta)return;var o=a.PrevInAEL,l=a.NextInAEL;if(null!==o&&o.Curr.X==a.Bot.X&&o.Curr.Y==a.Bot.Y&&0!==o.WindDelta&&o.OutIdx>=0&&o.Curr.Y>o.Top.Y&&e.ClipperBase.SlopesEqual(a,o,this.m_UseFullRange)){var p=this.AddOutPt(o,a.Bot);this.AddJoin(n,p,a.Top)}else if(null!==l&&l.Curr.X==a.Bot.X&&l.Curr.Y==a.Bot.Y&&0!==l.WindDelta&&l.OutIdx>=0&&l.Curr.Y>l.Top.Y&&e.ClipperBase.SlopesEqual(a,l,this.m_UseFullRange)){var p=this.AddOutPt(l,a.Bot);this.AddJoin(n,p,a.Top)}}else a=this.UpdateEdgeIntoAEL(a);else null!==i?i.OutIdx>=0?(d==e.Direction.dLeftToRight?this.IntersectEdges(a,i,a.Top,!1):this.IntersectEdges(i,a,a.Top,!1),i.OutIdx>=0&&e.Error("ProcessHorizontal error")):(this.DeleteFromAEL(a),this.DeleteFromAEL(i)):(a.OutIdx>=0&&this.AddOutPt(a,a.Top),this.DeleteFromAEL(a))},e.Clipper.prototype.GetNextInAEL=function(a,b){return b==e.Direction.dLeftToRight?a.NextInAEL:a.PrevInAEL},e.Clipper.prototype.IsMinima=function(a){return null!==a&&a.Prev.NextInLML!=a&&a.Next.NextInLML!=a},e.Clipper.prototype.IsMaxima=function(a,b){return null!==a&&a.Top.Y==b&&null===a.NextInLML},e.Clipper.prototype.IsIntermediate=function(a,b){return a.Top.Y==b&&null!==a.NextInLML},e.Clipper.prototype.GetMaximaPair=function(a){var b=null;return e.IntPoint.op_Equality(a.Next.Top,a.Top)&&null===a.Next.NextInLML?b=a.Next:e.IntPoint.op_Equality(a.Prev.Top,a.Top)&&null===a.Prev.NextInLML&&(b=a.Prev),null===b||-2!=b.OutIdx&&(b.NextInAEL!=b.PrevInAEL||e.ClipperBase.IsHorizontal(b))?b:null},e.Clipper.prototype.ProcessIntersections=function(a,b){if(null==this.m_ActiveEdges)return!0;try{if(this.BuildIntersectList(a,b),0==this.m_IntersectList.length)return!0;if(1!=this.m_IntersectList.length&&!this.FixupIntersectionOrder())return!1;this.ProcessIntersectList()}catch(c){this.m_SortedEdges=null,this.m_IntersectList.length=0,e.Error("ProcessIntersections error")}return this.m_SortedEdges=null,!0},e.Clipper.prototype.BuildIntersectList=function(a,b){if(null!==this.m_ActiveEdges){var c=this.m_ActiveEdges;for(this.m_SortedEdges=c;null!==c;)c.PrevInSEL=c.PrevInAEL,c.NextInSEL=c.NextInAEL,c.Curr.X=e.Clipper.TopX(c,b),c=c.NextInAEL;for(var d=!0;d&&null!==this.m_SortedEdges;){for(d=!1,c=this.m_SortedEdges;null!==c.NextInSEL;){var f=c.NextInSEL,g=new e.IntPoint;if(c.Curr.X>f.Curr.X){!this.IntersectPoint(c,f,g)&&c.Curr.X>f.Curr.X+1&&e.Error("Intersection error"),g.Y>a&&(g.Y=a,g.X=Math.abs(c.Dx)>Math.abs(f.Dx)?e.Clipper.TopX(f,a):e.Clipper.TopX(c,a));var h=new e.IntersectNode;h.Edge1=c,h.Edge2=f,h.Pt.X=g.X,h.Pt.Y=g.Y,this.m_IntersectList.push(h),this.SwapPositionsInSEL(c,f),d=!0}else c=f}if(null===c.PrevInSEL)break;c.PrevInSEL.NextInSEL=null}this.m_SortedEdges=null}},e.Clipper.prototype.EdgesAdjacent=function(a){return a.Edge1.NextInSEL==a.Edge2||a.Edge1.PrevInSEL==a.Edge2},e.Clipper.IntersectNodeSort=function(a,b){return b.Pt.Y-a.Pt.Y},e.Clipper.prototype.FixupIntersectionOrder=function(){this.m_IntersectList.sort(this.m_IntersectNodeComparer),this.CopyAELToSEL();for(var a=this.m_IntersectList.length,b=0;a>b;b++){if(!this.EdgesAdjacent(this.m_IntersectList[b])){for(var c=b+1;a>c&&!this.EdgesAdjacent(this.m_IntersectList[c]);)c++;if(c==a)return!1;var d=this.m_IntersectList[b];this.m_IntersectList[b]=this.m_IntersectList[c],this.m_IntersectList[c]=d}this.SwapPositionsInSEL(this.m_IntersectList[b].Edge1,this.m_IntersectList[b].Edge2)}return!0},e.Clipper.prototype.ProcessIntersectList=function(){for(var a=0,b=this.m_IntersectList.length;b>a;a++){var c=this.m_IntersectList[a];this.IntersectEdges(c.Edge1,c.Edge2,c.Pt,!0),this.SwapPositionsInAEL(c.Edge1,c.Edge2)}this.m_IntersectList.length=0};var tc=function(a){return 0>a?Math.ceil(a-.5):Math.round(a)},uc=function(a){return 0>a?Math.ceil(a-.5):Math.floor(a+.5)},vc=function(a){return 0>a?-Math.round(Math.abs(a)):Math.round(a)},wc=function(a){return 0>a?(a-=.5,-2147483648>a?Math.ceil(a):0|a):(a+=.5,a>2147483647?Math.floor(a):0|a)};return e.Clipper.Round=i.msie?tc:i.chromium?vc:i.safari?wc:uc,e.Clipper.TopX=function(a,b){return b==a.Top.Y?a.Top.X:a.Bot.X+e.Clipper.Round(a.Dx*(b-a.Bot.Y))},e.Clipper.prototype.IntersectPoint=function(a,b,c){c.X=0,c.Y=0;var d,f;if(e.ClipperBase.SlopesEqual(a,b,this.m_UseFullRange)||a.Dx==b.Dx)return b.Bot.Y>a.Bot.Y?(c.X=b.Bot.X,c.Y=b.Bot.Y):(c.X=a.Bot.X,c.Y=a.Bot.Y),!1;if(0===a.Delta.X)c.X=a.Bot.X,e.ClipperBase.IsHorizontal(b)?c.Y=b.Bot.Y:(f=b.Bot.Y-b.Bot.X/b.Dx,c.Y=e.Clipper.Round(c.X/b.Dx+f));
else if(0===b.Delta.X)c.X=b.Bot.X,e.ClipperBase.IsHorizontal(a)?c.Y=a.Bot.Y:(d=a.Bot.Y-a.Bot.X/a.Dx,c.Y=e.Clipper.Round(c.X/a.Dx+d));else{d=a.Bot.X-a.Bot.Y*a.Dx,f=b.Bot.X-b.Bot.Y*b.Dx;var g=(f-d)/(a.Dx-b.Dx);c.Y=e.Clipper.Round(g),c.X=Math.abs(a.Dx)<Math.abs(b.Dx)?e.Clipper.Round(a.Dx*g+d):e.Clipper.Round(b.Dx*g+f)}if(c.Y<a.Top.Y||c.Y<b.Top.Y){if(a.Top.Y>b.Top.Y)return c.Y=a.Top.Y,c.X=e.Clipper.TopX(b,a.Top.Y),c.X<a.Top.X;c.Y=b.Top.Y,c.X=Math.abs(a.Dx)<Math.abs(b.Dx)?e.Clipper.TopX(a,c.Y):e.Clipper.TopX(b,c.Y)}return!0},e.Clipper.prototype.ProcessEdgesAtTopOfScanbeam=function(a){for(var b=this.m_ActiveEdges;null!==b;){var c=this.IsMaxima(b,a);if(c){var d=this.GetMaximaPair(b);c=null===d||!e.ClipperBase.IsHorizontal(d)}if(c){var f=b.PrevInAEL;this.DoMaxima(b),b=null===f?this.m_ActiveEdges:f.NextInAEL}else{if(this.IsIntermediate(b,a)&&e.ClipperBase.IsHorizontal(b.NextInLML)?(b=this.UpdateEdgeIntoAEL(b),b.OutIdx>=0&&this.AddOutPt(b,b.Bot),this.AddEdgeToSEL(b)):(b.Curr.X=e.Clipper.TopX(b,a),b.Curr.Y=a),this.StrictlySimple){var f=b.PrevInAEL;if(b.OutIdx>=0&&0!==b.WindDelta&&null!==f&&f.OutIdx>=0&&f.Curr.X==b.Curr.X&&0!==f.WindDelta){var g=this.AddOutPt(f,b.Curr),h=this.AddOutPt(b,b.Curr);this.AddJoin(g,h,b.Curr)}}b=b.NextInAEL}}for(this.ProcessHorizontals(!0),b=this.m_ActiveEdges;null!==b;){if(this.IsIntermediate(b,a)){var g=null;b.OutIdx>=0&&(g=this.AddOutPt(b,b.Top)),b=this.UpdateEdgeIntoAEL(b);var f=b.PrevInAEL,i=b.NextInAEL;if(null!==f&&f.Curr.X==b.Bot.X&&f.Curr.Y==b.Bot.Y&&null!==g&&f.OutIdx>=0&&f.Curr.Y>f.Top.Y&&e.ClipperBase.SlopesEqual(b,f,this.m_UseFullRange)&&0!==b.WindDelta&&0!==f.WindDelta){var h=this.AddOutPt(f,b.Bot);this.AddJoin(g,h,b.Top)}else if(null!==i&&i.Curr.X==b.Bot.X&&i.Curr.Y==b.Bot.Y&&null!==g&&i.OutIdx>=0&&i.Curr.Y>i.Top.Y&&e.ClipperBase.SlopesEqual(b,i,this.m_UseFullRange)&&0!==b.WindDelta&&0!==i.WindDelta){var h=this.AddOutPt(i,b.Bot);this.AddJoin(g,h,b.Top)}}b=b.NextInAEL}},e.Clipper.prototype.DoMaxima=function(a){var b=this.GetMaximaPair(a);if(null===b)return a.OutIdx>=0&&this.AddOutPt(a,a.Top),this.DeleteFromAEL(a),void 0;for(var c=a.NextInAEL,d=!0;null!==c&&c!=b;)this.IntersectEdges(a,c,a.Top,!0),this.SwapPositionsInAEL(a,c),c=a.NextInAEL;-1==a.OutIdx&&-1==b.OutIdx?(this.DeleteFromAEL(a),this.DeleteFromAEL(b)):a.OutIdx>=0&&b.OutIdx>=0?this.IntersectEdges(a,b,a.Top,!1):d&&0===a.WindDelta?(a.OutIdx>=0&&(this.AddOutPt(a,a.Top),a.OutIdx=-1),this.DeleteFromAEL(a),b.OutIdx>=0&&(this.AddOutPt(b,a.Top),b.OutIdx=-1),this.DeleteFromAEL(b)):e.Error("DoMaxima error")},e.Clipper.ReversePaths=function(a){for(var b=0,c=a.length;c>b;b++)a[b].reverse()},e.Clipper.Orientation=function(a){return e.Clipper.Area(a)>=0},e.Clipper.prototype.PointCount=function(a){if(null===a)return 0;var b=0,c=a;do b++,c=c.Next;while(c!=a);return b},e.Clipper.prototype.BuildResult=function(a){e.Clear(a);for(var b=0,c=this.m_PolyOuts.length;c>b;b++){var d=this.m_PolyOuts[b];if(null!==d.Pts){var f=d.Pts.Prev,g=this.PointCount(f);if(!(2>g)){for(var h=new Array(g),i=0;g>i;i++)h[i]=f.Pt,f=f.Prev;a.push(h)}}}},e.Clipper.prototype.BuildResult2=function(a){a.Clear();for(var b=0,c=this.m_PolyOuts.length;c>b;b++){var d=this.m_PolyOuts[b],f=this.PointCount(d.Pts);if(!(d.IsOpen&&2>f||!d.IsOpen&&3>f)){this.FixHoleLinkage(d);var g=new e.PolyNode;a.m_AllPolys.push(g),d.PolyNode=g,g.m_polygon.length=f;for(var h=d.Pts.Prev,i=0;f>i;i++)g.m_polygon[i]=h.Pt,h=h.Prev}}for(var b=0,c=this.m_PolyOuts.length;c>b;b++){var d=this.m_PolyOuts[b];null!==d.PolyNode&&(d.IsOpen?(d.PolyNode.IsOpen=!0,a.AddChild(d.PolyNode)):null!==d.FirstLeft&&null!=d.FirstLeft.PolyNode?d.FirstLeft.PolyNode.AddChild(d.PolyNode):a.AddChild(d.PolyNode))}},e.Clipper.prototype.FixupOutPolygon=function(a){var b=null;a.BottomPt=null;for(var c=a.Pts;;){if(c.Prev==c||c.Prev==c.Next)return this.DisposeOutPts(c),a.Pts=null,void 0;if(e.IntPoint.op_Equality(c.Pt,c.Next.Pt)||e.IntPoint.op_Equality(c.Pt,c.Prev.Pt)||e.ClipperBase.SlopesEqual(c.Prev.Pt,c.Pt,c.Next.Pt,this.m_UseFullRange)&&(!this.PreserveCollinear||!this.Pt2IsBetweenPt1AndPt3(c.Prev.Pt,c.Pt,c.Next.Pt))){b=null;var d=c;c.Prev.Next=c.Next,c.Next.Prev=c.Prev,c=c.Prev,d=null}else{if(c==b)break;null===b&&(b=c),c=c.Next}}a.Pts=c},e.Clipper.prototype.DupOutPt=function(a,b){var c=new e.OutPt;return c.Pt.X=a.Pt.X,c.Pt.Y=a.Pt.Y,c.Idx=a.Idx,b?(c.Next=a.Next,c.Prev=a,a.Next.Prev=c,a.Next=c):(c.Prev=a.Prev,c.Next=a,a.Prev.Next=c,a.Prev=c),c},e.Clipper.prototype.GetOverlap=function(a,b,c,d,e){return b>a?d>c?(e.Left=Math.max(a,c),e.Right=Math.min(b,d)):(e.Left=Math.max(a,d),e.Right=Math.min(b,c)):d>c?(e.Left=Math.max(b,c),e.Right=Math.min(a,d)):(e.Left=Math.max(b,d),e.Right=Math.min(a,c)),e.Left<e.Right},e.Clipper.prototype.JoinHorz=function(a,b,c,d,f,g){var h=a.Pt.X>b.Pt.X?e.Direction.dRightToLeft:e.Direction.dLeftToRight,i=c.Pt.X>d.Pt.X?e.Direction.dRightToLeft:e.Direction.dLeftToRight;if(h==i)return!1;if(h==e.Direction.dLeftToRight){for(;a.Next.Pt.X<=f.X&&a.Next.Pt.X>=a.Pt.X&&a.Next.Pt.Y==f.Y;)a=a.Next;g&&a.Pt.X!=f.X&&(a=a.Next),b=this.DupOutPt(a,!g),e.IntPoint.op_Inequality(b.Pt,f)&&(a=b,a.Pt.X=f.X,a.Pt.Y=f.Y,b=this.DupOutPt(a,!g))}else{for(;a.Next.Pt.X>=f.X&&a.Next.Pt.X<=a.Pt.X&&a.Next.Pt.Y==f.Y;)a=a.Next;g||a.Pt.X==f.X||(a=a.Next),b=this.DupOutPt(a,g),e.IntPoint.op_Inequality(b.Pt,f)&&(a=b,a.Pt.X=f.X,a.Pt.Y=f.Y,b=this.DupOutPt(a,g))}if(i==e.Direction.dLeftToRight){for(;c.Next.Pt.X<=f.X&&c.Next.Pt.X>=c.Pt.X&&c.Next.Pt.Y==f.Y;)c=c.Next;g&&c.Pt.X!=f.X&&(c=c.Next),d=this.DupOutPt(c,!g),e.IntPoint.op_Inequality(d.Pt,f)&&(c=d,c.Pt.X=f.X,c.Pt.Y=f.Y,d=this.DupOutPt(c,!g))}else{for(;c.Next.Pt.X>=f.X&&c.Next.Pt.X<=c.Pt.X&&c.Next.Pt.Y==f.Y;)c=c.Next;g||c.Pt.X==f.X||(c=c.Next),d=this.DupOutPt(c,g),e.IntPoint.op_Inequality(d.Pt,f)&&(c=d,c.Pt.X=f.X,c.Pt.Y=f.Y,d=this.DupOutPt(c,g))}return h==e.Direction.dLeftToRight==g?(a.Prev=c,c.Next=a,b.Next=d,d.Prev=b):(a.Next=c,c.Prev=a,b.Prev=d,d.Next=b),!0},e.Clipper.prototype.JoinPoints=function(a,b,c){var d=a.OutPt1,f=new e.OutPt,g=a.OutPt2,h=new e.OutPt,i=a.OutPt1.Pt.Y==a.OffPt.Y;if(i&&e.IntPoint.op_Equality(a.OffPt,a.OutPt1.Pt)&&e.IntPoint.op_Equality(a.OffPt,a.OutPt2.Pt)){for(f=a.OutPt1.Next;f!=d&&e.IntPoint.op_Equality(f.Pt,a.OffPt);)f=f.Next;var j=f.Pt.Y>a.OffPt.Y;for(h=a.OutPt2.Next;h!=g&&e.IntPoint.op_Equality(h.Pt,a.OffPt);)h=h.Next;var k=h.Pt.Y>a.OffPt.Y;return j==k?!1:j?(f=this.DupOutPt(d,!1),h=this.DupOutPt(g,!0),d.Prev=g,g.Next=d,f.Next=h,h.Prev=f,a.OutPt1=d,a.OutPt2=f,!0):(f=this.DupOutPt(d,!0),h=this.DupOutPt(g,!1),d.Next=g,g.Prev=d,f.Prev=h,h.Next=f,a.OutPt1=d,a.OutPt2=f,!0)}if(i){for(f=d;d.Prev.Pt.Y==d.Pt.Y&&d.Prev!=f&&d.Prev!=g;)d=d.Prev;for(;f.Next.Pt.Y==f.Pt.Y&&f.Next!=d&&f.Next!=g;)f=f.Next;if(f.Next==d||f.Next==g)return!1;for(h=g;g.Prev.Pt.Y==g.Pt.Y&&g.Prev!=h&&g.Prev!=f;)g=g.Prev;for(;h.Next.Pt.Y==h.Pt.Y&&h.Next!=g&&h.Next!=d;)h=h.Next;if(h.Next==g||h.Next==d)return!1;var l={Left:null,Right:null};if(!this.GetOverlap(d.Pt.X,f.Pt.X,g.Pt.X,h.Pt.X,l))return!1;var p,m=l.Left,n=l.Right,o=new e.IntPoint;return d.Pt.X>=m&&d.Pt.X<=n?(o.X=d.Pt.X,o.Y=d.Pt.Y,p=d.Pt.X>f.Pt.X):g.Pt.X>=m&&g.Pt.X<=n?(o.X=g.Pt.X,o.Y=g.Pt.Y,p=g.Pt.X>h.Pt.X):f.Pt.X>=m&&f.Pt.X<=n?(o.X=f.Pt.X,o.Y=f.Pt.Y,p=f.Pt.X>d.Pt.X):(o.X=h.Pt.X,o.Y=h.Pt.Y,p=h.Pt.X>g.Pt.X),a.OutPt1=d,a.OutPt2=g,this.JoinHorz(d,f,g,h,o,p)}for(f=d.Next;e.IntPoint.op_Equality(f.Pt,d.Pt)&&f!=d;)f=f.Next;var q=f.Pt.Y>d.Pt.Y||!e.ClipperBase.SlopesEqual(d.Pt,f.Pt,a.OffPt,this.m_UseFullRange);if(q){for(f=d.Prev;e.IntPoint.op_Equality(f.Pt,d.Pt)&&f!=d;)f=f.Prev;if(f.Pt.Y>d.Pt.Y||!e.ClipperBase.SlopesEqual(d.Pt,f.Pt,a.OffPt,this.m_UseFullRange))return!1}for(h=g.Next;e.IntPoint.op_Equality(h.Pt,g.Pt)&&h!=g;)h=h.Next;var r=h.Pt.Y>g.Pt.Y||!e.ClipperBase.SlopesEqual(g.Pt,h.Pt,a.OffPt,this.m_UseFullRange);if(r){for(h=g.Prev;e.IntPoint.op_Equality(h.Pt,g.Pt)&&h!=g;)h=h.Prev;if(h.Pt.Y>g.Pt.Y||!e.ClipperBase.SlopesEqual(g.Pt,h.Pt,a.OffPt,this.m_UseFullRange))return!1}return f==d||h==g||f==h||b==c&&q==r?!1:q?(f=this.DupOutPt(d,!1),h=this.DupOutPt(g,!0),d.Prev=g,g.Next=d,f.Next=h,h.Prev=f,a.OutPt1=d,a.OutPt2=f,!0):(f=this.DupOutPt(d,!0),h=this.DupOutPt(g,!1),d.Next=g,g.Prev=d,f.Prev=h,h.Next=f,a.OutPt1=d,a.OutPt2=f,!0)},e.Clipper.GetBounds=function(a){for(var b=0,c=a.length;c>b&&0==a[b].length;)b++;if(b==c)return new e.IntRect(0,0,0,0);var d=new e.IntRect;for(d.left=a[b][0].X,d.right=d.left,d.top=a[b][0].Y,d.bottom=d.top;c>b;b++)for(var f=0,g=a[b].length;g>f;f++)a[b][f].X<d.left?d.left=a[b][f].X:a[b][f].X>d.right&&(d.right=a[b][f].X),a[b][f].Y<d.top?d.top=a[b][f].Y:a[b][f].Y>d.bottom&&(d.bottom=a[b][f].Y);return d},e.Clipper.prototype.GetBounds2=function(a){var b=a,c=new e.IntRect;for(c.left=a.Pt.X,c.right=a.Pt.X,c.top=a.Pt.Y,c.bottom=a.Pt.Y,a=a.Next;a!=b;)a.Pt.X<c.left&&(c.left=a.Pt.X),a.Pt.X>c.right&&(c.right=a.Pt.X),a.Pt.Y<c.top&&(c.top=a.Pt.Y),a.Pt.Y>c.bottom&&(c.bottom=a.Pt.Y),a=a.Next;return c},e.Clipper.PointInPolygon=function(a,b){var c=0,d=b.length;if(3>d)return 0;for(var e=b[0],f=1;d>=f;++f){var g=f==d?b[0]:b[f];if(g.Y==a.Y&&(g.X==a.X||e.Y==a.Y&&g.X>a.X==e.X<a.X))return-1;if(e.Y<a.Y!=g.Y<a.Y)if(e.X>=a.X)if(g.X>a.X)c=1-c;else{var h=(e.X-a.X)*(g.Y-a.Y)-(g.X-a.X)*(e.Y-a.Y);if(0==h)return-1;h>0==g.Y>e.Y&&(c=1-c)}else if(g.X>a.X){var h=(e.X-a.X)*(g.Y-a.Y)-(g.X-a.X)*(e.Y-a.Y);if(0==h)return-1;h>0==g.Y>e.Y&&(c=1-c)}e=g}return c},e.Clipper.prototype.PointInPolygon=function(a,b){for(var c=0,d=b;;){var e=b.Pt.X,f=b.Pt.Y,g=b.Next.Pt.X,h=b.Next.Pt.Y;if(h==a.Y&&(g==a.X||f==a.Y&&g>a.X==e<a.X))return-1;if(f<a.Y!=h<a.Y)if(e>=a.X)if(g>a.X)c=1-c;else{var i=(e-a.X)*(h-a.Y)-(g-a.X)*(f-a.Y);if(0==i)return-1;i>0==h>f&&(c=1-c)}else if(g>a.X){var i=(e-a.X)*(h-a.Y)-(g-a.X)*(f-a.Y);if(0==i)return-1;i>0==h>f&&(c=1-c)}if(b=b.Next,d==b)break}return c},e.Clipper.prototype.Poly2ContainsPoly1=function(a,b){var c=a;do{var d=this.PointInPolygon(c.Pt,b);if(d>=0)return 0!=d;c=c.Next}while(c!=a);return!0},e.Clipper.prototype.FixupFirstLefts1=function(a,b){for(var c=0,d=this.m_PolyOuts.length;d>c;c++){var e=this.m_PolyOuts[c];null!==e.Pts&&e.FirstLeft==a&&this.Poly2ContainsPoly1(e.Pts,b.Pts)&&(e.FirstLeft=b)}},e.Clipper.prototype.FixupFirstLefts2=function(a,b){for(var c=0,d=this.m_PolyOuts,e=d.length,f=d[c];e>c;c++,f=d[c])f.FirstLeft==a&&(f.FirstLeft=b)},e.Clipper.ParseFirstLeft=function(a){for(;null!=a&&null==a.Pts;)a=a.FirstLeft;return a},e.Clipper.prototype.JoinCommonEdges=function(){for(var a=0,b=this.m_Joins.length;b>a;a++){var c=this.m_Joins[a],d=this.GetOutRec(c.OutPt1.Idx),f=this.GetOutRec(c.OutPt2.Idx);if(null!=d.Pts&&null!=f.Pts){var g;if(g=d==f?d:this.Param1RightOfParam2(d,f)?f:this.Param1RightOfParam2(f,d)?d:this.GetLowermostRec(d,f),this.JoinPoints(c,d,f))if(d==f){if(d.Pts=c.OutPt1,d.BottomPt=null,f=this.CreateOutRec(),f.Pts=c.OutPt2,this.UpdateOutPtIdxs(f),this.m_UsingPolyTree)for(var h=0,i=this.m_PolyOuts.length;i-1>h;h++){var j=this.m_PolyOuts[h];null!=j.Pts&&e.Clipper.ParseFirstLeft(j.FirstLeft)==d&&j.IsHole!=d.IsHole&&this.Poly2ContainsPoly1(j.Pts,c.OutPt2)&&(j.FirstLeft=f)}this.Poly2ContainsPoly1(f.Pts,d.Pts)?(f.IsHole=!d.IsHole,f.FirstLeft=d,this.m_UsingPolyTree&&this.FixupFirstLefts2(f,d),(f.IsHole^this.ReverseSolution)==this.Area(f)>0&&this.ReversePolyPtLinks(f.Pts)):this.Poly2ContainsPoly1(d.Pts,f.Pts)?(f.IsHole=d.IsHole,d.IsHole=!f.IsHole,f.FirstLeft=d.FirstLeft,d.FirstLeft=f,this.m_UsingPolyTree&&this.FixupFirstLefts2(d,f),(d.IsHole^this.ReverseSolution)==this.Area(d)>0&&this.ReversePolyPtLinks(d.Pts)):(f.IsHole=d.IsHole,f.FirstLeft=d.FirstLeft,this.m_UsingPolyTree&&this.FixupFirstLefts1(d,f))}else f.Pts=null,f.BottomPt=null,f.Idx=d.Idx,d.IsHole=g.IsHole,g==f&&(d.FirstLeft=f.FirstLeft),f.FirstLeft=d,this.m_UsingPolyTree&&this.FixupFirstLefts2(f,d)}}},e.Clipper.prototype.UpdateOutPtIdxs=function(a){var b=a.Pts;do b.Idx=a.Idx,b=b.Prev;while(b!=a.Pts)},e.Clipper.prototype.DoSimplePolygons=function(){for(var a=0;a<this.m_PolyOuts.length;){var b=this.m_PolyOuts[a++],c=b.Pts;if(null!==c)do{for(var d=c.Next;d!=b.Pts;){if(e.IntPoint.op_Equality(c.Pt,d.Pt)&&d.Next!=c&&d.Prev!=c){var f=c.Prev,g=d.Prev;c.Prev=g,g.Next=c,d.Prev=f,f.Next=d,b.Pts=c;var h=this.CreateOutRec();h.Pts=d,this.UpdateOutPtIdxs(h),this.Poly2ContainsPoly1(h.Pts,b.Pts)?(h.IsHole=!b.IsHole,h.FirstLeft=b):this.Poly2ContainsPoly1(b.Pts,h.Pts)?(h.IsHole=b.IsHole,b.IsHole=!h.IsHole,h.FirstLeft=b.FirstLeft,b.FirstLeft=h):(h.IsHole=b.IsHole,h.FirstLeft=b.FirstLeft),d=c}d=d.Next}c=c.Next}while(c!=b.Pts)}},e.Clipper.Area=function(a){var b=a.length;if(3>b)return 0;for(var c=0,d=0,e=b-1;b>d;++d)c+=(a[e].X+a[d].X)*(a[e].Y-a[d].Y),e=d;return.5*-c},e.Clipper.prototype.Area=function(a){var b=a.Pts;if(null==b)return 0;var c=0;do c+=(b.Prev.Pt.X+b.Pt.X)*(b.Prev.Pt.Y-b.Pt.Y),b=b.Next;while(b!=a.Pts);return.5*c},d&&(e.Clipper.OffsetPaths=function(a,b,c,d,f){var g=new e.Paths,h=new e.ClipperOffset(f,f);return h.AddPaths(a,c,d),h.Execute(g,b),g}),e.Clipper.SimplifyPolygon=function(a,b){var c=new Array,d=new e.Clipper(0);return d.StrictlySimple=!0,d.AddPath(a,e.PolyType.ptSubject,!0),d.Execute(e.ClipType.ctUnion,c,b,b),c},e.Clipper.SimplifyPolygons=function(a,b){"undefined"==typeof b&&(b=e.PolyFillType.pftEvenOdd);var c=new Array,d=new e.Clipper(0);return d.StrictlySimple=!0,d.AddPaths(a,e.PolyType.ptSubject,!0),d.Execute(e.ClipType.ctUnion,c,b,b),c},e.Clipper.DistanceSqrd=function(a,b){var c=a.X-b.X,d=a.Y-b.Y;return c*c+d*d},e.Clipper.DistanceFromLineSqrd=function(a,b,c){var d=b.Y-c.Y,e=c.X-b.X,f=d*b.X+e*b.Y;return f=d*a.X+e*a.Y-f,f*f/(d*d+e*e)},e.Clipper.SlopesNearCollinear=function(a,b,c,d){return e.Clipper.DistanceFromLineSqrd(b,a,c)<d},e.Clipper.PointsAreClose=function(a,b,c){var d=a.X-b.X,e=a.Y-b.Y;return c>=d*d+e*e},e.Clipper.ExcludeOp=function(a){var b=a.Prev;return b.Next=a.Next,a.Next.Prev=b,b.Idx=0,b},e.Clipper.CleanPolygon=function(a,b){"undefined"==typeof b&&(b=1.415);var c=a.length;if(0==c)return new Array;for(var d=new Array(c),f=0;c>f;++f)d[f]=new e.OutPt;for(var f=0;c>f;++f)d[f].Pt=a[f],d[f].Next=d[(f+1)%c],d[f].Next.Prev=d[f],d[f].Idx=0;for(var g=b*b,h=d[0];0==h.Idx&&h.Next!=h.Prev;)e.Clipper.PointsAreClose(h.Pt,h.Prev.Pt,g)?(h=e.Clipper.ExcludeOp(h),c--):e.Clipper.PointsAreClose(h.Prev.Pt,h.Next.Pt,g)?(e.Clipper.ExcludeOp(h.Next),h=e.Clipper.ExcludeOp(h),c-=2):e.Clipper.SlopesNearCollinear(h.Prev.Pt,h.Pt,h.Next.Pt,g)?(h=e.Clipper.ExcludeOp(h),c--):(h.Idx=1,h=h.Next);3>c&&(c=0);for(var i=new Array(c),f=0;c>f;++f)i[f]=new e.IntPoint(h.Pt),h=h.Next;return d=null,i},e.Clipper.CleanPolygons=function(a,b){for(var c=new Array(a.length),d=0,f=a.length;f>d;d++)c[d]=e.Clipper.CleanPolygon(a[d],b);return c},e.Clipper.Minkowski=function(a,b,c,d){var f=d?1:0,g=a.length,h=b.length,i=new Array;if(c)for(var j=0;h>j;j++){for(var k=new Array(g),l=0,m=a.length,n=a[l];m>l;l++,n=a[l])k[l]=new e.IntPoint(b[j].X+n.X,b[j].Y+n.Y);i.push(k)}else for(var j=0;h>j;j++){for(var k=new Array(g),l=0,m=a.length,n=a[l];m>l;l++,n=a[l])k[l]=new e.IntPoint(b[j].X-n.X,b[j].Y-n.Y);i.push(k)}for(var o=new Array,j=0;h-1+f>j;j++)for(var l=0;g>l;l++){var p=new Array;p.push(i[j%h][l%g]),p.push(i[(j+1)%h][l%g]),p.push(i[(j+1)%h][(l+1)%g]),p.push(i[j%h][(l+1)%g]),e.Clipper.Orientation(p)||p.reverse(),o.push(p)}var q=new e.Clipper(0);return q.AddPaths(o,e.PolyType.ptSubject,!0),q.Execute(e.ClipType.ctUnion,i,e.PolyFillType.pftNonZero,e.PolyFillType.pftNonZero),i},e.Clipper.MinkowskiSum=function(){var a=arguments,b=a.length;if(3==b){var c=a[0],d=a[1],f=a[2];return e.Clipper.Minkowski(c,d,!0,f)}if(4==b){for(var j,c=a[0],g=a[1],h=a[2],f=a[3],i=new e.Clipper,k=0,l=g.length;l>k;++k){var j=e.Clipper.Minkowski(c,g[k],!0,f);i.AddPaths(j,e.PolyType.ptSubject,!0)}f&&i.AddPaths(g,e.PolyType.ptClip,!0);var m=new e.Paths;return i.Execute(e.ClipType.ctUnion,m,h,h),m}},e.Clipper.MinkowskiDiff=function(a,b,c){return e.Clipper.Minkowski(a,b,!1,c)},e.Clipper.PolyTreeToPaths=function(a){var b=new Array;return e.Clipper.AddPolyNodeToPaths(a,e.Clipper.NodeType.ntAny,b),b},e.Clipper.AddPolyNodeToPaths=function(a,b,c){var d=!0;switch(b){case e.Clipper.NodeType.ntOpen:return;case e.Clipper.NodeType.ntClosed:d=!a.IsOpen}a.m_polygon.length>0&&d&&c.push(a.m_polygon);for(var f=0,g=a.Childs(),h=g.length,i=g[f];h>f;f++,i=g[f])e.Clipper.AddPolyNodeToPaths(i,b,c)},e.Clipper.OpenPathsFromPolyTree=function(a){for(var b=new e.Paths,c=0,d=a.ChildCount();d>c;c++)a.Childs()[c].IsOpen&&b.push(a.Childs()[c].m_polygon);return b},e.Clipper.ClosedPathsFromPolyTree=function(a){var b=new e.Paths;return e.Clipper.AddPolyNodeToPaths(a,e.Clipper.NodeType.ntClosed,b),b},sc(e.Clipper,e.ClipperBase),e.Clipper.NodeType={ntAny:0,ntOpen:1,ntClosed:2},e.ClipperOffset=function(a,b){"undefined"==typeof a&&(a=2),"undefined"==typeof b&&(b=e.ClipperOffset.def_arc_tolerance),this.m_destPolys=new e.Paths,this.m_srcPoly=new e.Path,this.m_destPoly=new e.Path,this.m_normals=new Array,this.m_delta=0,this.m_sinA=0,this.m_sin=0,this.m_cos=0,this.m_miterLim=0,this.m_StepsPerRad=0,this.m_lowest=new e.IntPoint,this.m_polyNodes=new e.PolyNode,this.MiterLimit=a,this.ArcTolerance=b,this.m_lowest.X=-1},e.ClipperOffset.two_pi=6.28318530717959,e.ClipperOffset.def_arc_tolerance=.25,e.ClipperOffset.prototype.Clear=function(){e.Clear(this.m_polyNodes.Childs()),this.m_lowest.X=-1},e.ClipperOffset.Round=e.Clipper.Round,e.ClipperOffset.prototype.AddPath=function(a,b,c){var d=a.length-1;if(!(0>d)){var f=new e.PolyNode;if(f.m_jointype=b,f.m_endtype=c,c==e.EndType.etClosedLine||c==e.EndType.etClosedPolygon)for(;d>0&&e.IntPoint.op_Equality(a[0],a[d]);)d--;f.m_polygon.push(a[0]);for(var g=0,h=0,i=1;d>=i;i++)e.IntPoint.op_Inequality(f.m_polygon[g],a[i])&&(g++,f.m_polygon.push(a[i]),(a[i].Y>f.m_polygon[h].Y||a[i].Y==f.m_polygon[h].Y&&a[i].X<f.m_polygon[h].X)&&(h=g));if(!(c==e.EndType.etClosedPolygon&&2>g||c!=e.EndType.etClosedPolygon&&0>g)&&(this.m_polyNodes.AddChild(f),c==e.EndType.etClosedPolygon))if(this.m_lowest.X<0)this.m_lowest=new e.IntPoint(0,h);else{var j=this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];(f.m_polygon[h].Y>j.Y||f.m_polygon[h].Y==j.Y&&f.m_polygon[h].X<j.X)&&(this.m_lowest=new e.IntPoint(this.m_polyNodes.ChildCount()-1,h))}}},e.ClipperOffset.prototype.AddPaths=function(a,b,c){for(var d=0,e=a.length;e>d;d++)this.AddPath(a[d],b,c)},e.ClipperOffset.prototype.FixOrientations=function(){if(this.m_lowest.X>=0&&!e.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))for(var a=0;a<this.m_polyNodes.ChildCount();a++){var b=this.m_polyNodes.Childs()[a];(b.m_endtype==e.EndType.etClosedPolygon||b.m_endtype==e.EndType.etClosedLine&&e.Clipper.Orientation(b.m_polygon))&&b.m_polygon.reverse()}else for(var a=0;a<this.m_polyNodes.ChildCount();a++){var b=this.m_polyNodes.Childs()[a];b.m_endtype!=e.EndType.etClosedLine||e.Clipper.Orientation(b.m_polygon)||b.m_polygon.reverse()}},e.ClipperOffset.GetUnitNormal=function(a,b){var c=b.X-a.X,d=b.Y-a.Y;if(0==c&&0==d)return new e.DoublePoint(0,0);var f=1/Math.sqrt(c*c+d*d);return c*=f,d*=f,new e.DoublePoint(d,-c)},e.ClipperOffset.prototype.DoOffset=function(a){if(this.m_destPolys=new Array,this.m_delta=a,e.ClipperBase.near_zero(a))for(var b=0;b<this.m_polyNodes.ChildCount();b++){var c=this.m_polyNodes.Childs()[b];c.m_endtype==e.EndType.etClosedPolygon&&this.m_destPolys.push(c.m_polygon)}else{this.m_miterLim=this.MiterLimit>2?2/(this.MiterLimit*this.MiterLimit):.5;var d;d=this.ArcTolerance<=0?e.ClipperOffset.def_arc_tolerance:this.ArcTolerance>Math.abs(a)*e.ClipperOffset.def_arc_tolerance?Math.abs(a)*e.ClipperOffset.def_arc_tolerance:this.ArcTolerance;var f=3.14159265358979/Math.acos(1-d/Math.abs(a));this.m_sin=Math.sin(e.ClipperOffset.two_pi/f),this.m_cos=Math.cos(e.ClipperOffset.two_pi/f),this.m_StepsPerRad=f/e.ClipperOffset.two_pi,0>a&&(this.m_sin=-this.m_sin);for(var b=0;b<this.m_polyNodes.ChildCount();b++){var c=this.m_polyNodes.Childs()[b];this.m_srcPoly=c.m_polygon;var g=this.m_srcPoly.length;if(!(0==g||0>=a&&(3>g||c.m_endtype!=e.EndType.etClosedPolygon)))if(this.m_destPoly=new Array,1!=g){this.m_normals.length=0;for(var j=0;g-1>j;j++)this.m_normals.push(e.ClipperOffset.GetUnitNormal(this.m_srcPoly[j],this.m_srcPoly[j+1]));if(c.m_endtype==e.EndType.etClosedLine||c.m_endtype==e.EndType.etClosedPolygon?this.m_normals.push(e.ClipperOffset.GetUnitNormal(this.m_srcPoly[g-1],this.m_srcPoly[0])):this.m_normals.push(new e.DoublePoint(this.m_normals[g-2])),c.m_endtype==e.EndType.etClosedPolygon){for(var l=g-1,j=0;g>j;j++)l=this.OffsetPoint(j,l,c.m_jointype);this.m_destPolys.push(this.m_destPoly)}else if(c.m_endtype==e.EndType.etClosedLine){for(var l=g-1,j=0;g>j;j++)l=this.OffsetPoint(j,l,c.m_jointype);this.m_destPolys.push(this.m_destPoly),this.m_destPoly=new Array;for(var m=this.m_normals[g-1],j=g-1;j>0;j--)this.m_normals[j]=new e.DoublePoint(-this.m_normals[j-1].X,-this.m_normals[j-1].Y);this.m_normals[0]=new e.DoublePoint(-m.X,-m.Y),l=0;for(var j=g-1;j>=0;j--)l=this.OffsetPoint(j,l,c.m_jointype);this.m_destPolys.push(this.m_destPoly)}else{for(var l=0,j=1;g-1>j;++j)l=this.OffsetPoint(j,l,c.m_jointype);var n;if(c.m_endtype==e.EndType.etOpenButt){var j=g-1;n=new e.IntPoint(e.ClipperOffset.Round(this.m_srcPoly[j].X+this.m_normals[j].X*a),e.ClipperOffset.Round(this.m_srcPoly[j].Y+this.m_normals[j].Y*a)),this.m_destPoly.push(n),n=new e.IntPoint(e.ClipperOffset.Round(this.m_srcPoly[j].X-this.m_normals[j].X*a),e.ClipperOffset.Round(this.m_srcPoly[j].Y-this.m_normals[j].Y*a)),this.m_destPoly.push(n)}else{var j=g-1;l=g-2,this.m_sinA=0,this.m_normals[j]=new e.DoublePoint(-this.m_normals[j].X,-this.m_normals[j].Y),c.m_endtype==e.EndType.etOpenSquare?this.DoSquare(j,l):this.DoRound(j,l)}for(var j=g-1;j>0;j--)this.m_normals[j]=new e.DoublePoint(-this.m_normals[j-1].X,-this.m_normals[j-1].Y);this.m_normals[0]=new e.DoublePoint(-this.m_normals[1].X,-this.m_normals[1].Y),l=g-1;for(var j=l-1;j>0;--j)l=this.OffsetPoint(j,l,c.m_jointype);c.m_endtype==e.EndType.etOpenButt?(n=new e.IntPoint(e.ClipperOffset.Round(this.m_srcPoly[0].X-this.m_normals[0].X*a),e.ClipperOffset.Round(this.m_srcPoly[0].Y-this.m_normals[0].Y*a)),this.m_destPoly.push(n),n=new e.IntPoint(e.ClipperOffset.Round(this.m_srcPoly[0].X+this.m_normals[0].X*a),e.ClipperOffset.Round(this.m_srcPoly[0].Y+this.m_normals[0].Y*a)),this.m_destPoly.push(n)):(l=1,this.m_sinA=0,c.m_endtype==e.EndType.etOpenSquare?this.DoSquare(0,1):this.DoRound(0,1)),this.m_destPolys.push(this.m_destPoly)}}else{if(c.m_jointype==e.JoinType.jtRound)for(var h=1,i=0,j=1;f>=j;j++){this.m_destPoly.push(new e.IntPoint(e.ClipperOffset.Round(this.m_srcPoly[0].X+h*a),e.ClipperOffset.Round(this.m_srcPoly[0].Y+i*a)));var k=h;h=h*this.m_cos-this.m_sin*i,i=k*this.m_sin+i*this.m_cos}else for(var h=-1,i=-1,j=0;4>j;++j)this.m_destPoly.push(new e.IntPoint(e.ClipperOffset.Round(this.m_srcPoly[0].X+h*a),e.ClipperOffset.Round(this.m_srcPoly[0].Y+i*a))),0>h?h=1:0>i?i=1:h=-1;this.m_destPolys.push(this.m_destPoly)}}}},e.ClipperOffset.prototype.Execute=function(){var a=arguments,b=a[0]instanceof e.PolyTree;if(b){var c=a[0],d=a[1];c.Clear(),this.FixOrientations(),this.DoOffset(d);var f=new e.Clipper(0);if(f.AddPaths(this.m_destPolys,e.PolyType.ptSubject,!0),d>0)f.Execute(e.ClipType.ctUnion,c,e.PolyFillType.pftPositive,e.PolyFillType.pftPositive);else{var g=e.Clipper.GetBounds(this.m_destPolys),h=new e.Path;if(h.push(new e.IntPoint(g.left-10,g.bottom+10)),h.push(new e.IntPoint(g.right+10,g.bottom+10)),h.push(new e.IntPoint(g.right+10,g.top-10)),h.push(new e.IntPoint(g.left-10,g.top-10)),f.AddPath(h,e.PolyType.ptSubject,!0),f.ReverseSolution=!0,f.Execute(e.ClipType.ctUnion,c,e.PolyFillType.pftNegative,e.PolyFillType.pftNegative),1==c.ChildCount()&&c.Childs()[0].ChildCount()>0){var i=c.Childs()[0];c.Childs()[0]=i.Childs()[0];for(var j=1;j<i.ChildCount();j++)c.AddChild(i.Childs()[j])}else c.Clear()}}else{var c=a[0],d=a[1];e.Clear(c),this.FixOrientations(),this.DoOffset(d);var f=new e.Clipper(0);if(f.AddPaths(this.m_destPolys,e.PolyType.ptSubject,!0),d>0)f.Execute(e.ClipType.ctUnion,c,e.PolyFillType.pftPositive,e.PolyFillType.pftPositive);else{var g=e.Clipper.GetBounds(this.m_destPolys),h=new e.Path;h.push(new e.IntPoint(g.left-10,g.bottom+10)),h.push(new e.IntPoint(g.right+10,g.bottom+10)),h.push(new e.IntPoint(g.right+10,g.top-10)),h.push(new e.IntPoint(g.left-10,g.top-10)),f.AddPath(h,e.PolyType.ptSubject,!0),f.ReverseSolution=!0,f.Execute(e.ClipType.ctUnion,c,e.PolyFillType.pftNegative,e.PolyFillType.pftNegative),c.length>0&&c.splice(0,1)}}},e.ClipperOffset.prototype.OffsetPoint=function(a,b,c){if(this.m_sinA=this.m_normals[b].X*this.m_normals[a].Y-this.m_normals[a].X*this.m_normals[b].Y,this.m_sinA<5e-5&&this.m_sinA>-5e-5)return b;if(this.m_sinA>1?this.m_sinA=1:this.m_sinA<-1&&(this.m_sinA=-1),this.m_sinA*this.m_delta<0)this.m_destPoly.push(new e.IntPoint(e.ClipperOffset.Round(this.m_srcPoly[a].X+this.m_normals[b].X*this.m_delta),e.ClipperOffset.Round(this.m_srcPoly[a].Y+this.m_normals[b].Y*this.m_delta))),this.m_destPoly.push(new e.IntPoint(this.m_srcPoly[a])),this.m_destPoly.push(new e.IntPoint(e.ClipperOffset.Round(this.m_srcPoly[a].X+this.m_normals[a].X*this.m_delta),e.ClipperOffset.Round(this.m_srcPoly[a].Y+this.m_normals[a].Y*this.m_delta)));else switch(c){case e.JoinType.jtMiter:var d=1+(this.m_normals[a].X*this.m_normals[b].X+this.m_normals[a].Y*this.m_normals[b].Y);d>=this.m_miterLim?this.DoMiter(a,b,d):this.DoSquare(a,b);break;case e.JoinType.jtSquare:this.DoSquare(a,b);break;case e.JoinType.jtRound:this.DoRound(a,b)}return b=a},e.ClipperOffset.prototype.DoSquare=function(a,b){var c=Math.tan(Math.atan2(this.m_sinA,this.m_normals[b].X*this.m_normals[a].X+this.m_normals[b].Y*this.m_normals[a].Y)/4);this.m_destPoly.push(new e.IntPoint(e.ClipperOffset.Round(this.m_srcPoly[a].X+this.m_delta*(this.m_normals[b].X-this.m_normals[b].Y*c)),e.ClipperOffset.Round(this.m_srcPoly[a].Y+this.m_delta*(this.m_normals[b].Y+this.m_normals[b].X*c)))),this.m_destPoly.push(new e.IntPoint(e.ClipperOffset.Round(this.m_srcPoly[a].X+this.m_delta*(this.m_normals[a].X+this.m_normals[a].Y*c)),e.ClipperOffset.Round(this.m_srcPoly[a].Y+this.m_delta*(this.m_normals[a].Y-this.m_normals[a].X*c))))},e.ClipperOffset.prototype.DoMiter=function(a,b,c){var d=this.m_delta/c;this.m_destPoly.push(new e.IntPoint(e.ClipperOffset.Round(this.m_srcPoly[a].X+(this.m_normals[b].X+this.m_normals[a].X)*d),e.ClipperOffset.Round(this.m_srcPoly[a].Y+(this.m_normals[b].Y+this.m_normals[a].Y)*d)))},e.ClipperOffset.prototype.DoRound=function(a,b){for(var h,c=Math.atan2(this.m_sinA,this.m_normals[b].X*this.m_normals[a].X+this.m_normals[b].Y*this.m_normals[a].Y),d=e.Cast_Int32(e.ClipperOffset.Round(this.m_StepsPerRad*Math.abs(c))),f=this.m_normals[b].X,g=this.m_normals[b].Y,i=0;d>i;++i)this.m_destPoly.push(new e.IntPoint(e.ClipperOffset.Round(this.m_srcPoly[a].X+f*this.m_delta),e.ClipperOffset.Round(this.m_srcPoly[a].Y+g*this.m_delta))),h=f,f=f*this.m_cos-this.m_sin*g,g=h*this.m_sin+g*this.m_cos;this.m_destPoly.push(new e.IntPoint(e.ClipperOffset.Round(this.m_srcPoly[a].X+this.m_normals[a].X*this.m_delta),e.ClipperOffset.Round(this.m_srcPoly[a].Y+this.m_normals[a].Y*this.m_delta)))},e.Error=function(a){try{throw new Error(a)}catch(b){alert(b.message)}},e.JS={},e.JS.AreaOfPolygon=function(a,b){return b||(b=1),e.Clipper.Area(a)/(b*b)},e.JS.AreaOfPolygons=function(a,b){b||(b=1);for(var c=0,d=0;d<a.length;d++)c+=e.Clipper.Area(a[d]);return c/(b*b)},e.JS.BoundsOfPath=function(a,b){return e.JS.BoundsOfPaths([a],b)},e.JS.BoundsOfPaths=function(a,b){b||(b=1);var c=e.Clipper.GetBounds(a);return c.left/=b,c.bottom/=b,c.right/=b,c.top/=b,c},e.JS.Clean=function(a,b){if(!(a instanceof Array))return[];var c=a[0]instanceof Array,a=e.JS.Clone(a);if("number"!=typeof b||null===b)return e.Error("Delta is not a number in Clean()."),a;if(0===a.length||1==a.length&&0===a[0].length||0>b)return a;c||(a=[a]);for(var f,g,h,i,j,k,l,d=a.length,m=[],n=0;d>n;n++)if(g=a[n],f=g.length,0!==f)if(3>f)h=g,m.push(h);else{for(h=g,i=b*b,j=g[0],k=1,l=1;f>l;l++)(g[l].X-j.X)*(g[l].X-j.X)+(g[l].Y-j.Y)*(g[l].Y-j.Y)<=i||(h[k]=g[l],j=g[l],k++);j=g[k-1],(g[0].X-j.X)*(g[0].X-j.X)+(g[0].Y-j.Y)*(g[0].Y-j.Y)<=i&&k--,f>k&&h.splice(k,f-k),h.length&&m.push(h)}return!c&&m.length?m=m[0]:c||0!==m.length?c&&0===m.length&&(m=[[]]):m=[],m},e.JS.Clone=function(a){if(!(a instanceof Array))return[];if(0===a.length)return[];if(1==a.length&&0===a[0].length)return[[]];var b=a[0]instanceof Array;b||(a=[a]);var d,e,f,g,c=a.length,h=new Array(c);for(e=0;c>e;e++){for(d=a[e].length,g=new Array(d),f=0;d>f;f++)g[f]={X:a[e][f].X,Y:a[e][f].Y};h[e]=g}return b||(h=h[0]),h},e.JS.Lighten=function(a,b){if(!(a instanceof Array))return[];if("number"!=typeof b||null===b)return e.Error("Tolerance is not a number in Lighten()."),e.JS.Clone(a);if(0===a.length||1==a.length&&0===a[0].length||0>b)return e.JS.Clone(a);a[0]instanceof Array||(a=[a]);var c,d,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u=a.length,v=b*b,w=[];for(c=0;u>c;c++)if(f=a[c],i=f.length,0!=i){for(g=0;1e6>g;g++){for(h=[],i=f.length,f[i-1].X!=f[0].X||f[i-1].Y!=f[0].Y?(o=1,f.push({X:f[0].X,Y:f[0].Y}),i=f.length):o=0,n=[],d=0;i-2>d;d++)j=f[d],l=f[d+1],k=f[d+2],s=j.X,t=j.Y,p=k.X-s,q=k.Y-t,(0!==p||0!==q)&&(r=((l.X-s)*p+(l.Y-t)*q)/(p*p+q*q),r>1?(s=k.X,t=k.Y):r>0&&(s+=p*r,t+=q*r)),p=l.X-s,q=l.Y-t,m=p*p+q*q,v>=m&&(n[d+1]=1,d++);for(h.push({X:f[0].X,Y:f[0].Y}),d=1;i-1>d;d++)n[d]||h.push({X:f[d].X,Y:f[d].Y});if(h.push({X:f[i-1].X,Y:f[i-1].Y}),o&&f.pop(),!n.length)break;f=h}i=h.length,h[i-1].X==h[0].X&&h[i-1].Y==h[0].Y&&h.pop(),h.length>2&&w.push(h)}return!a[0]instanceof Array&&(w=w[0]),"undefined"==typeof w&&(w=[[]]),w},e.JS.PerimeterOfPath=function(a,b,c){if("undefined"==typeof a)return 0;var f,g,d=Math.sqrt,e=0,h=0,i=0,j=0,k=0,l=a.length;if(2>l)return 0;for(b&&(a[l]=a[0],l++);--l;)f=a[l],h=f.X,i=f.Y,g=a[l-1],j=g.X,k=g.Y,e+=d((h-j)*(h-j)+(i-k)*(i-k));return b&&a.pop(),e/c},e.JS.PerimeterOfPaths=function(a,b,c){c||(c=1);for(var d=0,f=0;f<a.length;f++)d+=e.JS.PerimeterOfPath(a[f],b,c);return d},e.JS.ScaleDownPath=function(a,b){var c,d;for(b||(b=1),c=a.length;c--;)d=a[c],d.X=d.X/b,d.Y=d.Y/b},e.JS.ScaleDownPaths=function(a,b){var c,d,e;for(Math.round,b||(b=1),c=a.length;c--;)for(d=a[c].length;d--;)e=a[c][d],e.X=e.X/b,e.Y=e.Y/b},e.JS.ScaleUpPath=function(a,b){var c,d,e=Math.round;for(b||(b=1),c=a.length;c--;)d=a[c],d.X=e(d.X*b),d.Y=e(d.Y*b)},e.JS.ScaleUpPaths=function(a,b){var c,d,e,f=Math.round;for(b||(b=1),c=a.length;c--;)for(d=a[c].length;d--;)e=a[c][d],e.X=f(e.X*b),e.Y=f(e.Y*b)},e.ExPolygons=function(){return[]},e.ExPolygon=function(){this.outer=null,this.holes=null},e.JS.AddOuterPolyNodeToExPolygons=function(a,b){var c=new e.ExPolygon;c.outer=a.Contour();var d=a.Childs(),f=d.length;c.holes=new Array(f);var g,h,i,j,k,l;for(i=0;f>i;i++)for(g=d[i],c.holes[i]=g.Contour(),j=0,k=g.Childs(),l=k.length;l>j;j++)h=k[j],e.JS.AddOuterPolyNodeToExPolygons(h,b);b.push(c)},e.JS.ExPolygonsToPaths=function(a){var b,c,d,f,g=new e.Paths;for(b=0,d=a.length;d>b;b++)for(g.push(a[b].outer),c=0,f=a[b].holes.length;f>c;c++)g.push(a[b].holes[c]);return g},e.JS.PolyTreeToExPolygons=function(a){var c,d,f,g,b=new e.ExPolygons;for(d=0,f=a.Childs(),g=f.length;g>d;d++)c=f[d],e.JS.AddOuterPolyNodeToExPolygons(c,b);return b},e});

/**
 * @license RequireJS text 2.0.12 Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/text for details
 */
/*jslint regexp: true */
/*global require, XMLHttpRequest, ActiveXObject,
  define, window, process, Packages,
  java, location, Components, FileUtils */

define('lib/text',['module'], function (module) {
    

    var text, fs, Cc, Ci, xpcIsWindows,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = {},
        masterConfig = (module.config && module.config()) || {};

    text = {
        version: '2.0.12',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var modName, ext, temp,
                strip = false,
                index = name.indexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                             name.indexOf('../') === 0;

            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1, name.length);
            } else {
                modName = name;
            }

            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || uPort === port);
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config && config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config && config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                    (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            // Do not load if it is an empty: url
            if (url.indexOf('empty:') === 0) {
                onLoad();
                return;
            }

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node &&
            !process.versions['node-webkit'])) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback, errback) {
            try {
                var file = fs.readFileSync(url, 'utf8');
                //Remove BOM (Byte Mark Order) from utf8 files if it is there.
                if (file.indexOf('\uFEFF') === 0) {
                    file = file.substring(1);
                }
                callback(file);
            } catch (e) {
                if (errback) {
                    errback(e);
                }
            }
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status || 0;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        if (errback) {
                            errback(err);
                        }
                    } else {
                        callback(xhr.responseText);
                    }

                    if (masterConfig.onXhrComplete) {
                        masterConfig.onXhrComplete(xhr, url);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                if (line !== null) {
                    stringBuffer.append(line);
                }

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&
            typeof Components !== 'undefined' && Components.classes &&
            Components.interfaces)) {
        //Avert your gaze!
        Cc = Components.classes;
        Ci = Components.interfaces;
        Components.utils['import']('resource://gre/modules/FileUtils.jsm');
        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);

        text.get = function (url, callback) {
            var inStream, convertStream, fileObj,
                readData = {};

            if (xpcIsWindows) {
                url = url.replace(/\//g, '\\');
            }

            fileObj = new FileUtils.File(url);

            //XPCOM, you so crazy
            try {
                inStream = Cc['@mozilla.org/network/file-input-stream;1']
                           .createInstance(Ci.nsIFileInputStream);
                inStream.init(fileObj, 1, 0, false);

                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']
                                .createInstance(Ci.nsIConverterInputStream);
                convertStream.init(inStream, "utf-8", inStream.available(),
                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);

                convertStream.readString(inStream.available(), readData);
                convertStream.close();
                inStream.close();
                callback(readData.value);
            } catch (e) {
                throw new Error((fileObj && fileObj.path || '') + ': ' + e);
            }
        };
    }
    return text;
});

// Based on https://github.com/chadly/requirejs-web-workers
/**
 * This RequireJS plugin allows loading of web workers identified by
 * the string passed to the plugin. The `text` RequireJS plugin is used
 * to retrieve the script, so it should work even if the referenced
 * module is on a different domain. A Promise object is returned which
 * will have the asyncronously-loaded worker available. Set the desired
 * callbacks using the `then` function of the returned Promise object.
 * 
 * This plugin supports configurable Web Workers that themselves use
 * RequireJS. Set the location of RequireJS and the baseUrl to be used
 * on the config property of the object passed to `requirejs.config`.
 * Example:
 *     requirejs.config({
 *       config: {
 *         requirejsUrl: 'require.js',
 *         baseUrl: '.'
 *       }
 *     });
 * With the above config, the following will be inserted at the top of
 * the retrieved web worker, assuming you've placed the `worker` plugin
 * in a directory named `js` relative to the root of the domain.
 *     importScripts('http://example.com/js/require.js');
 *     require.config({baseUrl: 'http://example.com/js'});
 * All paths should be relative to the worker plugin script.
 * The possible configurations are:
 * requirejsUrl - template: requirejs - URL to requireJS for web
 *   workers that require it.
 * baseUrl - template: baseUrl - Base URL to use in configuration
 *   options passed to web worker RequireJS.
 */
define('worker',['./lib/text'],
function(  text) {
  /**
   * Retrieve the web worker at the given URL. If the worker can be
   * loaded then a Promise is returned. The Promise is fulfilled when
   * the worker is loaded. If the worker cannot be loaded, and the
   * conditions are known on execution of this function, then false
   * is returned.
   * @param {string} url - The url to the web worker script.
   * @param {string} [header=""] - The header to add to the retrieved
   *   web worker script, if any.
   * @return {Promise} - The Promise object holding the future
   *   web worker, or false if it cannot be loaded.
   */
  function getWorkerPromise(url, header) {
    if (typeof header == 'undefined') header = "";
    if (typeof Promise == 'undefined') return;
    return new Promise(function(resolve, reject) {
      if (!window.Worker) {
        reject(Error("Web workers not available."));
        return;
      }
      text.get(url, function(data) {
        try {
          var worker = makeWebWorker(header + data);
          resolve(worker);
        } catch (e) {
          reject(Error("Syntax error in worker."));
        }
      });
    });
  }

  /**
   * Make a web worker from the provided string.
   * @param {string} content - The content to use as the code for the
   *   web worker.
   * @return {Worker} - The constructed web worker.
   * @throws {SyntaxError} - Thrown if the worker has a syntax error.
   */
  function makeWebWorker(content) {
    var blob = new Blob(
      [content],
      {type: 'application/javascript'}
    );
    var worker = new Worker(URL.createObjectURL(blob));
    return worker;
  }

  /**
   * Get header to be inserted at the top of the worker file prior to loading.
   */
  function getWorkerHeader(req, config) {
    var header = "";
    var rjsUrl = false;
    if (config.config.requirejsUrl) {
      rjsUrl = req.toUrl(config.config.requirejsUrl);
    }
    var baseUrl = false;
    if (config.config.baseUrl) {
      baseUrl = req.toUrl(config.config.baseUrl);
    }

    if (rjsUrl) {
      header = header + "importScripts('" + rjsUrl + "');";
    }

    if (baseUrl) {
      header = header +
        "require.config({" +
          "baseUrl: '" + baseUrl + "'" + 
        "});";
    }
    return header;
  }

  return {
    version: "1.0.0",
    load: function (name, req, onLoad, config) {
      if (config.isBuild) {
        //don't do anything if this is a build, can't inline a web worker
        onLoad();
        return;
      }

      var url = req.toUrl(name);

      var header = getWorkerHeader(req, config);

      onLoad(getWorkerPromise(url, header));
      return;
    },
    pluginBuilder: 'workerBuilder'
  };
});


define('worker!aStarWorker.js',[],function() {var makeWebWorker = function makeWebWorker(content) {
    var blob = new Blob(
      [content],
      {type: 'application/javascript'}
    );
    var worker = new Worker(URL.createObjectURL(blob));
    return worker;
  };var getWorkerPromise = function getWorkerPromise(content) {
    return new Promise(function(resolve, reject) {
      if (!window.Worker) {
        reject(Error("Web workers not available."));
        return;
      }

      try {
        var worker = makeWebWorker(content);
        resolve(worker);
      } catch (e) {
        reject(Error("Syntax error in worker."));
      }
    });
  };return getWorkerPromise('/**\n * @license almond 0.3.0 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/almond for details\n */\r\n\r\n/*! poly2tri v1.3.5 | (c) 2009-2014 Poly2Tri Contributors */\r\n\r\n(function(){var t,n,r;(function(e){function v(e,t){return h.call(e,t)}function m(e,t){var n,r,i,s,o,u,a,f,c,h,p,v=t&&t.split("/"),m=l.map,g=m&&m["*"]||{};if(e&&e.charAt(0)===".")if(t){v=v.slice(0,v.length-1),e=e.split("/"),o=e.length-1,l.nodeIdCompat&&d.test(e[o])&&(e[o]=e[o].replace(d,"")),e=v.concat(e);for(c=0;c<e.length;c+=1){p=e[c];if(p===".")e.splice(c,1),c-=1;else if(p===".."){if(c===1&&(e[2]===".."||e[0]===".."))break;c>0&&(e.splice(c-1,2),c-=2)}}e=e.join("/")}else e.indexOf("./")===0&&(e=e.substring(2));if((v||g)&&m){n=e.split("/");for(c=n.length;c>0;c-=1){r=n.slice(0,c).join("/");if(v)for(h=v.length;h>0;h-=1){i=m[v.slice(0,h).join("/")];if(i){i=i[r];if(i){s=i,u=c;break}}}if(s)break;!a&&g&&g[r]&&(a=g[r],f=c)}!s&&a&&(s=a,u=f),s&&(n.splice(0,u,s),e=n.join("/"))}return e}function g(t,n){return function(){var r=p.call(arguments,0);return typeof r[0]!="string"&&r.length===1&&r.push(null),s.apply(e,r.concat([t,n]))}}function y(e){return function(t){return m(t,e)}}function b(e){return function(t){a[e]=t}}function w(t){if(v(f,t)){var n=f[t];delete f[t],c[t]=!0,i.apply(e,n)}if(!v(a,t)&&!v(c,t))throw new Error("No "+t);return a[t]}function E(e){var t,n=e?e.indexOf("!"):-1;return n>-1&&(t=e.substring(0,n),e=e.substring(n+1,e.length)),[t,e]}function S(e){return function(){return l&&l.config&&l.config[e]||{}}}var i,s,o,u,a={},f={},l={},c={},h=Object.prototype.hasOwnProperty,p=[].slice,d=/\\.js$/;o=function(e,t){var n,r=E(e),i=r[0];return e=r[1],i&&(i=m(i,t),n=w(i)),i?n&&n.normalize?e=n.normalize(e,y(t)):e=m(e,t):(e=m(e,t),r=E(e),i=r[0],e=r[1],i&&(n=w(i))),{f:i?i+"!"+e:e,n:e,pr:i,p:n}},u={require:function(e){return g(e)},exports:function(e){var t=a[e];return typeof t!="undefined"?t:a[e]={}},module:function(e){return{id:e,uri:"",exports:a[e],config:S(e)}}},i=function(t,n,r,i){var s,l,h,p,d,m=[],y=typeof r,E;i=i||t;if(y==="undefined"||y==="function"){n=!n.length&&r.length?["require","exports","module"]:n;for(d=0;d<n.length;d+=1){p=o(n[d],i),l=p.f;if(l==="require")m[d]=u.require(t);else if(l==="exports")m[d]=u.exports(t),E=!0;else if(l==="module")s=m[d]=u.module(t);else if(v(a,l)||v(f,l)||v(c,l))m[d]=w(l);else{if(!p.p)throw new Error(t+" missing "+l);p.p.load(p.n,g(i,!0),b(l),{}),m[d]=a[l]}}h=r?r.apply(a[t],m):undefined;if(t)if(s&&s.exports!==e&&s.exports!==a[t])a[t]=s.exports;else if(h!==e||!E)a[t]=h}else t&&(a[t]=r)},t=n=s=function(t,n,r,a,f){if(typeof t=="string")return u[t]?u[t](n):w(o(t,n).f);if(!t.splice){l=t,l.deps&&s(l.deps,l.callback);if(!n)return;n.splice?(t=n,n=r,r=null):t=e}return n=n||function(){},typeof r=="function"&&(r=a,a=f),a?i(e,t,n,r):setTimeout(function(){i(e,t,n,r)},4),s},s.config=function(e){return s(e)},t._defined=a,r=function(e,t,n){t.splice||(n=t,t=[]),!v(a,e)&&!v(f,e)&&(f[e]=[e,t,n])},r.amd={jQuery:!0}})(),r("../tools/build/almond",function(){}),!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof r&&r.amd)r("lib/priority-queue",[],e);else{var t;"undefined"!=typeof window?t=window:"undefined"!=typeof global?t=global:"undefined"!=typeof self&&(t=self),t.PriorityQueue=e()}}(function(){return function e(t,r,i){function s(u,f){if(!r[u]){if(!t[u]){var l="function"==typeof n&&n;if(!f&&l)return l(u,!0);if(o)return o(u,!0);var c=new Error("Cannot find module \'"+u+"\'");throw c.code="MODULE_NOT_FOUND",c}var h=r[u]={exports:{}};t[u][0].call(h.exports,function(e){var n=t[u][1][e];return s(n?n:e)},h,h.exports,e,t,r,i)}return r[u].exports}for(var o="function"==typeof n&&n,u=0;u<i.length;u++)s(i[u]);return s}({1:[function(e,t){var n,r,i,s,o,u={}.hasOwnProperty,a=function(e,t){function n(){this.constructor=e}for(var r in t)u.call(t,r)&&(e[r]=t[r]);return n.prototype=t.prototype,e.prototype=new n,e.__super__=t.prototype,e};n=e("./PriorityQueue/AbstractPriorityQueue"),r=e("./PriorityQueue/ArrayStrategy"),s=e("./PriorityQueue/BinaryHeapStrategy"),i=e("./PriorityQueue/BHeapStrategy"),o=function(e){function t(e){e||(e={}),e.strategy||(e.strategy=s),e.comparator||(e.comparator=function(e,t){return(e||0)-(t||0)}),t.__super__.constructor.call(this,e)}return a(t,e),t}(n),o.ArrayStrategy=r,o.BinaryHeapStrategy=s,o.BHeapStrategy=i,t.exports=o},{"./PriorityQueue/AbstractPriorityQueue":2,"./PriorityQueue/ArrayStrategy":3,"./PriorityQueue/BHeapStrategy":4,"./PriorityQueue/BinaryHeapStrategy":5}],2:[function(e,t){var n;t.exports=n=function(){function e(e){if(null==(null!=e?e.strategy:void 0))throw"Must pass options.strategy, a strategy";if(null==(null!=e?e.comparator:void 0))throw"Must pass options.comparator, a comparator";this.priv=new e.strategy(e),this.length=0}return e.prototype.queue=function(e){return this.length++,void this.priv.queue(e)},e.prototype.dequeue=function(){if(!this.length)throw"Empty queue";return this.length--,this.priv.dequeue()},e.prototype.peek=function(){if(!this.length)throw"Empty queue";return this.priv.peek()},e}()},{}],3:[function(e,t){var n,r;r=function(e,t,n){var r,i,s;for(i=0,r=e.length;r>i;)s=i+r>>>1,n(e[s],t)>=0?i=s+1:r=s;return i},t.exports=n=function(){function e(e){var t;this.options=e,this.comparator=this.options.comparator,this.data=(null!=(t=this.options.initialValues)?t.slice(0):void 0)||[],this.data.sort(this.comparator).reverse()}return e.prototype.queue=function(e){var t;return t=r(this.data,e,this.comparator),void this.data.splice(t,0,e)},e.prototype.dequeue=function(){return this.data.pop()},e.prototype.peek=function(){return this.data[this.data.length-1]},e}()},{}],4:[function(e,t){var n;t.exports=n=function(){function e(e){var t,n,r,i,s,o,u,a,f;for(this.comparator=(null!=e?e.comparator:void 0)||function(e,t){return e-t},this.pageSize=(null!=e?e.pageSize:void 0)||512,this.length=0,r=0;1<<r<this.pageSize;)r+=1;if(1<<r!==this.pageSize)throw"pageSize must be a power of two";for(this._shift=r,this._emptyMemoryPageTemplate=t=[],n=s=0,a=this.pageSize;a>=0?a>s:s>a;n=a>=0?++s:--s)t.push(null);if(this._memory=[],this._mask=this.pageSize-1,e.initialValues)for(f=e.initialValues,o=0,u=f.length;u>o;o++)i=f[o],this.queue(i)}return e.prototype.queue=function(e){return this.length+=1,this._write(this.length,e),void this._bubbleUp(this.length,e)},e.prototype.dequeue=function(){var e,t;return e=this._read(1),t=this._read(this.length),this.length-=1,this.length>0&&(this._write(1,t),this._bubbleDown(1,t)),e},e.prototype.peek=function(){return this._read(1)},e.prototype._write=function(e,t){var n;for(n=e>>this._shift;n>=this._memory.length;)this._memory.push(this._emptyMemoryPageTemplate.slice(0));return this._memory[n][e&this._mask]=t},e.prototype._read=function(e){return this._memory[e>>this._shift][e&this._mask]},e.prototype._bubbleUp=function(e,t){var n,r,i,s;for(n=this.comparator;e>1&&(r=e&this._mask,e<this.pageSize||r>3?i=e&~this._mask|r>>1:2>r?(i=e-this.pageSize>>this._shift,i+=i&~(this._mask>>1),i|=this.pageSize>>1):i=e-2,s=this._read(i),!(n(s,t)<0));)this._write(i,t),this._write(e,s),e=i;return void 0},e.prototype._bubbleDown=function(e,t){var n,r,i,s,o;for(o=this.comparator;e<this.length;)if(e>this._mask&&!(e&this._mask-1)?n=r=e+2:e&this.pageSize>>1?(n=(e&~this._mask)>>1,n|=e&this._mask>>1,n=n+1<<this._shift,r=n+1):(n=e+(e&this._mask),r=n+1),n!==r&&r<=this.length)if(i=this._read(n),s=this._read(r),o(i,t)<0&&o(i,s)<=0)this._write(n,t),this._write(e,i),e=n;else{if(!(o(s,t)<0))break;this._write(r,t),this._write(e,s),e=r}else{if(!(n<=this.length))break;if(i=this._read(n),!(o(i,t)<0))break;this._write(n,t),this._write(e,i),e=n}return void 0},e}()},{}],5:[function(e,t){var n;t.exports=n=function(){function e(e){var t;this.comparator=(null!=e?e.comparator:void 0)||function(e,t){return e-t},this.length=0,this.data=(null!=(t=e.initialValues)?t.slice(0):void 0)||[],this._heapify()}return e.prototype._heapify=function(){var e,t,n;if(this.data.length>0)for(e=t=1,n=this.data.length;n>=1?n>t:t>n;e=n>=1?++t:--t)this._bubbleUp(e);return void 0},e.prototype.queue=function(e){return this.data.push(e),void this._bubbleUp(this.data.length-1)},e.prototype.dequeue=function(){var e,t;return t=this.data[0],e=this.data.pop(),this.data.length>0&&(this.data[0]=e,this._bubbleDown(0)),t},e.prototype.peek=function(){return this.data[0]},e.prototype._bubbleUp=function(e){for(var t,n;e>0&&(t=e-1>>>1,this.comparator(this.data[e],this.data[t])<0);)n=this.data[t],this.data[t]=this.data[e],this.data[e]=n,e=t;return void 0},e.prototype._bubbleDown=function(e){var t,n,r,i,s;for(t=this.data.length-1;;){if(n=(e<<1)+1,i=n+1,r=e,t>=n&&this.comparator(this.data[n],this.data[r])<0&&(r=n),t>=i&&this.comparator(this.data[i],this.data[r])<0&&(r=i),r===e)break;s=this.data[r],this.data[r]=this.data[e],this.data[e]=s,e=r}return void 0},e}()},{}]},{},[1])(1)}),!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof r&&r.amd)r("lib/poly2tri",e);else{var t;"undefined"!=typeof window?t=window:"undefined"!=typeof global?t=global:"undefined"!=typeof self&&(t=self),t.poly2tri=e()}}(function(){return function e(t,r,i){function s(u,a){if(!r[u]){if(!t[u]){var f="function"==typeof n&&n;if(!a&&f)return f(u,!0);if(o)return o(u,!0);throw new Error("Cannot find module \'"+u+"\'")}var l=r[u]={exports:{}};t[u][0].call(l.exports,function(e){var n=t[u][1][e];return s(n?n:e)},l,l.exports,e,t,r,i)}return r[u].exports}for(var o="function"==typeof n&&n,u=0;u<i.length;u++)s(i[u]);return s}({1:[function(e,t){t.exports={version:"1.3.5"}},{}],2:[function(e,t){var n=function(e,t){this.point=e,this.triangle=t||null,this.next=null,this.prev=null,this.value=e.x},r=function(e,t){this.head_=e,this.tail_=t,this.search_node_=e};r.prototype.head=function(){return this.head_},r.prototype.setHead=function(e){this.head_=e},r.prototype.tail=function(){return this.tail_},r.prototype.setTail=function(e){this.tail_=e},r.prototype.search=function(){return this.search_node_},r.prototype.setSearch=function(e){this.search_node_=e},r.prototype.findSearchNode=function(){return this.search_node_},r.prototype.locateNode=function(e){var t=this.search_node_;if(e<t.value){for(;t=t.prev;)if(e>=t.value)return this.search_node_=t,t}else for(;t=t.next;)if(e<t.value)return this.search_node_=t.prev,t.prev;return null},r.prototype.locatePoint=function(e){var t=e.x,n=this.findSearchNode(t),r=n.point.x;if(t===r){if(e!==n.point)if(e===n.prev.point)n=n.prev;else{if(e!==n.next.point)throw new Error("poly2tri Invalid AdvancingFront.locatePoint() call");n=n.next}}else if(r>t)for(;(n=n.prev)&&e!==n.point;);else for(;(n=n.next)&&e!==n.point;);return n&&(this.search_node_=n),n},t.exports=r,t.exports.Node=n},{}],3:[function(e,t){function n(e,t){if(!e)throw new Error(t||"Assert Failed")}t.exports=n},{}],4:[function(e,t){var n=e("./xy"),r=function(e,t){this.x=+e||0,this.y=+t||0,this._p2t_edge_list=null};r.prototype.toString=function(){return n.toStringBase(this)},r.prototype.toJSON=function(){return{x:this.x,y:this.y}},r.prototype.clone=function(){return new r(this.x,this.y)},r.prototype.set_zero=function(){return this.x=0,this.y=0,this},r.prototype.set=function(e,t){return this.x=+e||0,this.y=+t||0,this},r.prototype.negate=function(){return this.x=-this.x,this.y=-this.y,this},r.prototype.add=function(e){return this.x+=e.x,this.y+=e.y,this},r.prototype.sub=function(e){return this.x-=e.x,this.y-=e.y,this},r.prototype.mul=function(e){return this.x*=e,this.y*=e,this},r.prototype.length=function(){return Math.sqrt(this.x*this.x+this.y*this.y)},r.prototype.normalize=function(){var e=this.length();return this.x/=e,this.y/=e,e},r.prototype.equals=function(e){return this.x===e.x&&this.y===e.y},r.negate=function(e){return new r(-e.x,-e.y)},r.add=function(e,t){return new r(e.x+t.x,e.y+t.y)},r.sub=function(e,t){return new r(e.x-t.x,e.y-t.y)},r.mul=function(e,t){return new r(e*t.x,e*t.y)},r.cross=function(e,t){return"number"==typeof e?"number"==typeof t?e*t:new r(-e*t.y,e*t.x):"number"==typeof t?new r(t*e.y,-t*e.x):e.x*t.y-e.y*t.x},r.toString=n.toString,r.compare=n.compare,r.cmp=n.compare,r.equals=n.equals,r.dot=function(e,t){return e.x*t.x+e.y*t.y},t.exports=r},{"./xy":11}],5:[function(e,t){var n=e("./xy"),r=function(e,t){this.name="PointError",this.points=t=t||[],this.message=e||"Invalid Points!";for(var r=0;r<t.length;r++)this.message+=" "+n.toString(t[r])};r.prototype=new Error,r.prototype.constructor=r,t.exports=r},{"./xy":11}],6:[function(e,t,n){(function(t){var r=t.poly2tri;n.noConflict=function(){return t.poly2tri=r,n},n.VERSION=e("../dist/version.json").version,n.PointError=e("./pointerror"),n.Point=e("./point"),n.Triangle=e("./triangle"),n.SweepContext=e("./sweepcontext");var i=e("./sweep");n.triangulate=i.triangulate,n.sweep={Triangulate:i.triangulate}}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"../dist/version.json":1,"./point":4,"./pointerror":5,"./sweep":7,"./sweepcontext":8,"./triangle":9}],7:[function(e,t,n){function r(e){e.initTriangulation(),e.createAdvancingFront(),i(e),s(e)}function i(e){var t,n=e.pointCount();for(t=1;n>t;++t)for(var r=e.getPoint(t),i=o(e,r),s=r._p2t_edge_list,a=0;s&&a<s.length;++a)u(e,s[a],i)}function s(e){for(var t=e.front().head().next.triangle,n=e.front().head().next.point;!t.getConstrainedEdgeCW(n);)t=t.neighborCCW(n);e.meshClean(t)}function o(e,t){var n=e.locateNode(t),r=l(e,t,n);return t.x<=n.point.x+F&&c(e,n),h(e,r),r}function u(e,t,n){e.edge_event.constrained_edge=t,e.edge_event.right=t.p.x>t.q.x,f(n.triangle,t.p,t.q)||(w(e,t,n),a(e,t.p,t.q,n.triangle,t.q))}function a(e,t,n,r,i){if(!f(r,t,n)){var s=r.pointCCW(i),o=q(n,s,t);if(o===I.COLLINEAR)throw new P("poly2tri EdgeEvent: Collinear not supported!",[n,s,t]);var u=r.pointCW(i),l=q(n,u,t);if(l===I.COLLINEAR)throw new P("poly2tri EdgeEvent: Collinear not supported!",[n,u,t]);o===l?(r=o===I.CW?r.neighborCCW(i):r.neighborCW(i),a(e,t,n,r,i)):A(e,t,n,r,i)}}function f(e,t,n){var r=e.edgeIndex(t,n);if(-1!==r){e.markConstrainedEdgeByIndex(r);var i=e.getNeighbor(r);return i&&i.markConstrainedEdgeByPoints(t,n),!0}return!1}function l(e,t,n){var r=new H(t,n.point,n.next.point);r.markNeighbor(n.triangle),e.addToMap(r);var i=new B(t);return i.next=n.next,i.prev=n,n.next.prev=i,n.next=i,d(e,r)||e.mapTriangleToNodes(r),i}function c(e,t){var n=new H(t.prev.point,t.point,t.next.point);n.markNeighbor(t.prev.triangle),n.markNeighbor(t.triangle),e.addToMap(n),t.prev.next=t.next,t.next.prev=t.prev,d(e,n)||e.mapTriangleToNodes(n)}function h(e,t){for(var n=t.next;n.next&&!U(n.point,n.next.point,n.prev.point);)c(e,n),n=n.next;for(n=t.prev;n.prev&&!U(n.point,n.next.point,n.prev.point);)c(e,n),n=n.prev;t.next&&t.next.next&&p(t)&&g(e,t)}function p(e){var t=e.point.x-e.next.next.point.x,n=e.point.y-e.next.next.point.y;return D(n>=0,"unordered y"),t>=0||Math.abs(t)<n}function d(e,t){for(var n=0;3>n;++n)if(!t.delaunay_edge[n]){var r=t.getNeighbor(n);if(r){var i=t.getPoint(n),s=r.oppositePoint(t,i),o=r.index(s);if(r.constrained_edge[o]||r.delaunay_edge[o]){t.constrained_edge[n]=r.constrained_edge[o];continue}var u=v(i,t.pointCCW(i),t.pointCW(i),s);if(u){t.delaunay_edge[n]=!0,r.delaunay_edge[o]=!0,m(t,i,r,s);var a=!d(e,t);return a&&e.mapTriangleToNodes(t),a=!d(e,r),a&&e.mapTriangleToNodes(r),t.delaunay_edge[n]=!1,r.delaunay_edge[o]=!1,!0}}}return!1}function v(e,t,n,r){var i=e.x-r.x,s=e.y-r.y,o=t.x-r.x,u=t.y-r.y,a=i*u,f=o*s,l=a-f;if(0>=l)return!1;var c=n.x-r.x,h=n.y-r.y,p=c*s,d=i*h,v=p-d;if(0>=v)return!1;var m=o*h,g=c*u,y=i*i+s*s,b=o*o+u*u,w=c*c+h*h,E=y*(m-g)+b*v+w*l;return E>0}function m(e,t,n,r){var i,s,o,u;i=e.neighborCCW(t),s=e.neighborCW(t),o=n.neighborCCW(r),u=n.neighborCW(r);var a,f,l,c;a=e.getConstrainedEdgeCCW(t),f=e.getConstrainedEdgeCW(t),l=n.getConstrainedEdgeCCW(r),c=n.getConstrainedEdgeCW(r);var h,p,d,v;h=e.getDelaunayEdgeCCW(t),p=e.getDelaunayEdgeCW(t),d=n.getDelaunayEdgeCCW(r),v=n.getDelaunayEdgeCW(r),e.legalize(t,r),n.legalize(r,t),n.setDelaunayEdgeCCW(t,h),e.setDelaunayEdgeCW(t,p),e.setDelaunayEdgeCCW(r,d),n.setDelaunayEdgeCW(r,v),n.setConstrainedEdgeCCW(t,a),e.setConstrainedEdgeCW(t,f),e.setConstrainedEdgeCCW(r,l),n.setConstrainedEdgeCW(r,c),e.clearNeighbors(),n.clearNeighbors(),i&&n.markNeighbor(i),s&&e.markNeighbor(s),o&&e.markNeighbor(o),u&&n.markNeighbor(u),e.markNeighbor(n)}function g(e,t){for(e.basin.left_node=q(t.point,t.next.point,t.next.next.point)===I.CCW?t.next.next:t.next,e.basin.bottom_node=e.basin.left_node;e.basin.bottom_node.next&&e.basin.bottom_node.point.y>=e.basin.bottom_node.next.point.y;)e.basin.bottom_node=e.basin.bottom_node.next;if(e.basin.bottom_node!==e.basin.left_node){for(e.basin.right_node=e.basin.bottom_node;e.basin.right_node.next&&e.basin.right_node.point.y<e.basin.right_node.next.point.y;)e.basin.right_node=e.basin.right_node.next;e.basin.right_node!==e.basin.bottom_node&&(e.basin.width=e.basin.right_node.point.x-e.basin.left_node.point.x,e.basin.left_highest=e.basin.left_node.point.y>e.basin.right_node.point.y,y(e,e.basin.bottom_node))}}function y(e,t){if(!b(e,t)){c(e,t);var n;if(t.prev!==e.basin.left_node||t.next!==e.basin.right_node){if(t.prev===e.basin.left_node){if(n=q(t.point,t.next.point,t.next.next.point),n===I.CW)return;t=t.next}else if(t.next===e.basin.right_node){if(n=q(t.point,t.prev.point,t.prev.prev.point),n===I.CCW)return;t=t.prev}else t=t.prev.point.y<t.next.point.y?t.prev:t.next;y(e,t)}}}function b(e,t){var n;return n=e.basin.left_highest?e.basin.left_node.point.y-t.point.y:e.basin.right_node.point.y-t.point.y,e.basin.width>n?!0:!1}function w(e,t,n){e.edge_event.right?E(e,t,n):N(e,t,n)}function E(e,t,n){for(;n.next.point.x<t.p.x;)q(t.q,n.next.point,t.p)===I.CCW?S(e,t,n):n=n.next}function S(e,t,n){n.point.x<t.p.x&&(q(n.point,n.next.point,n.next.next.point)===I.CCW?x(e,t,n):(T(e,t,n),S(e,t,n)))}function x(e,t,n){c(e,n.next),n.next.point!==t.p&&q(t.q,n.next.point,t.p)===I.CCW&&q(n.point,n.next.point,n.next.next.point)===I.CCW&&x(e,t,n)}function T(e,t,n){q(n.next.point,n.next.next.point,n.next.next.next.point)===I.CCW?x(e,t,n.next):q(t.q,n.next.next.point,t.p)===I.CCW&&T(e,t,n.next)}function N(e,t,n){for(;n.prev.point.x>t.p.x;)q(t.q,n.prev.point,t.p)===I.CW?C(e,t,n):n=n.prev}function C(e,t,n){n.point.x>t.p.x&&(q(n.point,n.prev.point,n.prev.prev.point)===I.CW?L(e,t,n):(k(e,t,n),C(e,t,n)))}function k(e,t,n){q(n.prev.point,n.prev.prev.point,n.prev.prev.prev.point)===I.CW?L(e,t,n.prev):q(t.q,n.prev.prev.point,t.p)===I.CW&&k(e,t,n.prev)}function L(e,t,n){c(e,n.prev),n.prev.point!==t.p&&q(t.q,n.prev.point,t.p)===I.CW&&q(n.point,n.prev.point,n.prev.prev.point)===I.CW&&L(e,t,n)}function A(e,t,n,r,i){var s=r.neighborAcross(i);D(s,"FLIP failed due to missing triangle!");var o=s.oppositePoint(r,i);if(r.getConstrainedEdgeAcross(i)){var u=r.index(i);throw new P("poly2tri Intersecting Constraints",[i,o,r.getPoint((u+1)%3),r.getPoint((u+2)%3)])}if(R(i,r.pointCCW(i),r.pointCW(i),o))if(m(r,i,s,o),e.mapTriangleToNodes(r),e.mapTriangleToNodes(s),i===n&&o===t)n===e.edge_event.constrained_edge.q&&t===e.edge_event.constrained_edge.p&&(r.markConstrainedEdgeByPoints(t,n),s.markConstrainedEdgeByPoints(t,n),d(e,r),d(e,s));else{var f=q(n,o,t);r=O(e,f,r,s,i,o),A(e,t,n,r,i)}else{var l=M(t,n,s,o);_(e,t,n,r,s,l),a(e,t,n,r,i)}}function O(e,t,n,r,i,s){var o;return t===I.CCW?(o=r.edgeIndex(i,s),r.delaunay_edge[o]=!0,d(e,r),r.clearDelaunayEdges(),n):(o=n.edgeIndex(i,s),n.delaunay_edge[o]=!0,d(e,n),n.clearDelaunayEdges(),r)}function M(e,t,n,r){var i=q(t,r,e);if(i===I.CW)return n.pointCCW(r);if(i===I.CCW)return n.pointCW(r);throw new P("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!",[t,r,e])}function _(e,t,n,r,i,s){var o=i.neighborAcross(s);D(o,"FLIP failed due to missing triangle");var u=o.oppositePoint(i,s);if(R(n,r.pointCCW(n),r.pointCW(n),u))A(e,n,u,o,u);else{var a=M(t,n,o,u);_(e,t,n,r,o,a)}}var D=e("./assert"),P=e("./pointerror"),H=e("./triangle"),B=e("./advancingfront").Node,j=e("./utils"),F=j.EPSILON,I=j.Orientation,q=j.orient2d,R=j.inScanArea,U=j.isAngleObtuse;n.triangulate=r},{"./advancingfront":2,"./assert":3,"./pointerror":5,"./triangle":9,"./utils":10}],8:[function(e,t){var n=e("./pointerror"),r=e("./point"),i=e("./triangle"),s=e("./sweep"),o=e("./advancingfront"),u=o.Node,a=.3,f=function(e,t){if(this.p=e,this.q=t,e.y>t.y)this.q=e,this.p=t;else if(e.y===t.y)if(e.x>t.x)this.q=e,this.p=t;else if(e.x===t.x)throw new n("poly2tri Invalid Edge constructor: repeated points!",[e]);this.q._p2t_edge_list||(this.q._p2t_edge_list=[]),this.q._p2t_edge_list.push(this)},l=function(){this.left_node=null,this.bottom_node=null,this.right_node=null,this.width=0,this.left_highest=!1};l.prototype.clear=function(){this.left_node=null,this.bottom_node=null,this.right_node=null,this.width=0,this.left_highest=!1};var c=function(){this.constrained_edge=null,this.right=!1},h=function(e,t){t=t||{},this.triangles_=[],this.map_=[],this.points_=t.cloneArrays?e.slice(0):e,this.edge_list=[],this.pmin_=this.pmax_=null,this.front_=null,this.head_=null,this.tail_=null,this.af_head_=null,this.af_middle_=null,this.af_tail_=null,this.basin=new l,this.edge_event=new c,this.initEdges(this.points_)};h.prototype.addHole=function(e){this.initEdges(e);var t,n=e.length;for(t=0;n>t;t++)this.points_.push(e[t]);return this},h.prototype.AddHole=h.prototype.addHole,h.prototype.addHoles=function(e){var t,n=e.length;for(t=0;n>t;t++)this.initEdges(e[t]);return this.points_=this.points_.concat.apply(this.points_,e),this},h.prototype.addPoint=function(e){return this.points_.push(e),this},h.prototype.AddPoint=h.prototype.addPoint,h.prototype.addPoints=function(e){return this.points_=this.points_.concat(e),this},h.prototype.triangulate=function(){return s.triangulate(this),this},h.prototype.getBoundingBox=function(){return{min:this.pmin_,max:this.pmax_}},h.prototype.getTriangles=function(){return this.triangles_},h.prototype.GetTriangles=h.prototype.getTriangles,h.prototype.front=function(){return this.front_},h.prototype.pointCount=function(){return this.points_.length},h.prototype.head=function(){return this.head_},h.prototype.setHead=function(e){this.head_=e},h.prototype.tail=function(){return this.tail_},h.prototype.setTail=function(e){this.tail_=e},h.prototype.getMap=function(){return this.map_},h.prototype.initTriangulation=function(){var e,t=this.points_[0].x,n=this.points_[0].x,i=this.points_[0].y,s=this.points_[0].y,o=this.points_.length;for(e=1;o>e;e++){var u=this.points_[e];u.x>t&&(t=u.x),u.x<n&&(n=u.x),u.y>i&&(i=u.y),u.y<s&&(s=u.y)}this.pmin_=new r(n,s),this.pmax_=new r(t,i);var f=a*(t-n),l=a*(i-s);this.head_=new r(t+f,s-l),this.tail_=new r(n-f,s-l),this.points_.sort(r.compare)},h.prototype.initEdges=function(e){var t,n=e.length;for(t=0;n>t;++t)this.edge_list.push(new f(e[t],e[(t+1)%n]))},h.prototype.getPoint=function(e){return this.points_[e]},h.prototype.addToMap=function(e){this.map_.push(e)},h.prototype.locateNode=function(e){return this.front_.locateNode(e.x)},h.prototype.createAdvancingFront=function(){var e,t,n,r=new i(this.points_[0],this.tail_,this.head_);this.map_.push(r),e=new u(r.getPoint(1),r),t=new u(r.getPoint(0),r),n=new u(r.getPoint(2)),this.front_=new o(e,n),e.next=t,t.next=n,t.prev=e,n.prev=t},h.prototype.removeNode=function(){},h.prototype.mapTriangleToNodes=function(e){for(var t=0;3>t;++t)if(!e.getNeighbor(t)){var n=this.front_.locatePoint(e.pointCW(e.getPoint(t)));n&&(n.triangle=e)}},h.prototype.removeFromMap=function(e){var t,n=this.map_,r=n.length;for(t=0;r>t;t++)if(n[t]===e){n.splice(t,1);break}},h.prototype.meshClean=function(e){for(var t,n,r=[e];t=r.pop();)if(!t.isInterior())for(t.setInterior(!0),this.triangles_.push(t),n=0;3>n;n++)t.constrained_edge[n]||r.push(t.getNeighbor(n))},t.exports=h},{"./advancingfront":2,"./point":4,"./pointerror":5,"./sweep":7,"./triangle":9}],9:[function(e,t){var n=e("./xy"),r=function(e,t,n){this.points_=[e,t,n],this.neighbors_=[null,null,null],this.interior_=!1,this.constrained_edge=[!1,!1,!1],this.delaunay_edge=[!1,!1,!1]},i=n.toString;r.prototype.toString=function(){return"["+i(this.points_[0])+i(this.points_[1])+i(this.points_[2])+"]"},r.prototype.getPoint=function(e){return this.points_[e]},r.prototype.GetPoint=r.prototype.getPoint,r.prototype.getPoints=function(){return this.points_},r.prototype.getNeighbor=function(e){return this.neighbors_[e]},r.prototype.containsPoint=function(e){var t=this.points_;return e===t[0]||e===t[1]||e===t[2]},r.prototype.containsEdge=function(e){return this.containsPoint(e.p)&&this.containsPoint(e.q)},r.prototype.containsPoints=function(e,t){return this.containsPoint(e)&&this.containsPoint(t)},r.prototype.isInterior=function(){return this.interior_},r.prototype.setInterior=function(e){return this.interior_=e,this},r.prototype.markNeighborPointers=function(e,t,n){var r=this.points_;if(e===r[2]&&t===r[1]||e===r[1]&&t===r[2])this.neighbors_[0]=n;else if(e===r[0]&&t===r[2]||e===r[2]&&t===r[0])this.neighbors_[1]=n;else{if(!(e===r[0]&&t===r[1]||e===r[1]&&t===r[0]))throw new Error("poly2tri Invalid Triangle.markNeighborPointers() call");this.neighbors_[2]=n}},r.prototype.markNeighbor=function(e){var t=this.points_;e.containsPoints(t[1],t[2])?(this.neighbors_[0]=e,e.markNeighborPointers(t[1],t[2],this)):e.containsPoints(t[0],t[2])?(this.neighbors_[1]=e,e.markNeighborPointers(t[0],t[2],this)):e.containsPoints(t[0],t[1])&&(this.neighbors_[2]=e,e.markNeighborPointers(t[0],t[1],this))},r.prototype.clearNeighbors=function(){this.neighbors_[0]=null,this.neighbors_[1]=null,this.neighbors_[2]=null},r.prototype.clearDelaunayEdges=function(){this.delaunay_edge[0]=!1,this.delaunay_edge[1]=!1,this.delaunay_edge[2]=!1},r.prototype.pointCW=function(e){var t=this.points_;return e===t[0]?t[2]:e===t[1]?t[0]:e===t[2]?t[1]:null},r.prototype.pointCCW=function(e){var t=this.points_;return e===t[0]?t[1]:e===t[1]?t[2]:e===t[2]?t[0]:null},r.prototype.neighborCW=function(e){return e===this.points_[0]?this.neighbors_[1]:e===this.points_[1]?this.neighbors_[2]:this.neighbors_[0]},r.prototype.neighborCCW=function(e){return e===this.points_[0]?this.neighbors_[2]:e===this.points_[1]?this.neighbors_[0]:this.neighbors_[1]},r.prototype.getConstrainedEdgeCW=function(e){return e===this.points_[0]?this.constrained_edge[1]:e===this.points_[1]?this.constrained_edge[2]:this.constrained_edge[0]},r.prototype.getConstrainedEdgeCCW=function(e){return e===this.points_[0]?this.constrained_edge[2]:e===this.points_[1]?this.constrained_edge[0]:this.constrained_edge[1]},r.prototype.getConstrainedEdgeAcross=function(e){return e===this.points_[0]?this.constrained_edge[0]:e===this.points_[1]?this.constrained_edge[1]:this.constrained_edge[2]},r.prototype.setConstrainedEdgeCW=function(e,t){e===this.points_[0]?this.constrained_edge[1]=t:e===this.points_[1]?this.constrained_edge[2]=t:this.constrained_edge[0]=t},r.prototype.setConstrainedEdgeCCW=function(e,t){e===this.points_[0]?this.constrained_edge[2]=t:e===this.points_[1]?this.constrained_edge[0]=t:this.constrained_edge[1]=t},r.prototype.getDelaunayEdgeCW=function(e){return e===this.points_[0]?this.delaunay_edge[1]:e===this.points_[1]?this.delaunay_edge[2]:this.delaunay_edge[0]},r.prototype.getDelaunayEdgeCCW=function(e){return e===this.points_[0]?this.delaunay_edge[2]:e===this.points_[1]?this.delaunay_edge[0]:this.delaunay_edge[1]},r.prototype.setDelaunayEdgeCW=function(e,t){e===this.points_[0]?this.delaunay_edge[1]=t:e===this.points_[1]?this.delaunay_edge[2]=t:this.delaunay_edge[0]=t},r.prototype.setDelaunayEdgeCCW=function(e,t){e===this.points_[0]?this.delaunay_edge[2]=t:e===this.points_[1]?this.delaunay_edge[0]=t:this.delaunay_edge[1]=t},r.prototype.neighborAcross=function(e){return e===this.points_[0]?this.neighbors_[0]:e===this.points_[1]?this.neighbors_[1]:this.neighbors_[2]},r.prototype.oppositePoint=function(e,t){var n=e.pointCW(t);return this.pointCW(n)},r.prototype.legalize=function(e,t){var n=this.points_;if(e===n[0])n[1]=n[0],n[0]=n[2],n[2]=t;else if(e===n[1])n[2]=n[1],n[1]=n[0],n[0]=t;else{if(e!==n[2])throw new Error("poly2tri Invalid Triangle.legalize() call");n[0]=n[2],n[2]=n[1],n[1]=t}},r.prototype.index=function(e){var t=this.points_;if(e===t[0])return 0;if(e===t[1])return 1;if(e===t[2])return 2;throw new Error("poly2tri Invalid Triangle.index() call")},r.prototype.edgeIndex=function(e,t){var n=this.points_;if(e===n[0]){if(t===n[1])return 2;if(t===n[2])return 1}else if(e===n[1]){if(t===n[2])return 0;if(t===n[0])return 2}else if(e===n[2]){if(t===n[0])return 1;if(t===n[1])return 0}return-1},r.prototype.markConstrainedEdgeByIndex=function(e){this.constrained_edge[e]=!0},r.prototype.markConstrainedEdgeByEdge=function(e){this.markConstrainedEdgeByPoints(e.p,e.q)},r.prototype.markConstrainedEdgeByPoints=function(e,t){var n=this.points_;t===n[0]&&e===n[1]||t===n[1]&&e===n[0]?this.constrained_edge[2]=!0:t===n[0]&&e===n[2]||t===n[2]&&e===n[0]?this.constrained_edge[1]=!0:(t===n[1]&&e===n[2]||t===n[2]&&e===n[1])&&(this.constrained_edge[0]=!0)},t.exports=r},{"./xy":11}],10:[function(e,t,n){function r(e,t,n){var r=(e.x-n.x)*(t.y-n.y),i=(e.y-n.y)*(t.x-n.x),s=r-i;return s>-o&&o>s?u.COLLINEAR:s>0?u.CCW:u.CW}function i(e,t,n,r){var i=(e.x-t.x)*(r.y-t.y)-(r.x-t.x)*(e.y-t.y);if(i>=-o)return!1;var s=(e.x-n.x)*(r.y-n.y)-(r.x-n.x)*(e.y-n.y);return o>=s?!1:!0}function s(e,t,n){var r=t.x-e.x,i=t.y-e.y,s=n.x-e.x,o=n.y-e.y;return 0>r*s+i*o}var o=1e-12;n.EPSILON=o;var u={CW:1,CCW:-1,COLLINEAR:0};n.Orientation=u,n.orient2d=r,n.inScanArea=i,n.isAngleObtuse=s},{}],11:[function(e,t){function n(e){return"("+e.x+";"+e.y+")"}function r(e){var t=e.toString();return"[object Object]"===t?n(e):t}function i(e,t){return e.y===t.y?e.x-t.x:e.y-t.y}function s(e,t){return e.x===t.x&&e.y===t.y}t.exports={toString:r,toStringBase:n,compare:i,equals:s}},{}]},{},[6])(6)}),r("polypartition",["./lib/poly2tri"],function(t){var n={};Point=function(e,t){this.x=e,this.y=t},n.Point=Point,Point.prototype.add=function(e){return typeof e=="number"?new Point(this.x+e,this.y+e):new Point(this.x+e.x,this.y+e.y)},Point.prototype.sub=function(e){return typeof e=="number"?new Point(this.x-e,this.y-e):new Point(this.x-e.x,this.y-e.y)},Point.prototype.mul=function(e){return new Point(this.x*e,this.y*e)},Point.prototype.div=function(e){return new Point(this.x/e,this.y/e)},Point.prototype.eq=function(e){return this.x==e.x&&this.y==e.y},Point.prototype.neq=function(e){return this.x!=e.x||this.y!=e.y},Point.prototype.dot=function(e){return this.x*e.x+this.y*e.y},Point.prototype.cross=function(e){return this.x*e.y-this.y*e.x},Point.prototype.dist=function(e){var t=this.sub(e);return Math.sqrt(t.dot(t))},Point.prototype.dist2=function(e){var t=this.sub(e);return t.dot(t)},Point.prototype.zero=function(){return this.x==0&&this.y==0},Point.prototype.len=function(){return this.dist(new Point(0,0))},Point.prototype.normalize=function(){var e=this.dist(new Point(0,0));return e>0?this.div(e):new Point(0,0)},Point.prototype.toString=function(){return"x"+this.x+"y"+this.y},Edge=function(e,t){this.p1=e,this.p2=t,this.center=e.add(t.sub(e).div(2)),this.points=[this.p1,this.center,this.p2]},n.Edge=Edge,Edge.prototype._CCW=function(t,n,r){return a=t.x,b=t.y,c=n.x,d=n.y,e=r.x,f=r.y,(f-b)*(c-a)>(d-b)*(e-a)},Edge.prototype.intersects=function(e){var t=e.p1,n=e.p2;return t.eq(this.p1)||t.eq(this.p2)||n.eq(this.p1)||n.eq(this.p2)?!1:this._CCW(this.p1,t,n)!=this._CCW(this.p2,t,n)&&this._CCW(this.p1,this.p2,t)!=this._CCW(this.p1,this.p2,n)},Poly=function(){this.hole=!1,this.points=null,this.numpoints=0},n.Poly=Poly,Poly.prototype.init=function(e){this.points=new Array(e),this.numpoints=e},Poly.prototype.update=function(){this.numpoints=this.points.length},Poly.prototype.triangle=function(e,t,n){this.init(3),this.points[0]=e,this.points[1]=t,this.points[2]=n},Poly.prototype.getPoint=function(e){return this.points&&this.numpoints>e?this.points[e]:null},Poly.prototype.setPoint=function(e,t){this.points&&this.points.length>e&&(this.points[e]=t)},Poly.prototype.getNextI=function(e){return(e+1)%this.numpoints},Poly.prototype.getPrevI=function(e){return e==0?this.numpoints-1:e-1},Poly.prototype.getArea=function(){var e=0;for(var t=0;t<this.numpoints;t++){var n=this.getNextI(t);e+=this.points[t].x*this.points[n].y-this.points[t].y*this.points[n].x}return e},Poly.prototype.getOrientation=function(){var e=this.getArea();return e>0?"CCW":e<0?"CW":0},Poly.prototype.setOrientation=function(e){var t=this.getOrientation();t&&t!==e&&this.invert()},Poly.prototype.invert=function(){var e=new Array(this.numpoints);for(var t=0;t<this.numpoints;t++)e[t]=this.points[this.numpoints-t-1];this.points=e},Poly.prototype.getCenter=function(){var e=this.points.map(function(e){return e.x}),t=this.points.map(function(e){return e.y}),n=Math.min.apply(null,e),r=Math.max.apply(null,e),i=Math.min.apply(null,t),s=Math.max.apply(null,t);return new Point((n+r)/2,(i+s)/2)},Poly.prototype.centroid=function(){var e=0,t=0,n,r,i,s,o;for(n=0,r=this.points.length-1;n<this.points.length;r=n,n+=1)s=this.points[n],o=this.points[r],i=s.x*o.y-o.x*s.y,e+=(s.x+o.x)*i,t+=(s.y+o.y)*i;return i=this.getArea()*3,e=Math.abs(e),t=Math.abs(t),new Point(e/i,t/i)},Poly.prototype.toPointString=function(e,t){e=e||" ",t=t||"\\n";var n="";return this.points.forEach(function(r){n=n+r.x+e+r.y+t}),n},Poly.prototype.toString=function(){var e=this.centroid();return""+e.x+" "+e.y},Poly.prototype.containsPoint=function(e){var t=!1;for(var n=0,r=this.numpoints-1;n<this.numpoints;r=n++){var i=this.points[r],s=this.points[n];s.y>e.y!=i.y>e.y&&e.x<(i.x-s.x)*(e.y-s.y)/(i.y-s.y)+s.x&&(t=!t)}return t},Partition=function(){this.drawCallback=null},n.Partition=Partition,Partition.prototype.convertTrianglesToPolys=function(e){var t=e.map(function(e){var t=new Poly;return t.init(3),e.getPoints().forEach(function(e,n){t.setPoint(n,new Point(e.x,e.y))}),t});return t},Partition.prototype.convexPartition=function(e,n,i){typeof n=="undefined"&&(n=!1),typeof i=="undefined"&&(i=5);var s,o,u,a,f,l,c=new Array;if(!n){var h=!1;for(var p=0;p<e.numpoints;p++){var d=e.getPrevI(p),v=e.getNextI(p);if(!r.isConvex(e.getPoint(d),e.getPoint(p),e.getPoint(v))){h=!0;break}}if(!h)return c.push(e),c}var m=e.points.map(function(e){return new t.Point(e.x,e.y)});n&&(n=n.map(function(e){return e.points.map(function(e){return new t.Point(e.x,e.y)})}));var g=new t.SweepContext(m);n&&g.addHoles(n);var y=g.triangulate().getTriangles();y=this.convertTrianglesToPolys(y).filter(function(e){return e.getArea()>=i});for(var b=0;b<y.length;b++){var w=y[b],E=null;for(s=0;s<w.numpoints;s++){var S=w.getPoint(s);o=w.getNextI(s);var x=w.getPoint(o),T=!1;for(var N=b;N<y.length;N++){if(b==N)continue;var C=y[N];for(a=0;a<C.numpoints;a++){if(x.neq(C.getPoint(a)))continue;f=C.getNextI(a);if(S.neq(C.getPoint(f)))continue;T=!0,object_2_index=N;break}if(T)break}if(!T)continue;var k,L,A;L=w.getPoint(s),u=w.getPrevI(s),k=w.getPoint(u),l=C.getNextI(f),A=C.getPoint(l);if(!r.isConvex(k,L,A))continue;L=w.getPoint(o),u=w.getNextI(o),A=w.getPoint(u),l=C.getPrevI(a),k=C.getPoint(l);if(!r.isConvex(k,L,A))continue;var O=new Poly;O.init(w.numpoints+C.numpoints-2);var M=0;for(var _=o;_!=s;_=w.getNextI(_))O.setPoint(M,w.getPoint(_)),M++;for(var _=f;_!=a;_=C.getNextI(_))O.setPoint(M,C.getPoint(_)),M++;b>object_2_index?(y[b]=O,w=y[b],y.splice(object_2_index,1)):(y.splice(object_2_index,1),y[b]=O,w=y[b]),s=-1}}return y};var r={};return r.isConvex=function(e,t,n){var r=(n.y-e.y)*(t.x-e.x)-(n.x-e.x)*(t.y-e.y);return r>0},r.findPolyForPoint=function(e,t){var n,r;for(n in t){r=t[n];if(r.containsPoint(e))return r}return null},r.lineCircleIntersection=function(e,t,n,r){var i={collides:!1,inside:!1,point:null,normal:null},s=n.sub(e);if(s.len()<=r)i.collides=!0,i.inside=s.len()!==r;else if(t.dot(s)>=0){var o=e.add(t.mul(t.dot(s))),u=n.sub(o).len();if(u<=r){i.collides=!0;var a=Math.sqrt(u*u+r*r);i.point=o.sub(t.mul(a)),i.normal=i.point.sub(n).normalize()}}return i},n.PolyUtils=r,n}),r("pathfinder",["./lib/priority-queue","./polypartition"],function(e,t){var n=t.PolyUtils,r=function(e,t){typeof t=="undefined"&&(t=!0),this.polys=e,t&&this.init()};return r.prototype.init=function(){this.grid=this.generateAdjacencyGrid(this.polys)},r.prototype.aStar=function(t,r){function i(e,t){return e.dist+u(e.point)-(t.dist+u(t.point))}function s(e,t){return e.dist(t)}function o(e,t){return e.r-t.r+(e.c-t.c)}function u(e){return s(e,r)}var a=n.findPolyForPoint(t,this.polys);if(!a){var f=[new Point(5,0),new Point(-5,0),new Point(0,-5),new Point(0,5)];for(var l=0;l<f.length;l++){var c=t.add(f[l]);a=n.findPolyForPoint(c,this.polys);if(a){t=c;break}}if(!a)return null}var h=n.findPolyForPoint(r,this.polys);if(a==h)return[t,r];var p=new WeakSet,d=new WeakSet,v=new e({comparator:i}),m=null;v.queue({dist:0,poly:a,point:t,parent:null});while(v.length>0){var g=v.dequeue();if(g.poly==h){m=g;break}p.add(g.poly),d.add(g.point);var y=this.grid.get(g.poly);for(var l=0;l<y.length;l++){var b=y[l],w=p.has(b.poly);for(var E=0;E<b.edge.points.length;E++){var S=b.edge.points[E];(!w||!d.has(S))&&v.queue({dist:g.dist+s(S,g.point),poly:b.poly,point:S,parent:g})}}}if(m){var x=[],T=m;while(T.parent)x.unshift(T.point),T=T.parent;return x.unshift(T.point),x.push(r),x}return null},r.prototype.generateAdjacencyGrid=function(e){var t=new WeakMap;return e.forEach(function(e,n,r){if(t.has(e)){if(t.get(e).length==e.numpoints)return}else t.set(e,new Array);e.points.forEach(function(i,s,o){var u=o[e.getNextI(s)];for(var a=n+1;a<r.length;a++){var f=r[a];f.points.some(function(n,r,s){var o=s[f.getNextI(r)],a=i.eq(o)&&u.eq(n);if(a){var l=new Edge(i,u);t.get(e).push({poly:f,edge:l}),t.has(f)||t.set(f,new Array),t.get(f).push({poly:e,edge:l})}return a});if(t.get(e).length==e.numpoints)break}})}),t},r}),n(["./pathfinder","./polypartition"],function(e,t){var n=t.Point,r=t.Poly,i=t.PolyUtils,s={};s.toPoint=function(e){return new n(e.x,e.y)},s.toPoly=function(e){var t=new r;return t.points=e.points.map(s.toPoint),t.hole=e.hole,t.update(),t};var o={};o.log=function(e){var t=["log"];Array.prototype.push.apply(t,arguments),postMessage(t)},onmessage=function(t){var n=t.data,r=n[0];o.log("worker:debug","Message received to worker:",n);if(r=="polys")self.polys=n[1].map(s.toPoly),self.pathfinder=new e(self.polys);else if(r=="aStar"){var i=s.toPoint(n[1]),u=s.toPoint(n[2]),a=self.pathfinder.aStar(i,u);postMessage(["result",a])}else r=="isInitialized"&&postMessage(["init",!0])},o.log("worker","Worker loaded."),postMessage(["init",!0])}),r("aStarWorker",function(){})})();');});

/**
 * A NavMesh represents the traversable area of a map and gives
 * utilities for pathfinding.
 * Usage:
 *   // Assuming the 2d map tiles array is available:
 *   var navmesh = new NavMesh(map);
 *   navmesh.calculatePath(currentlocation, targetLocation, callback);
 * @module navmesh
 */
define('navmesh',['./polypartition', './parse-map', './pathfinder', './lib/clipper', './worker!./aStarWorker.js'],
function(  pp,                MapParser,     Pathfinder,     ClipperLib,     workerPromise) {
  var Point = pp.Point;
  var Poly = pp.Poly;
  var Partition = pp.Partition;
  var Edge = pp.Edge;
  var PolyUtils = pp.PolyUtils;
  
  /**
   * @constructor
   * @alias module:navmesh
   * @param {MapTiles} map - The 2d array defining the map tiles.
   * @param {Logger} [logger] - The logger to use.
   */
  var NavMesh = function(map, logger) {
    if (typeof logger == 'undefined') {
      logger = {};
      logger.log = function() {};
    }
    this.logger = logger;
    this.initialized = false;
    // Make utilities in polypartition available without requiting
    // that it be included in external scripts.
    this.geom = pp;

    // Parse map tiles into polygons.
    var polys = MapParser.parse(map);
    if (!polys) {
      throw "Map parsing failed!";
    }

    // Set callbacks for worker promise object.
    workerPromise.then(function(worker) {
      this.workerInitialized = false;
      this.logger.log("navmesh", "Using worker.");
      this.worker = worker;
      this.worker.onmessage = function(message) {
        var data = message.data;
        var name = data[0];
        if (name !== "log")
          this.logger.log("navmesh:debug", "Message received from worker: ", data);
          
        if (name == "log") {
          this._workerLogger(data.slice(1));
        } else if (name == "init") {
          this.workerInitialized = data[1];
          this._workerInit();
        }
      }.bind(this);
      // Check if worker is already initialized.
      this.worker.postMessage(["isInitialized"]);
    }.bind(this), function(Error) {
      this.logger.log("navmesh:warn", "No worker, falling back to in-thread computation.");
      this.logger.log("navmesh:warn", "Worker error:", Error);
      this.worker = false;
    }.bind(this));

    this.init(polys);
  };

  /**
   * Initialize the navigation mesh with the polygons describing the
   * map elements.
   * @private
   * @param {ParsedMap} - The map information parsed into polygons.
   */
  NavMesh.prototype.init = function(parsedMap) {
    // Save original parsed map polys.
    this.parsedMap = parsedMap;

    // Perform initial separation of any slightly overlapping polygons.
    this._separatePolys(parsedMap.walls);
    this._separatePolys(parsedMap.obstacles);

    // Offset polys from side so they represent traversable area.
    var areas = this._offsetPolys(parsedMap);

    this.polys = [];
    areas.forEach(function(area) {
      var outline = area.polygon;
      var holes = area.holes;
      var polys = this._generatePartition(outline, holes);
      Array.prototype.push.apply(this.polys, polys);
    }, this);

    if (!this.worker) {
      this.pathfinder = new Pathfinder(this.polys);
    }

    // Keep track of original polygons, generate their edges in advance.
    //this.original_polys = parsedMap.walls.concat(parsedMap.obstacles);
    this.obstacle_edges = [];
    //this.original_polys.forEach(function(poly) {
    areas.forEach(function(area) {
      var polys = [area.polygon].concat(area.holes);
      polys.forEach(function(poly) {
        for (var i = 0, j = poly.numpoints - 1; i < poly.numpoints; j = i++) {
          this.obstacle_edges.push(new Edge(poly.points[j], poly.points[i]));
        }
      }, this);
    }, this);
    this.initialized = true;
  }

  /**
   * Callback for path calculation requests.
   * @callback pathCallback
   * @param {?Array.<Point>} - The calculated path, the first Point
   *   of which should be the target of any navigation. The goal Point
   *   is included at the end of the path.
   */
  /**
   * Calculate a path from the source point to the target point, invoking
   * the callback with the path after calculation.
   * @param {Point} source - The start location of the search.
   * @param {Point} target - The target of the search.
   * @param {pathCallback} callback - The callback function invoked
   *   when the path has been calculated.
   */
  NavMesh.prototype.calculatePath = function(source, target, callback) {
    this.logger.log("navmesh:debug", "Calculating path.");

    // Use web worker if present.
    if (this.worker && this.workerInitialized) {
      this.logger.log("navmesh:debug", "Using worker to calculate path.");
      this.worker.postMessage(["aStar", source, target]);
      // Set callback so it is accessible when results are sent back.
      this.lastCallback = callback;
    } else {
      path = this.pathfinder.aStar(source, target);
      if (typeof path !== 'undefined' && path) {
        // Remove first entry, which is current position.
        path = path.slice(1);
      }
      callback(path);
    }
  }

  // Return true if p1 is visible from p2. The offset outline and holes are
  // used as obstacles in this case.
  NavMesh.prototype.checkVisible = function(p1, p2) {
    var edge = new Edge(p1, p2);

    checkEdge = function(edges, edge_index, my_edge) {
      var thisEdge = edges[edge_index];

      if (edge_index !== edges.length - 1) {
        setTimeout(function() {
          checkEdge(edges, edge_index + 1, my_edge);
        }, 1000);
      }
    }
    var blocked = this.obstacle_edges.some(function(e) {return e.intersects(edge);});
    return !blocked;
  }

  // private
  // Given a polygon outline and an [optional] array of polygons
  // representing holes in the polygon, partition the outline. Returns
  // an array of polygons representing the partitioned space
  NavMesh.prototype._generatePartition = function(outline, holes) {
    // Ensure proper vertex order for holes and outline.
    outline.setOrientation("CCW");
    holes.forEach(function(e) {
      e.setOrientation("CW");
      e.hole = true;
    });

    var partitioner = new Partition();

    return partitioner.convexPartition(outline, holes);
  }

  /**
   * Takes an array of polygons that overlap themselves and others
   * at discrete corner points and separate those overlapping corners
   * slightly so the polygons are suitable for triangulation by
   * poly2tri.js. This changes the Poly objects in the array.
   * @private
   * @param {Array.<Poly>} polys - The polygons to separate.
   * @param {number} [offset=1] - The number of units the vertices
   *   should be moved away from each other.
   */
  NavMesh.prototype._separatePolys = function(polys, offset) {
    offset = offset || 1;
    var discovered = {};
    var dupes = {};
    // Offset to use in calculation.
    // Find duplicates.
    for (var s1 = 0; s1 < polys.length; s1++) {
      var poly = polys[s1];
      for (var i = 0; i < poly.numpoints; i++) {
        var point = poly.points[i].toString();
        if (!discovered.hasOwnProperty(point)) {
          discovered[point] = true;
        } else {
          dupes[point] = true;
        }
      }
    }

    // Get duplicate points.
    var dupe_points = [];
    var dupe;
    for (var s1 = 0; s1 < polys.length; s1++) {
      var poly = polys[s1];
      for (var i = 0; i < poly.numpoints; i++) {
        var point = poly.points[i];
        if (dupes.hasOwnProperty(point.toString())) {
          dupe = [point, i, poly];
          dupe_points.push(dupe);
        }
      }
    }

    // Sort elements in descending order based on their indices to
    // prevent future indices from becoming invalid when changes are made.
    dupe_points.sort(function(a, b) {
      return b[1] - a[1]
    })
    // Edit duplicates.
    var prev, next, point, index, p1, p2;
    dupe_points.forEach(function(e, i, ary) {
      point = e[0], index = e[1], poly = e[2];
      prev = poly.points[poly.getPrevI(index)];
      next = poly.points[poly.getNextI(index)];
      p1 = point.add(prev.sub(point).normalize().mul(offset));
      p2 = point.add(next.sub(point).normalize().mul(offset));
      // Insert new points.
      poly.points.splice(index, 1, p1, p2);
      poly.update();
    });
  }

  /**
   * Represents the outline of a shape along with its holes.
   * @typedef MapArea
   * @type {object}
   * @property {Poly} polygon - The polygon defining the exterior of
   *   the shape.
   * @property {Array.<Poly>} holes - The holes of the shape.
   */

  /**
   * Offset the polygons such that there is a `offset` unit buffer
   * between the sides of the outline and around the obstacles. This
   * buffer makes it so that the mesh truly represents the movable area
   * in the map. Assumes vertices defining interior shapes (like the
   * main outline of an enclosed map) are given in CCW order and
   * obstacles are given in CW order.
   * @private
   * @param {Array.<Poly>} polys - The polygons to offset.
   * @param {number} [offset=16] - The amount to offset the polygons
   *   from the movable areas.
   * @return {Array.<MapArea>} - The shapes defining the polygons after
   *   offsetting and merging.
   */
  NavMesh.prototype._offsetPolys = function(parsedMap, offset) {
    // ~= ball radius / 2
    if (typeof offset == 'undefined') offset = 16;

    // Separate interior and exterior walls. The CCW shapes correspond
    // to the interior wall outlines of out map, the CW shapes are walls
    // that were traced on their outside.
    var interior_walls = [];
    var exterior_walls = parsedMap.walls.filter(function(poly, index) {
      if (poly.getOrientation() == "CCW") {
        interior_walls.push(poly);
        return false;
      }
      return true;
    });

    interior_walls = interior_walls.map(this._convertPolyToClipper);
    exterior_walls = exterior_walls.map(this._convertPolyToClipper);

    var scale = 100;
    
    ClipperLib.JS.ScaleUpPaths(interior_walls, scale);
    ClipperLib.JS.ScaleUpPaths(exterior_walls, scale);

    var cpr = new ClipperLib.Clipper();
    var co = new ClipperLib.ClipperOffset();
    co.MiterLimit = 2;
    var wall_fillType = ClipperLib.PolyFillType.pftEvenOdd;
    var obstacle_fillType = ClipperLib.PolyFillType.pftNonZero;

    var offsetted_interior_walls = [];
    // Handle interior walls.
    interior_walls.forEach(function(wall) {
      // First, create a shape with the outline as the interior.
      var boundingShape = this._getBoundingShapeForPaths([wall]);
      //ClipperLib.JS.ScaleUpPath(boundingShape, scale);
      cpr.Clear();
      cpr.AddPath(boundingShape, ClipperLib.PolyType.ptSubject, true);
      cpr.AddPath(wall, ClipperLib.PolyType.ptClip, true);

      var solution_paths = new ClipperLib.Paths();
      cpr.Execute(ClipperLib.ClipType.ctDifference,
        solution_paths,
        ClipperLib.PolyFillType.pftNonZero,
        ClipperLib.PolyFillType.pftNonZero);

      // Once we have the shape as created above, inflate it. This gives
      // better results than treating the outline as the exterior of a
      // shape and deflating it.
      var offsetted_paths = new ClipperLib.Paths();

      co.Clear();
      co.AddPaths(solution_paths, ClipperLib.JoinType.jtSquare, ClipperLib.EndType.etClosedPolygon);
      co.Execute(offsetted_paths, offset * scale);

      // If this is not true then the offsetting process shrank the
      // outline into non-existence and only the bounding shape is
      // left.
      // >= 2 in case the offsetting process isolates portions of the
      // outline (see: GamePad).
      if (offsetted_paths.length >= 2) {
        // Get only the paths defining the outlines we were interested
        // in, discarding the exterior bounding shape.
        offsetted_paths.shift();

        // Reverse paths since from here on we're going to treat the
        // outlines as the exterior of a shape.
        offsetted_paths.forEach(function(path) {
          path.reverse();
        });
        Array.prototype.push.apply(offsetted_interior_walls, offsetted_paths);
      }
    }, this);
    
    // Offset exterior walls.
    var offsetted_exterior_walls = [];

    exterior_walls.forEach(function(wall) {
      var offsetted_exterior_wall = new ClipperLib.Paths();
      co.Clear();
      co.AddPath(wall, ClipperLib.JoinType.jtSquare, ClipperLib.EndType.etClosedPolygon);
      co.Execute(offsetted_exterior_wall, offset * scale);
      offsetted_exterior_walls.push(offsetted_exterior_wall[0]);
    });
    
    // Offset obstacles.
    var offsetted_obstacles = new ClipperLib.Paths();

    var obstacles = parsedMap.obstacles.map(this._convertPolyToClipper);
    ClipperLib.JS.ScaleUpPaths(obstacles, scale);
    co.Clear();
    co.AddPaths(obstacles, ClipperLib.JoinType.jtMiter, ClipperLib.EndType.etClosedPolygon);
    co.Execute(offsetted_obstacles, offset * scale);

    // Take difference of polygons defining interior wall and polygons
    // defining exterior walls, limiting to exterior wall polygons whose
    // area is less than the interior wall polygons so the difference
    // operation doesn't remove potentially traversable areas.
    var merged_paths = [];
    offsetted_interior_walls.forEach(function(wall) {
      var area = ClipperLib.JS.AreaOfPolygon(wall, scale);
      var smaller_exterior_walls = offsetted_exterior_walls.filter(function(ext_wall) {
        return ClipperLib.JS.AreaOfPolygon(ext_wall, scale) < area;
      });
      var paths = new ClipperLib.Paths();
      cpr.Clear();
      cpr.AddPath(wall, ClipperLib.PolyType.ptSubject, true);
      cpr.AddPaths(smaller_exterior_walls, ClipperLib.PolyType.ptClip, true);
      cpr.AddPaths(offsetted_obstacles, ClipperLib.PolyType.ptClip, true);
      cpr.Execute(ClipperLib.ClipType.ctDifference,
        paths,
        ClipperLib.PolyFillType.pftNonZero,
        ClipperLib.PolyFillType.pftNonZero
      );
      Array.prototype.push.apply(merged_paths, paths);
    });

    // Merge everything.
    cpr.Clear();
    cpr.AddPaths(merged_paths, ClipperLib.PolyType.ptSubject, true);
    var unioned_shapes_polytree = new ClipperLib.PolyTree();
    cpr.Execute(ClipperLib.ClipType.ctUnion, unioned_shapes_polytree, wall_fillType, null);

    var polys = new Array();

    /**
     * An area is an interior shape along with its holes, if any.
     */
    var areas = [];

    var outer_polygons = unioned_shapes_polytree.Childs();

    // Organize shapes into their outer polygons and holes.
    for (var i = 0; i < outer_polygons.length; i++) {
      var outer_polygon = outer_polygons[i];
      var contour = outer_polygon.Contour();
      ClipperLib.JS.ScaleDownPath(contour, scale);
      var area = {
        polygon: contour,
        holes: []
      }

      outer_polygon.Childs().forEach(function(child) {
        var contour = child.Contour();
        ClipperLib.JS.ScaleDownPath(child.Contour(), scale);
        // Add as a hole.
        area.holes.push(contour);

        // Add children as additional outer polygons to be expanded.
        child.Childs().forEach(function(child_outer) {
          outer_polygons.push(child_outer);
        });
      });
      areas.push(area);
    }
    
    // Convert Clipper Paths to Polys.
    areas.forEach(function(area) {
      area.polygon = this._convertClipperToPoly(area.polygon);
      area.holes = area.holes.map(this._convertClipperToPoly);
    }, this);

    return areas;
  }

  /**
   * A point in ClipperLib is just an object with properties
   * X and Y corresponding to a point.
   * @typedef CLPoint
   * @type {object}
   * @property {integer} X - The x coordinate of the point.
   * @property {integer} Y - The y coordinate of the point.
   */

  /**
   * A shape in ClipperLib is simply an array of CLPoints.
   * @typedef CLShape
   * @type {Array.<CLPoint>}
   */

  /**
   * Takes a Poly and converts it into a ClipperLib polygon.
   * @private
   * @param {Poly} poly - The Poly to convert.
   * @return {CLShape} - The converted polygon.
   */
  NavMesh.prototype._convertPolyToClipper = function(poly) {
    return poly.points.map(function(p) {
      return {X:p.x, Y:p.y};
    });
  }

  /**
   * Convert a ClipperLib shape into a Poly.
   * @private
   * @param {CLShape} clip - The shape to convert.
   * @return {Poly} - The converted shape.
   */
  NavMesh.prototype._convertClipperToPoly = function(clip) {
    var poly = new Poly();
    poly.init(clip.length);
    poly.points = clip.map(function(p) {
      return new Point(p.X, p.Y);
    });
    return poly;
  }

  /**
   * Generate a bounding shape for paths with a given buffer. If using
   * for an offsetting operation, the returned CLShape does NOT need to
   * be scaled up.
   * @private
   * @param {Array.<CLShape>} paths - The paths to get a bounding shape for.
   * @param {integer} [buffer=5] - How many units to pad the bounding
   *   rectangle.
   * @return {CLShape} - A bounding rectangle for the paths.
   */
  NavMesh.prototype._getBoundingShapeForPaths = function(paths, buffer) {
    if (typeof buffer == "undefined") buffer = 5;
    var bounds = ClipperLib.Clipper.GetBounds(paths);
    bounds.left -= buffer;
    bounds.top -= buffer;
    bounds.right += buffer;
    bounds.bottom += buffer;
    var shape = [];
    shape.push({X: bounds.right, Y: bounds.bottom});
    shape.push({X: bounds.left, Y: bounds.bottom});
    shape.push({X: bounds.left, Y: bounds.top});
    shape.push({X: bounds.right, Y: bounds.top});
    return shape;
  }

  /**
   * Handler for log messages sent by worker.
   * @private
   * @param {Array.<(string|object)>} message - Array of arguments to
   *   pass to `Logger.log`. The first element should be the group to
   *   associate the message with.
   */
  NavMesh.prototype._workerLogger = function(message) {
    this.logger.log.apply(null, message);
  }

  /**
   * Fully initialize listeners for pathfinding web worker.
   * @private
   */
  NavMesh.prototype._workerInit = function() {
    if (this.initialized && this.worker && this.workerInitialized) {
      // Send polygons of navigation mesh to web worker.
      this.worker.postMessage(["polys", this.polys]);
    }

    /**
     * Set up listeners for web worker messages.
     * Messages can have type "log" and "result".
     */
    this.worker.onmessage = function(message) {
      var data = message.data;
      var name = data[0];

      // Omit log messages from worker in debug message.
      if (name !== "log")
        this.logger.log("navmesh:debug", "Message received from worker:", data);

      if (name == "log") {
        this._workerLogger(data.slice(1));
      } else if (name == "result") {
        var path = data[1];

        if (path) {
          // Convert Path back to points.
          path = path.map(function(location) {
            return new Point(location.x, location.y);
          });
          // Remove first entry, which is current position.
          path = path.slice(1);
        }
        this.lastCallback(path);
      }
    }.bind(this)
  }

  return NavMesh;
});

    //The modules for your project will be inlined above
    //this snippet. Ask almond to synchronously require the
    //module value for 'main' here and return it as the
    //value to use for the public API for the built file.
    return require('navmesh');
}));

//# sourceMappingURL=navmesh.min.js.map