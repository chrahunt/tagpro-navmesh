(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.NavMesh = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
; var __browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
// rev 452
/********************************************************************************
 *                                                                              *
 * Author    :  Angus Johnson                                                   *
 * Version   :  6.1.3a                                                          *
 * Date      :  22 January 2014                                                 *
 * Website   :  http://www.angusj.com                                           *
 * Copyright :  Angus Johnson 2010-2014                                         *
 *                                                                              *
 * License:                                                                     *
 * Use, modification & distribution is subject to Boost Software License Ver 1. *
 * http://www.boost.org/LICENSE_1_0.txt                                         *
 *                                                                              *
 * Attributions:                                                                *
 * The code in this library is an extension of Bala Vatti's clipping algorithm: *
 * "A generic solution to polygon clipping"                                     *
 * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *
 * http://portal.acm.org/citation.cfm?id=129906                                 *
 *                                                                              *
 * Computer graphics and geometric modeling: implementation and algorithms      *
 * By Max K. Agoston                                                            *
 * Springer; 1 edition (January 4, 2005)                                        *
 * http://books.google.com/books?q=vatti+clipping+agoston                       *
 *                                                                              *
 * See also:                                                                    *
 * "Polygon Offsetting by Computing Winding Numbers"                            *
 * Paper no. DETC2005-85513 pp. 565-575                                         *
 * ASME 2005 International Design Engineering Technical Conferences             *
 * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *
 * September 24-28, 2005 , Long Beach, California, USA                          *
 * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *
 *                                                                              *
 *******************************************************************************/
/*******************************************************************************
 *                                                                              *
 * Author    :  Timo                                                            *
 * Version   :  6.1.3.2                                                         *
 * Date      :  1 February 2014                                                 *
 *                                                                              *
 * This is a translation of the C# Clipper library to Javascript.               *
 * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *
 * Because Javascript lacks support for 64-bit integers, the space              *
 * is a little more restricted than in C# version.                              *
 *                                                                              *
 * C# version has support for coordinate space:                                 *
 * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *
 * while Javascript version has support for space:                              *
 * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *
 *                                                                              *
 * Tom Wu's JSBN proved to be the fastest big integer library:                  *
 * http://jsperf.com/big-integer-library-test                                   *
 *                                                                              *
 * This class can be made simpler when (if ever) 64-bit integer support comes.  *
 *                                                                              *
 *******************************************************************************/
/*******************************************************************************
 *                                                                              *
 * Basic JavaScript BN library - subset useful for RSA encryption.              *
 * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *
 * Copyright (c) 2005  Tom Wu                                                   *
 * All Rights Reserved.                                                         *
 * See "LICENSE" for details:                                                   *
 * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *
 *                                                                              *
 *******************************************************************************/
(function(){function k(a,b,c){d.biginteger_used=1;null!=a&&("number"==typeof a&&"undefined"==typeof b?this.fromInt(a):"number"==typeof a?this.fromNumber(a,b,c):null==b&&"string"!=typeof a?this.fromString(a,256):this.fromString(a,b))}function q(){return new k(null)}function Q(a,b,c,e,d,g){for(;0<=--g;){var h=b*this[a++]+c[e]+d;d=Math.floor(h/67108864);c[e++]=h&67108863}return d}function R(a,b,c,e,d,g){var h=b&32767;for(b>>=15;0<=--g;){var l=this[a]&32767,k=this[a++]>>15,n=b*l+k*h,l=h*l+((n&32767)<<
15)+c[e]+(d&1073741823);d=(l>>>30)+(n>>>15)+b*k+(d>>>30);c[e++]=l&1073741823}return d}function S(a,b,c,e,d,g){var h=b&16383;for(b>>=14;0<=--g;){var l=this[a]&16383,k=this[a++]>>14,n=b*l+k*h,l=h*l+((n&16383)<<14)+c[e]+d;d=(l>>28)+(n>>14)+b*k;c[e++]=l&268435455}return d}function L(a,b){var c=B[a.charCodeAt(b)];return null==c?-1:c}function v(a){var b=q();b.fromInt(a);return b}function C(a){var b=1,c;0!=(c=a>>>16)&&(a=c,b+=16);0!=(c=a>>8)&&(a=c,b+=8);0!=(c=a>>4)&&(a=c,b+=4);0!=(c=a>>2)&&(a=c,b+=2);0!=
a>>1&&(b+=1);return b}function x(a){this.m=a}function y(a){this.m=a;this.mp=a.invDigit();this.mpl=this.mp&32767;this.mph=this.mp>>15;this.um=(1<<a.DB-15)-1;this.mt2=2*a.t}function T(a,b){return a&b}function I(a,b){return a|b}function M(a,b){return a^b}function N(a,b){return a&~b}function A(){}function O(a){return a}function w(a){this.r2=q();this.q3=q();k.ONE.dlShiftTo(2*a.t,this.r2);this.mu=this.r2.divide(a);this.m=a}var d={},D=!1;"undefined"!==typeof module&&module.exports?(module.exports=d,D=!0):
"undefined"!==typeof document?window.ClipperLib=d:self.ClipperLib=d;var r;if(D)p="chrome",r="Netscape";else{var p=navigator.userAgent.toString().toLowerCase();r=navigator.appName}var E,J,F,G,H,P;E=-1!=p.indexOf("chrome")&&-1==p.indexOf("chromium")?1:0;D=-1!=p.indexOf("chromium")?1:0;J=-1!=p.indexOf("safari")&&-1==p.indexOf("chrome")&&-1==p.indexOf("chromium")?1:0;F=-1!=p.indexOf("firefox")?1:0;p.indexOf("firefox/17");p.indexOf("firefox/15");p.indexOf("firefox/3");G=-1!=p.indexOf("opera")?1:0;p.indexOf("msie 10");
p.indexOf("msie 9");H=-1!=p.indexOf("msie 8")?1:0;P=-1!=p.indexOf("msie 7")?1:0;p=-1!=p.indexOf("msie ")?1:0;d.biginteger_used=null;"Microsoft Internet Explorer"==r?(k.prototype.am=R,r=30):"Netscape"!=r?(k.prototype.am=Q,r=26):(k.prototype.am=S,r=28);k.prototype.DB=r;k.prototype.DM=(1<<r)-1;k.prototype.DV=1<<r;k.prototype.FV=Math.pow(2,52);k.prototype.F1=52-r;k.prototype.F2=2*r-52;var B=[],u;r=48;for(u=0;9>=u;++u)B[r++]=u;r=97;for(u=10;36>u;++u)B[r++]=u;r=65;for(u=10;36>u;++u)B[r++]=u;x.prototype.convert=
function(a){return 0>a.s||0<=a.compareTo(this.m)?a.mod(this.m):a};x.prototype.revert=function(a){return a};x.prototype.reduce=function(a){a.divRemTo(this.m,null,a)};x.prototype.mulTo=function(a,b,c){a.multiplyTo(b,c);this.reduce(c)};x.prototype.sqrTo=function(a,b){a.squareTo(b);this.reduce(b)};y.prototype.convert=function(a){var b=q();a.abs().dlShiftTo(this.m.t,b);b.divRemTo(this.m,null,b);0>a.s&&0<b.compareTo(k.ZERO)&&this.m.subTo(b,b);return b};y.prototype.revert=function(a){var b=q();a.copyTo(b);
this.reduce(b);return b};y.prototype.reduce=function(a){for(;a.t<=this.mt2;)a[a.t++]=0;for(var b=0;b<this.m.t;++b){var c=a[b]&32767,e=c*this.mpl+((c*this.mph+(a[b]>>15)*this.mpl&this.um)<<15)&a.DM,c=b+this.m.t;for(a[c]+=this.m.am(0,e,a,b,0,this.m.t);a[c]>=a.DV;)a[c]-=a.DV,a[++c]++}a.clamp();a.drShiftTo(this.m.t,a);0<=a.compareTo(this.m)&&a.subTo(this.m,a)};y.prototype.mulTo=function(a,b,c){a.multiplyTo(b,c);this.reduce(c)};y.prototype.sqrTo=function(a,b){a.squareTo(b);this.reduce(b)};k.prototype.copyTo=
function(a){for(var b=this.t-1;0<=b;--b)a[b]=this[b];a.t=this.t;a.s=this.s};k.prototype.fromInt=function(a){this.t=1;this.s=0>a?-1:0;0<a?this[0]=a:-1>a?this[0]=a+this.DV:this.t=0};k.prototype.fromString=function(a,b){var c;if(16==b)c=4;else if(8==b)c=3;else if(256==b)c=8;else if(2==b)c=1;else if(32==b)c=5;else if(4==b)c=2;else{this.fromRadix(a,b);return}this.s=this.t=0;for(var e=a.length,d=!1,g=0;0<=--e;){var h=8==c?a[e]&255:L(a,e);0>h?"-"==a.charAt(e)&&(d=!0):(d=!1,0==g?this[this.t++]=h:g+c>this.DB?
(this[this.t-1]|=(h&(1<<this.DB-g)-1)<<g,this[this.t++]=h>>this.DB-g):this[this.t-1]|=h<<g,g+=c,g>=this.DB&&(g-=this.DB))}8==c&&0!=(a[0]&128)&&(this.s=-1,0<g&&(this[this.t-1]|=(1<<this.DB-g)-1<<g));this.clamp();d&&k.ZERO.subTo(this,this)};k.prototype.clamp=function(){for(var a=this.s&this.DM;0<this.t&&this[this.t-1]==a;)--this.t};k.prototype.dlShiftTo=function(a,b){var c;for(c=this.t-1;0<=c;--c)b[c+a]=this[c];for(c=a-1;0<=c;--c)b[c]=0;b.t=this.t+a;b.s=this.s};k.prototype.drShiftTo=function(a,b){for(var c=
a;c<this.t;++c)b[c-a]=this[c];b.t=Math.max(this.t-a,0);b.s=this.s};k.prototype.lShiftTo=function(a,b){var c=a%this.DB,e=this.DB-c,d=(1<<e)-1,g=Math.floor(a/this.DB),h=this.s<<c&this.DM,l;for(l=this.t-1;0<=l;--l)b[l+g+1]=this[l]>>e|h,h=(this[l]&d)<<c;for(l=g-1;0<=l;--l)b[l]=0;b[g]=h;b.t=this.t+g+1;b.s=this.s;b.clamp()};k.prototype.rShiftTo=function(a,b){b.s=this.s;var c=Math.floor(a/this.DB);if(c>=this.t)b.t=0;else{var e=a%this.DB,d=this.DB-e,g=(1<<e)-1;b[0]=this[c]>>e;for(var h=c+1;h<this.t;++h)b[h-
c-1]|=(this[h]&g)<<d,b[h-c]=this[h]>>e;0<e&&(b[this.t-c-1]|=(this.s&g)<<d);b.t=this.t-c;b.clamp()}};k.prototype.subTo=function(a,b){for(var c=0,e=0,d=Math.min(a.t,this.t);c<d;)e+=this[c]-a[c],b[c++]=e&this.DM,e>>=this.DB;if(a.t<this.t){for(e-=a.s;c<this.t;)e+=this[c],b[c++]=e&this.DM,e>>=this.DB;e+=this.s}else{for(e+=this.s;c<a.t;)e-=a[c],b[c++]=e&this.DM,e>>=this.DB;e-=a.s}b.s=0>e?-1:0;-1>e?b[c++]=this.DV+e:0<e&&(b[c++]=e);b.t=c;b.clamp()};k.prototype.multiplyTo=function(a,b){var c=this.abs(),e=
a.abs(),d=c.t;for(b.t=d+e.t;0<=--d;)b[d]=0;for(d=0;d<e.t;++d)b[d+c.t]=c.am(0,e[d],b,d,0,c.t);b.s=0;b.clamp();this.s!=a.s&&k.ZERO.subTo(b,b)};k.prototype.squareTo=function(a){for(var b=this.abs(),c=a.t=2*b.t;0<=--c;)a[c]=0;for(c=0;c<b.t-1;++c){var e=b.am(c,b[c],a,2*c,0,1);(a[c+b.t]+=b.am(c+1,2*b[c],a,2*c+1,e,b.t-c-1))>=b.DV&&(a[c+b.t]-=b.DV,a[c+b.t+1]=1)}0<a.t&&(a[a.t-1]+=b.am(c,b[c],a,2*c,0,1));a.s=0;a.clamp()};k.prototype.divRemTo=function(a,b,c){var e=a.abs();if(!(0>=e.t)){var d=this.abs();if(d.t<
e.t)null!=b&&b.fromInt(0),null!=c&&this.copyTo(c);else{null==c&&(c=q());var g=q(),h=this.s;a=a.s;var l=this.DB-C(e[e.t-1]);0<l?(e.lShiftTo(l,g),d.lShiftTo(l,c)):(e.copyTo(g),d.copyTo(c));e=g.t;d=g[e-1];if(0!=d){var z=d*(1<<this.F1)+(1<e?g[e-2]>>this.F2:0),n=this.FV/z,z=(1<<this.F1)/z,U=1<<this.F2,m=c.t,p=m-e,s=null==b?q():b;g.dlShiftTo(p,s);0<=c.compareTo(s)&&(c[c.t++]=1,c.subTo(s,c));k.ONE.dlShiftTo(e,s);for(s.subTo(g,g);g.t<e;)g[g.t++]=0;for(;0<=--p;){var r=c[--m]==d?this.DM:Math.floor(c[m]*n+(c[m-
1]+U)*z);if((c[m]+=g.am(0,r,c,p,0,e))<r)for(g.dlShiftTo(p,s),c.subTo(s,c);c[m]<--r;)c.subTo(s,c)}null!=b&&(c.drShiftTo(e,b),h!=a&&k.ZERO.subTo(b,b));c.t=e;c.clamp();0<l&&c.rShiftTo(l,c);0>h&&k.ZERO.subTo(c,c)}}}};k.prototype.invDigit=function(){if(1>this.t)return 0;var a=this[0];if(0==(a&1))return 0;var b=a&3,b=b*(2-(a&15)*b)&15,b=b*(2-(a&255)*b)&255,b=b*(2-((a&65535)*b&65535))&65535,b=b*(2-a*b%this.DV)%this.DV;return 0<b?this.DV-b:-b};k.prototype.isEven=function(){return 0==(0<this.t?this[0]&1:this.s)};
k.prototype.exp=function(a,b){if(4294967295<a||1>a)return k.ONE;var c=q(),e=q(),d=b.convert(this),g=C(a)-1;for(d.copyTo(c);0<=--g;)if(b.sqrTo(c,e),0<(a&1<<g))b.mulTo(e,d,c);else var h=c,c=e,e=h;return b.revert(c)};k.prototype.toString=function(a){if(0>this.s)return"-"+this.negate().toString(a);if(16==a)a=4;else if(8==a)a=3;else if(2==a)a=1;else if(32==a)a=5;else if(4==a)a=2;else return this.toRadix(a);var b=(1<<a)-1,c,e=!1,d="",g=this.t,h=this.DB-g*this.DB%a;if(0<g--)for(h<this.DB&&0<(c=this[g]>>
h)&&(e=!0,d="0123456789abcdefghijklmnopqrstuvwxyz".charAt(c));0<=g;)h<a?(c=(this[g]&(1<<h)-1)<<a-h,c|=this[--g]>>(h+=this.DB-a)):(c=this[g]>>(h-=a)&b,0>=h&&(h+=this.DB,--g)),0<c&&(e=!0),e&&(d+="0123456789abcdefghijklmnopqrstuvwxyz".charAt(c));return e?d:"0"};k.prototype.negate=function(){var a=q();k.ZERO.subTo(this,a);return a};k.prototype.abs=function(){return 0>this.s?this.negate():this};k.prototype.compareTo=function(a){var b=this.s-a.s;if(0!=b)return b;var c=this.t,b=c-a.t;if(0!=b)return 0>this.s?
-b:b;for(;0<=--c;)if(0!=(b=this[c]-a[c]))return b;return 0};k.prototype.bitLength=function(){return 0>=this.t?0:this.DB*(this.t-1)+C(this[this.t-1]^this.s&this.DM)};k.prototype.mod=function(a){var b=q();this.abs().divRemTo(a,null,b);0>this.s&&0<b.compareTo(k.ZERO)&&a.subTo(b,b);return b};k.prototype.modPowInt=function(a,b){var c;c=256>a||b.isEven()?new x(b):new y(b);return this.exp(a,c)};k.ZERO=v(0);k.ONE=v(1);A.prototype.convert=O;A.prototype.revert=O;A.prototype.mulTo=function(a,b,c){a.multiplyTo(b,
c)};A.prototype.sqrTo=function(a,b){a.squareTo(b)};w.prototype.convert=function(a){if(0>a.s||a.t>2*this.m.t)return a.mod(this.m);if(0>a.compareTo(this.m))return a;var b=q();a.copyTo(b);this.reduce(b);return b};w.prototype.revert=function(a){return a};w.prototype.reduce=function(a){a.drShiftTo(this.m.t-1,this.r2);a.t>this.m.t+1&&(a.t=this.m.t+1,a.clamp());this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);for(this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);0>a.compareTo(this.r2);)a.dAddOffset(1,
this.m.t+1);for(a.subTo(this.r2,a);0<=a.compareTo(this.m);)a.subTo(this.m,a)};w.prototype.mulTo=function(a,b,c){a.multiplyTo(b,c);this.reduce(c)};w.prototype.sqrTo=function(a,b){a.squareTo(b);this.reduce(b)};var t=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,
409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997],V=67108864/t[t.length-1];k.prototype.chunkSize=function(a){return Math.floor(Math.LN2*this.DB/Math.log(a))};k.prototype.toRadix=function(a){null==
a&&(a=10);if(0==this.signum()||2>a||36<a)return"0";var b=this.chunkSize(a),b=Math.pow(a,b),c=v(b),e=q(),d=q(),g="";for(this.divRemTo(c,e,d);0<e.signum();)g=(b+d.intValue()).toString(a).substr(1)+g,e.divRemTo(c,e,d);return d.intValue().toString(a)+g};k.prototype.fromRadix=function(a,b){this.fromInt(0);null==b&&(b=10);for(var c=this.chunkSize(b),e=Math.pow(b,c),d=!1,g=0,h=0,l=0;l<a.length;++l){var z=L(a,l);0>z?"-"==a.charAt(l)&&0==this.signum()&&(d=!0):(h=b*h+z,++g>=c&&(this.dMultiply(e),this.dAddOffset(h,
0),h=g=0))}0<g&&(this.dMultiply(Math.pow(b,g)),this.dAddOffset(h,0));d&&k.ZERO.subTo(this,this)};k.prototype.fromNumber=function(a,b,c){if("number"==typeof b)if(2>a)this.fromInt(1);else for(this.fromNumber(a,c),this.testBit(a-1)||this.bitwiseTo(k.ONE.shiftLeft(a-1),I,this),this.isEven()&&this.dAddOffset(1,0);!this.isProbablePrime(b);)this.dAddOffset(2,0),this.bitLength()>a&&this.subTo(k.ONE.shiftLeft(a-1),this);else{c=[];var e=a&7;c.length=(a>>3)+1;b.nextBytes(c);c[0]=0<e?c[0]&(1<<e)-1:0;this.fromString(c,
256)}};k.prototype.bitwiseTo=function(a,b,c){var e,d,g=Math.min(a.t,this.t);for(e=0;e<g;++e)c[e]=b(this[e],a[e]);if(a.t<this.t){d=a.s&this.DM;for(e=g;e<this.t;++e)c[e]=b(this[e],d);c.t=this.t}else{d=this.s&this.DM;for(e=g;e<a.t;++e)c[e]=b(d,a[e]);c.t=a.t}c.s=b(this.s,a.s);c.clamp()};k.prototype.changeBit=function(a,b){var c=k.ONE.shiftLeft(a);this.bitwiseTo(c,b,c);return c};k.prototype.addTo=function(a,b){for(var c=0,e=0,d=Math.min(a.t,this.t);c<d;)e+=this[c]+a[c],b[c++]=e&this.DM,e>>=this.DB;if(a.t<
this.t){for(e+=a.s;c<this.t;)e+=this[c],b[c++]=e&this.DM,e>>=this.DB;e+=this.s}else{for(e+=this.s;c<a.t;)e+=a[c],b[c++]=e&this.DM,e>>=this.DB;e+=a.s}b.s=0>e?-1:0;0<e?b[c++]=e:-1>e&&(b[c++]=this.DV+e);b.t=c;b.clamp()};k.prototype.dMultiply=function(a){this[this.t]=this.am(0,a-1,this,0,0,this.t);++this.t;this.clamp()};k.prototype.dAddOffset=function(a,b){if(0!=a){for(;this.t<=b;)this[this.t++]=0;for(this[b]+=a;this[b]>=this.DV;)this[b]-=this.DV,++b>=this.t&&(this[this.t++]=0),++this[b]}};k.prototype.multiplyLowerTo=
function(a,b,c){var e=Math.min(this.t+a.t,b);c.s=0;for(c.t=e;0<e;)c[--e]=0;var d;for(d=c.t-this.t;e<d;++e)c[e+this.t]=this.am(0,a[e],c,e,0,this.t);for(d=Math.min(a.t,b);e<d;++e)this.am(0,a[e],c,e,0,b-e);c.clamp()};k.prototype.multiplyUpperTo=function(a,b,c){--b;var e=c.t=this.t+a.t-b;for(c.s=0;0<=--e;)c[e]=0;for(e=Math.max(b-this.t,0);e<a.t;++e)c[this.t+e-b]=this.am(b-e,a[e],c,0,0,this.t+e-b);c.clamp();c.drShiftTo(1,c)};k.prototype.modInt=function(a){if(0>=a)return 0;var b=this.DV%a,c=0>this.s?a-
1:0;if(0<this.t)if(0==b)c=this[0]%a;else for(var e=this.t-1;0<=e;--e)c=(b*c+this[e])%a;return c};k.prototype.millerRabin=function(a){var b=this.subtract(k.ONE),c=b.getLowestSetBit();if(0>=c)return!1;var e=b.shiftRight(c);a=a+1>>1;a>t.length&&(a=t.length);for(var d=q(),g=0;g<a;++g){d.fromInt(t[Math.floor(Math.random()*t.length)]);var h=d.modPow(e,this);if(0!=h.compareTo(k.ONE)&&0!=h.compareTo(b)){for(var l=1;l++<c&&0!=h.compareTo(b);)if(h=h.modPowInt(2,this),0==h.compareTo(k.ONE))return!1;if(0!=h.compareTo(b))return!1}}return!0};
k.prototype.clone=function(){var a=q();this.copyTo(a);return a};k.prototype.intValue=function(){if(0>this.s){if(1==this.t)return this[0]-this.DV;if(0==this.t)return-1}else{if(1==this.t)return this[0];if(0==this.t)return 0}return(this[1]&(1<<32-this.DB)-1)<<this.DB|this[0]};k.prototype.byteValue=function(){return 0==this.t?this.s:this[0]<<24>>24};k.prototype.shortValue=function(){return 0==this.t?this.s:this[0]<<16>>16};k.prototype.signum=function(){return 0>this.s?-1:0>=this.t||1==this.t&&0>=this[0]?
0:1};k.prototype.toByteArray=function(){var a=this.t,b=[];b[0]=this.s;var c=this.DB-a*this.DB%8,e,d=0;if(0<a--)for(c<this.DB&&(e=this[a]>>c)!=(this.s&this.DM)>>c&&(b[d++]=e|this.s<<this.DB-c);0<=a;)if(8>c?(e=(this[a]&(1<<c)-1)<<8-c,e|=this[--a]>>(c+=this.DB-8)):(e=this[a]>>(c-=8)&255,0>=c&&(c+=this.DB,--a)),0!=(e&128)&&(e|=-256),0==d&&(this.s&128)!=(e&128)&&++d,0<d||e!=this.s)b[d++]=e;return b};k.prototype.equals=function(a){return 0==this.compareTo(a)};k.prototype.min=function(a){return 0>this.compareTo(a)?
this:a};k.prototype.max=function(a){return 0<this.compareTo(a)?this:a};k.prototype.and=function(a){var b=q();this.bitwiseTo(a,T,b);return b};k.prototype.or=function(a){var b=q();this.bitwiseTo(a,I,b);return b};k.prototype.xor=function(a){var b=q();this.bitwiseTo(a,M,b);return b};k.prototype.andNot=function(a){var b=q();this.bitwiseTo(a,N,b);return b};k.prototype.not=function(){for(var a=q(),b=0;b<this.t;++b)a[b]=this.DM&~this[b];a.t=this.t;a.s=~this.s;return a};k.prototype.shiftLeft=function(a){var b=
q();0>a?this.rShiftTo(-a,b):this.lShiftTo(a,b);return b};k.prototype.shiftRight=function(a){var b=q();0>a?this.lShiftTo(-a,b):this.rShiftTo(a,b);return b};k.prototype.getLowestSetBit=function(){for(var a=0;a<this.t;++a)if(0!=this[a]){var b=a*this.DB;a=this[a];if(0==a)a=-1;else{var c=0;0==(a&65535)&&(a>>=16,c+=16);0==(a&255)&&(a>>=8,c+=8);0==(a&15)&&(a>>=4,c+=4);0==(a&3)&&(a>>=2,c+=2);0==(a&1)&&++c;a=c}return b+a}return 0>this.s?this.t*this.DB:-1};k.prototype.bitCount=function(){for(var a=0,b=this.s&
this.DM,c=0;c<this.t;++c){for(var e=this[c]^b,d=0;0!=e;)e&=e-1,++d;a+=d}return a};k.prototype.testBit=function(a){var b=Math.floor(a/this.DB);return b>=this.t?0!=this.s:0!=(this[b]&1<<a%this.DB)};k.prototype.setBit=function(a){return this.changeBit(a,I)};k.prototype.clearBit=function(a){return this.changeBit(a,N)};k.prototype.flipBit=function(a){return this.changeBit(a,M)};k.prototype.add=function(a){var b=q();this.addTo(a,b);return b};k.prototype.subtract=function(a){var b=q();this.subTo(a,b);return b};
k.prototype.multiply=function(a){var b=q();this.multiplyTo(a,b);return b};k.prototype.divide=function(a){var b=q();this.divRemTo(a,b,null);return b};k.prototype.remainder=function(a){var b=q();this.divRemTo(a,null,b);return b};k.prototype.divideAndRemainder=function(a){var b=q(),c=q();this.divRemTo(a,b,c);return[b,c]};k.prototype.modPow=function(a,b){var c=a.bitLength(),e,d=v(1),g;if(0>=c)return d;e=18>c?1:48>c?3:144>c?4:768>c?5:6;g=8>c?new x(b):b.isEven()?new w(b):new y(b);var h=[],l=3,k=e-1,n=(1<<
e)-1;h[1]=g.convert(this);if(1<e)for(c=q(),g.sqrTo(h[1],c);l<=n;)h[l]=q(),g.mulTo(c,h[l-2],h[l]),l+=2;for(var m=a.t-1,p,r=!0,s=q(),c=C(a[m])-1;0<=m;){c>=k?p=a[m]>>c-k&n:(p=(a[m]&(1<<c+1)-1)<<k-c,0<m&&(p|=a[m-1]>>this.DB+c-k));for(l=e;0==(p&1);)p>>=1,--l;0>(c-=l)&&(c+=this.DB,--m);if(r)h[p].copyTo(d),r=!1;else{for(;1<l;)g.sqrTo(d,s),g.sqrTo(s,d),l-=2;0<l?g.sqrTo(d,s):(l=d,d=s,s=l);g.mulTo(s,h[p],d)}for(;0<=m&&0==(a[m]&1<<c);)g.sqrTo(d,s),l=d,d=s,s=l,0>--c&&(c=this.DB-1,--m)}return g.revert(d)};k.prototype.modInverse=
function(a){var b=a.isEven();if(this.isEven()&&b||0==a.signum())return k.ZERO;for(var c=a.clone(),e=this.clone(),d=v(1),g=v(0),h=v(0),l=v(1);0!=c.signum();){for(;c.isEven();)c.rShiftTo(1,c),b?(d.isEven()&&g.isEven()||(d.addTo(this,d),g.subTo(a,g)),d.rShiftTo(1,d)):g.isEven()||g.subTo(a,g),g.rShiftTo(1,g);for(;e.isEven();)e.rShiftTo(1,e),b?(h.isEven()&&l.isEven()||(h.addTo(this,h),l.subTo(a,l)),h.rShiftTo(1,h)):l.isEven()||l.subTo(a,l),l.rShiftTo(1,l);0<=c.compareTo(e)?(c.subTo(e,c),b&&d.subTo(h,d),
g.subTo(l,g)):(e.subTo(c,e),b&&h.subTo(d,h),l.subTo(g,l))}if(0!=e.compareTo(k.ONE))return k.ZERO;if(0<=l.compareTo(a))return l.subtract(a);if(0>l.signum())l.addTo(a,l);else return l;return 0>l.signum()?l.add(a):l};k.prototype.pow=function(a){return this.exp(a,new A)};k.prototype.gcd=function(a){var b=0>this.s?this.negate():this.clone();a=0>a.s?a.negate():a.clone();if(0>b.compareTo(a)){var c=b,b=a;a=c}var c=b.getLowestSetBit(),e=a.getLowestSetBit();if(0>e)return b;c<e&&(e=c);0<e&&(b.rShiftTo(e,b),
a.rShiftTo(e,a));for(;0<b.signum();)0<(c=b.getLowestSetBit())&&b.rShiftTo(c,b),0<(c=a.getLowestSetBit())&&a.rShiftTo(c,a),0<=b.compareTo(a)?(b.subTo(a,b),b.rShiftTo(1,b)):(a.subTo(b,a),a.rShiftTo(1,a));0<e&&a.lShiftTo(e,a);return a};k.prototype.isProbablePrime=function(a){var b,c=this.abs();if(1==c.t&&c[0]<=t[t.length-1]){for(b=0;b<t.length;++b)if(c[0]==t[b])return!0;return!1}if(c.isEven())return!1;for(b=1;b<t.length;){for(var e=t[b],d=b+1;d<t.length&&e<V;)e*=t[d++];for(e=c.modInt(e);b<d;)if(0==e%
t[b++])return!1}return c.millerRabin(a)};k.prototype.square=function(){var a=q();this.squareTo(a);return a};var m=k;m.prototype.IsNegative=function(){return-1==this.compareTo(m.ZERO)?!0:!1};m.op_Equality=function(a,b){return 0==a.compareTo(b)?!0:!1};m.op_Inequality=function(a,b){return 0!=a.compareTo(b)?!0:!1};m.op_GreaterThan=function(a,b){return 0<a.compareTo(b)?!0:!1};m.op_LessThan=function(a,b){return 0>a.compareTo(b)?!0:!1};m.op_Addition=function(a,b){return(new m(a)).add(new m(b))};m.op_Subtraction=
function(a,b){return(new m(a)).subtract(new m(b))};m.Int128Mul=function(a,b){return(new m(a)).multiply(new m(b))};m.op_Division=function(a,b){return a.divide(b)};m.prototype.ToDouble=function(){return parseFloat(this.toString())};if("undefined"==typeof K)var K=function(a,b){var c;if("undefined"==typeof Object.getOwnPropertyNames)for(c in b.prototype){if("undefined"==typeof a.prototype[c]||a.prototype[c]==Object.prototype[c])a.prototype[c]=b.prototype[c]}else for(var e=Object.getOwnPropertyNames(b.prototype),
d=0;d<e.length;d++)"undefined"==typeof Object.getOwnPropertyDescriptor(a.prototype,e[d])&&Object.defineProperty(a.prototype,e[d],Object.getOwnPropertyDescriptor(b.prototype,e[d]));for(c in b)"undefined"==typeof a[c]&&(a[c]=b[c]);a.$baseCtor=b};d.Path=function(){return[]};d.Paths=function(){return[]};d.DoublePoint=function(){var a=arguments;this.Y=this.X=0;1==a.length?(this.X=a[0].X,this.Y=a[0].Y):2==a.length&&(this.X=a[0],this.Y=a[1])};d.DoublePoint0=function(){this.Y=this.X=0};d.DoublePoint1=function(a){this.X=
a.X;this.Y=a.Y};d.DoublePoint2=function(a,b){this.X=a;this.Y=b};d.PolyNode=function(){this.m_Parent=null;this.m_polygon=new d.Path;this.m_endtype=this.m_jointype=this.m_Index=0;this.m_Childs=[];this.IsOpen=!1};d.PolyNode.prototype.IsHoleNode=function(){for(var a=!0,b=this.m_Parent;null!==b;)a=!a,b=b.m_Parent;return a};d.PolyNode.prototype.ChildCount=function(){return this.m_Childs.length};d.PolyNode.prototype.Contour=function(){return this.m_polygon};d.PolyNode.prototype.AddChild=function(a){var b=
this.m_Childs.length;this.m_Childs.push(a);a.m_Parent=this;a.m_Index=b};d.PolyNode.prototype.GetNext=function(){return 0<this.m_Childs.length?this.m_Childs[0]:this.GetNextSiblingUp()};d.PolyNode.prototype.GetNextSiblingUp=function(){return null===this.m_Parent?null:this.m_Index==this.m_Parent.m_Childs.length-1?this.m_Parent.GetNextSiblingUp():this.m_Parent.m_Childs[this.m_Index+1]};d.PolyNode.prototype.Childs=function(){return this.m_Childs};d.PolyNode.prototype.Parent=function(){return this.m_Parent};
d.PolyNode.prototype.IsHole=function(){return this.IsHoleNode()};d.PolyTree=function(){this.m_AllPolys=[];d.PolyNode.call(this)};d.PolyTree.prototype.Clear=function(){for(var a=0,b=this.m_AllPolys.length;a<b;a++)this.m_AllPolys[a]=null;this.m_AllPolys.length=0;this.m_Childs.length=0};d.PolyTree.prototype.GetFirst=function(){return 0<this.m_Childs.length?this.m_Childs[0]:null};d.PolyTree.prototype.Total=function(){return this.m_AllPolys.length};K(d.PolyTree,d.PolyNode);d.Math_Abs_Int64=d.Math_Abs_Int32=
d.Math_Abs_Double=function(a){return Math.abs(a)};d.Math_Max_Int32_Int32=function(a,b){return Math.max(a,b)};d.Cast_Int32=p||G||J?function(a){return a|0}:function(a){return~~a};d.Cast_Int64=E?function(a){return-2147483648>a||2147483647<a?0>a?Math.ceil(a):Math.floor(a):~~a}:F&&"function"==typeof Number.toInteger?function(a){return Number.toInteger(a)}:P||H?function(a){return parseInt(a,10)}:p?function(a){return-2147483648>a||2147483647<a?0>a?Math.ceil(a):Math.floor(a):a|0}:function(a){return 0>a?Math.ceil(a):
Math.floor(a)};d.Clear=function(a){a.length=0};d.PI=3.141592653589793;d.PI2=6.283185307179586;d.IntPoint=function(){var a;a=arguments;var b=a.length;this.Y=this.X=0;2==b?(this.X=a[0],this.Y=a[1]):1==b?a[0]instanceof d.DoublePoint?(a=a[0],this.X=d.Clipper.Round(a.X),this.Y=d.Clipper.Round(a.Y)):(a=a[0],this.X=a.X,this.Y=a.Y):this.Y=this.X=0};d.IntPoint.op_Equality=function(a,b){return a.X==b.X&&a.Y==b.Y};d.IntPoint.op_Inequality=function(a,b){return a.X!=b.X||a.Y!=b.Y};d.IntPoint0=function(){this.Y=
this.X=0};d.IntPoint1=function(a){this.X=a.X;this.Y=a.Y};d.IntPoint1dp=function(a){this.X=d.Clipper.Round(a.X);this.Y=d.Clipper.Round(a.Y)};d.IntPoint2=function(a,b){this.X=a;this.Y=b};d.IntRect=function(){var a=arguments,b=a.length;4==b?(this.left=a[0],this.top=a[1],this.right=a[2],this.bottom=a[3]):1==b?(this.left=ir.left,this.top=ir.top,this.right=ir.right,this.bottom=ir.bottom):this.bottom=this.right=this.top=this.left=0};d.IntRect0=function(){this.bottom=this.right=this.top=this.left=0};d.IntRect1=
function(a){this.left=a.left;this.top=a.top;this.right=a.right;this.bottom=a.bottom};d.IntRect4=function(a,b,c,e){this.left=a;this.top=b;this.right=c;this.bottom=e};d.ClipType={ctIntersection:0,ctUnion:1,ctDifference:2,ctXor:3};d.PolyType={ptSubject:0,ptClip:1};d.PolyFillType={pftEvenOdd:0,pftNonZero:1,pftPositive:2,pftNegative:3};d.JoinType={jtSquare:0,jtRound:1,jtMiter:2};d.EndType={etOpenSquare:0,etOpenRound:1,etOpenButt:2,etClosedLine:3,etClosedPolygon:4};d.EdgeSide={esLeft:0,esRight:1};d.Direction=
{dRightToLeft:0,dLeftToRight:1};d.TEdge=function(){this.Bot=new d.IntPoint;this.Curr=new d.IntPoint;this.Top=new d.IntPoint;this.Delta=new d.IntPoint;this.Dx=0;this.PolyTyp=d.PolyType.ptSubject;this.Side=d.EdgeSide.esLeft;this.OutIdx=this.WindCnt2=this.WindCnt=this.WindDelta=0;this.PrevInSEL=this.NextInSEL=this.PrevInAEL=this.NextInAEL=this.NextInLML=this.Prev=this.Next=null};d.IntersectNode=function(){this.Edge2=this.Edge1=null;this.Pt=new d.IntPoint};d.MyIntersectNodeSort=function(){};d.MyIntersectNodeSort.Compare=
function(a,b){return b.Pt.Y-a.Pt.Y};d.LocalMinima=function(){this.Y=0;this.Next=this.RightBound=this.LeftBound=null};d.Scanbeam=function(){this.Y=0;this.Next=null};d.OutRec=function(){this.Idx=0;this.IsOpen=this.IsHole=!1;this.PolyNode=this.BottomPt=this.Pts=this.FirstLeft=null};d.OutPt=function(){this.Idx=0;this.Pt=new d.IntPoint;this.Prev=this.Next=null};d.Join=function(){this.OutPt2=this.OutPt1=null;this.OffPt=new d.IntPoint};d.ClipperBase=function(){this.m_CurrentLM=this.m_MinimaList=null;this.m_edges=
[];this.PreserveCollinear=this.m_HasOpenPaths=this.m_UseFullRange=!1;this.m_CurrentLM=this.m_MinimaList=null;this.m_HasOpenPaths=this.m_UseFullRange=!1};d.ClipperBase.horizontal=-9007199254740992;d.ClipperBase.Skip=-2;d.ClipperBase.Unassigned=-1;d.ClipperBase.tolerance=1E-20;d.ClipperBase.loRange=47453132;d.ClipperBase.hiRange=0xfffffffffffff;d.ClipperBase.near_zero=function(a){return a>-d.ClipperBase.tolerance&&a<d.ClipperBase.tolerance};d.ClipperBase.IsHorizontal=function(a){return 0===a.Delta.Y};
d.ClipperBase.prototype.PointIsVertex=function(a,b){var c=b;do{if(d.IntPoint.op_Equality(c.Pt,a))return!0;c=c.Next}while(c!=b);return!1};d.ClipperBase.prototype.PointOnLineSegment=function(a,b,c,e){return e?a.X==b.X&&a.Y==b.Y||a.X==c.X&&a.Y==c.Y||a.X>b.X==a.X<c.X&&a.Y>b.Y==a.Y<c.Y&&m.op_Equality(m.Int128Mul(a.X-b.X,c.Y-b.Y),m.Int128Mul(c.X-b.X,a.Y-b.Y)):a.X==b.X&&a.Y==b.Y||a.X==c.X&&a.Y==c.Y||a.X>b.X==a.X<c.X&&a.Y>b.Y==a.Y<c.Y&&(a.X-b.X)*(c.Y-b.Y)==(c.X-b.X)*(a.Y-b.Y)};d.ClipperBase.prototype.PointOnPolygon=
function(a,b,c){for(var e=b;;){if(this.PointOnLineSegment(a,e.Pt,e.Next.Pt,c))return!0;e=e.Next;if(e==b)break}return!1};d.ClipperBase.prototype.SlopesEqual=d.ClipperBase.SlopesEqual=function(){var a=arguments,b=a.length,c,e,f;if(3==b)return b=a[0],c=a[1],(a=a[2])?m.op_Equality(m.Int128Mul(b.Delta.Y,c.Delta.X),m.Int128Mul(b.Delta.X,c.Delta.Y)):d.Cast_Int64(b.Delta.Y*c.Delta.X)==d.Cast_Int64(b.Delta.X*c.Delta.Y);if(4==b)return b=a[0],c=a[1],e=a[2],(a=a[3])?m.op_Equality(m.Int128Mul(b.Y-c.Y,c.X-e.X),
m.Int128Mul(b.X-c.X,c.Y-e.Y)):0===d.Cast_Int64((b.Y-c.Y)*(c.X-e.X))-d.Cast_Int64((b.X-c.X)*(c.Y-e.Y));b=a[0];c=a[1];e=a[2];f=a[3];return(a=a[4])?m.op_Equality(m.Int128Mul(b.Y-c.Y,e.X-f.X),m.Int128Mul(b.X-c.X,e.Y-f.Y)):0===d.Cast_Int64((b.Y-c.Y)*(e.X-f.X))-d.Cast_Int64((b.X-c.X)*(e.Y-f.Y))};d.ClipperBase.SlopesEqual3=function(a,b,c){return c?m.op_Equality(m.Int128Mul(a.Delta.Y,b.Delta.X),m.Int128Mul(a.Delta.X,b.Delta.Y)):d.Cast_Int64(a.Delta.Y*b.Delta.X)==d.Cast_Int64(a.Delta.X*b.Delta.Y)};d.ClipperBase.SlopesEqual4=
function(a,b,c,e){return e?m.op_Equality(m.Int128Mul(a.Y-b.Y,b.X-c.X),m.Int128Mul(a.X-b.X,b.Y-c.Y)):0===d.Cast_Int64((a.Y-b.Y)*(b.X-c.X))-d.Cast_Int64((a.X-b.X)*(b.Y-c.Y))};d.ClipperBase.SlopesEqual5=function(a,b,c,e,f){return f?m.op_Equality(m.Int128Mul(a.Y-b.Y,c.X-e.X),m.Int128Mul(a.X-b.X,c.Y-e.Y)):0===d.Cast_Int64((a.Y-b.Y)*(c.X-e.X))-d.Cast_Int64((a.X-b.X)*(c.Y-e.Y))};d.ClipperBase.prototype.Clear=function(){this.DisposeLocalMinimaList();for(var a=0,b=this.m_edges.length;a<b;++a){for(var c=0,
e=this.m_edges[a].length;c<e;++c)this.m_edges[a][c]=null;d.Clear(this.m_edges[a])}d.Clear(this.m_edges);this.m_HasOpenPaths=this.m_UseFullRange=!1};d.ClipperBase.prototype.DisposeLocalMinimaList=function(){for(;null!==this.m_MinimaList;){var a=this.m_MinimaList.Next;this.m_MinimaList=null;this.m_MinimaList=a}this.m_CurrentLM=null};d.ClipperBase.prototype.RangeTest=function(a,b){if(b.Value)(a.X>d.ClipperBase.hiRange||a.Y>d.ClipperBase.hiRange||-a.X>d.ClipperBase.hiRange||-a.Y>d.ClipperBase.hiRange)&&
d.Error("Coordinate outside allowed range in RangeTest().");else if(a.X>d.ClipperBase.loRange||a.Y>d.ClipperBase.loRange||-a.X>d.ClipperBase.loRange||-a.Y>d.ClipperBase.loRange)b.Value=!0,this.RangeTest(a,b)};d.ClipperBase.prototype.InitEdge=function(a,b,c,e){a.Next=b;a.Prev=c;a.Curr.X=e.X;a.Curr.Y=e.Y;a.OutIdx=-1};d.ClipperBase.prototype.InitEdge2=function(a,b){a.Curr.Y>=a.Next.Curr.Y?(a.Bot.X=a.Curr.X,a.Bot.Y=a.Curr.Y,a.Top.X=a.Next.Curr.X,a.Top.Y=a.Next.Curr.Y):(a.Top.X=a.Curr.X,a.Top.Y=a.Curr.Y,
a.Bot.X=a.Next.Curr.X,a.Bot.Y=a.Next.Curr.Y);this.SetDx(a);a.PolyTyp=b};d.ClipperBase.prototype.FindNextLocMin=function(a){for(var b;;){for(;d.IntPoint.op_Inequality(a.Bot,a.Prev.Bot)||d.IntPoint.op_Equality(a.Curr,a.Top);)a=a.Next;if(a.Dx!=d.ClipperBase.horizontal&&a.Prev.Dx!=d.ClipperBase.horizontal)break;for(;a.Prev.Dx==d.ClipperBase.horizontal;)a=a.Prev;for(b=a;a.Dx==d.ClipperBase.horizontal;)a=a.Next;if(a.Top.Y!=a.Prev.Bot.Y){b.Prev.Bot.X<a.Bot.X&&(a=b);break}}return a};d.ClipperBase.prototype.ProcessBound=
function(a,b){var c=a,e=a,f;a.Dx==d.ClipperBase.horizontal&&(f=b?a.Prev.Bot.X:a.Next.Bot.X,a.Bot.X!=f&&this.ReverseHorizontal(a));if(e.OutIdx!=d.ClipperBase.Skip)if(b){for(;e.Top.Y==e.Next.Bot.Y&&e.Next.OutIdx!=d.ClipperBase.Skip;)e=e.Next;if(e.Dx==d.ClipperBase.horizontal&&e.Next.OutIdx!=d.ClipperBase.Skip){for(f=e;f.Prev.Dx==d.ClipperBase.horizontal;)f=f.Prev;f.Prev.Top.X==e.Next.Top.X?b||(e=f.Prev):f.Prev.Top.X>e.Next.Top.X&&(e=f.Prev)}for(;a!=e;)a.NextInLML=a.Next,a.Dx==d.ClipperBase.horizontal&&
a!=c&&a.Bot.X!=a.Prev.Top.X&&this.ReverseHorizontal(a),a=a.Next;a.Dx==d.ClipperBase.horizontal&&a!=c&&a.Bot.X!=a.Prev.Top.X&&this.ReverseHorizontal(a);e=e.Next}else{for(;e.Top.Y==e.Prev.Bot.Y&&e.Prev.OutIdx!=d.ClipperBase.Skip;)e=e.Prev;if(e.Dx==d.ClipperBase.horizontal&&e.Prev.OutIdx!=d.ClipperBase.Skip){for(f=e;f.Next.Dx==d.ClipperBase.horizontal;)f=f.Next;f.Next.Top.X==e.Prev.Top.X?b||(e=f.Next):f.Next.Top.X>e.Prev.Top.X&&(e=f.Next)}for(;a!=e;)a.NextInLML=a.Prev,a.Dx==d.ClipperBase.horizontal&&
a!=c&&a.Bot.X!=a.Next.Top.X&&this.ReverseHorizontal(a),a=a.Prev;a.Dx==d.ClipperBase.horizontal&&a!=c&&a.Bot.X!=a.Next.Top.X&&this.ReverseHorizontal(a);e=e.Prev}if(e.OutIdx==d.ClipperBase.Skip){a=e;if(b){for(;a.Top.Y==a.Next.Bot.Y;)a=a.Next;for(;a!=e&&a.Dx==d.ClipperBase.horizontal;)a=a.Prev}else{for(;a.Top.Y==a.Prev.Bot.Y;)a=a.Prev;for(;a!=e&&a.Dx==d.ClipperBase.horizontal;)a=a.Next}a==e?e=b?a.Next:a.Prev:(a=b?e.Next:e.Prev,c=new d.LocalMinima,c.Next=null,c.Y=a.Bot.Y,c.LeftBound=null,c.RightBound=
a,c.RightBound.WindDelta=0,e=this.ProcessBound(c.RightBound,b),this.InsertLocalMinima(c))}return e};d.ClipperBase.prototype.AddPath=function(a,b,c){c||b!=d.PolyType.ptClip||d.Error("AddPath: Open paths must be subject.");var e=a.length-1;if(c)for(;0<e&&d.IntPoint.op_Equality(a[e],a[0]);)--e;for(;0<e&&d.IntPoint.op_Equality(a[e],a[e-1]);)--e;if(c&&2>e||!c&&1>e)return!1;for(var f=[],g=0;g<=e;g++)f.push(new d.TEdge);var h=!0;f[1].Curr.X=a[1].X;f[1].Curr.Y=a[1].Y;var l={Value:this.m_UseFullRange};this.RangeTest(a[0],
l);this.m_UseFullRange=l.Value;l.Value=this.m_UseFullRange;this.RangeTest(a[e],l);this.m_UseFullRange=l.Value;this.InitEdge(f[0],f[1],f[e],a[0]);this.InitEdge(f[e],f[0],f[e-1],a[e]);for(g=e-1;1<=g;--g)l.Value=this.m_UseFullRange,this.RangeTest(a[g],l),this.m_UseFullRange=l.Value,this.InitEdge(f[g],f[g+1],f[g-1],a[g]);for(g=a=e=f[0];;)if(d.IntPoint.op_Equality(a.Curr,a.Next.Curr)){if(a==a.Next)break;a==e&&(e=a.Next);g=a=this.RemoveEdge(a)}else{if(a.Prev==a.Next)break;else if(c&&d.ClipperBase.SlopesEqual(a.Prev.Curr,
a.Curr,a.Next.Curr,this.m_UseFullRange)&&(!this.PreserveCollinear||!this.Pt2IsBetweenPt1AndPt3(a.Prev.Curr,a.Curr,a.Next.Curr))){a==e&&(e=a.Next);a=this.RemoveEdge(a);g=a=a.Prev;continue}a=a.Next;if(a==g)break}if(!c&&a==a.Next||c&&a.Prev==a.Next)return!1;c||(this.m_HasOpenPaths=!0,e.Prev.OutIdx=d.ClipperBase.Skip);a=e;do this.InitEdge2(a,b),a=a.Next,h&&a.Curr.Y!=e.Curr.Y&&(h=!1);while(a!=e);if(h){if(c)return!1;a.Prev.OutIdx=d.ClipperBase.Skip;a.Prev.Bot.X<a.Prev.Top.X&&this.ReverseHorizontal(a.Prev);
b=new d.LocalMinima;b.Next=null;b.Y=a.Bot.Y;b.LeftBound=null;b.RightBound=a;b.RightBound.Side=d.EdgeSide.esRight;for(b.RightBound.WindDelta=0;a.Next.OutIdx!=d.ClipperBase.Skip;)a.NextInLML=a.Next,a.Bot.X!=a.Prev.Top.X&&this.ReverseHorizontal(a),a=a.Next;this.InsertLocalMinima(b);this.m_edges.push(f);return!0}this.m_edges.push(f);for(h=null;;){a=this.FindNextLocMin(a);if(a==h)break;else null==h&&(h=a);b=new d.LocalMinima;b.Next=null;b.Y=a.Bot.Y;a.Dx<a.Prev.Dx?(b.LeftBound=a.Prev,b.RightBound=a,f=!1):
(b.LeftBound=a,b.RightBound=a.Prev,f=!0);b.LeftBound.Side=d.EdgeSide.esLeft;b.RightBound.Side=d.EdgeSide.esRight;b.LeftBound.WindDelta=c?b.LeftBound.Next==b.RightBound?-1:1:0;b.RightBound.WindDelta=-b.LeftBound.WindDelta;a=this.ProcessBound(b.LeftBound,f);e=this.ProcessBound(b.RightBound,!f);b.LeftBound.OutIdx==d.ClipperBase.Skip?b.LeftBound=null:b.RightBound.OutIdx==d.ClipperBase.Skip&&(b.RightBound=null);this.InsertLocalMinima(b);f||(a=e)}return!0};d.ClipperBase.prototype.AddPaths=function(a,b,
c){for(var e=!1,d=0,g=a.length;d<g;++d)this.AddPath(a[d],b,c)&&(e=!0);return e};d.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3=function(a,b,c){return d.IntPoint.op_Equality(a,c)||d.IntPoint.op_Equality(a,b)||d.IntPoint.op_Equality(c,b)?!1:a.X!=c.X?b.X>a.X==b.X<c.X:b.Y>a.Y==b.Y<c.Y};d.ClipperBase.prototype.RemoveEdge=function(a){a.Prev.Next=a.Next;a.Next.Prev=a.Prev;var b=a.Next;a.Prev=null;return b};d.ClipperBase.prototype.SetDx=function(a){a.Delta.X=a.Top.X-a.Bot.X;a.Delta.Y=a.Top.Y-a.Bot.Y;a.Dx=
0===a.Delta.Y?d.ClipperBase.horizontal:a.Delta.X/a.Delta.Y};d.ClipperBase.prototype.InsertLocalMinima=function(a){if(null===this.m_MinimaList)this.m_MinimaList=a;else if(a.Y>=this.m_MinimaList.Y)a.Next=this.m_MinimaList,this.m_MinimaList=a;else{for(var b=this.m_MinimaList;null!==b.Next&&a.Y<b.Next.Y;)b=b.Next;a.Next=b.Next;b.Next=a}};d.ClipperBase.prototype.PopLocalMinima=function(){null!==this.m_CurrentLM&&(this.m_CurrentLM=this.m_CurrentLM.Next)};d.ClipperBase.prototype.ReverseHorizontal=function(a){var b=
a.Top.X;a.Top.X=a.Bot.X;a.Bot.X=b};d.ClipperBase.prototype.Reset=function(){this.m_CurrentLM=this.m_MinimaList;if(null!=this.m_CurrentLM)for(var a=this.m_MinimaList;null!=a;){var b=a.LeftBound;null!=b&&(b.Curr.X=b.Bot.X,b.Curr.Y=b.Bot.Y,b.Side=d.EdgeSide.esLeft,b.OutIdx=d.ClipperBase.Unassigned);b=a.RightBound;null!=b&&(b.Curr.X=b.Bot.X,b.Curr.Y=b.Bot.Y,b.Side=d.EdgeSide.esRight,b.OutIdx=d.ClipperBase.Unassigned);a=a.Next}};d.Clipper=function(a){"undefined"==typeof a&&(a=0);this.m_PolyOuts=null;this.m_ClipType=
d.ClipType.ctIntersection;this.m_IntersectNodeComparer=this.m_IntersectList=this.m_SortedEdges=this.m_ActiveEdges=this.m_Scanbeam=null;this.m_ExecuteLocked=!1;this.m_SubjFillType=this.m_ClipFillType=d.PolyFillType.pftEvenOdd;this.m_GhostJoins=this.m_Joins=null;this.StrictlySimple=this.ReverseSolution=this.m_UsingPolyTree=!1;d.ClipperBase.call(this);this.m_SortedEdges=this.m_ActiveEdges=this.m_Scanbeam=null;this.m_IntersectList=[];this.m_IntersectNodeComparer=d.MyIntersectNodeSort.Compare;this.m_UsingPolyTree=
this.m_ExecuteLocked=!1;this.m_PolyOuts=[];this.m_Joins=[];this.m_GhostJoins=[];this.ReverseSolution=0!==(1&a);this.StrictlySimple=0!==(2&a);this.PreserveCollinear=0!==(4&a)};d.Clipper.ioReverseSolution=1;d.Clipper.ioStrictlySimple=2;d.Clipper.ioPreserveCollinear=4;d.Clipper.prototype.Clear=function(){0!==this.m_edges.length&&(this.DisposeAllPolyPts(),d.ClipperBase.prototype.Clear.call(this))};d.Clipper.prototype.DisposeScanbeamList=function(){for(;null!==this.m_Scanbeam;){var a=this.m_Scanbeam.Next;
this.m_Scanbeam=null;this.m_Scanbeam=a}};d.Clipper.prototype.Reset=function(){d.ClipperBase.prototype.Reset.call(this);this.m_SortedEdges=this.m_ActiveEdges=this.m_Scanbeam=null;for(var a=this.m_MinimaList;null!==a;)this.InsertScanbeam(a.Y),a=a.Next};d.Clipper.prototype.InsertScanbeam=function(a){if(null===this.m_Scanbeam)this.m_Scanbeam=new d.Scanbeam,this.m_Scanbeam.Next=null,this.m_Scanbeam.Y=a;else if(a>this.m_Scanbeam.Y){var b=new d.Scanbeam;b.Y=a;b.Next=this.m_Scanbeam;this.m_Scanbeam=b}else{for(var c=
this.m_Scanbeam;null!==c.Next&&a<=c.Next.Y;)c=c.Next;a!=c.Y&&(b=new d.Scanbeam,b.Y=a,b.Next=c.Next,c.Next=b)}};d.Clipper.prototype.Execute=function(){var a=arguments,b=a.length,c=a[1]instanceof d.PolyTree;if(4!=b||c){if(4==b&&c){var b=a[0],e=a[1],c=a[2],a=a[3];if(this.m_ExecuteLocked)return!1;this.m_ExecuteLocked=!0;this.m_SubjFillType=c;this.m_ClipFillType=a;this.m_ClipType=b;this.m_UsingPolyTree=!0;try{(f=this.ExecuteInternal())&&this.BuildResult2(e)}finally{this.DisposeAllPolyPts(),this.m_ExecuteLocked=
!1}return f}if(2==b&&!c||2==b&&c)return b=a[0],e=a[1],this.Execute(b,e,d.PolyFillType.pftEvenOdd,d.PolyFillType.pftEvenOdd)}else{b=a[0];e=a[1];c=a[2];a=a[3];if(this.m_ExecuteLocked)return!1;this.m_HasOpenPaths&&d.Error("Error: PolyTree struct is need for open path clipping.");this.m_ExecuteLocked=!0;d.Clear(e);this.m_SubjFillType=c;this.m_ClipFillType=a;this.m_ClipType=b;this.m_UsingPolyTree=!1;try{var f=this.ExecuteInternal();f&&this.BuildResult(e)}finally{this.DisposeAllPolyPts(),this.m_ExecuteLocked=
!1}return f}};d.Clipper.prototype.FixHoleLinkage=function(a){if(null!==a.FirstLeft&&(a.IsHole==a.FirstLeft.IsHole||null===a.FirstLeft.Pts)){for(var b=a.FirstLeft;null!==b&&(b.IsHole==a.IsHole||null===b.Pts);)b=b.FirstLeft;a.FirstLeft=b}};d.Clipper.prototype.ExecuteInternal=function(){try{this.Reset();if(null===this.m_CurrentLM)return!1;var a=this.PopScanbeam();do{this.InsertLocalMinimaIntoAEL(a);d.Clear(this.m_GhostJoins);this.ProcessHorizontals(!1);if(null===this.m_Scanbeam)break;var b=this.PopScanbeam();
if(!this.ProcessIntersections(a,b))return!1;this.ProcessEdgesAtTopOfScanbeam(b);a=b}while(null!==this.m_Scanbeam||null!==this.m_CurrentLM);for(var a=0,c=this.m_PolyOuts.length;a<c;a++){var e=this.m_PolyOuts[a];null===e.Pts||e.IsOpen||(e.IsHole^this.ReverseSolution)==0<this.Area(e)&&this.ReversePolyPtLinks(e.Pts)}this.JoinCommonEdges();a=0;for(c=this.m_PolyOuts.length;a<c;a++)e=this.m_PolyOuts[a],null===e.Pts||e.IsOpen||this.FixupOutPolygon(e);this.StrictlySimple&&this.DoSimplePolygons();return!0}finally{d.Clear(this.m_Joins),
d.Clear(this.m_GhostJoins)}};d.Clipper.prototype.PopScanbeam=function(){var a=this.m_Scanbeam.Y;this.m_Scanbeam=this.m_Scanbeam.Next;return a};d.Clipper.prototype.DisposeAllPolyPts=function(){for(var a=0,b=this.m_PolyOuts.length;a<b;++a)this.DisposeOutRec(a);d.Clear(this.m_PolyOuts)};d.Clipper.prototype.DisposeOutRec=function(a){var b=this.m_PolyOuts[a];null!==b.Pts&&this.DisposeOutPts(b.Pts);this.m_PolyOuts[a]=null};d.Clipper.prototype.DisposeOutPts=function(a){if(null!==a)for(a.Prev.Next=null;null!==
a;)a=a.Next};d.Clipper.prototype.AddJoin=function(a,b,c){var e=new d.Join;e.OutPt1=a;e.OutPt2=b;e.OffPt.X=c.X;e.OffPt.Y=c.Y;this.m_Joins.push(e)};d.Clipper.prototype.AddGhostJoin=function(a,b){var c=new d.Join;c.OutPt1=a;c.OffPt.X=b.X;c.OffPt.Y=b.Y;this.m_GhostJoins.push(c)};d.Clipper.prototype.InsertLocalMinimaIntoAEL=function(a){for(;null!==this.m_CurrentLM&&this.m_CurrentLM.Y==a;){var b=this.m_CurrentLM.LeftBound,c=this.m_CurrentLM.RightBound;this.PopLocalMinima();var e=null;null===b?(this.InsertEdgeIntoAEL(c,
null),this.SetWindingCount(c),this.IsContributing(c)&&(e=this.AddOutPt(c,c.Bot))):(null==c?(this.InsertEdgeIntoAEL(b,null),this.SetWindingCount(b),this.IsContributing(b)&&(e=this.AddOutPt(b,b.Bot))):(this.InsertEdgeIntoAEL(b,null),this.InsertEdgeIntoAEL(c,b),this.SetWindingCount(b),c.WindCnt=b.WindCnt,c.WindCnt2=b.WindCnt2,this.IsContributing(b)&&(e=this.AddLocalMinPoly(b,c,b.Bot))),this.InsertScanbeam(b.Top.Y));null!=c&&(d.ClipperBase.IsHorizontal(c)?this.AddEdgeToSEL(c):this.InsertScanbeam(c.Top.Y));
if(null!=b&&null!=c){if(null!==e&&d.ClipperBase.IsHorizontal(c)&&0<this.m_GhostJoins.length&&0!==c.WindDelta)for(var f=0,g=this.m_GhostJoins.length;f<g;f++){var h=this.m_GhostJoins[f];this.HorzSegmentsOverlap(h.OutPt1.Pt,h.OffPt,c.Bot,c.Top)&&this.AddJoin(h.OutPt1,e,h.OffPt)}0<=b.OutIdx&&null!==b.PrevInAEL&&b.PrevInAEL.Curr.X==b.Bot.X&&0<=b.PrevInAEL.OutIdx&&d.ClipperBase.SlopesEqual(b.PrevInAEL,b,this.m_UseFullRange)&&0!==b.WindDelta&&0!==b.PrevInAEL.WindDelta&&(f=this.AddOutPt(b.PrevInAEL,b.Bot),
this.AddJoin(e,f,b.Top));if(b.NextInAEL!=c&&(0<=c.OutIdx&&0<=c.PrevInAEL.OutIdx&&d.ClipperBase.SlopesEqual(c.PrevInAEL,c,this.m_UseFullRange)&&0!==c.WindDelta&&0!==c.PrevInAEL.WindDelta&&(f=this.AddOutPt(c.PrevInAEL,c.Bot),this.AddJoin(e,f,c.Top)),e=b.NextInAEL,null!==e))for(;e!=c;)this.IntersectEdges(c,e,b.Curr,!1),e=e.NextInAEL}}};d.Clipper.prototype.InsertEdgeIntoAEL=function(a,b){if(null===this.m_ActiveEdges)a.PrevInAEL=null,a.NextInAEL=null,this.m_ActiveEdges=a;else if(null===b&&this.E2InsertsBeforeE1(this.m_ActiveEdges,
a))a.PrevInAEL=null,a.NextInAEL=this.m_ActiveEdges,this.m_ActiveEdges=this.m_ActiveEdges.PrevInAEL=a;else{null===b&&(b=this.m_ActiveEdges);for(;null!==b.NextInAEL&&!this.E2InsertsBeforeE1(b.NextInAEL,a);)b=b.NextInAEL;a.NextInAEL=b.NextInAEL;null!==b.NextInAEL&&(b.NextInAEL.PrevInAEL=a);a.PrevInAEL=b;b.NextInAEL=a}};d.Clipper.prototype.E2InsertsBeforeE1=function(a,b){return b.Curr.X==a.Curr.X?b.Top.Y>a.Top.Y?b.Top.X<d.Clipper.TopX(a,b.Top.Y):a.Top.X>d.Clipper.TopX(b,a.Top.Y):b.Curr.X<a.Curr.X};d.Clipper.prototype.IsEvenOddFillType=
function(a){return a.PolyTyp==d.PolyType.ptSubject?this.m_SubjFillType==d.PolyFillType.pftEvenOdd:this.m_ClipFillType==d.PolyFillType.pftEvenOdd};d.Clipper.prototype.IsEvenOddAltFillType=function(a){return a.PolyTyp==d.PolyType.ptSubject?this.m_ClipFillType==d.PolyFillType.pftEvenOdd:this.m_SubjFillType==d.PolyFillType.pftEvenOdd};d.Clipper.prototype.IsContributing=function(a){var b,c;a.PolyTyp==d.PolyType.ptSubject?(b=this.m_SubjFillType,c=this.m_ClipFillType):(b=this.m_ClipFillType,c=this.m_SubjFillType);
switch(b){case d.PolyFillType.pftEvenOdd:if(0===a.WindDelta&&1!=a.WindCnt)return!1;break;case d.PolyFillType.pftNonZero:if(1!=Math.abs(a.WindCnt))return!1;break;case d.PolyFillType.pftPositive:if(1!=a.WindCnt)return!1;break;default:if(-1!=a.WindCnt)return!1}switch(this.m_ClipType){case d.ClipType.ctIntersection:switch(c){case d.PolyFillType.pftEvenOdd:case d.PolyFillType.pftNonZero:return 0!==a.WindCnt2;case d.PolyFillType.pftPositive:return 0<a.WindCnt2;default:return 0>a.WindCnt2}case d.ClipType.ctUnion:switch(c){case d.PolyFillType.pftEvenOdd:case d.PolyFillType.pftNonZero:return 0===
a.WindCnt2;case d.PolyFillType.pftPositive:return 0>=a.WindCnt2;default:return 0<=a.WindCnt2}case d.ClipType.ctDifference:if(a.PolyTyp==d.PolyType.ptSubject)switch(c){case d.PolyFillType.pftEvenOdd:case d.PolyFillType.pftNonZero:return 0===a.WindCnt2;case d.PolyFillType.pftPositive:return 0>=a.WindCnt2;default:return 0<=a.WindCnt2}else switch(c){case d.PolyFillType.pftEvenOdd:case d.PolyFillType.pftNonZero:return 0!==a.WindCnt2;case d.PolyFillType.pftPositive:return 0<a.WindCnt2;default:return 0>
a.WindCnt2}case d.ClipType.ctXor:if(0===a.WindDelta)switch(c){case d.PolyFillType.pftEvenOdd:case d.PolyFillType.pftNonZero:return 0===a.WindCnt2;case d.PolyFillType.pftPositive:return 0>=a.WindCnt2;default:return 0<=a.WindCnt2}}return!0};d.Clipper.prototype.SetWindingCount=function(a){for(var b=a.PrevInAEL;null!==b&&(b.PolyTyp!=a.PolyTyp||0===b.WindDelta);)b=b.PrevInAEL;if(null===b)a.WindCnt=0===a.WindDelta?1:a.WindDelta,a.WindCnt2=0,b=this.m_ActiveEdges;else{if(0===a.WindDelta&&this.m_ClipType!=
d.ClipType.ctUnion)a.WindCnt=1;else if(this.IsEvenOddFillType(a))if(0===a.WindDelta){for(var c=!0,e=b.PrevInAEL;null!==e;)e.PolyTyp==b.PolyTyp&&0!==e.WindDelta&&(c=!c),e=e.PrevInAEL;a.WindCnt=c?0:1}else a.WindCnt=a.WindDelta;else 0>b.WindCnt*b.WindDelta?1<Math.abs(b.WindCnt)?a.WindCnt=0>b.WindDelta*a.WindDelta?b.WindCnt:b.WindCnt+a.WindDelta:a.WindCnt=0===a.WindDelta?1:a.WindDelta:a.WindCnt=0===a.WindDelta?0>b.WindCnt?b.WindCnt-1:b.WindCnt+1:0>b.WindDelta*a.WindDelta?b.WindCnt:b.WindCnt+a.WindDelta;
a.WindCnt2=b.WindCnt2;b=b.NextInAEL}if(this.IsEvenOddAltFillType(a))for(;b!=a;)0!==b.WindDelta&&(a.WindCnt2=0===a.WindCnt2?1:0),b=b.NextInAEL;else for(;b!=a;)a.WindCnt2+=b.WindDelta,b=b.NextInAEL};d.Clipper.prototype.AddEdgeToSEL=function(a){null===this.m_SortedEdges?(this.m_SortedEdges=a,a.PrevInSEL=null,a.NextInSEL=null):(a.NextInSEL=this.m_SortedEdges,a.PrevInSEL=null,this.m_SortedEdges=this.m_SortedEdges.PrevInSEL=a)};d.Clipper.prototype.CopyAELToSEL=function(){var a=this.m_ActiveEdges;for(this.m_SortedEdges=
a;null!==a;)a.PrevInSEL=a.PrevInAEL,a=a.NextInSEL=a.NextInAEL};d.Clipper.prototype.SwapPositionsInAEL=function(a,b){if(a.NextInAEL!=a.PrevInAEL&&b.NextInAEL!=b.PrevInAEL){if(a.NextInAEL==b){var c=b.NextInAEL;null!==c&&(c.PrevInAEL=a);var e=a.PrevInAEL;null!==e&&(e.NextInAEL=b);b.PrevInAEL=e;b.NextInAEL=a;a.PrevInAEL=b;a.NextInAEL=c}else b.NextInAEL==a?(c=a.NextInAEL,null!==c&&(c.PrevInAEL=b),e=b.PrevInAEL,null!==e&&(e.NextInAEL=a),a.PrevInAEL=e,a.NextInAEL=b,b.PrevInAEL=a,b.NextInAEL=c):(c=a.NextInAEL,
e=a.PrevInAEL,a.NextInAEL=b.NextInAEL,null!==a.NextInAEL&&(a.NextInAEL.PrevInAEL=a),a.PrevInAEL=b.PrevInAEL,null!==a.PrevInAEL&&(a.PrevInAEL.NextInAEL=a),b.NextInAEL=c,null!==b.NextInAEL&&(b.NextInAEL.PrevInAEL=b),b.PrevInAEL=e,null!==b.PrevInAEL&&(b.PrevInAEL.NextInAEL=b));null===a.PrevInAEL?this.m_ActiveEdges=a:null===b.PrevInAEL&&(this.m_ActiveEdges=b)}};d.Clipper.prototype.SwapPositionsInSEL=function(a,b){if(null!==a.NextInSEL||null!==a.PrevInSEL)if(null!==b.NextInSEL||null!==b.PrevInSEL){if(a.NextInSEL==
b){var c=b.NextInSEL;null!==c&&(c.PrevInSEL=a);var e=a.PrevInSEL;null!==e&&(e.NextInSEL=b);b.PrevInSEL=e;b.NextInSEL=a;a.PrevInSEL=b;a.NextInSEL=c}else b.NextInSEL==a?(c=a.NextInSEL,null!==c&&(c.PrevInSEL=b),e=b.PrevInSEL,null!==e&&(e.NextInSEL=a),a.PrevInSEL=e,a.NextInSEL=b,b.PrevInSEL=a,b.NextInSEL=c):(c=a.NextInSEL,e=a.PrevInSEL,a.NextInSEL=b.NextInSEL,null!==a.NextInSEL&&(a.NextInSEL.PrevInSEL=a),a.PrevInSEL=b.PrevInSEL,null!==a.PrevInSEL&&(a.PrevInSEL.NextInSEL=a),b.NextInSEL=c,null!==b.NextInSEL&&
(b.NextInSEL.PrevInSEL=b),b.PrevInSEL=e,null!==b.PrevInSEL&&(b.PrevInSEL.NextInSEL=b));null===a.PrevInSEL?this.m_SortedEdges=a:null===b.PrevInSEL&&(this.m_SortedEdges=b)}};d.Clipper.prototype.AddLocalMaxPoly=function(a,b,c){this.AddOutPt(a,c);0==b.WindDelta&&this.AddOutPt(b,c);a.OutIdx==b.OutIdx?(a.OutIdx=-1,b.OutIdx=-1):a.OutIdx<b.OutIdx?this.AppendPolygon(a,b):this.AppendPolygon(b,a)};d.Clipper.prototype.AddLocalMinPoly=function(a,b,c){var e,f;d.ClipperBase.IsHorizontal(b)||a.Dx>b.Dx?(e=this.AddOutPt(a,
c),b.OutIdx=a.OutIdx,a.Side=d.EdgeSide.esLeft,b.Side=d.EdgeSide.esRight,f=a,a=f.PrevInAEL==b?b.PrevInAEL:f.PrevInAEL):(e=this.AddOutPt(b,c),a.OutIdx=b.OutIdx,a.Side=d.EdgeSide.esRight,b.Side=d.EdgeSide.esLeft,f=b,a=f.PrevInAEL==a?a.PrevInAEL:f.PrevInAEL);null!==a&&0<=a.OutIdx&&d.Clipper.TopX(a,c.Y)==d.Clipper.TopX(f,c.Y)&&d.ClipperBase.SlopesEqual(f,a,this.m_UseFullRange)&&0!==f.WindDelta&&0!==a.WindDelta&&(c=this.AddOutPt(a,c),this.AddJoin(e,c,f.Top));return e};d.Clipper.prototype.CreateOutRec=function(){var a=
new d.OutRec;a.Idx=-1;a.IsHole=!1;a.IsOpen=!1;a.FirstLeft=null;a.Pts=null;a.BottomPt=null;a.PolyNode=null;this.m_PolyOuts.push(a);a.Idx=this.m_PolyOuts.length-1;return a};d.Clipper.prototype.AddOutPt=function(a,b){var c=a.Side==d.EdgeSide.esLeft;if(0>a.OutIdx){var e=this.CreateOutRec();e.IsOpen=0===a.WindDelta;var f=new d.OutPt;e.Pts=f;f.Idx=e.Idx;f.Pt.X=b.X;f.Pt.Y=b.Y;f.Next=f;f.Prev=f;e.IsOpen||this.SetHoleState(a,e);a.OutIdx=e.Idx}else{var e=this.m_PolyOuts[a.OutIdx],g=e.Pts;if(c&&d.IntPoint.op_Equality(b,
g.Pt))return g;if(!c&&d.IntPoint.op_Equality(b,g.Prev.Pt))return g.Prev;f=new d.OutPt;f.Idx=e.Idx;f.Pt.X=b.X;f.Pt.Y=b.Y;f.Next=g;f.Prev=g.Prev;f.Prev.Next=f;g.Prev=f;c&&(e.Pts=f)}return f};d.Clipper.prototype.SwapPoints=function(a,b){var c=new d.IntPoint(a.Value);a.Value.X=b.Value.X;a.Value.Y=b.Value.Y;b.Value.X=c.X;b.Value.Y=c.Y};d.Clipper.prototype.HorzSegmentsOverlap=function(a,b,c,e){return a.X>c.X==a.X<e.X?!0:b.X>c.X==b.X<e.X?!0:c.X>a.X==c.X<b.X?!0:e.X>a.X==e.X<b.X?!0:a.X==c.X&&b.X==e.X?!0:a.X==
e.X&&b.X==c.X?!0:!1};d.Clipper.prototype.InsertPolyPtBetween=function(a,b,c){var e=new d.OutPt;e.Pt.X=c.X;e.Pt.Y=c.Y;b==a.Next?(a.Next=e,b.Prev=e,e.Next=b,e.Prev=a):(b.Next=e,a.Prev=e,e.Next=a,e.Prev=b);return e};d.Clipper.prototype.SetHoleState=function(a,b){for(var c=!1,e=a.PrevInAEL;null!==e;)0<=e.OutIdx&&0!=e.WindDelta&&(c=!c,null===b.FirstLeft&&(b.FirstLeft=this.m_PolyOuts[e.OutIdx])),e=e.PrevInAEL;c&&(b.IsHole=!0)};d.Clipper.prototype.GetDx=function(a,b){return a.Y==b.Y?d.ClipperBase.horizontal:
(b.X-a.X)/(b.Y-a.Y)};d.Clipper.prototype.FirstIsBottomPt=function(a,b){for(var c=a.Prev;d.IntPoint.op_Equality(c.Pt,a.Pt)&&c!=a;)c=c.Prev;for(var e=Math.abs(this.GetDx(a.Pt,c.Pt)),c=a.Next;d.IntPoint.op_Equality(c.Pt,a.Pt)&&c!=a;)c=c.Next;for(var f=Math.abs(this.GetDx(a.Pt,c.Pt)),c=b.Prev;d.IntPoint.op_Equality(c.Pt,b.Pt)&&c!=b;)c=c.Prev;for(var g=Math.abs(this.GetDx(b.Pt,c.Pt)),c=b.Next;d.IntPoint.op_Equality(c.Pt,b.Pt)&&c!=b;)c=c.Next;c=Math.abs(this.GetDx(b.Pt,c.Pt));return e>=g&&e>=c||f>=g&&f>=
c};d.Clipper.prototype.GetBottomPt=function(a){for(var b=null,c=a.Next;c!=a;)c.Pt.Y>a.Pt.Y?(a=c,b=null):c.Pt.Y==a.Pt.Y&&c.Pt.X<=a.Pt.X&&(c.Pt.X<a.Pt.X?(b=null,a=c):c.Next!=a&&c.Prev!=a&&(b=c)),c=c.Next;if(null!==b)for(;b!=c;)for(this.FirstIsBottomPt(c,b)||(a=b),b=b.Next;d.IntPoint.op_Inequality(b.Pt,a.Pt);)b=b.Next;return a};d.Clipper.prototype.GetLowermostRec=function(a,b){null===a.BottomPt&&(a.BottomPt=this.GetBottomPt(a.Pts));null===b.BottomPt&&(b.BottomPt=this.GetBottomPt(b.Pts));var c=a.BottomPt,
e=b.BottomPt;return c.Pt.Y>e.Pt.Y?a:c.Pt.Y<e.Pt.Y?b:c.Pt.X<e.Pt.X?a:c.Pt.X>e.Pt.X?b:c.Next==c?b:e.Next==e?a:this.FirstIsBottomPt(c,e)?a:b};d.Clipper.prototype.Param1RightOfParam2=function(a,b){do if(a=a.FirstLeft,a==b)return!0;while(null!==a);return!1};d.Clipper.prototype.GetOutRec=function(a){for(a=this.m_PolyOuts[a];a!=this.m_PolyOuts[a.Idx];)a=this.m_PolyOuts[a.Idx];return a};d.Clipper.prototype.AppendPolygon=function(a,b){var c=this.m_PolyOuts[a.OutIdx],e=this.m_PolyOuts[b.OutIdx],f;f=this.Param1RightOfParam2(c,
e)?e:this.Param1RightOfParam2(e,c)?c:this.GetLowermostRec(c,e);var g=c.Pts,h=g.Prev,l=e.Pts,k=l.Prev;a.Side==d.EdgeSide.esLeft?(b.Side==d.EdgeSide.esLeft?(this.ReversePolyPtLinks(l),l.Next=g,g.Prev=l,h.Next=k,k.Prev=h,c.Pts=k):(k.Next=g,g.Prev=k,l.Prev=h,h.Next=l,c.Pts=l),g=d.EdgeSide.esLeft):(b.Side==d.EdgeSide.esRight?(this.ReversePolyPtLinks(l),h.Next=k,k.Prev=h,l.Next=g,g.Prev=l):(h.Next=l,l.Prev=h,g.Prev=k,k.Next=g),g=d.EdgeSide.esRight);c.BottomPt=null;f==e&&(e.FirstLeft!=c&&(c.FirstLeft=e.FirstLeft),
c.IsHole=e.IsHole);e.Pts=null;e.BottomPt=null;e.FirstLeft=c;f=a.OutIdx;h=b.OutIdx;a.OutIdx=-1;b.OutIdx=-1;for(l=this.m_ActiveEdges;null!==l;){if(l.OutIdx==h){l.OutIdx=f;l.Side=g;break}l=l.NextInAEL}e.Idx=c.Idx};d.Clipper.prototype.ReversePolyPtLinks=function(a){if(null!==a){var b,c;b=a;do c=b.Next,b.Next=b.Prev,b=b.Prev=c;while(b!=a)}};d.Clipper.SwapSides=function(a,b){var c=a.Side;a.Side=b.Side;b.Side=c};d.Clipper.SwapPolyIndexes=function(a,b){var c=a.OutIdx;a.OutIdx=b.OutIdx;b.OutIdx=c};d.Clipper.prototype.IntersectEdges=
function(a,b,c,e){var f=!e&&null===a.NextInLML&&a.Top.X==c.X&&a.Top.Y==c.Y;e=!e&&null===b.NextInLML&&b.Top.X==c.X&&b.Top.Y==c.Y;var g=0<=a.OutIdx,h=0<=b.OutIdx;if(0===a.WindDelta||0===b.WindDelta)0===a.WindDelta&&0===b.WindDelta?(f||e)&&g&&h&&this.AddLocalMaxPoly(a,b,c):a.PolyTyp==b.PolyTyp&&a.WindDelta!=b.WindDelta&&this.m_ClipType==d.ClipType.ctUnion?0===a.WindDelta?h&&(this.AddOutPt(a,c),g&&(a.OutIdx=-1)):g&&(this.AddOutPt(b,c),h&&(b.OutIdx=-1)):a.PolyTyp!=b.PolyTyp&&(0!==a.WindDelta||1!=Math.abs(b.WindCnt)||
this.m_ClipType==d.ClipType.ctUnion&&0!==b.WindCnt2?0!==b.WindDelta||1!=Math.abs(a.WindCnt)||this.m_ClipType==d.ClipType.ctUnion&&0!==a.WindCnt2||(this.AddOutPt(b,c),h&&(b.OutIdx=-1)):(this.AddOutPt(a,c),g&&(a.OutIdx=-1))),f&&(0>a.OutIdx?this.DeleteFromAEL(a):d.Error("Error intersecting polylines")),e&&(0>b.OutIdx?this.DeleteFromAEL(b):d.Error("Error intersecting polylines"));else{if(a.PolyTyp==b.PolyTyp)if(this.IsEvenOddFillType(a)){var l=a.WindCnt;a.WindCnt=b.WindCnt;b.WindCnt=l}else a.WindCnt=
0===a.WindCnt+b.WindDelta?-a.WindCnt:a.WindCnt+b.WindDelta,b.WindCnt=0===b.WindCnt-a.WindDelta?-b.WindCnt:b.WindCnt-a.WindDelta;else this.IsEvenOddFillType(b)?a.WindCnt2=0===a.WindCnt2?1:0:a.WindCnt2+=b.WindDelta,this.IsEvenOddFillType(a)?b.WindCnt2=0===b.WindCnt2?1:0:b.WindCnt2-=a.WindDelta;var k,n,m;a.PolyTyp==d.PolyType.ptSubject?(k=this.m_SubjFillType,m=this.m_ClipFillType):(k=this.m_ClipFillType,m=this.m_SubjFillType);b.PolyTyp==d.PolyType.ptSubject?(n=this.m_SubjFillType,l=this.m_ClipFillType):
(n=this.m_ClipFillType,l=this.m_SubjFillType);switch(k){case d.PolyFillType.pftPositive:k=a.WindCnt;break;case d.PolyFillType.pftNegative:k=-a.WindCnt;break;default:k=Math.abs(a.WindCnt)}switch(n){case d.PolyFillType.pftPositive:n=b.WindCnt;break;case d.PolyFillType.pftNegative:n=-b.WindCnt;break;default:n=Math.abs(b.WindCnt)}if(g&&h)f||e||0!==k&&1!=k||0!==n&&1!=n||a.PolyTyp!=b.PolyTyp&&this.m_ClipType!=d.ClipType.ctXor?this.AddLocalMaxPoly(a,b,c):(this.AddOutPt(a,c),this.AddOutPt(b,c),d.Clipper.SwapSides(a,
b),d.Clipper.SwapPolyIndexes(a,b));else if(g){if(0===n||1==n)this.AddOutPt(a,c),d.Clipper.SwapSides(a,b),d.Clipper.SwapPolyIndexes(a,b)}else if(h){if(0===k||1==k)this.AddOutPt(b,c),d.Clipper.SwapSides(a,b),d.Clipper.SwapPolyIndexes(a,b)}else if(!(0!==k&&1!=k||0!==n&&1!=n||f||e)){switch(m){case d.PolyFillType.pftPositive:g=a.WindCnt2;break;case d.PolyFillType.pftNegative:g=-a.WindCnt2;break;default:g=Math.abs(a.WindCnt2)}switch(l){case d.PolyFillType.pftPositive:h=b.WindCnt2;break;case d.PolyFillType.pftNegative:h=
-b.WindCnt2;break;default:h=Math.abs(b.WindCnt2)}if(a.PolyTyp!=b.PolyTyp)this.AddLocalMinPoly(a,b,c);else if(1==k&&1==n)switch(this.m_ClipType){case d.ClipType.ctIntersection:0<g&&0<h&&this.AddLocalMinPoly(a,b,c);break;case d.ClipType.ctUnion:0>=g&&0>=h&&this.AddLocalMinPoly(a,b,c);break;case d.ClipType.ctDifference:(a.PolyTyp==d.PolyType.ptClip&&0<g&&0<h||a.PolyTyp==d.PolyType.ptSubject&&0>=g&&0>=h)&&this.AddLocalMinPoly(a,b,c);break;case d.ClipType.ctXor:this.AddLocalMinPoly(a,b,c)}else d.Clipper.SwapSides(a,
b)}f!=e&&(f&&0<=a.OutIdx||e&&0<=b.OutIdx)&&(d.Clipper.SwapSides(a,b),d.Clipper.SwapPolyIndexes(a,b));f&&this.DeleteFromAEL(a);e&&this.DeleteFromAEL(b)}};d.Clipper.prototype.DeleteFromAEL=function(a){var b=a.PrevInAEL,c=a.NextInAEL;if(null!==b||null!==c||a==this.m_ActiveEdges)null!==b?b.NextInAEL=c:this.m_ActiveEdges=c,null!==c&&(c.PrevInAEL=b),a.NextInAEL=null,a.PrevInAEL=null};d.Clipper.prototype.DeleteFromSEL=function(a){var b=a.PrevInSEL,c=a.NextInSEL;if(null!==b||null!==c||a==this.m_SortedEdges)null!==
b?b.NextInSEL=c:this.m_SortedEdges=c,null!==c&&(c.PrevInSEL=b),a.NextInSEL=null,a.PrevInSEL=null};d.Clipper.prototype.UpdateEdgeIntoAEL=function(a){null===a.NextInLML&&d.Error("UpdateEdgeIntoAEL: invalid call");var b=a.PrevInAEL,c=a.NextInAEL;a.NextInLML.OutIdx=a.OutIdx;null!==b?b.NextInAEL=a.NextInLML:this.m_ActiveEdges=a.NextInLML;null!==c&&(c.PrevInAEL=a.NextInLML);a.NextInLML.Side=a.Side;a.NextInLML.WindDelta=a.WindDelta;a.NextInLML.WindCnt=a.WindCnt;a.NextInLML.WindCnt2=a.WindCnt2;a=a.NextInLML;
a.Curr.X=a.Bot.X;a.Curr.Y=a.Bot.Y;a.PrevInAEL=b;a.NextInAEL=c;d.ClipperBase.IsHorizontal(a)||this.InsertScanbeam(a.Top.Y);return a};d.Clipper.prototype.ProcessHorizontals=function(a){for(var b=this.m_SortedEdges;null!==b;)this.DeleteFromSEL(b),this.ProcessHorizontal(b,a),b=this.m_SortedEdges};d.Clipper.prototype.GetHorzDirection=function(a,b){a.Bot.X<a.Top.X?(b.Left=a.Bot.X,b.Right=a.Top.X,b.Dir=d.Direction.dLeftToRight):(b.Left=a.Top.X,b.Right=a.Bot.X,b.Dir=d.Direction.dRightToLeft)};d.Clipper.prototype.PrepareHorzJoins=
function(a,b){var c=this.m_PolyOuts[a.OutIdx].Pts;a.Side!=d.EdgeSide.esLeft&&(c=c.Prev);b&&(d.IntPoint.op_Equality(c.Pt,a.Top)?this.AddGhostJoin(c,a.Bot):this.AddGhostJoin(c,a.Top))};d.Clipper.prototype.ProcessHorizontal=function(a,b){var c={Dir:null,Left:null,Right:null};this.GetHorzDirection(a,c);for(var e=c.Dir,f=c.Left,g=c.Right,h=a,l=null;null!==h.NextInLML&&d.ClipperBase.IsHorizontal(h.NextInLML);)h=h.NextInLML;for(null===h.NextInLML&&(l=this.GetMaximaPair(h));;){for(var k=a==h,n=this.GetNextInAEL(a,
e);null!==n&&!(n.Curr.X==a.Top.X&&null!==a.NextInLML&&n.Dx<a.NextInLML.Dx);){c=this.GetNextInAEL(n,e);if(e==d.Direction.dLeftToRight&&n.Curr.X<=g||e==d.Direction.dRightToLeft&&n.Curr.X>=f){0<=a.OutIdx&&0!=a.WindDelta&&this.PrepareHorzJoins(a,b);if(n==l&&k){e==d.Direction.dLeftToRight?this.IntersectEdges(a,n,n.Top,!1):this.IntersectEdges(n,a,n.Top,!1);0<=l.OutIdx&&d.Error("ProcessHorizontal error");return}if(e==d.Direction.dLeftToRight){var m=new d.IntPoint(n.Curr.X,a.Curr.Y);this.IntersectEdges(a,
n,m,!0)}else m=new d.IntPoint(n.Curr.X,a.Curr.Y),this.IntersectEdges(n,a,m,!0);this.SwapPositionsInAEL(a,n)}else if(e==d.Direction.dLeftToRight&&n.Curr.X>=g||e==d.Direction.dRightToLeft&&n.Curr.X<=f)break;n=c}0<=a.OutIdx&&0!==a.WindDelta&&this.PrepareHorzJoins(a,b);if(null!==a.NextInLML&&d.ClipperBase.IsHorizontal(a.NextInLML))a=this.UpdateEdgeIntoAEL(a),0<=a.OutIdx&&this.AddOutPt(a,a.Bot),c={Dir:e,Left:f,Right:g},this.GetHorzDirection(a,c),e=c.Dir,f=c.Left,g=c.Right;else break}null!==a.NextInLML?
0<=a.OutIdx?(e=this.AddOutPt(a,a.Top),a=this.UpdateEdgeIntoAEL(a),0!==a.WindDelta&&(f=a.PrevInAEL,c=a.NextInAEL,null!==f&&f.Curr.X==a.Bot.X&&f.Curr.Y==a.Bot.Y&&0!==f.WindDelta&&0<=f.OutIdx&&f.Curr.Y>f.Top.Y&&d.ClipperBase.SlopesEqual(a,f,this.m_UseFullRange)?(c=this.AddOutPt(f,a.Bot),this.AddJoin(e,c,a.Top)):null!==c&&c.Curr.X==a.Bot.X&&c.Curr.Y==a.Bot.Y&&0!==c.WindDelta&&0<=c.OutIdx&&c.Curr.Y>c.Top.Y&&d.ClipperBase.SlopesEqual(a,c,this.m_UseFullRange)&&(c=this.AddOutPt(c,a.Bot),this.AddJoin(e,c,
a.Top)))):this.UpdateEdgeIntoAEL(a):null!==l?0<=l.OutIdx?(e==d.Direction.dLeftToRight?this.IntersectEdges(a,l,a.Top,!1):this.IntersectEdges(l,a,a.Top,!1),0<=l.OutIdx&&d.Error("ProcessHorizontal error")):(this.DeleteFromAEL(a),this.DeleteFromAEL(l)):(0<=a.OutIdx&&this.AddOutPt(a,a.Top),this.DeleteFromAEL(a))};d.Clipper.prototype.GetNextInAEL=function(a,b){return b==d.Direction.dLeftToRight?a.NextInAEL:a.PrevInAEL};d.Clipper.prototype.IsMinima=function(a){return null!==a&&a.Prev.NextInLML!=a&&a.Next.NextInLML!=
a};d.Clipper.prototype.IsMaxima=function(a,b){return null!==a&&a.Top.Y==b&&null===a.NextInLML};d.Clipper.prototype.IsIntermediate=function(a,b){return a.Top.Y==b&&null!==a.NextInLML};d.Clipper.prototype.GetMaximaPair=function(a){var b=null;d.IntPoint.op_Equality(a.Next.Top,a.Top)&&null===a.Next.NextInLML?b=a.Next:d.IntPoint.op_Equality(a.Prev.Top,a.Top)&&null===a.Prev.NextInLML&&(b=a.Prev);return null===b||-2!=b.OutIdx&&(b.NextInAEL!=b.PrevInAEL||d.ClipperBase.IsHorizontal(b))?b:null};d.Clipper.prototype.ProcessIntersections=
function(a,b){if(null==this.m_ActiveEdges)return!0;try{this.BuildIntersectList(a,b);if(0==this.m_IntersectList.length)return!0;if(1==this.m_IntersectList.length||this.FixupIntersectionOrder())this.ProcessIntersectList();else return!1}catch(c){this.m_SortedEdges=null,this.m_IntersectList.length=0,d.Error("ProcessIntersections error")}this.m_SortedEdges=null;return!0};d.Clipper.prototype.BuildIntersectList=function(a,b){if(null!==this.m_ActiveEdges){var c=this.m_ActiveEdges;for(this.m_SortedEdges=c;null!==
c;)c.PrevInSEL=c.PrevInAEL,c.NextInSEL=c.NextInAEL,c.Curr.X=d.Clipper.TopX(c,b),c=c.NextInAEL;for(var e=!0;e&&null!==this.m_SortedEdges;){e=!1;for(c=this.m_SortedEdges;null!==c.NextInSEL;){var f=c.NextInSEL,g=new d.IntPoint;c.Curr.X>f.Curr.X?(!this.IntersectPoint(c,f,g)&&c.Curr.X>f.Curr.X+1&&d.Error("Intersection error"),g.Y>a&&(g.Y=a,Math.abs(c.Dx)>Math.abs(f.Dx)?g.X=d.Clipper.TopX(f,a):g.X=d.Clipper.TopX(c,a)),e=new d.IntersectNode,e.Edge1=c,e.Edge2=f,e.Pt.X=g.X,e.Pt.Y=g.Y,this.m_IntersectList.push(e),
this.SwapPositionsInSEL(c,f),e=!0):c=f}if(null!==c.PrevInSEL)c.PrevInSEL.NextInSEL=null;else break}this.m_SortedEdges=null}};d.Clipper.prototype.EdgesAdjacent=function(a){return a.Edge1.NextInSEL==a.Edge2||a.Edge1.PrevInSEL==a.Edge2};d.Clipper.IntersectNodeSort=function(a,b){return b.Pt.Y-a.Pt.Y};d.Clipper.prototype.FixupIntersectionOrder=function(){this.m_IntersectList.sort(this.m_IntersectNodeComparer);this.CopyAELToSEL();for(var a=this.m_IntersectList.length,b=0;b<a;b++){if(!this.EdgesAdjacent(this.m_IntersectList[b])){for(var c=
b+1;c<a&&!this.EdgesAdjacent(this.m_IntersectList[c]);)c++;if(c==a)return!1;var e=this.m_IntersectList[b];this.m_IntersectList[b]=this.m_IntersectList[c];this.m_IntersectList[c]=e}this.SwapPositionsInSEL(this.m_IntersectList[b].Edge1,this.m_IntersectList[b].Edge2)}return!0};d.Clipper.prototype.ProcessIntersectList=function(){for(var a=0,b=this.m_IntersectList.length;a<b;a++){var c=this.m_IntersectList[a];this.IntersectEdges(c.Edge1,c.Edge2,c.Pt,!0);this.SwapPositionsInAEL(c.Edge1,c.Edge2)}this.m_IntersectList.length=
0};E=function(a){return 0>a?Math.ceil(a-0.5):Math.round(a)};F=function(a){return 0>a?Math.ceil(a-0.5):Math.floor(a+0.5)};G=function(a){return 0>a?-Math.round(Math.abs(a)):Math.round(a)};H=function(a){if(0>a)return a-=0.5,-2147483648>a?Math.ceil(a):a|0;a+=0.5;return 2147483647<a?Math.floor(a):a|0};d.Clipper.Round=p?E:D?G:J?H:F;d.Clipper.TopX=function(a,b){return b==a.Top.Y?a.Top.X:a.Bot.X+d.Clipper.Round(a.Dx*(b-a.Bot.Y))};d.Clipper.prototype.IntersectPoint=function(a,b,c){c.X=0;c.Y=0;var e,f;if(d.ClipperBase.SlopesEqual(a,
b,this.m_UseFullRange)||a.Dx==b.Dx)return b.Bot.Y>a.Bot.Y?(c.X=b.Bot.X,c.Y=b.Bot.Y):(c.X=a.Bot.X,c.Y=a.Bot.Y),!1;if(0===a.Delta.X)c.X=a.Bot.X,d.ClipperBase.IsHorizontal(b)?c.Y=b.Bot.Y:(f=b.Bot.Y-b.Bot.X/b.Dx,c.Y=d.Clipper.Round(c.X/b.Dx+f));else if(0===b.Delta.X)c.X=b.Bot.X,d.ClipperBase.IsHorizontal(a)?c.Y=a.Bot.Y:(e=a.Bot.Y-a.Bot.X/a.Dx,c.Y=d.Clipper.Round(c.X/a.Dx+e));else{e=a.Bot.X-a.Bot.Y*a.Dx;f=b.Bot.X-b.Bot.Y*b.Dx;var g=(f-e)/(a.Dx-b.Dx);c.Y=d.Clipper.Round(g);Math.abs(a.Dx)<Math.abs(b.Dx)?
c.X=d.Clipper.Round(a.Dx*g+e):c.X=d.Clipper.Round(b.Dx*g+f)}if(c.Y<a.Top.Y||c.Y<b.Top.Y){if(a.Top.Y>b.Top.Y)return c.Y=a.Top.Y,c.X=d.Clipper.TopX(b,a.Top.Y),c.X<a.Top.X;c.Y=b.Top.Y;Math.abs(a.Dx)<Math.abs(b.Dx)?c.X=d.Clipper.TopX(a,c.Y):c.X=d.Clipper.TopX(b,c.Y)}return!0};d.Clipper.prototype.ProcessEdgesAtTopOfScanbeam=function(a){for(var b=this.m_ActiveEdges;null!==b;){var c=this.IsMaxima(b,a);c&&(c=this.GetMaximaPair(b),c=null===c||!d.ClipperBase.IsHorizontal(c));if(c){var e=b.PrevInAEL;this.DoMaxima(b);
b=null===e?this.m_ActiveEdges:e.NextInAEL}else this.IsIntermediate(b,a)&&d.ClipperBase.IsHorizontal(b.NextInLML)?(b=this.UpdateEdgeIntoAEL(b),0<=b.OutIdx&&this.AddOutPt(b,b.Bot),this.AddEdgeToSEL(b)):(b.Curr.X=d.Clipper.TopX(b,a),b.Curr.Y=a),this.StrictlySimple&&(e=b.PrevInAEL,0<=b.OutIdx&&0!==b.WindDelta&&null!==e&&0<=e.OutIdx&&e.Curr.X==b.Curr.X&&0!==e.WindDelta&&(c=this.AddOutPt(e,b.Curr),e=this.AddOutPt(b,b.Curr),this.AddJoin(c,e,b.Curr))),b=b.NextInAEL}this.ProcessHorizontals(!0);for(b=this.m_ActiveEdges;null!==
b;){if(this.IsIntermediate(b,a)){c=null;0<=b.OutIdx&&(c=this.AddOutPt(b,b.Top));var b=this.UpdateEdgeIntoAEL(b),e=b.PrevInAEL,f=b.NextInAEL;null!==e&&e.Curr.X==b.Bot.X&&e.Curr.Y==b.Bot.Y&&null!==c&&0<=e.OutIdx&&e.Curr.Y>e.Top.Y&&d.ClipperBase.SlopesEqual(b,e,this.m_UseFullRange)&&0!==b.WindDelta&&0!==e.WindDelta?(e=this.AddOutPt(e,b.Bot),this.AddJoin(c,e,b.Top)):null!==f&&f.Curr.X==b.Bot.X&&f.Curr.Y==b.Bot.Y&&null!==c&&0<=f.OutIdx&&f.Curr.Y>f.Top.Y&&d.ClipperBase.SlopesEqual(b,f,this.m_UseFullRange)&&
0!==b.WindDelta&&0!==f.WindDelta&&(e=this.AddOutPt(f,b.Bot),this.AddJoin(c,e,b.Top))}b=b.NextInAEL}};d.Clipper.prototype.DoMaxima=function(a){var b=this.GetMaximaPair(a);if(null===b)0<=a.OutIdx&&this.AddOutPt(a,a.Top),this.DeleteFromAEL(a);else{for(var c=a.NextInAEL;null!==c&&c!=b;)this.IntersectEdges(a,c,a.Top,!0),this.SwapPositionsInAEL(a,c),c=a.NextInAEL;-1==a.OutIdx&&-1==b.OutIdx?(this.DeleteFromAEL(a),this.DeleteFromAEL(b)):0<=a.OutIdx&&0<=b.OutIdx?this.IntersectEdges(a,b,a.Top,!1):0===a.WindDelta?
(0<=a.OutIdx&&(this.AddOutPt(a,a.Top),a.OutIdx=-1),this.DeleteFromAEL(a),0<=b.OutIdx&&(this.AddOutPt(b,a.Top),b.OutIdx=-1),this.DeleteFromAEL(b)):d.Error("DoMaxima error")}};d.Clipper.ReversePaths=function(a){for(var b=0,c=a.length;b<c;b++)a[b].reverse()};d.Clipper.Orientation=function(a){return 0<=d.Clipper.Area(a)};d.Clipper.prototype.PointCount=function(a){if(null===a)return 0;var b=0,c=a;do b++,c=c.Next;while(c!=a);return b};d.Clipper.prototype.BuildResult=function(a){d.Clear(a);for(var b=0,c=
this.m_PolyOuts.length;b<c;b++){var e=this.m_PolyOuts[b];if(null!==e.Pts){var e=e.Pts.Prev,f=this.PointCount(e);if(!(2>f)){for(var g=Array(f),h=0;h<f;h++)g[h]=e.Pt,e=e.Prev;a.push(g)}}}};d.Clipper.prototype.BuildResult2=function(a){a.Clear();for(var b=0,c=this.m_PolyOuts.length;b<c;b++){var e=this.m_PolyOuts[b],f=this.PointCount(e.Pts);if(!(e.IsOpen&&2>f||!e.IsOpen&&3>f)){this.FixHoleLinkage(e);var g=new d.PolyNode;a.m_AllPolys.push(g);e.PolyNode=g;g.m_polygon.length=f;for(var e=e.Pts.Prev,h=0;h<
f;h++)g.m_polygon[h]=e.Pt,e=e.Prev}}b=0;for(c=this.m_PolyOuts.length;b<c;b++)e=this.m_PolyOuts[b],null!==e.PolyNode&&(e.IsOpen?(e.PolyNode.IsOpen=!0,a.AddChild(e.PolyNode)):null!==e.FirstLeft&&null!=e.FirstLeft.PolyNode?e.FirstLeft.PolyNode.AddChild(e.PolyNode):a.AddChild(e.PolyNode))};d.Clipper.prototype.FixupOutPolygon=function(a){var b=null;a.BottomPt=null;for(var c=a.Pts;;){if(c.Prev==c||c.Prev==c.Next){this.DisposeOutPts(c);a.Pts=null;return}if(d.IntPoint.op_Equality(c.Pt,c.Next.Pt)||d.IntPoint.op_Equality(c.Pt,
c.Prev.Pt)||d.ClipperBase.SlopesEqual(c.Prev.Pt,c.Pt,c.Next.Pt,this.m_UseFullRange)&&(!this.PreserveCollinear||!this.Pt2IsBetweenPt1AndPt3(c.Prev.Pt,c.Pt,c.Next.Pt)))b=null,c.Prev.Next=c.Next,c=c.Next.Prev=c.Prev;else if(c==b)break;else null===b&&(b=c),c=c.Next}a.Pts=c};d.Clipper.prototype.DupOutPt=function(a,b){var c=new d.OutPt;c.Pt.X=a.Pt.X;c.Pt.Y=a.Pt.Y;c.Idx=a.Idx;b?(c.Next=a.Next,c.Prev=a,a.Next.Prev=c,a.Next=c):(c.Prev=a.Prev,c.Next=a,a.Prev.Next=c,a.Prev=c);return c};d.Clipper.prototype.GetOverlap=
function(a,b,c,e,d){a<b?c<e?(d.Left=Math.max(a,c),d.Right=Math.min(b,e)):(d.Left=Math.max(a,e),d.Right=Math.min(b,c)):c<e?(d.Left=Math.max(b,c),d.Right=Math.min(a,e)):(d.Left=Math.max(b,e),d.Right=Math.min(a,c));return d.Left<d.Right};d.Clipper.prototype.JoinHorz=function(a,b,c,e,f,g){var h=a.Pt.X>b.Pt.X?d.Direction.dRightToLeft:d.Direction.dLeftToRight;e=c.Pt.X>e.Pt.X?d.Direction.dRightToLeft:d.Direction.dLeftToRight;if(h==e)return!1;if(h==d.Direction.dLeftToRight){for(;a.Next.Pt.X<=f.X&&a.Next.Pt.X>=
a.Pt.X&&a.Next.Pt.Y==f.Y;)a=a.Next;g&&a.Pt.X!=f.X&&(a=a.Next);b=this.DupOutPt(a,!g);d.IntPoint.op_Inequality(b.Pt,f)&&(a=b,a.Pt.X=f.X,a.Pt.Y=f.Y,b=this.DupOutPt(a,!g))}else{for(;a.Next.Pt.X>=f.X&&a.Next.Pt.X<=a.Pt.X&&a.Next.Pt.Y==f.Y;)a=a.Next;g||a.Pt.X==f.X||(a=a.Next);b=this.DupOutPt(a,g);d.IntPoint.op_Inequality(b.Pt,f)&&(a=b,a.Pt.X=f.X,a.Pt.Y=f.Y,b=this.DupOutPt(a,g))}if(e==d.Direction.dLeftToRight){for(;c.Next.Pt.X<=f.X&&c.Next.Pt.X>=c.Pt.X&&c.Next.Pt.Y==f.Y;)c=c.Next;g&&c.Pt.X!=f.X&&(c=c.Next);
e=this.DupOutPt(c,!g);d.IntPoint.op_Inequality(e.Pt,f)&&(c=e,c.Pt.X=f.X,c.Pt.Y=f.Y,e=this.DupOutPt(c,!g))}else{for(;c.Next.Pt.X>=f.X&&c.Next.Pt.X<=c.Pt.X&&c.Next.Pt.Y==f.Y;)c=c.Next;g||c.Pt.X==f.X||(c=c.Next);e=this.DupOutPt(c,g);d.IntPoint.op_Inequality(e.Pt,f)&&(c=e,c.Pt.X=f.X,c.Pt.Y=f.Y,e=this.DupOutPt(c,g))}h==d.Direction.dLeftToRight==g?(a.Prev=c,c.Next=a,b.Next=e,e.Prev=b):(a.Next=c,c.Prev=a,b.Prev=e,e.Next=b);return!0};d.Clipper.prototype.JoinPoints=function(a,b,c){var e=a.OutPt1,f=new d.OutPt,
g=a.OutPt2,h=new d.OutPt;if((h=a.OutPt1.Pt.Y==a.OffPt.Y)&&d.IntPoint.op_Equality(a.OffPt,a.OutPt1.Pt)&&d.IntPoint.op_Equality(a.OffPt,a.OutPt2.Pt)){for(f=a.OutPt1.Next;f!=e&&d.IntPoint.op_Equality(f.Pt,a.OffPt);)f=f.Next;f=f.Pt.Y>a.OffPt.Y;for(h=a.OutPt2.Next;h!=g&&d.IntPoint.op_Equality(h.Pt,a.OffPt);)h=h.Next;if(f==h.Pt.Y>a.OffPt.Y)return!1;f?(f=this.DupOutPt(e,!1),h=this.DupOutPt(g,!0),e.Prev=g,g.Next=e,f.Next=h,h.Prev=f):(f=this.DupOutPt(e,!0),h=this.DupOutPt(g,!1),e.Next=g,g.Prev=e,f.Prev=h,
h.Next=f);a.OutPt1=e;a.OutPt2=f;return!0}if(h){for(f=e;e.Prev.Pt.Y==e.Pt.Y&&e.Prev!=f&&e.Prev!=g;)e=e.Prev;for(;f.Next.Pt.Y==f.Pt.Y&&f.Next!=e&&f.Next!=g;)f=f.Next;if(f.Next==e||f.Next==g)return!1;for(h=g;g.Prev.Pt.Y==g.Pt.Y&&g.Prev!=h&&g.Prev!=f;)g=g.Prev;for(;h.Next.Pt.Y==h.Pt.Y&&h.Next!=g&&h.Next!=e;)h=h.Next;if(h.Next==g||h.Next==e)return!1;c={Left:null,Right:null};if(!this.GetOverlap(e.Pt.X,f.Pt.X,g.Pt.X,h.Pt.X,c))return!1;b=c.Left;var l=c.Right;c=new d.IntPoint;e.Pt.X>=b&&e.Pt.X<=l?(c.X=e.Pt.X,
c.Y=e.Pt.Y,b=e.Pt.X>f.Pt.X):g.Pt.X>=b&&g.Pt.X<=l?(c.X=g.Pt.X,c.Y=g.Pt.Y,b=g.Pt.X>h.Pt.X):f.Pt.X>=b&&f.Pt.X<=l?(c.X=f.Pt.X,c.Y=f.Pt.Y,b=f.Pt.X>e.Pt.X):(c.X=h.Pt.X,c.Y=h.Pt.Y,b=h.Pt.X>g.Pt.X);a.OutPt1=e;a.OutPt2=g;return this.JoinHorz(e,f,g,h,c,b)}for(f=e.Next;d.IntPoint.op_Equality(f.Pt,e.Pt)&&f!=e;)f=f.Next;if(l=f.Pt.Y>e.Pt.Y||!d.ClipperBase.SlopesEqual(e.Pt,f.Pt,a.OffPt,this.m_UseFullRange)){for(f=e.Prev;d.IntPoint.op_Equality(f.Pt,e.Pt)&&f!=e;)f=f.Prev;if(f.Pt.Y>e.Pt.Y||!d.ClipperBase.SlopesEqual(e.Pt,
f.Pt,a.OffPt,this.m_UseFullRange))return!1}for(h=g.Next;d.IntPoint.op_Equality(h.Pt,g.Pt)&&h!=g;)h=h.Next;var k=h.Pt.Y>g.Pt.Y||!d.ClipperBase.SlopesEqual(g.Pt,h.Pt,a.OffPt,this.m_UseFullRange);if(k){for(h=g.Prev;d.IntPoint.op_Equality(h.Pt,g.Pt)&&h!=g;)h=h.Prev;if(h.Pt.Y>g.Pt.Y||!d.ClipperBase.SlopesEqual(g.Pt,h.Pt,a.OffPt,this.m_UseFullRange))return!1}if(f==e||h==g||f==h||b==c&&l==k)return!1;l?(f=this.DupOutPt(e,!1),h=this.DupOutPt(g,!0),e.Prev=g,g.Next=e,f.Next=h,h.Prev=f):(f=this.DupOutPt(e,!0),
h=this.DupOutPt(g,!1),e.Next=g,g.Prev=e,f.Prev=h,h.Next=f);a.OutPt1=e;a.OutPt2=f;return!0};d.Clipper.GetBounds=function(a){for(var b=0,c=a.length;b<c&&0==a[b].length;)b++;if(b==c)return new d.IntRect(0,0,0,0);var e=new d.IntRect;e.left=a[b][0].X;e.right=e.left;e.top=a[b][0].Y;for(e.bottom=e.top;b<c;b++)for(var f=0,g=a[b].length;f<g;f++)a[b][f].X<e.left?e.left=a[b][f].X:a[b][f].X>e.right&&(e.right=a[b][f].X),a[b][f].Y<e.top?e.top=a[b][f].Y:a[b][f].Y>e.bottom&&(e.bottom=a[b][f].Y);return e};d.Clipper.prototype.GetBounds2=
function(a){var b=a,c=new d.IntRect;c.left=a.Pt.X;c.right=a.Pt.X;c.top=a.Pt.Y;c.bottom=a.Pt.Y;for(a=a.Next;a!=b;)a.Pt.X<c.left&&(c.left=a.Pt.X),a.Pt.X>c.right&&(c.right=a.Pt.X),a.Pt.Y<c.top&&(c.top=a.Pt.Y),a.Pt.Y>c.bottom&&(c.bottom=a.Pt.Y),a=a.Next;return c};d.Clipper.PointInPolygon=function(a,b){var c=0,e=b.length;if(3>e)return 0;for(var d=b[0],g=1;g<=e;++g){var h=g==e?b[0]:b[g];if(h.Y==a.Y&&(h.X==a.X||d.Y==a.Y&&h.X>a.X==d.X<a.X))return-1;if(d.Y<a.Y!=h.Y<a.Y)if(d.X>=a.X)if(h.X>a.X)c=1-c;else{var l=
(d.X-a.X)*(h.Y-a.Y)-(h.X-a.X)*(d.Y-a.Y);if(0==l)return-1;0<l==h.Y>d.Y&&(c=1-c)}else if(h.X>a.X){l=(d.X-a.X)*(h.Y-a.Y)-(h.X-a.X)*(d.Y-a.Y);if(0==l)return-1;0<l==h.Y>d.Y&&(c=1-c)}d=h}return c};d.Clipper.prototype.PointInPolygon=function(a,b){for(var c=0,e=b;;){var d=b.Pt.X,g=b.Pt.Y,h=b.Next.Pt.X,l=b.Next.Pt.Y;if(l==a.Y&&(h==a.X||g==a.Y&&h>a.X==d<a.X))return-1;if(g<a.Y!=l<a.Y)if(d>=a.X)if(h>a.X)c=1-c;else{d=(d-a.X)*(l-a.Y)-(h-a.X)*(g-a.Y);if(0==d)return-1;0<d==l>g&&(c=1-c)}else if(h>a.X){d=(d-a.X)*(l-
a.Y)-(h-a.X)*(g-a.Y);if(0==d)return-1;0<d==l>g&&(c=1-c)}b=b.Next;if(e==b)break}return c};d.Clipper.prototype.Poly2ContainsPoly1=function(a,b){var c=a;do{var e=this.PointInPolygon(c.Pt,b);if(0<=e)return 0!=e;c=c.Next}while(c!=a);return!0};d.Clipper.prototype.FixupFirstLefts1=function(a,b){for(var c=0,e=this.m_PolyOuts.length;c<e;c++){var d=this.m_PolyOuts[c];null!==d.Pts&&d.FirstLeft==a&&this.Poly2ContainsPoly1(d.Pts,b.Pts)&&(d.FirstLeft=b)}};d.Clipper.prototype.FixupFirstLefts2=function(a,b){for(var c=
0,e=this.m_PolyOuts,d=e.length,g=e[c];c<d;c++,g=e[c])g.FirstLeft==a&&(g.FirstLeft=b)};d.Clipper.ParseFirstLeft=function(a){for(;null!=a&&null==a.Pts;)a=a.FirstLeft;return a};d.Clipper.prototype.JoinCommonEdges=function(){for(var a=0,b=this.m_Joins.length;a<b;a++){var c=this.m_Joins[a],e=this.GetOutRec(c.OutPt1.Idx),f=this.GetOutRec(c.OutPt2.Idx);if(null!=e.Pts&&null!=f.Pts){var g;g=e==f?e:this.Param1RightOfParam2(e,f)?f:this.Param1RightOfParam2(f,e)?e:this.GetLowermostRec(e,f);if(this.JoinPoints(c,
e,f))if(e==f){e.Pts=c.OutPt1;e.BottomPt=null;f=this.CreateOutRec();f.Pts=c.OutPt2;this.UpdateOutPtIdxs(f);if(this.m_UsingPolyTree){g=0;for(var h=this.m_PolyOuts.length;g<h-1;g++){var l=this.m_PolyOuts[g];null!=l.Pts&&d.Clipper.ParseFirstLeft(l.FirstLeft)==e&&l.IsHole!=e.IsHole&&this.Poly2ContainsPoly1(l.Pts,c.OutPt2)&&(l.FirstLeft=f)}}this.Poly2ContainsPoly1(f.Pts,e.Pts)?(f.IsHole=!e.IsHole,f.FirstLeft=e,this.m_UsingPolyTree&&this.FixupFirstLefts2(f,e),(f.IsHole^this.ReverseSolution)==0<this.Area(f)&&
this.ReversePolyPtLinks(f.Pts)):this.Poly2ContainsPoly1(e.Pts,f.Pts)?(f.IsHole=e.IsHole,e.IsHole=!f.IsHole,f.FirstLeft=e.FirstLeft,e.FirstLeft=f,this.m_UsingPolyTree&&this.FixupFirstLefts2(e,f),(e.IsHole^this.ReverseSolution)==0<this.Area(e)&&this.ReversePolyPtLinks(e.Pts)):(f.IsHole=e.IsHole,f.FirstLeft=e.FirstLeft,this.m_UsingPolyTree&&this.FixupFirstLefts1(e,f))}else f.Pts=null,f.BottomPt=null,f.Idx=e.Idx,e.IsHole=g.IsHole,g==f&&(e.FirstLeft=f.FirstLeft),f.FirstLeft=e,this.m_UsingPolyTree&&this.FixupFirstLefts2(f,
e)}}};d.Clipper.prototype.UpdateOutPtIdxs=function(a){var b=a.Pts;do b.Idx=a.Idx,b=b.Prev;while(b!=a.Pts)};d.Clipper.prototype.DoSimplePolygons=function(){for(var a=0;a<this.m_PolyOuts.length;){var b=this.m_PolyOuts[a++],c=b.Pts;if(null!==c){do{for(var e=c.Next;e!=b.Pts;){if(d.IntPoint.op_Equality(c.Pt,e.Pt)&&e.Next!=c&&e.Prev!=c){var f=c.Prev,g=e.Prev;c.Prev=g;g.Next=c;e.Prev=f;f.Next=e;b.Pts=c;f=this.CreateOutRec();f.Pts=e;this.UpdateOutPtIdxs(f);this.Poly2ContainsPoly1(f.Pts,b.Pts)?(f.IsHole=!b.IsHole,
f.FirstLeft=b):this.Poly2ContainsPoly1(b.Pts,f.Pts)?(f.IsHole=b.IsHole,b.IsHole=!f.IsHole,f.FirstLeft=b.FirstLeft,b.FirstLeft=f):(f.IsHole=b.IsHole,f.FirstLeft=b.FirstLeft);e=c}e=e.Next}c=c.Next}while(c!=b.Pts)}}};d.Clipper.Area=function(a){var b=a.length;if(3>b)return 0;for(var c=0,e=0,d=b-1;e<b;++e)c+=(a[d].X+a[e].X)*(a[d].Y-a[e].Y),d=e;return 0.5*-c};d.Clipper.prototype.Area=function(a){var b=a.Pts;if(null==b)return 0;var c=0;do c+=(b.Prev.Pt.X+b.Pt.X)*(b.Prev.Pt.Y-b.Pt.Y),b=b.Next;while(b!=a.Pts);
return 0.5*c};d.Clipper.SimplifyPolygon=function(a,b){var c=[],e=new d.Clipper(0);e.StrictlySimple=!0;e.AddPath(a,d.PolyType.ptSubject,!0);e.Execute(d.ClipType.ctUnion,c,b,b);return c};d.Clipper.SimplifyPolygons=function(a,b){"undefined"==typeof b&&(b=d.PolyFillType.pftEvenOdd);var c=[],e=new d.Clipper(0);e.StrictlySimple=!0;e.AddPaths(a,d.PolyType.ptSubject,!0);e.Execute(d.ClipType.ctUnion,c,b,b);return c};d.Clipper.DistanceSqrd=function(a,b){var c=a.X-b.X,e=a.Y-b.Y;return c*c+e*e};d.Clipper.DistanceFromLineSqrd=
function(a,b,c){var e=b.Y-c.Y;c=c.X-b.X;b=e*b.X+c*b.Y;b=e*a.X+c*a.Y-b;return b*b/(e*e+c*c)};d.Clipper.SlopesNearCollinear=function(a,b,c,e){return d.Clipper.DistanceFromLineSqrd(b,a,c)<e};d.Clipper.PointsAreClose=function(a,b,c){var e=a.X-b.X;a=a.Y-b.Y;return e*e+a*a<=c};d.Clipper.ExcludeOp=function(a){var b=a.Prev;b.Next=a.Next;a.Next.Prev=b;b.Idx=0;return b};d.Clipper.CleanPolygon=function(a,b){"undefined"==typeof b&&(b=1.415);var c=a.length;if(0==c)return[];for(var e=Array(c),f=0;f<c;++f)e[f]=
new d.OutPt;for(f=0;f<c;++f)e[f].Pt=a[f],e[f].Next=e[(f+1)%c],e[f].Next.Prev=e[f],e[f].Idx=0;f=b*b;for(e=e[0];0==e.Idx&&e.Next!=e.Prev;)d.Clipper.PointsAreClose(e.Pt,e.Prev.Pt,f)?(e=d.Clipper.ExcludeOp(e),c--):d.Clipper.PointsAreClose(e.Prev.Pt,e.Next.Pt,f)?(d.Clipper.ExcludeOp(e.Next),e=d.Clipper.ExcludeOp(e),c-=2):d.Clipper.SlopesNearCollinear(e.Prev.Pt,e.Pt,e.Next.Pt,f)?(e=d.Clipper.ExcludeOp(e),c--):(e.Idx=1,e=e.Next);3>c&&(c=0);for(var g=Array(c),f=0;f<c;++f)g[f]=new d.IntPoint(e.Pt),e=e.Next;
return g};d.Clipper.CleanPolygons=function(a,b){for(var c=Array(a.length),e=0,f=a.length;e<f;e++)c[e]=d.Clipper.CleanPolygon(a[e],b);return c};d.Clipper.Minkowski=function(a,b,c,e){var f=e?1:0,g=a.length,h=b.length;e=[];if(c)for(c=0;c<h;c++){for(var l=Array(g),k=0,n=a.length,m=a[k];k<n;k++,m=a[k])l[k]=new d.IntPoint(b[c].X+m.X,b[c].Y+m.Y);e.push(l)}else for(c=0;c<h;c++){l=Array(g);k=0;n=a.length;for(m=a[k];k<n;k++,m=a[k])l[k]=new d.IntPoint(b[c].X-m.X,b[c].Y-m.Y);e.push(l)}a=[];for(c=0;c<h-1+f;c++)for(k=
0;k<g;k++)b=[],b.push(e[c%h][k%g]),b.push(e[(c+1)%h][k%g]),b.push(e[(c+1)%h][(k+1)%g]),b.push(e[c%h][(k+1)%g]),d.Clipper.Orientation(b)||b.reverse(),a.push(b);f=new d.Clipper(0);f.AddPaths(a,d.PolyType.ptSubject,!0);f.Execute(d.ClipType.ctUnion,e,d.PolyFillType.pftNonZero,d.PolyFillType.pftNonZero);return e};d.Clipper.MinkowskiSum=function(){var a=arguments,b=a.length;if(3==b){var c=a[0],e=a[2];return d.Clipper.Minkowski(c,a[1],!0,e)}if(4==b){for(var c=a[0],f=a[1],b=a[2],e=a[3],a=new d.Clipper,g,
h=0,l=f.length;h<l;++h)g=d.Clipper.Minkowski(c,f[h],!0,e),a.AddPaths(g,d.PolyType.ptSubject,!0);e&&a.AddPaths(f,d.PolyType.ptClip,!0);c=new d.Paths;a.Execute(d.ClipType.ctUnion,c,b,b);return c}};d.Clipper.MinkowskiDiff=function(a,b,c){return d.Clipper.Minkowski(a,b,!1,c)};d.Clipper.PolyTreeToPaths=function(a){var b=[];d.Clipper.AddPolyNodeToPaths(a,d.Clipper.NodeType.ntAny,b);return b};d.Clipper.AddPolyNodeToPaths=function(a,b,c){var e=!0;switch(b){case d.Clipper.NodeType.ntOpen:return;case d.Clipper.NodeType.ntClosed:e=
!a.IsOpen}0<a.m_polygon.length&&e&&c.push(a.m_polygon);e=0;a=a.Childs();for(var f=a.length,g=a[e];e<f;e++,g=a[e])d.Clipper.AddPolyNodeToPaths(g,b,c)};d.Clipper.OpenPathsFromPolyTree=function(a){for(var b=new d.Paths,c=0,e=a.ChildCount();c<e;c++)a.Childs()[c].IsOpen&&b.push(a.Childs()[c].m_polygon);return b};d.Clipper.ClosedPathsFromPolyTree=function(a){var b=new d.Paths;d.Clipper.AddPolyNodeToPaths(a,d.Clipper.NodeType.ntClosed,b);return b};K(d.Clipper,d.ClipperBase);d.Clipper.NodeType={ntAny:0,ntOpen:1,
ntClosed:2};d.ClipperOffset=function(a,b){"undefined"==typeof a&&(a=2);"undefined"==typeof b&&(b=d.ClipperOffset.def_arc_tolerance);this.m_destPolys=new d.Paths;this.m_srcPoly=new d.Path;this.m_destPoly=new d.Path;this.m_normals=[];this.m_StepsPerRad=this.m_miterLim=this.m_cos=this.m_sin=this.m_sinA=this.m_delta=0;this.m_lowest=new d.IntPoint;this.m_polyNodes=new d.PolyNode;this.MiterLimit=a;this.ArcTolerance=b;this.m_lowest.X=-1};d.ClipperOffset.two_pi=6.28318530717959;d.ClipperOffset.def_arc_tolerance=
0.25;d.ClipperOffset.prototype.Clear=function(){d.Clear(this.m_polyNodes.Childs());this.m_lowest.X=-1};d.ClipperOffset.Round=d.Clipper.Round;d.ClipperOffset.prototype.AddPath=function(a,b,c){var e=a.length-1;if(!(0>e)){var f=new d.PolyNode;f.m_jointype=b;f.m_endtype=c;if(c==d.EndType.etClosedLine||c==d.EndType.etClosedPolygon)for(;0<e&&d.IntPoint.op_Equality(a[0],a[e]);)e--;f.m_polygon.push(a[0]);var g=0;b=0;for(var h=1;h<=e;h++)d.IntPoint.op_Inequality(f.m_polygon[g],a[h])&&(g++,f.m_polygon.push(a[h]),
a[h].Y>f.m_polygon[b].Y||a[h].Y==f.m_polygon[b].Y&&a[h].X<f.m_polygon[b].X)&&(b=g);if(!(c==d.EndType.etClosedPolygon&&2>g||c!=d.EndType.etClosedPolygon&&0>g)&&(this.m_polyNodes.AddChild(f),c==d.EndType.etClosedPolygon))if(0>this.m_lowest.X)this.m_lowest=new d.IntPoint(0,b);else if(a=this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y],f.m_polygon[b].Y>a.Y||f.m_polygon[b].Y==a.Y&&f.m_polygon[b].X<a.X)this.m_lowest=new d.IntPoint(this.m_polyNodes.ChildCount()-1,b)}};d.ClipperOffset.prototype.AddPaths=
function(a,b,c){for(var e=0,d=a.length;e<d;e++)this.AddPath(a[e],b,c)};d.ClipperOffset.prototype.FixOrientations=function(){if(0<=this.m_lowest.X&&!d.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))for(var a=0;a<this.m_polyNodes.ChildCount();a++){var b=this.m_polyNodes.Childs()[a];(b.m_endtype==d.EndType.etClosedPolygon||b.m_endtype==d.EndType.etClosedLine&&d.Clipper.Orientation(b.m_polygon))&&b.m_polygon.reverse()}else for(a=0;a<this.m_polyNodes.ChildCount();a++)b=this.m_polyNodes.Childs()[a],
b.m_endtype!=d.EndType.etClosedLine||d.Clipper.Orientation(b.m_polygon)||b.m_polygon.reverse()};d.ClipperOffset.GetUnitNormal=function(a,b){var c=b.X-a.X,e=b.Y-a.Y;if(0==c&&0==e)return new d.DoublePoint(0,0);var f=1/Math.sqrt(c*c+e*e);return new d.DoublePoint(e*f,-(c*f))};d.ClipperOffset.prototype.DoOffset=function(a){this.m_destPolys=[];this.m_delta=a;if(d.ClipperBase.near_zero(a))for(var b=0;b<this.m_polyNodes.ChildCount();b++){var c=this.m_polyNodes.Childs()[b];c.m_endtype==d.EndType.etClosedPolygon&&
this.m_destPolys.push(c.m_polygon)}else{this.m_miterLim=2<this.MiterLimit?2/(this.MiterLimit*this.MiterLimit):0.5;var b=0>=this.ArcTolerance?d.ClipperOffset.def_arc_tolerance:this.ArcTolerance>Math.abs(a)*d.ClipperOffset.def_arc_tolerance?Math.abs(a)*d.ClipperOffset.def_arc_tolerance:this.ArcTolerance,e=3.14159265358979/Math.acos(1-b/Math.abs(a));this.m_sin=Math.sin(d.ClipperOffset.two_pi/e);this.m_cos=Math.cos(d.ClipperOffset.two_pi/e);this.m_StepsPerRad=e/d.ClipperOffset.two_pi;0>a&&(this.m_sin=
-this.m_sin);for(b=0;b<this.m_polyNodes.ChildCount();b++){c=this.m_polyNodes.Childs()[b];this.m_srcPoly=c.m_polygon;var f=this.m_srcPoly.length;if(!(0==f||0>=a&&(3>f||c.m_endtype!=d.EndType.etClosedPolygon))){this.m_destPoly=[];if(1==f)if(c.m_jointype==d.JoinType.jtRound)for(var c=1,f=0,g=1;g<=e;g++){this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[0].X+c*a),d.ClipperOffset.Round(this.m_srcPoly[0].Y+f*a)));var h=c,c=c*this.m_cos-this.m_sin*f,f=h*this.m_sin+f*this.m_cos}else for(f=
c=-1,g=0;4>g;++g)this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[0].X+c*a),d.ClipperOffset.Round(this.m_srcPoly[0].Y+f*a))),0>c?c=1:0>f?f=1:c=-1;else{for(g=this.m_normals.length=0;g<f-1;g++)this.m_normals.push(d.ClipperOffset.GetUnitNormal(this.m_srcPoly[g],this.m_srcPoly[g+1]));c.m_endtype==d.EndType.etClosedLine||c.m_endtype==d.EndType.etClosedPolygon?this.m_normals.push(d.ClipperOffset.GetUnitNormal(this.m_srcPoly[f-1],this.m_srcPoly[0])):this.m_normals.push(new d.DoublePoint(this.m_normals[f-
2]));if(c.m_endtype==d.EndType.etClosedPolygon)for(h=f-1,g=0;g<f;g++)h=this.OffsetPoint(g,h,c.m_jointype);else if(c.m_endtype==d.EndType.etClosedLine){h=f-1;for(g=0;g<f;g++)h=this.OffsetPoint(g,h,c.m_jointype);this.m_destPolys.push(this.m_destPoly);this.m_destPoly=[];h=this.m_normals[f-1];for(g=f-1;0<g;g--)this.m_normals[g]=new d.DoublePoint(-this.m_normals[g-1].X,-this.m_normals[g-1].Y);this.m_normals[0]=new d.DoublePoint(-h.X,-h.Y);h=0;for(g=f-1;0<=g;g--)h=this.OffsetPoint(g,h,c.m_jointype)}else{h=
0;for(g=1;g<f-1;++g)h=this.OffsetPoint(g,h,c.m_jointype);c.m_endtype==d.EndType.etOpenButt?(g=f-1,h=new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[g].X+this.m_normals[g].X*a),d.ClipperOffset.Round(this.m_srcPoly[g].Y+this.m_normals[g].Y*a)),this.m_destPoly.push(h),h=new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[g].X-this.m_normals[g].X*a),d.ClipperOffset.Round(this.m_srcPoly[g].Y-this.m_normals[g].Y*a)),this.m_destPoly.push(h)):(g=f-1,h=f-2,this.m_sinA=0,this.m_normals[g]=new d.DoublePoint(-this.m_normals[g].X,
-this.m_normals[g].Y),c.m_endtype==d.EndType.etOpenSquare?this.DoSquare(g,h):this.DoRound(g,h));for(g=f-1;0<g;g--)this.m_normals[g]=new d.DoublePoint(-this.m_normals[g-1].X,-this.m_normals[g-1].Y);this.m_normals[0]=new d.DoublePoint(-this.m_normals[1].X,-this.m_normals[1].Y);h=f-1;for(g=h-1;0<g;--g)h=this.OffsetPoint(g,h,c.m_jointype);c.m_endtype==d.EndType.etOpenButt?(h=new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[0].X-this.m_normals[0].X*a),d.ClipperOffset.Round(this.m_srcPoly[0].Y-this.m_normals[0].Y*
a)),this.m_destPoly.push(h),h=new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[0].X+this.m_normals[0].X*a),d.ClipperOffset.Round(this.m_srcPoly[0].Y+this.m_normals[0].Y*a)),this.m_destPoly.push(h)):(this.m_sinA=0,c.m_endtype==d.EndType.etOpenSquare?this.DoSquare(0,1):this.DoRound(0,1))}}this.m_destPolys.push(this.m_destPoly)}}}};d.ClipperOffset.prototype.Execute=function(){var a=arguments;if(a[0]instanceof d.PolyTree)if(b=a[0],c=a[1],b.Clear(),this.FixOrientations(),this.DoOffset(c),a=new d.Clipper(0),
a.AddPaths(this.m_destPolys,d.PolyType.ptSubject,!0),0<c)a.Execute(d.ClipType.ctUnion,b,d.PolyFillType.pftPositive,d.PolyFillType.pftPositive);else if(c=d.Clipper.GetBounds(this.m_destPolys),e=new d.Path,e.push(new d.IntPoint(c.left-10,c.bottom+10)),e.push(new d.IntPoint(c.right+10,c.bottom+10)),e.push(new d.IntPoint(c.right+10,c.top-10)),e.push(new d.IntPoint(c.left-10,c.top-10)),a.AddPath(e,d.PolyType.ptSubject,!0),a.ReverseSolution=!0,a.Execute(d.ClipType.ctUnion,b,d.PolyFillType.pftNegative,d.PolyFillType.pftNegative),
1==b.ChildCount()&&0<b.Childs()[0].ChildCount())for(a=b.Childs()[0],b.Childs()[0]=a.Childs()[0],c=1;c<a.ChildCount();c++)b.AddChild(a.Childs()[c]);else b.Clear();else{var b=a[0],c=a[1];d.Clear(b);this.FixOrientations();this.DoOffset(c);a=new d.Clipper(0);a.AddPaths(this.m_destPolys,d.PolyType.ptSubject,!0);if(0<c)a.Execute(d.ClipType.ctUnion,b,d.PolyFillType.pftPositive,d.PolyFillType.pftPositive);else{var c=d.Clipper.GetBounds(this.m_destPolys),e=new d.Path;e.push(new d.IntPoint(c.left-10,c.bottom+
10));e.push(new d.IntPoint(c.right+10,c.bottom+10));e.push(new d.IntPoint(c.right+10,c.top-10));e.push(new d.IntPoint(c.left-10,c.top-10));a.AddPath(e,d.PolyType.ptSubject,!0);a.ReverseSolution=!0;a.Execute(d.ClipType.ctUnion,b,d.PolyFillType.pftNegative,d.PolyFillType.pftNegative);0<b.length&&b.splice(0,1)}}};d.ClipperOffset.prototype.OffsetPoint=function(a,b,c){this.m_sinA=this.m_normals[b].X*this.m_normals[a].Y-this.m_normals[a].X*this.m_normals[b].Y;if(5E-5>this.m_sinA&&-5E-5<this.m_sinA)return b;
1<this.m_sinA?this.m_sinA=1:-1>this.m_sinA&&(this.m_sinA=-1);if(0>this.m_sinA*this.m_delta)this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[a].X+this.m_normals[b].X*this.m_delta),d.ClipperOffset.Round(this.m_srcPoly[a].Y+this.m_normals[b].Y*this.m_delta))),this.m_destPoly.push(new d.IntPoint(this.m_srcPoly[a])),this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[a].X+this.m_normals[a].X*this.m_delta),d.ClipperOffset.Round(this.m_srcPoly[a].Y+this.m_normals[a].Y*
this.m_delta)));else switch(c){case d.JoinType.jtMiter:c=1+(this.m_normals[a].X*this.m_normals[b].X+this.m_normals[a].Y*this.m_normals[b].Y);c>=this.m_miterLim?this.DoMiter(a,b,c):this.DoSquare(a,b);break;case d.JoinType.jtSquare:this.DoSquare(a,b);break;case d.JoinType.jtRound:this.DoRound(a,b)}return a};d.ClipperOffset.prototype.DoSquare=function(a,b){var c=Math.tan(Math.atan2(this.m_sinA,this.m_normals[b].X*this.m_normals[a].X+this.m_normals[b].Y*this.m_normals[a].Y)/4);this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[a].X+
this.m_delta*(this.m_normals[b].X-this.m_normals[b].Y*c)),d.ClipperOffset.Round(this.m_srcPoly[a].Y+this.m_delta*(this.m_normals[b].Y+this.m_normals[b].X*c))));this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[a].X+this.m_delta*(this.m_normals[a].X+this.m_normals[a].Y*c)),d.ClipperOffset.Round(this.m_srcPoly[a].Y+this.m_delta*(this.m_normals[a].Y-this.m_normals[a].X*c))))};d.ClipperOffset.prototype.DoMiter=function(a,b,c){c=this.m_delta/c;this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[a].X+
(this.m_normals[b].X+this.m_normals[a].X)*c),d.ClipperOffset.Round(this.m_srcPoly[a].Y+(this.m_normals[b].Y+this.m_normals[a].Y)*c)))};d.ClipperOffset.prototype.DoRound=function(a,b){for(var c=Math.atan2(this.m_sinA,this.m_normals[b].X*this.m_normals[a].X+this.m_normals[b].Y*this.m_normals[a].Y),c=d.Cast_Int32(d.ClipperOffset.Round(this.m_StepsPerRad*Math.abs(c))),e=this.m_normals[b].X,f=this.m_normals[b].Y,g,h=0;h<c;++h)this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[a].X+
e*this.m_delta),d.ClipperOffset.Round(this.m_srcPoly[a].Y+f*this.m_delta))),g=e,e=e*this.m_cos-this.m_sin*f,f=g*this.m_sin+f*this.m_cos;this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[a].X+this.m_normals[a].X*this.m_delta),d.ClipperOffset.Round(this.m_srcPoly[a].Y+this.m_normals[a].Y*this.m_delta)))};d.Error=function(a){try{throw Error(a);}catch(b){alert(b.message)}};d.JS={};d.JS.AreaOfPolygon=function(a,b){b||(b=1);return d.Clipper.Area(a)/(b*b)};d.JS.AreaOfPolygons=function(a,
b){b||(b=1);for(var c=0,e=0;e<a.length;e++)c+=d.Clipper.Area(a[e]);return c/(b*b)};d.JS.BoundsOfPath=function(a,b){return d.JS.BoundsOfPaths([a],b)};d.JS.BoundsOfPaths=function(a,b){b||(b=1);var c=d.Clipper.GetBounds(a);c.left/=b;c.bottom/=b;c.right/=b;c.top/=b;return c};d.JS.Clean=function(a,b){if(!(a instanceof Array))return[];var c=a[0]instanceof Array;a=d.JS.Clone(a);if("number"!=typeof b||null===b)return d.Error("Delta is not a number in Clean()."),a;if(0===a.length||1==a.length&&0===a[0].length||
0>b)return a;c||(a=[a]);for(var e=a.length,f,g,h,l,k,n,m,p=[],q=0;q<e;q++)if(g=a[q],f=g.length,0!==f)if(3>f)h=g,p.push(h);else{h=g;l=b*b;k=g[0];for(m=n=1;m<f;m++)(g[m].X-k.X)*(g[m].X-k.X)+(g[m].Y-k.Y)*(g[m].Y-k.Y)<=l||(h[n]=g[m],k=g[m],n++);k=g[n-1];(g[0].X-k.X)*(g[0].X-k.X)+(g[0].Y-k.Y)*(g[0].Y-k.Y)<=l&&n--;n<f&&h.splice(n,f-n);h.length&&p.push(h)}!c&&p.length?p=p[0]:c||0!==p.length?c&&0===p.length&&(p=[[]]):p=[];return p};d.JS.Clone=function(a){if(!(a instanceof Array)||0===a.length)return[];if(1==
a.length&&0===a[0].length)return[[]];var b=a[0]instanceof Array;b||(a=[a]);var c=a.length,e,d,g,h,l=Array(c);for(d=0;d<c;d++){e=a[d].length;h=Array(e);for(g=0;g<e;g++)h[g]={X:a[d][g].X,Y:a[d][g].Y};l[d]=h}b||(l=l[0]);return l};d.JS.Lighten=function(a,b){if(!(a instanceof Array))return[];if("number"!=typeof b||null===b)return d.Error("Tolerance is not a number in Lighten()."),d.JS.Clone(a);if(0===a.length||1==a.length&&0===a[0].length||0>b)return d.JS.Clone(a);a[0]instanceof Array||(a=[a]);var c,e,
f,g,h,l,k,m,p,q,r,s,t,u,v,x=a.length,y=b*b,w=[];for(c=0;c<x;c++)if(f=a[c],l=f.length,0!=l){for(g=0;1E6>g;g++){h=[];l=f.length;f[l-1].X!=f[0].X||f[l-1].Y!=f[0].Y?(r=1,f.push({X:f[0].X,Y:f[0].Y}),l=f.length):r=0;q=[];for(e=0;e<l-2;e++){k=f[e];p=f[e+1];m=f[e+2];u=k.X;v=k.Y;k=m.X-u;s=m.Y-v;if(0!==k||0!==s)t=((p.X-u)*k+(p.Y-v)*s)/(k*k+s*s),1<t?(u=m.X,v=m.Y):0<t&&(u+=k*t,v+=s*t);k=p.X-u;s=p.Y-v;m=k*k+s*s;m<=y&&(q[e+1]=1,e++)}h.push({X:f[0].X,Y:f[0].Y});for(e=1;e<l-1;e++)q[e]||h.push({X:f[e].X,Y:f[e].Y});
h.push({X:f[l-1].X,Y:f[l-1].Y});r&&f.pop();if(q.length)f=h;else break}l=h.length;h[l-1].X==h[0].X&&h[l-1].Y==h[0].Y&&h.pop();2<h.length&&w.push(h)}!a[0]instanceof Array&&(w=w[0]);"undefined"==typeof w&&(w=[[]]);return w};d.JS.PerimeterOfPath=function(a,b,c){if("undefined"==typeof a)return 0;var e=Math.sqrt,d=0,g,h,k=0,m=g=0;h=0;var n=a.length;if(2>n)return 0;b&&(a[n]=a[0],n++);for(;--n;)g=a[n],k=g.X,g=g.Y,h=a[n-1],m=h.X,h=h.Y,d+=e((k-m)*(k-m)+(g-h)*(g-h));b&&a.pop();return d/c};d.JS.PerimeterOfPaths=
function(a,b,c){c||(c=1);for(var e=0,f=0;f<a.length;f++)e+=d.JS.PerimeterOfPath(a[f],b,c);return e};d.JS.ScaleDownPath=function(a,b){var c,d;b||(b=1);for(c=a.length;c--;)d=a[c],d.X/=b,d.Y/=b};d.JS.ScaleDownPaths=function(a,b){var c,d,f;b||(b=1);for(c=a.length;c--;)for(d=a[c].length;d--;)f=a[c][d],f.X/=b,f.Y/=b};d.JS.ScaleUpPath=function(a,b){var c,d,f=Math.round;b||(b=1);for(c=a.length;c--;)d=a[c],d.X=f(d.X*b),d.Y=f(d.Y*b)};d.JS.ScaleUpPaths=function(a,b){var c,d,f,g=Math.round;b||(b=1);for(c=a.length;c--;)for(d=
a[c].length;d--;)f=a[c][d],f.X=g(f.X*b),f.Y=g(f.Y*b)};d.ExPolygons=function(){return[]};d.ExPolygon=function(){this.holes=this.outer=null};d.JS.AddOuterPolyNodeToExPolygons=function(a,b){var c=new d.ExPolygon;c.outer=a.Contour();var e=a.Childs(),f=e.length;c.holes=Array(f);var g,h,k,m,n;for(h=0;h<f;h++)for(g=e[h],c.holes[h]=g.Contour(),k=0,m=g.Childs(),n=m.length;k<n;k++)g=m[k],d.JS.AddOuterPolyNodeToExPolygons(g,b);b.push(c)};d.JS.ExPolygonsToPaths=function(a){var b,c,e,f,g=new d.Paths;b=0;for(e=
a.length;b<e;b++)for(g.push(a[b].outer),c=0,f=a[b].holes.length;c<f;c++)g.push(a[b].holes[c]);return g};d.JS.PolyTreeToExPolygons=function(a){var b=new d.ExPolygons,c,e,f;c=0;e=a.Childs();for(f=e.length;c<f;c++)a=e[c],d.JS.AddOuterPolyNodeToExPolygons(a,b);return b}})();

; browserify_shim__define__module__export__(typeof ClipperLib != "undefined" ? ClipperLib : window.ClipperLib);

}).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round
;(function() {
  /**
   * Decimal adjustment of a number.
   *
   * @param {String}  type  The type of adjustment.
   * @param {Number}  value The number.
   * @param {Integer} exp   The exponent (the 10 logarithm of the adjustment base).
   * @returns {Number} The adjusted value.
   */
  function decimalAdjust(type, value, exp) {
    // If the exp is undefined or zero...
    if (typeof exp === 'undefined' || +exp === 0) {
      return Math[type](value);
    }
    value = +value;
    exp = +exp;
    // If the value is not a number or the exp is not an integer...
    if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
      return NaN;
    }
    // Shift
    value = value.toString().split('e');
    value = Math[type](+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));
    // Shift back
    value = value.toString().split('e');
    return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));
  }

  // Decimal round
  if (!Math.round10) {
    Math.round10 = function(value, exp) {
      return decimalAdjust('round', value, exp);
    };
  }
  // Decimal floor
  if (!Math.floor10) {
    Math.floor10 = function(value, exp) {
      return decimalAdjust('floor', value, exp);
    };
  }
  // Decimal ceil
  if (!Math.ceil10) {
    Math.ceil10 = function(value, exp) {
      return decimalAdjust('ceil', value, exp);
    };
  }
})();

},{}],3:[function(require,module,exports){
(function (global){
/*! poly2tri v1.3.5 | (c) 2009-2014 Poly2Tri Contributors */
!function(t){if("object"==typeof exports)module.exports=t();else if("function"==typeof define&&define.amd)define(t);else{var n;"undefined"!=typeof window?n=window:"undefined"!=typeof global?n=global:"undefined"!=typeof self&&(n=self),n.poly2tri=t()}}(function(){return function t(n,e,i){function o(s,p){if(!e[s]){if(!n[s]){var a="function"==typeof require&&require;if(!p&&a)return a(s,!0);if(r)return r(s,!0);throw new Error("Cannot find module '"+s+"'")}var h=e[s]={exports:{}};n[s][0].call(h.exports,function(t){var e=n[s][1][t];return o(e?e:t)},h,h.exports,t,n,e,i)}return e[s].exports}for(var r="function"==typeof require&&require,s=0;s<i.length;s++)o(i[s]);return o}({1:[function(t,n){n.exports={version:"1.3.5"}},{}],2:[function(t,n){"use strict";var e=function(t,n){this.point=t,this.triangle=n||null,this.next=null,this.prev=null,this.value=t.x},i=function(t,n){this.head_=t,this.tail_=n,this.search_node_=t};i.prototype.head=function(){return this.head_},i.prototype.setHead=function(t){this.head_=t},i.prototype.tail=function(){return this.tail_},i.prototype.setTail=function(t){this.tail_=t},i.prototype.search=function(){return this.search_node_},i.prototype.setSearch=function(t){this.search_node_=t},i.prototype.findSearchNode=function(){return this.search_node_},i.prototype.locateNode=function(t){var n=this.search_node_;if(t<n.value){for(;n=n.prev;)if(t>=n.value)return this.search_node_=n,n}else for(;n=n.next;)if(t<n.value)return this.search_node_=n.prev,n.prev;return null},i.prototype.locatePoint=function(t){var n=t.x,e=this.findSearchNode(n),i=e.point.x;if(n===i){if(t!==e.point)if(t===e.prev.point)e=e.prev;else{if(t!==e.next.point)throw new Error("poly2tri Invalid AdvancingFront.locatePoint() call");e=e.next}}else if(i>n)for(;(e=e.prev)&&t!==e.point;);else for(;(e=e.next)&&t!==e.point;);return e&&(this.search_node_=e),e},n.exports=i,n.exports.Node=e},{}],3:[function(t,n){"use strict";function e(t,n){if(!t)throw new Error(n||"Assert Failed")}n.exports=e},{}],4:[function(t,n){"use strict";var e=t("./xy"),i=function(t,n){this.x=+t||0,this.y=+n||0,this._p2t_edge_list=null};i.prototype.toString=function(){return e.toStringBase(this)},i.prototype.toJSON=function(){return{x:this.x,y:this.y}},i.prototype.clone=function(){return new i(this.x,this.y)},i.prototype.set_zero=function(){return this.x=0,this.y=0,this},i.prototype.set=function(t,n){return this.x=+t||0,this.y=+n||0,this},i.prototype.negate=function(){return this.x=-this.x,this.y=-this.y,this},i.prototype.add=function(t){return this.x+=t.x,this.y+=t.y,this},i.prototype.sub=function(t){return this.x-=t.x,this.y-=t.y,this},i.prototype.mul=function(t){return this.x*=t,this.y*=t,this},i.prototype.length=function(){return Math.sqrt(this.x*this.x+this.y*this.y)},i.prototype.normalize=function(){var t=this.length();return this.x/=t,this.y/=t,t},i.prototype.equals=function(t){return this.x===t.x&&this.y===t.y},i.negate=function(t){return new i(-t.x,-t.y)},i.add=function(t,n){return new i(t.x+n.x,t.y+n.y)},i.sub=function(t,n){return new i(t.x-n.x,t.y-n.y)},i.mul=function(t,n){return new i(t*n.x,t*n.y)},i.cross=function(t,n){return"number"==typeof t?"number"==typeof n?t*n:new i(-t*n.y,t*n.x):"number"==typeof n?new i(n*t.y,-n*t.x):t.x*n.y-t.y*n.x},i.toString=e.toString,i.compare=e.compare,i.cmp=e.compare,i.equals=e.equals,i.dot=function(t,n){return t.x*n.x+t.y*n.y},n.exports=i},{"./xy":11}],5:[function(t,n){"use strict";var e=t("./xy"),i=function(t,n){this.name="PointError",this.points=n=n||[],this.message=t||"Invalid Points!";for(var i=0;i<n.length;i++)this.message+=" "+e.toString(n[i])};i.prototype=new Error,i.prototype.constructor=i,n.exports=i},{"./xy":11}],6:[function(t,n,e){(function(n){"use strict";var i=n.poly2tri;e.noConflict=function(){return n.poly2tri=i,e},e.VERSION=t("../dist/version.json").version,e.PointError=t("./pointerror"),e.Point=t("./point"),e.Triangle=t("./triangle"),e.SweepContext=t("./sweepcontext");var o=t("./sweep");e.triangulate=o.triangulate,e.sweep={Triangulate:o.triangulate}}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"../dist/version.json":1,"./point":4,"./pointerror":5,"./sweep":7,"./sweepcontext":8,"./triangle":9}],7:[function(t,n,e){"use strict";function i(t){t.initTriangulation(),t.createAdvancingFront(),o(t),r(t)}function o(t){var n,e=t.pointCount();for(n=1;e>n;++n)for(var i=t.getPoint(n),o=s(t,i),r=i._p2t_edge_list,a=0;r&&a<r.length;++a)p(t,r[a],o)}function r(t){for(var n=t.front().head().next.triangle,e=t.front().head().next.point;!n.getConstrainedEdgeCW(e);)n=n.neighborCCW(e);t.meshClean(n)}function s(t,n){var e=t.locateNode(n),i=u(t,n,e);return n.x<=e.point.x+F&&d(t,e),g(t,i),i}function p(t,n,e){t.edge_event.constrained_edge=n,t.edge_event.right=n.p.x>n.q.x,h(e.triangle,n.p,n.q)||(C(t,n,e),a(t,n.p,n.q,e.triangle,n.q))}function a(t,n,e,i,o){if(!h(i,n,e)){var r=i.pointCCW(o),s=z(e,r,n);if(s===M.COLLINEAR)throw new D("poly2tri EdgeEvent: Collinear not supported!",[e,r,n]);var p=i.pointCW(o),u=z(e,p,n);if(u===M.COLLINEAR)throw new D("poly2tri EdgeEvent: Collinear not supported!",[e,p,n]);s===u?(i=s===M.CW?i.neighborCCW(o):i.neighborCW(o),a(t,n,e,i,o)):q(t,n,e,i,o)}}function h(t,n,e){var i=t.edgeIndex(n,e);if(-1!==i){t.markConstrainedEdgeByIndex(i);var o=t.getNeighbor(i);return o&&o.markConstrainedEdgeByPoints(n,e),!0}return!1}function u(t,n,e){var i=new O(n,e.point,e.next.point);i.markNeighbor(e.triangle),t.addToMap(i);var o=new B(n);return o.next=e.next,o.prev=e,e.next.prev=o,e.next=o,l(t,i)||t.mapTriangleToNodes(i),o}function d(t,n){var e=new O(n.prev.point,n.point,n.next.point);e.markNeighbor(n.prev.triangle),e.markNeighbor(n.triangle),t.addToMap(e),n.prev.next=n.next,n.next.prev=n.prev,l(t,e)||t.mapTriangleToNodes(e)}function g(t,n){for(var e=n.next;e.next&&!j(e.point,e.next.point,e.prev.point);)d(t,e),e=e.next;for(e=n.prev;e.prev&&!j(e.point,e.next.point,e.prev.point);)d(t,e),e=e.prev;n.next&&n.next.next&&f(n)&&y(t,n)}function f(t){var n=t.point.x-t.next.next.point.x,e=t.point.y-t.next.next.point.y;return S(e>=0,"unordered y"),n>=0||Math.abs(n)<e}function l(t,n){for(var e=0;3>e;++e)if(!n.delaunay_edge[e]){var i=n.getNeighbor(e);if(i){var o=n.getPoint(e),r=i.oppositePoint(n,o),s=i.index(r);if(i.constrained_edge[s]||i.delaunay_edge[s]){n.constrained_edge[e]=i.constrained_edge[s];continue}var p=c(o,n.pointCCW(o),n.pointCW(o),r);if(p){n.delaunay_edge[e]=!0,i.delaunay_edge[s]=!0,_(n,o,i,r);var a=!l(t,n);return a&&t.mapTriangleToNodes(n),a=!l(t,i),a&&t.mapTriangleToNodes(i),n.delaunay_edge[e]=!1,i.delaunay_edge[s]=!1,!0}}}return!1}function c(t,n,e,i){var o=t.x-i.x,r=t.y-i.y,s=n.x-i.x,p=n.y-i.y,a=o*p,h=s*r,u=a-h;if(0>=u)return!1;var d=e.x-i.x,g=e.y-i.y,f=d*r,l=o*g,c=f-l;if(0>=c)return!1;var _=s*g,y=d*p,x=o*o+r*r,v=s*s+p*p,C=d*d+g*g,b=x*(_-y)+v*c+C*u;return b>0}function _(t,n,e,i){var o,r,s,p;o=t.neighborCCW(n),r=t.neighborCW(n),s=e.neighborCCW(i),p=e.neighborCW(i);var a,h,u,d;a=t.getConstrainedEdgeCCW(n),h=t.getConstrainedEdgeCW(n),u=e.getConstrainedEdgeCCW(i),d=e.getConstrainedEdgeCW(i);var g,f,l,c;g=t.getDelaunayEdgeCCW(n),f=t.getDelaunayEdgeCW(n),l=e.getDelaunayEdgeCCW(i),c=e.getDelaunayEdgeCW(i),t.legalize(n,i),e.legalize(i,n),e.setDelaunayEdgeCCW(n,g),t.setDelaunayEdgeCW(n,f),t.setDelaunayEdgeCCW(i,l),e.setDelaunayEdgeCW(i,c),e.setConstrainedEdgeCCW(n,a),t.setConstrainedEdgeCW(n,h),t.setConstrainedEdgeCCW(i,u),e.setConstrainedEdgeCW(i,d),t.clearNeighbors(),e.clearNeighbors(),o&&e.markNeighbor(o),r&&t.markNeighbor(r),s&&t.markNeighbor(s),p&&e.markNeighbor(p),t.markNeighbor(e)}function y(t,n){for(t.basin.left_node=z(n.point,n.next.point,n.next.next.point)===M.CCW?n.next.next:n.next,t.basin.bottom_node=t.basin.left_node;t.basin.bottom_node.next&&t.basin.bottom_node.point.y>=t.basin.bottom_node.next.point.y;)t.basin.bottom_node=t.basin.bottom_node.next;if(t.basin.bottom_node!==t.basin.left_node){for(t.basin.right_node=t.basin.bottom_node;t.basin.right_node.next&&t.basin.right_node.point.y<t.basin.right_node.next.point.y;)t.basin.right_node=t.basin.right_node.next;t.basin.right_node!==t.basin.bottom_node&&(t.basin.width=t.basin.right_node.point.x-t.basin.left_node.point.x,t.basin.left_highest=t.basin.left_node.point.y>t.basin.right_node.point.y,x(t,t.basin.bottom_node))}}function x(t,n){if(!v(t,n)){d(t,n);var e;if(n.prev!==t.basin.left_node||n.next!==t.basin.right_node){if(n.prev===t.basin.left_node){if(e=z(n.point,n.next.point,n.next.next.point),e===M.CW)return;n=n.next}else if(n.next===t.basin.right_node){if(e=z(n.point,n.prev.point,n.prev.prev.point),e===M.CCW)return;n=n.prev}else n=n.prev.point.y<n.next.point.y?n.prev:n.next;x(t,n)}}}function v(t,n){var e;return e=t.basin.left_highest?t.basin.left_node.point.y-n.point.y:t.basin.right_node.point.y-n.point.y,t.basin.width>e?!0:!1}function C(t,n,e){t.edge_event.right?b(t,n,e):E(t,n,e)}function b(t,n,e){for(;e.next.point.x<n.p.x;)z(n.q,e.next.point,n.p)===M.CCW?m(t,n,e):e=e.next}function m(t,n,e){e.point.x<n.p.x&&(z(e.point,e.next.point,e.next.next.point)===M.CCW?W(t,n,e):(w(t,n,e),m(t,n,e)))}function W(t,n,e){d(t,e.next),e.next.point!==n.p&&z(n.q,e.next.point,n.p)===M.CCW&&z(e.point,e.next.point,e.next.next.point)===M.CCW&&W(t,n,e)}function w(t,n,e){z(e.next.point,e.next.next.point,e.next.next.next.point)===M.CCW?W(t,n,e.next):z(n.q,e.next.next.point,n.p)===M.CCW&&w(t,n,e.next)}function E(t,n,e){for(;e.prev.point.x>n.p.x;)z(n.q,e.prev.point,n.p)===M.CW?P(t,n,e):e=e.prev}function P(t,n,e){e.point.x>n.p.x&&(z(e.point,e.prev.point,e.prev.prev.point)===M.CW?T(t,n,e):(N(t,n,e),P(t,n,e)))}function N(t,n,e){z(e.prev.point,e.prev.prev.point,e.prev.prev.prev.point)===M.CW?T(t,n,e.prev):z(n.q,e.prev.prev.point,n.p)===M.CW&&N(t,n,e.prev)}function T(t,n,e){d(t,e.prev),e.prev.point!==n.p&&z(n.q,e.prev.point,n.p)===M.CW&&z(e.point,e.prev.point,e.prev.prev.point)===M.CW&&T(t,n,e)}function q(t,n,e,i,o){var r=i.neighborAcross(o);S(r,"FLIP failed due to missing triangle!");var s=r.oppositePoint(i,o);if(i.getConstrainedEdgeAcross(o)){var p=i.index(o);throw new D("poly2tri Intersecting Constraints",[o,s,i.getPoint((p+1)%3),i.getPoint((p+2)%3)])}if(H(o,i.pointCCW(o),i.pointCW(o),s))if(_(i,o,r,s),t.mapTriangleToNodes(i),t.mapTriangleToNodes(r),o===e&&s===n)e===t.edge_event.constrained_edge.q&&n===t.edge_event.constrained_edge.p&&(i.markConstrainedEdgeByPoints(n,e),r.markConstrainedEdgeByPoints(n,e),l(t,i),l(t,r));else{var h=z(e,s,n);i=I(t,h,i,r,o,s),q(t,n,e,i,o)}else{var u=k(n,e,r,s);A(t,n,e,i,r,u),a(t,n,e,i,o)}}function I(t,n,e,i,o,r){var s;return n===M.CCW?(s=i.edgeIndex(o,r),i.delaunay_edge[s]=!0,l(t,i),i.clearDelaunayEdges(),e):(s=e.edgeIndex(o,r),e.delaunay_edge[s]=!0,l(t,e),e.clearDelaunayEdges(),i)}function k(t,n,e,i){var o=z(n,i,t);if(o===M.CW)return e.pointCCW(i);if(o===M.CCW)return e.pointCW(i);throw new D("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!",[n,i,t])}function A(t,n,e,i,o,r){var s=o.neighborAcross(r);S(s,"FLIP failed due to missing triangle");var p=s.oppositePoint(o,r);if(H(e,i.pointCCW(e),i.pointCW(e),p))q(t,e,p,s,p);else{var a=k(n,e,s,p);A(t,n,e,i,s,a)}}var S=t("./assert"),D=t("./pointerror"),O=t("./triangle"),B=t("./advancingfront").Node,L=t("./utils"),F=L.EPSILON,M=L.Orientation,z=L.orient2d,H=L.inScanArea,j=L.isAngleObtuse;e.triangulate=i},{"./advancingfront":2,"./assert":3,"./pointerror":5,"./triangle":9,"./utils":10}],8:[function(t,n){"use strict";var e=t("./pointerror"),i=t("./point"),o=t("./triangle"),r=t("./sweep"),s=t("./advancingfront"),p=s.Node,a=.3,h=function(t,n){if(this.p=t,this.q=n,t.y>n.y)this.q=t,this.p=n;else if(t.y===n.y)if(t.x>n.x)this.q=t,this.p=n;else if(t.x===n.x)throw new e("poly2tri Invalid Edge constructor: repeated points!",[t]);this.q._p2t_edge_list||(this.q._p2t_edge_list=[]),this.q._p2t_edge_list.push(this)},u=function(){this.left_node=null,this.bottom_node=null,this.right_node=null,this.width=0,this.left_highest=!1};u.prototype.clear=function(){this.left_node=null,this.bottom_node=null,this.right_node=null,this.width=0,this.left_highest=!1};var d=function(){this.constrained_edge=null,this.right=!1},g=function(t,n){n=n||{},this.triangles_=[],this.map_=[],this.points_=n.cloneArrays?t.slice(0):t,this.edge_list=[],this.pmin_=this.pmax_=null,this.front_=null,this.head_=null,this.tail_=null,this.af_head_=null,this.af_middle_=null,this.af_tail_=null,this.basin=new u,this.edge_event=new d,this.initEdges(this.points_)};g.prototype.addHole=function(t){this.initEdges(t);var n,e=t.length;for(n=0;e>n;n++)this.points_.push(t[n]);return this},g.prototype.AddHole=g.prototype.addHole,g.prototype.addHoles=function(t){var n,e=t.length;for(n=0;e>n;n++)this.initEdges(t[n]);return this.points_=this.points_.concat.apply(this.points_,t),this},g.prototype.addPoint=function(t){return this.points_.push(t),this},g.prototype.AddPoint=g.prototype.addPoint,g.prototype.addPoints=function(t){return this.points_=this.points_.concat(t),this},g.prototype.triangulate=function(){return r.triangulate(this),this},g.prototype.getBoundingBox=function(){return{min:this.pmin_,max:this.pmax_}},g.prototype.getTriangles=function(){return this.triangles_},g.prototype.GetTriangles=g.prototype.getTriangles,g.prototype.front=function(){return this.front_},g.prototype.pointCount=function(){return this.points_.length},g.prototype.head=function(){return this.head_},g.prototype.setHead=function(t){this.head_=t},g.prototype.tail=function(){return this.tail_},g.prototype.setTail=function(t){this.tail_=t},g.prototype.getMap=function(){return this.map_},g.prototype.initTriangulation=function(){var t,n=this.points_[0].x,e=this.points_[0].x,o=this.points_[0].y,r=this.points_[0].y,s=this.points_.length;for(t=1;s>t;t++){var p=this.points_[t];p.x>n&&(n=p.x),p.x<e&&(e=p.x),p.y>o&&(o=p.y),p.y<r&&(r=p.y)}this.pmin_=new i(e,r),this.pmax_=new i(n,o);var h=a*(n-e),u=a*(o-r);this.head_=new i(n+h,r-u),this.tail_=new i(e-h,r-u),this.points_.sort(i.compare)},g.prototype.initEdges=function(t){var n,e=t.length;for(n=0;e>n;++n)this.edge_list.push(new h(t[n],t[(n+1)%e]))},g.prototype.getPoint=function(t){return this.points_[t]},g.prototype.addToMap=function(t){this.map_.push(t)},g.prototype.locateNode=function(t){return this.front_.locateNode(t.x)},g.prototype.createAdvancingFront=function(){var t,n,e,i=new o(this.points_[0],this.tail_,this.head_);this.map_.push(i),t=new p(i.getPoint(1),i),n=new p(i.getPoint(0),i),e=new p(i.getPoint(2)),this.front_=new s(t,e),t.next=n,n.next=e,n.prev=t,e.prev=n},g.prototype.removeNode=function(){},g.prototype.mapTriangleToNodes=function(t){for(var n=0;3>n;++n)if(!t.getNeighbor(n)){var e=this.front_.locatePoint(t.pointCW(t.getPoint(n)));e&&(e.triangle=t)}},g.prototype.removeFromMap=function(t){var n,e=this.map_,i=e.length;for(n=0;i>n;n++)if(e[n]===t){e.splice(n,1);break}},g.prototype.meshClean=function(t){for(var n,e,i=[t];n=i.pop();)if(!n.isInterior())for(n.setInterior(!0),this.triangles_.push(n),e=0;3>e;e++)n.constrained_edge[e]||i.push(n.getNeighbor(e))},n.exports=g},{"./advancingfront":2,"./point":4,"./pointerror":5,"./sweep":7,"./triangle":9}],9:[function(t,n){"use strict";var e=t("./xy"),i=function(t,n,e){this.points_=[t,n,e],this.neighbors_=[null,null,null],this.interior_=!1,this.constrained_edge=[!1,!1,!1],this.delaunay_edge=[!1,!1,!1]},o=e.toString;i.prototype.toString=function(){return"["+o(this.points_[0])+o(this.points_[1])+o(this.points_[2])+"]"},i.prototype.getPoint=function(t){return this.points_[t]},i.prototype.GetPoint=i.prototype.getPoint,i.prototype.getPoints=function(){return this.points_},i.prototype.getNeighbor=function(t){return this.neighbors_[t]},i.prototype.containsPoint=function(t){var n=this.points_;return t===n[0]||t===n[1]||t===n[2]},i.prototype.containsEdge=function(t){return this.containsPoint(t.p)&&this.containsPoint(t.q)},i.prototype.containsPoints=function(t,n){return this.containsPoint(t)&&this.containsPoint(n)},i.prototype.isInterior=function(){return this.interior_},i.prototype.setInterior=function(t){return this.interior_=t,this},i.prototype.markNeighborPointers=function(t,n,e){var i=this.points_;if(t===i[2]&&n===i[1]||t===i[1]&&n===i[2])this.neighbors_[0]=e;else if(t===i[0]&&n===i[2]||t===i[2]&&n===i[0])this.neighbors_[1]=e;else{if(!(t===i[0]&&n===i[1]||t===i[1]&&n===i[0]))throw new Error("poly2tri Invalid Triangle.markNeighborPointers() call");this.neighbors_[2]=e}},i.prototype.markNeighbor=function(t){var n=this.points_;t.containsPoints(n[1],n[2])?(this.neighbors_[0]=t,t.markNeighborPointers(n[1],n[2],this)):t.containsPoints(n[0],n[2])?(this.neighbors_[1]=t,t.markNeighborPointers(n[0],n[2],this)):t.containsPoints(n[0],n[1])&&(this.neighbors_[2]=t,t.markNeighborPointers(n[0],n[1],this))},i.prototype.clearNeighbors=function(){this.neighbors_[0]=null,this.neighbors_[1]=null,this.neighbors_[2]=null},i.prototype.clearDelaunayEdges=function(){this.delaunay_edge[0]=!1,this.delaunay_edge[1]=!1,this.delaunay_edge[2]=!1},i.prototype.pointCW=function(t){var n=this.points_;return t===n[0]?n[2]:t===n[1]?n[0]:t===n[2]?n[1]:null},i.prototype.pointCCW=function(t){var n=this.points_;return t===n[0]?n[1]:t===n[1]?n[2]:t===n[2]?n[0]:null},i.prototype.neighborCW=function(t){return t===this.points_[0]?this.neighbors_[1]:t===this.points_[1]?this.neighbors_[2]:this.neighbors_[0]},i.prototype.neighborCCW=function(t){return t===this.points_[0]?this.neighbors_[2]:t===this.points_[1]?this.neighbors_[0]:this.neighbors_[1]},i.prototype.getConstrainedEdgeCW=function(t){return t===this.points_[0]?this.constrained_edge[1]:t===this.points_[1]?this.constrained_edge[2]:this.constrained_edge[0]},i.prototype.getConstrainedEdgeCCW=function(t){return t===this.points_[0]?this.constrained_edge[2]:t===this.points_[1]?this.constrained_edge[0]:this.constrained_edge[1]},i.prototype.getConstrainedEdgeAcross=function(t){return t===this.points_[0]?this.constrained_edge[0]:t===this.points_[1]?this.constrained_edge[1]:this.constrained_edge[2]},i.prototype.setConstrainedEdgeCW=function(t,n){t===this.points_[0]?this.constrained_edge[1]=n:t===this.points_[1]?this.constrained_edge[2]=n:this.constrained_edge[0]=n},i.prototype.setConstrainedEdgeCCW=function(t,n){t===this.points_[0]?this.constrained_edge[2]=n:t===this.points_[1]?this.constrained_edge[0]=n:this.constrained_edge[1]=n},i.prototype.getDelaunayEdgeCW=function(t){return t===this.points_[0]?this.delaunay_edge[1]:t===this.points_[1]?this.delaunay_edge[2]:this.delaunay_edge[0]},i.prototype.getDelaunayEdgeCCW=function(t){return t===this.points_[0]?this.delaunay_edge[2]:t===this.points_[1]?this.delaunay_edge[0]:this.delaunay_edge[1]},i.prototype.setDelaunayEdgeCW=function(t,n){t===this.points_[0]?this.delaunay_edge[1]=n:t===this.points_[1]?this.delaunay_edge[2]=n:this.delaunay_edge[0]=n},i.prototype.setDelaunayEdgeCCW=function(t,n){t===this.points_[0]?this.delaunay_edge[2]=n:t===this.points_[1]?this.delaunay_edge[0]=n:this.delaunay_edge[1]=n},i.prototype.neighborAcross=function(t){return t===this.points_[0]?this.neighbors_[0]:t===this.points_[1]?this.neighbors_[1]:this.neighbors_[2]},i.prototype.oppositePoint=function(t,n){var e=t.pointCW(n);return this.pointCW(e)},i.prototype.legalize=function(t,n){var e=this.points_;if(t===e[0])e[1]=e[0],e[0]=e[2],e[2]=n;else if(t===e[1])e[2]=e[1],e[1]=e[0],e[0]=n;else{if(t!==e[2])throw new Error("poly2tri Invalid Triangle.legalize() call");e[0]=e[2],e[2]=e[1],e[1]=n}},i.prototype.index=function(t){var n=this.points_;if(t===n[0])return 0;if(t===n[1])return 1;if(t===n[2])return 2;throw new Error("poly2tri Invalid Triangle.index() call")},i.prototype.edgeIndex=function(t,n){var e=this.points_;if(t===e[0]){if(n===e[1])return 2;if(n===e[2])return 1}else if(t===e[1]){if(n===e[2])return 0;if(n===e[0])return 2}else if(t===e[2]){if(n===e[0])return 1;if(n===e[1])return 0}return-1},i.prototype.markConstrainedEdgeByIndex=function(t){this.constrained_edge[t]=!0},i.prototype.markConstrainedEdgeByEdge=function(t){this.markConstrainedEdgeByPoints(t.p,t.q)},i.prototype.markConstrainedEdgeByPoints=function(t,n){var e=this.points_;n===e[0]&&t===e[1]||n===e[1]&&t===e[0]?this.constrained_edge[2]=!0:n===e[0]&&t===e[2]||n===e[2]&&t===e[0]?this.constrained_edge[1]=!0:(n===e[1]&&t===e[2]||n===e[2]&&t===e[1])&&(this.constrained_edge[0]=!0)},n.exports=i},{"./xy":11}],10:[function(t,n,e){"use strict";function i(t,n,e){var i=(t.x-e.x)*(n.y-e.y),o=(t.y-e.y)*(n.x-e.x),r=i-o;return r>-s&&s>r?p.COLLINEAR:r>0?p.CCW:p.CW}function o(t,n,e,i){var o=(t.x-n.x)*(i.y-n.y)-(i.x-n.x)*(t.y-n.y);if(o>=-s)return!1;var r=(t.x-e.x)*(i.y-e.y)-(i.x-e.x)*(t.y-e.y);return s>=r?!1:!0}function r(t,n,e){var i=n.x-t.x,o=n.y-t.y,r=e.x-t.x,s=e.y-t.y;return 0>i*r+o*s}var s=1e-12;e.EPSILON=s;var p={CW:1,CCW:-1,COLLINEAR:0};e.Orientation=p,e.orient2d=i,e.inScanArea=o,e.isAngleObtuse=r},{}],11:[function(t,n){"use strict";function e(t){return"("+t.x+";"+t.y+")"}function i(t){var n=t.toString();return"[object Object]"===n?e(t):n}function o(t,n){return t.y===n.y?t.x-n.x:t.y-n.y}function r(t,n){return t.x===n.x&&t.y===n.y}n.exports={toString:i,toStringBase:e,compare:o,equals:r}},{}]},{},[6])(6)});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],4:[function(require,module,exports){
(function (global){
!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var e;"undefined"!=typeof window?e=window:"undefined"!=typeof global?e=global:"undefined"!=typeof self&&(e=self),e.PriorityQueue=t()}}(function(){return function t(e,i,r){function o(n,s){if(!i[n]){if(!e[n]){var u="function"==typeof require&&require;if(!s&&u)return u(n,!0);if(a)return a(n,!0);var h=new Error("Cannot find module '"+n+"'");throw h.code="MODULE_NOT_FOUND",h}var p=i[n]={exports:{}};e[n][0].call(p.exports,function(t){var i=e[n][1][t];return o(i?i:t)},p,p.exports,t,e,i,r)}return i[n].exports}for(var a="function"==typeof require&&require,n=0;n<r.length;n++)o(r[n]);return o}({1:[function(t,e){var i,r,o,a,n,s={}.hasOwnProperty,u=function(t,e){function i(){this.constructor=t}for(var r in e)s.call(e,r)&&(t[r]=e[r]);return i.prototype=e.prototype,t.prototype=new i,t.__super__=e.prototype,t};i=t("./PriorityQueue/AbstractPriorityQueue"),r=t("./PriorityQueue/ArrayStrategy"),a=t("./PriorityQueue/BinaryHeapStrategy"),o=t("./PriorityQueue/BHeapStrategy"),n=function(t){function e(t){t||(t={}),t.strategy||(t.strategy=a),t.comparator||(t.comparator=function(t,e){return(t||0)-(e||0)}),e.__super__.constructor.call(this,t)}return u(e,t),e}(i),n.ArrayStrategy=r,n.BinaryHeapStrategy=a,n.BHeapStrategy=o,e.exports=n},{"./PriorityQueue/AbstractPriorityQueue":2,"./PriorityQueue/ArrayStrategy":3,"./PriorityQueue/BHeapStrategy":4,"./PriorityQueue/BinaryHeapStrategy":5}],2:[function(t,e){var i;e.exports=i=function(){function t(t){if(null==(null!=t?t.strategy:void 0))throw"Must pass options.strategy, a strategy";if(null==(null!=t?t.comparator:void 0))throw"Must pass options.comparator, a comparator";this.priv=new t.strategy(t),this.length=0}return t.prototype.queue=function(t){return this.length++,void this.priv.queue(t)},t.prototype.dequeue=function(){if(!this.length)throw"Empty queue";return this.length--,this.priv.dequeue()},t.prototype.peek=function(){if(!this.length)throw"Empty queue";return this.priv.peek()},t}()},{}],3:[function(t,e){var i,r;r=function(t,e,i){var r,o,a;for(o=0,r=t.length;r>o;)a=o+r>>>1,i(t[a],e)>=0?o=a+1:r=a;return o},e.exports=i=function(){function t(t){var e;this.options=t,this.comparator=this.options.comparator,this.data=(null!=(e=this.options.initialValues)?e.slice(0):void 0)||[],this.data.sort(this.comparator).reverse()}return t.prototype.queue=function(t){var e;return e=r(this.data,t,this.comparator),void this.data.splice(e,0,t)},t.prototype.dequeue=function(){return this.data.pop()},t.prototype.peek=function(){return this.data[this.data.length-1]},t}()},{}],4:[function(t,e){var i;e.exports=i=function(){function t(t){var e,i,r,o,a,n,s,u,h;for(this.comparator=(null!=t?t.comparator:void 0)||function(t,e){return t-e},this.pageSize=(null!=t?t.pageSize:void 0)||512,this.length=0,r=0;1<<r<this.pageSize;)r+=1;if(1<<r!==this.pageSize)throw"pageSize must be a power of two";for(this._shift=r,this._emptyMemoryPageTemplate=e=[],i=a=0,u=this.pageSize;u>=0?u>a:a>u;i=u>=0?++a:--a)e.push(null);if(this._memory=[],this._mask=this.pageSize-1,t.initialValues)for(h=t.initialValues,n=0,s=h.length;s>n;n++)o=h[n],this.queue(o)}return t.prototype.queue=function(t){return this.length+=1,this._write(this.length,t),void this._bubbleUp(this.length,t)},t.prototype.dequeue=function(){var t,e;return t=this._read(1),e=this._read(this.length),this.length-=1,this.length>0&&(this._write(1,e),this._bubbleDown(1,e)),t},t.prototype.peek=function(){return this._read(1)},t.prototype._write=function(t,e){var i;for(i=t>>this._shift;i>=this._memory.length;)this._memory.push(this._emptyMemoryPageTemplate.slice(0));return this._memory[i][t&this._mask]=e},t.prototype._read=function(t){return this._memory[t>>this._shift][t&this._mask]},t.prototype._bubbleUp=function(t,e){var i,r,o,a;for(i=this.comparator;t>1&&(r=t&this._mask,t<this.pageSize||r>3?o=t&~this._mask|r>>1:2>r?(o=t-this.pageSize>>this._shift,o+=o&~(this._mask>>1),o|=this.pageSize>>1):o=t-2,a=this._read(o),!(i(a,e)<0));)this._write(o,e),this._write(t,a),t=o;return void 0},t.prototype._bubbleDown=function(t,e){var i,r,o,a,n;for(n=this.comparator;t<this.length;)if(t>this._mask&&!(t&this._mask-1)?i=r=t+2:t&this.pageSize>>1?(i=(t&~this._mask)>>1,i|=t&this._mask>>1,i=i+1<<this._shift,r=i+1):(i=t+(t&this._mask),r=i+1),i!==r&&r<=this.length)if(o=this._read(i),a=this._read(r),n(o,e)<0&&n(o,a)<=0)this._write(i,e),this._write(t,o),t=i;else{if(!(n(a,e)<0))break;this._write(r,e),this._write(t,a),t=r}else{if(!(i<=this.length))break;if(o=this._read(i),!(n(o,e)<0))break;this._write(i,e),this._write(t,o),t=i}return void 0},t}()},{}],5:[function(t,e){var i;e.exports=i=function(){function t(t){var e;this.comparator=(null!=t?t.comparator:void 0)||function(t,e){return t-e},this.length=0,this.data=(null!=(e=t.initialValues)?e.slice(0):void 0)||[],this._heapify()}return t.prototype._heapify=function(){var t,e,i;if(this.data.length>0)for(t=e=1,i=this.data.length;i>=1?i>e:e>i;t=i>=1?++e:--e)this._bubbleUp(t);return void 0},t.prototype.queue=function(t){return this.data.push(t),void this._bubbleUp(this.data.length-1)},t.prototype.dequeue=function(){var t,e;return e=this.data[0],t=this.data.pop(),this.data.length>0&&(this.data[0]=t,this._bubbleDown(0)),e},t.prototype.peek=function(){return this.data[0]},t.prototype._bubbleUp=function(t){for(var e,i;t>0&&(e=t-1>>>1,this.comparator(this.data[t],this.data[e])<0);)i=this.data[e],this.data[e]=this.data[t],this.data[t]=i,t=e;return void 0},t.prototype._bubbleDown=function(t){var e,i,r,o,a;for(e=this.data.length-1;;){if(i=(t<<1)+1,o=i+1,r=t,e>=i&&this.comparator(this.data[i],this.data[r])<0&&(r=i),e>=o&&this.comparator(this.data[o],this.data[r])<0&&(r=o),r===t)break;a=this.data[r],this.data[r]=this.data[t],this.data[t]=a,t=r}return void 0},t}()},{}]},{},[1])(1)});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],5:[function(require,module,exports){
/* 
 * These action values correspond to the 256 states possible given empty
 * tiles, diagonal tiles, and square tiles. Generated using diagonals.js.
 * There are two possible forms for an action value. One is as a single object.
 * If an item has only a single object, then there is only one possible entrance/
 * exit possible from that arrangement of tiles. If an item has an array of
 * objects then there are multiple entrance/exits possible. Each of the objects
 * in an array of this sort has a 'loc' property that itself is an object with
 * properties 'in_dir' and 'out_dir' corresponding to the values to get into the
 * cell and the value that should be taken to get out of it. Each of the objects
 * also has a property 'v' which is a boolean corresponding to whether there is 
 * a vertex at a tile with this arrangement. The locations can be n, e, s, w, ne,
 * nw, se, sw.
 * The keys of this object are strings generated using the number values of a
 * contour tile starting from the top left and moving clockwise, separated by hyphens.
 */
module.exports = {"0-0-0-0":{"v":false,"loc":"none"},"1-0-0-0":{"v":true,"loc":"w"},"2-0-0-0":{"v":true,"loc":"w"},"3-0-0-0":{"v":true,"loc":"nw"},"0-1-0-0":{"v":true,"loc":"n"},"1-1-0-0":{"v":false,"loc":"w"},"2-1-0-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}}],"3-1-0-0":{"v":true,"loc":"nw"},"0-2-0-0":{"v":true,"loc":"ne"},"1-2-0-0":[{"v":true,"loc":{"in_dir":"s","out_dir":"w"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"2-2-0-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"3-2-0-0":[{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-0-0":{"v":true,"loc":"n"},"1-3-0-0":{"v":true,"loc":"w"},"2-3-0-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}}],"3-3-0-0":{"v":true,"loc":"nw"},"0-0-1-0":{"v":true,"loc":"e"},"1-0-1-0":[{"v":true,"loc":{"in_dir":"s","out_dir":"w"}},{"v":true,"loc":{"in_dir":"n","out_dir":"e"}}],"2-0-1-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"n","out_dir":"e"}}],"3-0-1-0":[{"v":true,"loc":{"in_dir":"n","out_dir":"e"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-1-0":{"v":false,"loc":"n"},"1-1-1-0":{"v":true,"loc":"w"},"2-1-1-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":false,"loc":{"in_dir":"n","out_dir":"n"}}],"3-1-1-0":{"v":true,"loc":"nw"},"0-2-1-0":{"v":true,"loc":"ne"},"1-2-1-0":[{"v":true,"loc":{"in_dir":"n","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"w"}}],"2-2-1-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"n","out_dir":"ne"}}],"3-2-1-0":[{"v":true,"loc":{"in_dir":"n","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-1-0":[{"v":true,"loc":{"in_dir":"n","out_dir":"e"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}}],"1-3-1-0":[{"v":true,"loc":{"in_dir":"n","out_dir":"e"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}}],"2-3-1-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"n","out_dir":"e"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}}],"3-3-1-0":[{"v":true,"loc":{"in_dir":"n","out_dir":"e"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}}],"0-0-2-0":{"v":true,"loc":"se"},"1-0-2-0":[{"v":true,"loc":{"in_dir":"s","out_dir":"w"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"2-0-2-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"3-0-2-0":[{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"0-1-2-0":[{"v":true,"loc":{"in_dir":"w","out_dir":"n"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"1-1-2-0":[{"v":false,"loc":{"in_dir":"w","out_dir":"w"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"2-1-2-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"3-1-2-0":[{"v":true,"loc":{"in_dir":"w","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"0-2-2-0":[{"v":true,"loc":{"in_dir":"n","out_dir":"se"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"1-2-2-0":[{"v":true,"loc":{"in_dir":"s","out_dir":"w"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"2-2-2-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"3-2-2-0":[{"v":true,"loc":{"in_dir":"n","out_dir":"se"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"0-3-2-0":[{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"1-3-2-0":[{"v":true,"loc":{"in_dir":"sw","out_dir":"w"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"2-3-2-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"3-3-2-0":[{"v":true,"loc":{"in_dir":"sw","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"0-0-3-0":{"v":true,"loc":"e"},"1-0-3-0":[{"v":true,"loc":{"in_dir":"s","out_dir":"w"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"2-0-3-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"3-0-3-0":[{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-3-0":{"v":true,"loc":"n"},"1-1-3-0":{"v":true,"loc":"w"},"2-1-3-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"n"}}],"3-1-3-0":{"v":false,"loc":"nw"},"0-2-3-0":{"v":true,"loc":"ne"},"1-2-3-0":[{"v":true,"loc":{"in_dir":"nw","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"w"}}],"2-2-3-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"ne"}}],"3-2-3-0":[{"v":true,"loc":{"in_dir":"nw","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-3-0":[{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"1-3-3-0":[{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"2-3-3-0":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"3-3-3-0":[{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"0-0-0-1":{"v":true,"loc":"s"},"1-0-0-1":{"v":false,"loc":"s"},"2-0-0-1":{"v":true,"loc":"s"},"3-0-0-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-0-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}}],"1-1-0-1":{"v":true,"loc":"s"},"2-1-0-1":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}}],"3-1-0-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"w","out_dir":"nw"}}],"0-2-0-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"1-2-0-1":[{"v":false,"loc":{"in_dir":"s","out_dir":"s"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"2-2-0-1":[{"v":true,"loc":{"in_dir":"se","out_dir":"s"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"3-2-0-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-0-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}}],"1-3-0-1":{"v":true,"loc":"s"},"2-3-0-1":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}}],"3-3-0-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"nw"}}],"0-0-1-1":{"v":false,"loc":"e"},"1-0-1-1":{"v":true,"loc":"e"},"2-0-1-1":{"v":true,"loc":"e"},"3-0-1-1":[{"v":false,"loc":{"in_dir":"e","out_dir":"e"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-1-1":{"v":true,"loc":"n"},"1-1-1-1":{"v":false,"loc":"none"},"2-1-1-1":{"v":true,"loc":"n"},"3-1-1-1":{"v":true,"loc":"nw"},"0-2-1-1":{"v":true,"loc":"ne"},"1-2-1-1":{"v":true,"loc":"ne"},"2-2-1-1":{"v":true,"loc":"ne"},"3-2-1-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-1-1":[{"v":false,"loc":{"in_dir":"e","out_dir":"e"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}}],"1-3-1-1":{"v":true,"loc":"e"},"2-3-1-1":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}}],"3-3-1-1":[{"v":false,"loc":{"in_dir":"e","out_dir":"e"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}}],"0-0-2-1":{"v":true,"loc":"se"},"1-0-2-1":{"v":true,"loc":"se"},"2-0-2-1":{"v":false,"loc":"se"},"3-0-2-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"se"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-2-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"se"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}}],"1-1-2-1":{"v":true,"loc":"se"},"2-1-2-1":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}}],"3-1-2-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"se"}},{"v":true,"loc":{"in_dir":"w","out_dir":"nw"}}],"0-2-2-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"se"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"1-2-2-1":[{"v":true,"loc":{"in_dir":"s","out_dir":"se"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"2-2-2-1":[{"v":false,"loc":{"in_dir":"se","out_dir":"se"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"3-2-2-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"se"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"0-3-2-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"se"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}}],"1-3-2-1":{"v":true,"loc":"se"},"2-3-2-1":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}}],"3-3-2-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"se"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"nw"}}],"0-0-3-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"1-0-3-1":[{"v":false,"loc":{"in_dir":"s","out_dir":"s"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"2-0-3-1":[{"v":true,"loc":{"in_dir":"se","out_dir":"s"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"3-0-3-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-3-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"1-1-3-1":{"v":true,"loc":"s"},"2-1-3-1":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"3-1-3-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"0-2-3-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"1-2-3-1":[{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}},{"v":false,"loc":{"in_dir":"s","out_dir":"s"}}],"2-2-3-1":[{"v":true,"loc":{"in_dir":"se","out_dir":"s"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"3-2-3-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-3-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"1-3-3-1":[{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"2-3-3-1":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"3-3-3-1":[{"v":true,"loc":{"in_dir":"e","out_dir":"s"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}}],"0-0-0-2":{"v":true,"loc":"s"},"1-0-0-2":[{"v":true,"loc":{"in_dir":"s","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"2-0-0-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-0-0-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-0-2":[{"v":true,"loc":{"in_dir":"w","out_dir":"n"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}}],"1-1-0-2":[{"v":false,"loc":{"in_dir":"w","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"2-1-0-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-1-0-2":[{"v":true,"loc":{"in_dir":"w","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}}],"0-2-0-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"1-2-0-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}},{"v":true,"loc":{"in_dir":"s","out_dir":"w"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"2-2-0-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"3-2-0-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-0-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}}],"1-3-0-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"2-3-0-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-3-0-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}}],"0-0-1-2":{"v":true,"loc":"e"},"1-0-1-2":[{"v":true,"loc":{"in_dir":"s","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"2-0-1-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-0-1-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"e"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-1-2":{"v":true,"loc":"n"},"1-1-1-2":{"v":true,"loc":"w"},"2-1-1-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-1-1-2":{"v":true,"loc":"nw"},"0-2-1-2":{"v":false,"loc":"ne"},"1-2-1-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}},{"v":true,"loc":{"in_dir":"s","out_dir":"w"}}],"2-2-1-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-2-1-2":[{"v":false,"loc":{"in_dir":"ne","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-1-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"e"}}],"1-3-1-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"2-3-1-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-3-1-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"e"}}],"0-0-2-2":{"v":true,"loc":"se"},"1-0-2-2":[{"v":true,"loc":{"in_dir":"s","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"2-0-2-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-0-2-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"se"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-2-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"se"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}}],"1-1-2-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}},{"v":false,"loc":{"in_dir":"w","out_dir":"w"}}],"2-1-2-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}}],"3-1-2-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"se"}},{"v":true,"loc":{"in_dir":"w","out_dir":"nw"}}],"0-2-2-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"se"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"1-2-2-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}},{"v":true,"loc":{"in_dir":"s","out_dir":"w"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"2-2-2-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"3-2-2-2":[{"v":true,"loc":{"in_dir":"ne","out_dir":"se"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"0-3-2-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"se"}}],"1-3-2-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"w"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"2-3-2-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-3-2-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"se"}}],"0-0-3-2":[{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}}],"1-0-3-2":[{"v":true,"loc":{"in_dir":"s","out_dir":"w"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"2-0-3-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-0-3-2":[{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-3-2":[{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}}],"1-1-3-2":[{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"2-1-3-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-1-3-2":[{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}}],"0-2-3-2":[{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}}],"1-2-3-2":[{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}},{"v":true,"loc":{"in_dir":"s","out_dir":"w"}}],"2-2-3-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-2-3-2":[{"v":true,"loc":{"in_dir":"nw","out_dir":"s"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-3-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}}],"1-3-3-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"2-3-3-2":[{"v":true,"loc":{"in_dir":"se","out_dir":"w"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"w"}}],"3-3-3-2":[{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"ne","out_dir":"s"}}],"0-0-0-3":{"v":true,"loc":"sw"},"1-0-0-3":{"v":true,"loc":"sw"},"2-0-0-3":{"v":true,"loc":"sw"},"3-0-0-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-0-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}}],"1-1-0-3":{"v":true,"loc":"sw"},"2-1-0-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}}],"3-1-0-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"nw"}}],"0-2-0-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"1-2-0-3":[{"v":true,"loc":{"in_dir":"s","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"2-2-0-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}}],"3-2-0-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-0-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}}],"1-3-0-3":{"v":false,"loc":"sw"},"2-3-0-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}}],"3-3-0-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"nw"}}],"0-0-1-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"e"}}],"1-0-1-3":[{"v":true,"loc":{"in_dir":"s","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"e"}}],"2-0-1-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"e"}}],"3-0-1-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"e"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-1-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":false,"loc":{"in_dir":"n","out_dir":"n"}}],"1-1-1-3":{"v":true,"loc":"sw"},"2-1-1-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":false,"loc":{"in_dir":"n","out_dir":"n"}}],"3-1-1-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"nw"}}],"0-2-1-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"ne"}}],"1-2-1-3":[{"v":true,"loc":{"in_dir":"s","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"ne"}}],"2-2-1-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"ne"}}],"3-2-1-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-1-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"n","out_dir":"e"}}],"1-3-1-3":[{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"n","out_dir":"e"}}],"2-3-1-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"n","out_dir":"e"}}],"3-3-1-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"n","out_dir":"e"}}],"0-0-2-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"1-0-2-3":[{"v":true,"loc":{"in_dir":"s","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"2-0-2-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"3-0-2-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"0-1-2-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"1-1-2-3":[{"v":true,"loc":{"in_dir":"w","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"2-1-2-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"w","out_dir":"n"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"3-1-2-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"0-2-2-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"1-2-2-3":[{"v":true,"loc":{"in_dir":"s","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"2-2-2-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"3-2-2-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"w","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"0-3-2-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"1-3-2-3":[{"v":false,"loc":{"in_dir":"sw","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"2-3-2-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"3-3-2-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"nw"}},{"v":true,"loc":{"in_dir":"n","out_dir":"se"}}],"0-0-3-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"1-0-3-3":[{"v":true,"loc":{"in_dir":"s","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"2-0-3-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"3-0-3-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-1-3-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"n"}}],"1-1-3-3":{"v":true,"loc":"sw"},"2-1-3-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"n"}}],"3-1-3-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":false,"loc":{"in_dir":"nw","out_dir":"nw"}}],"0-2-3-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"ne"}}],"1-2-3-3":[{"v":true,"loc":{"in_dir":"nw","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"sw"}}],"2-2-3-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"ne"}}],"3-2-3-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"ne"}},{"v":true,"loc":{"in_dir":"s","out_dir":"nw"}}],"0-3-3-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"1-3-3-3":[{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"2-3-3-3":[{"v":true,"loc":{"in_dir":"se","out_dir":"n"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"n"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}],"3-3-3-3":[{"v":true,"loc":{"in_dir":"e","out_dir":"sw"}},{"v":true,"loc":{"in_dir":"sw","out_dir":"e"}},{"v":true,"loc":{"in_dir":"nw","out_dir":"e"}}]};

},{}],6:[function(require,module,exports){
/**
 * A point can represent a vertex in a 2d environment or a vector.
 * @constructor
 * @param {number} x - The `x` coordinate of the point.
 * @param {number} y - The `y` coordinate of the point.
 */
Point = function(x, y) {
  this.x = x;
  this.y = y;
};
exports.Point = Point;

/**
 * Convert a point-like object into a point.
 * @param {PointLike} p - The point-like object to convert.
 * @return {Point} - The new point representing the point-like
 *   object.
 */
Point.fromPointLike = function(p) {
  return new Point(p.x, p.y);
};

/**
 * String method for point-like objects.
 * @param {PointLike} p - The point-like object to convert.
 * @return {Point} - The new point representing the point-like
 *   object.
 */
Point.toString = function(p) {
  return "x" + p.x + "y" + p.y;
};

/**
 * Takes a point or scalar and adds slotwise in the case of another
 * point, or to each parameter in the case of a scalar.
 * @param {(Point|number)} - The Point, or scalar, to add to this
 *   point.
 */
Point.prototype.add = function(p) {
  if (typeof p == "number")
    return new Point(this.x + p, this.y + p);
  return new Point(this.x + p.x, this.y + p.y);
};

/**
 * Takes a point or scalar and subtracts slotwise in the case of
 * another point or from each parameter in the case of a scalar.
 * @param {(Point|number)} - The Point, or scalar, to subtract from
 *   this point.
 */
Point.prototype.sub = function(p) {
  if (typeof p == "number")
    return new Point(this.x - p, this.y - p);
  return new Point(this.x - p.x, this.y - p.y);
};

/**
 * Takes a scalar value and multiplies each parameter of the point
 * by the scalar.
 * @param  {number} f - The number to multiple the parameters by.
 * @return {Point} - A new point with the calculated coordinates.
 */
Point.prototype.mul = function(f) {
  return new Point(this.x * f, this.y * f);
};

/**
 * Takes a scalar value and divides each parameter of the point
 * by the scalar.
 * @param  {number} f - The number to divide the parameters by.
 * @return {Point} - A new point with the calculated coordinates.
 */
Point.prototype.div = function(f) {
  return new Point(this.x / f, this.y / f);
};

/**
 * Takes another point and returns a boolean indicating whether the
 * points are equal. Two points are equal if their parameters are
 * equal.
 * @param  {Point} p - The point to check equality against.
 * @return {boolean} - Whether or not the two points are equal.
 */
Point.prototype.eq = function(p) {
  return (this.x == p.x && this.y == p.y);
};

/**
 * Takes another point and returns a boolean indicating whether the
 * points are not equal. Two points are considered not equal if their
 * parameters are not equal.
 * @param  {Point} p - The point to check equality against.
 * @return {boolean} - Whether or not the two points are not equal.
 */
Point.prototype.neq = function(p) {
  return (this.x != p.x || this.y != p.y);
};

// Given another point, returns the dot product.
Point.prototype.dot = function(p) {
  return (this.x * p.x + this.y * p.y);
};

// Given another point, returns the 'cross product', or at least the 2d
// equivalent.
Point.prototype.cross = function(p) {
  return (this.x * p.y - this.y * p.x);
};

// Given another point, returns the distance to that point.
Point.prototype.dist = function(p) {
  var diff = this.sub(p);
  return Math.sqrt(diff.dot(diff));
};

// Given another point, returns the squared distance to that point.
Point.prototype.dist2 = function(p) {
  var diff = this.sub(p);
  return diff.dot(diff);
};

/**
 * Returns true if the point is (0, 0).
 * @return {boolean} - Whether or not the point is (0, 0).
 */
Point.prototype.zero = function() {
  return this.x == 0 && this.y == 0;
};

Point.prototype.len = function() {
  return this.dist(new Point(0, 0));
};

Point.prototype.normalize = function() {
  var n = this.dist(new Point(0, 0));
  if (n > 0) return this.div(n);
  return new Point(0, 0);
};

Point.prototype.toString = function() {
  return 'x' + this.x + 'y' + this.y;
};

/**
 * Return a copy of the point.
 * @return {Point} - The new point.
 */
Point.prototype.clone = function() {
  return new Point(this.x, this.y);
};

/**
 * Edges are used to represent the border between two adjacent
 * polygons.
 * @constructor
 * @param {Point} p1 - The first point of the edge.
 * @param {Point} p2 - The second point of the edge.
 */
Edge = function(p1, p2) {
  this.p1 = p1;
  this.p2 = p2;
  this.center = p1.add(p2.sub(p1).div(2));
  this.points = [this.p1, this.center, this.p2];
};
exports.Edge = Edge;

Edge.prototype._CCW = function(p1, p2, p3) {
  a = p1.x; b = p1.y;
  c = p2.x; d = p2.y;
  e = p3.x; f = p3.y;
  return (f - b) * (c - a) > (d - b) * (e - a);
};

/**
 * from http://stackoverflow.com/a/16725715
 * Checks whether this edge intersects the provided edge.
 * @param {Edge} edge - The edge to check intersection for.
 * @return {boolean} - Whether or not the edges intersect.
 */
Edge.prototype.intersects = function(edge) {
  var q1 = edge.p1, q2 = edge.p2;
  if (q1.eq(this.p1) || q1.eq(this.p2) || q2.eq(this.p1) || q2.eq(this.p2)) return false;
  return (this._CCW(this.p1, q1, q2) != this._CCW(this.p2, q1, q2)) && (this._CCW(this.p1, this.p2, q1) != this._CCW(this.p1, this.p2, q2));
};

/**
 * Polygon class.
 * Can be initialized with an array of points.
 * @constructor
 * @param {Array.<Point>} [points] - The points to use to initialize
 *   the poly.
 */
Poly = function(points) {
  if (typeof points == 'undefined') points = false;
  this.hole = false;
  this.points = null;
  this.numpoints = 0;
  if (points) {
    this.numpoints = points.length;
    this.points = points.slice();
  }
};
exports.Poly = Poly;

Poly.prototype.init = function(n) {
  this.points = new Array(n);
  this.numpoints = n;
};

Poly.prototype.update = function() {
  this.numpoints = this.points.length;
};

Poly.prototype.triangle = function(p1, p2, p3) {
  this.init(3);
  this.points[0] = p1;
  this.points[1] = p2;
  this.points[2] = p3;
};

// Takes an index and returns the point at that index, or null.
Poly.prototype.getPoint = function(n) {
  if (this.points && this.numpoints > n)
    return this.points[n];
  return null;
};

// Set a point, fails silently otherwise. TODO: replace with bracket notation.
Poly.prototype.setPoint = function(i, p) {
  if (this.points && this.points.length > i) {
    this.points[i] = p;
  }
};

// Given an index i, return the index of the next point.
Poly.prototype.getNextI = function(i) {
  return (i + 1) % this.numpoints;
};

Poly.prototype.getPrevI = function(i) {
  if (i == 0)
    return (this.numpoints - 1);
  return i - 1;
};

// Returns the signed area of a polygon, if the vertices are given in
// CCW order then the area will be > 0, < 0 otherwise.
Poly.prototype.getArea = function() {
  var area = 0;
  for (var i = 0; i < this.numpoints; i++) {
    var i2 = this.getNextI(i);
    area += this.points[i].x * this.points[i2].y - this.points[i].y * this.points[i2].x;
  }
  return area;
};

Poly.prototype.getOrientation = function() {
  var area = this.getArea();
  if (area > 0) return "CCW";
  if (area < 0) return "CW";
  return 0;
};

Poly.prototype.setOrientation = function(orientation) {
  var current_orientation = this.getOrientation();
  if (current_orientation && (current_orientation !== orientation)) {
    this.invert();
  }
};

Poly.prototype.invert = function() {
  var newpoints = new Array(this.numpoints);
  for (var i = 0; i < this.numpoints; i++) {
    newpoints[i] = this.points[this.numpoints - i - 1];
  }
  this.points = newpoints;
};

Poly.prototype.getCenter = function() {
  var x = this.points.map(function(p) { return p.x });
  var y = this.points.map(function(p) { return p.y });
  var minX = Math.min.apply(null, x);
  var maxX = Math.max.apply(null, x);
  var minY = Math.min.apply(null, y);
  var maxY = Math.max.apply(null, y);
  return new Point((minX + maxX)/2, (minY + maxY)/2);
};

// Adapted from http://stackoverflow.com/a/16283349
Poly.prototype.centroid = function() {
  var x = 0,
      y = 0,
      i,
      j,
      f,
      point1,
      point2;

  for (i = 0, j = this.points.length - 1; i < this.points.length; j = i, i += 1) {
    point1 = this.points[i];
    point2 = this.points[j];
    f = point1.x * point2.y - point2.x * point1.y;
    x += (point1.x + point2.x) * f;
    y += (point1.y + point2.y) * f;
  }

  f = this.getArea() * 3;
  x = Math.abs(x);
  y = Math.abs(y);
  return new Point(x / f, y / f);
};

Poly.prototype.toString = function() {
  var center = this.centroid();
  return "" + center.x + " " + center.y;
};

/**
 * Checks if the given point is contained within the Polygon.
 * Adapted from http://stackoverflow.com/a/8721483
 *
 * @param {Point} p - The point to check.
 * @return {boolean} - Whether or not the point is contained within
 *   the polygon.
 */
Poly.prototype.containsPoint = function(p) {
  var result = false;
  for (var i = 0, j = this.numpoints - 1; i < this.numpoints; j = i++) {
    var p1 = this.points[j], p2 = this.points[i];
    if ((p2.y > p.y) != (p1.y > p.y) &&
        (p.x < (p1.x - p2.x) * (p.y - p2.y) / (p1.y - p2.y) + p2.x)) {
      result = !result;
    }
  }
  return result;
};

/**
 * Clone the given polygon into a new polygon.
 * @return {Poly} - A clone of the polygon.
 */
Poly.prototype.clone = function() {
  return new Poly(this.points.slice().map(function(point) {
    return point.clone();
  }));
};

/**
 * Translate a polygon along a given vector.
 * @param {Point} vec - The vector along which to translate the
 *   polygon.
 * @return {Poly} - The translated polygon.
 */
Poly.prototype.translate = function(vec) {
  return new Poly(this.points.map(function(point) {
    return point.add(vec);
  }));
};

/**
 * Returns an array of edges representing the polygon.
 * @return {Array.<Edge>} - The edges of the polygon.
 */
Poly.prototype.edges = function() {
  if (!this.hasOwnProperty("cached_edges")) {
    this.cached_edges = this.points.map(function(point, i) {
      return new Edge(point, this.points[this.getNextI(i)]);
    }, this);
  }
  return this.cached_edges;
};

/**
 * Naive check if other poly intersects this one, assuming both convex.
 * @param {Poly} poly
 * @return {boolean} - Whether the polygons intersect.
 */
Poly.prototype.intersects = function(poly) {
  var inside = poly.points.some(function(p) {
    return this.containsPoint(p);
  }, this);
  inside = inside || this.points.some(function(p) {
    return poly.containsPoint(p);
  });
  if (inside) {
    return true;
  } else {
    var ownEdges = this.edges();
    var otherEdges = poly.edges();
    var intersect = ownEdges.some(function(ownEdge) {
      return otherEdges.some(function(otherEdge) {
        return ownEdge.intersects(otherEdge);
      });
    });
    return intersect;
  }
};

var util = {};
exports.util = util;

/**
 * Given an array of polygons, returns the one that contains the point.
 * If no polygon is found, null is returned.
 * @param {Point} p - The point to find the polygon for.
 * @param {Array.<Poly>} polys - The polygons to search for the point.
 * @return {?Polygon} - The polygon containing the point.
 */
util.findPolyForPoint = function(p, polys) {
  var i, poly;
  for (i in polys) {
    poly = polys[i];
    if (poly.containsPoint(p)) {
      return poly;
    }
  }
  return null;
};

/**
 * Holds the properties of a collision, if one occurred.
 * @typedef Collision
 * @type {object}
 * @property {boolean} collides - Whether there is a collision.
 * @property {boolean} inside - Whether one object is inside the other.
 * @property {?Point} point - The point of collision, if collision
 *   occurs, and if `inside` is false.
 * @property {?Point} normal - A unit vector normal to the point
 *   of collision, if it occurs and if `inside` is false.
 */
/**
 * If the ray intersects the circle, the distance to the intersection
 * along the ray is returned, otherwise false is returned.
 * @param {Point} p - The start of the ray.
 * @param {Point} ray - Unit vector extending from `p`.
 * @param {Point} c - The center of the circle for the object being
 *   checked for intersection.
 * @param {number} radius - The radius of the circle.
 * @return {Collision} - The collision information.
 */
util.lineCircleIntersection = function(p, ray, c, radius) {
  var collision = {
    collides: false,
    inside: false,
    point: null,
    normal: null
  };
  var vpc = c.sub(p);

  if (vpc.len() <= radius) {
    // Point is inside obstacle.
    collision.collides = true;
    collision.inside = (vpc.len() !== radius);
  } else if (ray.dot(vpc) >= 0) {
    // Circle is ahead of point.
    // Projection of center point onto ray.
    var pc = p.add(ray.mul(ray.dot(vpc)));
    // Length from c to its projection on the ray.
    var len_c_pc = c.sub(pc).len();

    if (len_c_pc <= radius) {
      collision.collides = true;

      // Distance from projected point to intersection.
      var len_intersection = Math.sqrt(len_c_pc * len_c_pc + radius * radius);
      collision.point = pc.sub(ray.mul(len_intersection));
      collision.normal = collision.point.sub(c).normalize();
    }
  }
  return collision;
};

},{}],7:[function(require,module,exports){
var partition = require('./partition');
var geo = require('./geometry');
var Point = geo.Point;
var Poly = geo.Poly;
var Edge = geo.Edge;

var MapParser = require('./parse-map');
var Pathfinder = require('./pathfinder');

require('math-round');
var ClipperLib = require('jsclipper');

/**
 * A NavMesh represents the traversable area of a map and gives
 * utilities for pathfinding.
 * Usage:
 * ```javascript
 * // Assuming the 2d map tiles array is available:
 * var navmesh = new NavMesh(map);
 * navmesh.calculatePath(currentlocation, targetLocation, callback);
 * ```
 * @module NavMesh
 */  
/**
 * @constructor
 * @alias module:NavMesh
 * @param {MapTiles} map - The 2d array defining the map tiles.
 * @param {Logger} [logger] - The logger to use.
 */
var NavMesh = function(map, logger) {
  if (typeof logger == 'undefined') {
    logger = {};
    logger.log = function() {};
  }
  this.logger = logger;

  this.initialized = false;

  this.updateFuncs = [];

  this._setupWorker();
  
  // Parse map tiles into polygons.
  var polys = MapParser.parse(map);
  if (!polys) {
    throw "Map parsing failed!";
  }

  // Track map state.
  this.map = JSON.parse(JSON.stringify(map));

  // Initialize navmesh.
  this._init(polys);
};
module.exports = NavMesh;

/**
 * Callback for path calculation requests.
 * @callback PathCallback
 * @param {?Array.<PointLike>} - The calculated path beginning with
 *   the start point, and ending at the target point. If no path is
 *   found then null is passed to the callback.
 */

/**
 * Calculate a path from the source point to the target point, invoking
 * the callback with the path after calculation.
 * @param {PointLike} source - The start location of the search.
 * @param {PointLike} target - The target of the search.
 * @param {PathCallback} callback - The callback function invoked
 *   when the path has been calculated.
 */
NavMesh.prototype.calculatePath = function(source, target, callback) {
  this.logger.log("navmesh:debug", "Calculating path.");

  // Use web worker if present.
  if (this.worker && this.workerInitialized) {
    this.logger.log("navmesh:debug", "Using worker to calculate path.");
    this.worker.postMessage(["aStar", source, target]);
    // Set callback so it is accessible when results are sent back.
    this.lastCallback = callback;
  } else {
    source = Point.fromPointLike(source);
    target = Point.fromPointLike(target);
    path = this.pathfinder.aStar(source, target);
    callback(path);
  }
};

/**
 * Check whether one point is visible from another, without being
 * blocked by obstacles.
 * @param {PointLike} p1 - The first point.
 * @param {PointLike} p2 - The second point.
 * @return {boolean} - Whether `p1` is visible from `p2`.
 */
NavMesh.prototype.checkVisible = function(p1, p2) {
  var edge = new Edge(Point.fromPointLike(p1), Point.fromPointLike(p2));
  var blocked = this.obstacle_edges.some(function(e) {return e.intersects(edge);});
  return !blocked;
};

/**
 * Ensure that passed function is executed when the navmesh has been
 * fully initialized.
 * @param {Function} fn - The function to call when the navmesh is
 *   initialized.
 */
NavMesh.prototype.onInit = function(fn) {
  if (this.initialized) {
    fn();
  } else {
    setTimeout(function() {
      this.onInit(fn);
    }.bind(this), 10);
  }
};

/**
 * @typedef TileUpdate
 * @type {object}
 * @property {integer} x - The x index of the tile to update in the
 *   original map array.
 * @property {integer} y - The y index of the tile to update in the
 *   original map array.
 * @property {(number|string)} v - The new value for the tile.
 */

/**
 * Takes an array of tiles and updates the navigation mesh to reflect
 * the newly traversable area. This should be set as a listener to
 * `mapupdate` socket events.
 * @param {Array.<TileUpdate>} - Information on the tiles updates.
 */
NavMesh.prototype.mapUpdate = function(data) {
  // Check the passed values.
  var error = false;
  // Hold updated tile locations.
  var updates = [];
  data.forEach(function(update) {
    // Update internal map state.
    this.map[update.x][update.y] = update.v;
    if (error) return;
    var tileId = update.v;
    var locId = Point.toString(update);
    var passable = this._isPassable(tileId);
    var currentLocState = this.obstacle_state[locId];
    // All dynamic tile locations should be defined.
    if (typeof currentLocState == 'undefined') {
      error = true;
      this.logger.log("navmesh:error",
        "Dynamic obstacle found but not already initialized.");
      return;
    } else {
      if (passable == currentLocState) {
        // Nothing to do here.
        return;
      } else {
        this.obstacle_state[locId] = passable;
        // Track whether update is making the tiles passable or
        // impassable.
        update.passable = passable;
        updates.push(update);
      }
    }
  }, this);

  if (error) {
    return;
  }

  // Check that we have updates to carry out.
  if (updates.length > 0) {
    // See whether this is an update from passable to impassable
    // or vice-versa.
    var passable = updates[0].passable;

    // Ensure that they all have the same update type.
    updates.forEach(function(update) {
      if (update.passable !== passable) {
        error = true;
      }
    }, this);
    if (error) {
      this.logger.log("navmesh:error",
        "Not all updates of same type.");
      return;
    }
    // Passable/impassable-specific update functions.
    if (passable) {
      this._passableUpdate(updates);
    } else {
      this._impassableUpdate(updates);
    }
  }
};

/**
 * Set up the navmesh to listen to the relevant socket.
 * @param  {Socket} socket - The socket to listen on for `mapupdate`
 *   packets.
 */
NavMesh.prototype.listen = function(socket) {
  socket.on("mapupdate", this.mapUpdate.bind(this));
};

/**
 * A function called when the navigation mesh updates.
 * @callback UpdateCallback
 * @param {Array.<Poly>} - The polys defining the current navigation
 *   mesh.
 * @param {Array.<Poly>} - The polys that were added to the mesh.
 * @param {Array.<integer>} - The indices of the polys that were
 *   removed from the mesh.
 */

/**
 * Register a function to be called when the navigation mesh updates.
 * @param {UpdateCallback} fn - The function to be called.
 */
NavMesh.prototype.onUpdate = function(fn) {
  this.updateFuncs.push(fn);
};

/**
 * Set specific tile identifiers as impassable to the agent.
 * @param {Array.<number>} ids - The tile ids to set as impassable.
 * @param {string} obstacle - The identifier for the polygon for the
 *   obstacles (already passed to addObstaclePoly).
 */
NavMesh.prototype.setImpassable = function(ids) {
  // Remove ids already set as impassable.
  ids = ids.filter(function(id) {
    return this._isPassable(id);
  }, this);
  this.logger.log("navmesh:debug", "Ids passed:", ids);

  var updates = [];
  // Check if any of the dynamic tiles have the values passed.
  this.dynamic_obstacle_locations.forEach(function(loc) {
    var idx = ids.indexOf(this.map[loc.x][loc.y]);
    if (idx !== -1) {
      updates.push({
        x: loc.x,
        y: loc.y,
        v: ids[idx]
      });
    }
  }, this);

  // Add to list of impassable tiles.
  ids.forEach(function(id) {
    this.impassable[id] = true;
  }, this);

  if (updates.length > 0) {
    this.mapUpdate(updates);
  }
};

/**
 * Remove tile identifiers from set of impassable tile types.
 * @param {Array.<number>} ids - The tile ids to set as traversable.
 */
NavMesh.prototype.removeImpassable = function(ids) {
  // Remove ids not set as impassable.
  ids = ids.filter(function(id) {
    return !this._isPassable(id);
  }, this);

  var updates = [];
  // Check if any of the dynamic tiles have the values passed.
  this.dynamic_obstacle_locations.forEach(function(loc) {
    var idx = ids.indexOf(this.map[loc.x][loc.y]);
    if (idx !== -1) {
      updates.push({
        x: loc.x,
        y: loc.y,
        v: ids[idx]
      });
    }
  }, this);

  // Remove from list of impassable tiles.
  ids.forEach(function(id) {
    this.impassable[id] = false;
  }, this);

  if (updates.length > 0) {
    this.mapUpdate(updates);
  }
};

/**
 * Initialize the navigation mesh with the polygons describing the
 * map elements.
 * @private
 * @param {ParsedMap} - The map information parsed into polygons.
 */
NavMesh.prototype._init = function(parsedMap) {
  // Save original parsed map polys.
  this.parsedMap = parsedMap;

  // Static objects relative to the navmesh.
  var navigation_static_objects = {
    walls: parsedMap.walls,
    obstacles: parsedMap.static_obstacles
  };
  var navigation_dynamic_objects = parsedMap.dynamic_obstacles;

  // Offset polys from side so they represent traversable area.
  var areas = this._offsetPolys(navigation_static_objects);

  this.polys = areas.map(NavMesh._geometry.partitionArea);
  this.polys = NavMesh._util.flatten(this.polys);

  if (!this.workerInitialized) {
    this.pathfinder = new Pathfinder(this.polys);
  }

  this._setupDynamicObstacles(navigation_dynamic_objects);

  
  // Hold the edges of static obstacles.
  this.static_obstacle_edges = [];
  areas.forEach(function(area) {
    var polys = [area.polygon].concat(area.holes);
    polys.forEach(function(poly) {
      for (var i = 0, j = poly.numpoints - 1; i < poly.numpoints; j = i++) {
        this.static_obstacle_edges.push(new Edge(poly.points[j], poly.points[i]));
      }
    }, this);
  }, this);

  // Holds the edges of static and dynamic obstacles.
  this.obstacle_edges = this.static_obstacle_edges.slice();

  this.initialized = true;
};

/**
 * Set up mesh-dynamic obstacles.
 * @private
 */
NavMesh.prototype._setupDynamicObstacles = function(obstacles) {
  // Holds tile id<->impassable (boolean) associations.
  this.impassable = {};
  // Polygons defining obstacles.
  this.obstacleDefinitions = {};
  // Relation between ids and obstacles.
  this.idToObstacles = {};

  var geo = NavMesh._geometry;

  // Add polygons describing dynamic obstacles.
  this._addObstaclePoly("bomb", geo.getApproximateCircle(15));
  this._addObstaclePoly("boost", geo.getApproximateCircle(15));
  this._addObstaclePoly("portal", geo.getApproximateCircle(15));
  this._addObstaclePoly("spike", geo.getApproximateCircle(14));
  this._addObstaclePoly("gate", geo.getSquare(20));
  this._addObstaclePoly("tile", geo.getSquare(20));
  this._addObstaclePoly("wall", geo.getSquare(20));
  this._addObstaclePoly("sewall", geo.getDiagonal(20, "se"));
  this._addObstaclePoly("newall", geo.getDiagonal(20, "ne"));
  this._addObstaclePoly("swwall", geo.getDiagonal(20, "sw"));
  this._addObstaclePoly("nwwall", geo.getDiagonal(20, "nw"));

  // Add id<->type associations.
  this._setObstacleType([10, 10.1], "bomb");
  this._setObstacleType([5, 5.1, 14, 14.1, 15, 15.1], "boost");
  this._setObstacleType([9, 9.1, 9.2, 9.3], "gate");
  this._setObstacleType([1], "wall");
  this._setObstacleType([1.1], "swwall");
  this._setObstacleType([1.2], "nwwall");
  this._setObstacleType([1.3], "newall");
  this._setObstacleType([1.4], "sewall");
  this._setObstacleType([7], "spike");

  // Set up obstacle state container. Holds whether position is
  // passable or not. Referenced using array location.
  this.obstacle_state = {};

  // Location of dynamic obstacles.
  this.dynamic_obstacle_locations = [];

  // Edges of offsetted obstacled, organized by id.
  this.dynamic_obstacle_polys = {};

  // Container to hold initial obstacle states.
  var initial_states = [];
  obstacles.forEach(function(obstacle) {
    var id = Point.toString(obstacle);

    // Generate offset obstacle.
    var obs = this._offsetDynamicObs([this._getTilePoly(obstacle)]);
    var areas = NavMesh._geometry.getAreas(obs);
    areas = areas.map(function(area) {
      area.holes.push(area.polygon);
      return area.holes;
    });
    areas = NavMesh._util.flatten(areas);
    // Get edges of obstacle.
    var edges = areas.map(function(poly) {
      return poly.edges();
    });
    edges = NavMesh._util.flatten(edges);
    this.dynamic_obstacle_polys[id] = edges;

    // Initialize obstacle states to all be passable.
    this.obstacle_state[id] = true;
    this.dynamic_obstacle_locations.push(Point.fromPointLike(obstacle));
    initial_states.push(obstacle);
  }, this);

  // Set up already-known dynamic impassable values.
  this.setImpassable([10, 5, 9.1]);
  // Walls and spikes.
  this.setImpassable([1, 1.1, 1.2, 1.3, 1.4, 7]);

  // Set up callback to regenerate obstacle edges for visibility checking.
  this.onUpdate(function(polys) {
    var obstacle_edges = [];
    for (id in this.obstacle_state) {
      if (!this.obstacle_state[id]) {
        Array.prototype.push.apply(
          obstacle_edges,
          this.dynamic_obstacle_polys[id]);
      }
    }
    this.obstacle_edges = this.static_obstacle_edges.concat(obstacle_edges);
  }.bind(this));

  // Initialize mapupdate with already-present dynamic obstacles.
  this.mapUpdate(initial_states);
};

/**
 * Add poly definition for obstacle type.
 * edges should be relative to center of tile.
 * @private
 */
NavMesh.prototype._addObstaclePoly = function(name, poly) {
  this.obstacleDefinitions[name] = poly;
};

/**
 * Retrieve the polygon for a given obstacle id.
 * @private
 * @param {number} id - The id to retrieve the obstacle polygon for.
 * @return {Poly} - The polygon representing the obstacle.
 */
NavMesh.prototype._getObstaclePoly = function(id) {
  var poly = this.obstacleDefinitions[this.idToObstacles[id]]
  if (poly) {
    return poly.clone();
  } else {
    this.logger.log("navmesh:debug", "No poly found for id:", id);
  }
};

/**
 * Update the navigation mesh to the given polys and call the update
 * functions.
 * @private
 * @param {Array.<Poly>} polys - The new polys defining the nav mesh.
 * @param {Array.<Poly>} added - The polys that were added to the mesh.
 * @param {Array.<integer>} removed - The indices of the polys that were
 *   removed from the mesh.
 */
NavMesh.prototype._update = function(polys, added, removed) {
  this.polys = polys;
  this.updateFuncs.forEach(function(fn) {
    setTimeout(function() {
      fn(this.polys, added, removed);
    }.bind(this), 0);
  }, this);
};

/**
 * Set the relationship between specific tile identifiers and the
 * polygons representing the shape of the obstacle they correspond
 * to.
 * @private
 * @param {Array.<number>} ids - The tile ids to set as impassable.
 * @param {string} obstacle - The identifier for the polygon for the
 *   obstacles (already passed to addObstaclePoly).
 */
NavMesh.prototype._setObstacleType = function(ids, type) {
  ids.forEach(function(id) {
    this.idToObstacles[id] = type;
  }, this);
};

/**
 * Check whether the provided id corresponds to a passable tile.
 * @return {boolean} - Whether the id is for a passable tile.
 */
NavMesh.prototype._isPassable = function(id) {
  // Check if in list of impassable tiles.
  return !this.impassable.hasOwnProperty(id) || !this.impassable[id];
};

/**
 * Get a polygon corresponding to the dimensions and location of the
 * provided tile update.
 * @private
 * @param {TileUpdate} tile - The tile update information.
 * @return {Poly} - The polygon representing the tile.
 */
NavMesh.prototype._getTilePoly = function(tile) {
  // Get the base poly from a list of such things by tile id
  // then translate according to the array location.
  var id = tile.v;
  var p = this._getWorldCoord(tile);
  var poly = this._getObstaclePoly(id).translate(p);
  return poly;
};

/**
 * Represents a point in space or a location in a 2d array.
 * @typedef PointLike
 * @type {object}
 * @property {number} x - The `x` coordinate for the point, or row
 *   for the array location.
 * @property {number} y - The `y` coordinate for the point. or column
 *   for the array location.
 */

/**
 * Given an array location, return the world coordinate representing
 * the center point of the tile at that array location.
 * @private
 * @param {PointLike} arrayLoc - The location in the map for the point.
 * @returm {Point} - The coordinates for the center of the location.
 */
NavMesh.prototype._getWorldCoord = function(arrayLoc) {
  var TILE_WIDTH = 40;
  return new Point(
    arrayLoc.x * TILE_WIDTH + (TILE_WIDTH / 2),
    arrayLoc.y * TILE_WIDTH + (TILE_WIDTH / 2)
  );
};

/**
 * Carry out the navmesh update for impassable dynamic obstacles that
 * have been removed from the navmesh.
 * @private
 * @param {Array.<TileUpdate>} updates - The tile update information.
 */
NavMesh.prototype._passableUpdate = function(updates) {
  var scale = 100;
  // Assume each of the tiles is now a square of open space.
  var passableTiles = updates.map(function(update) {
    return this._getTilePoly({
      x: update.x,
      y: update.y,
      v: 1
    });
  }, this);

  // Offset and merge newly passable tiles, assuming no tile along
  // with its offset would have been larger than a single tile.
  // Set offset slightly larger that normal so that we catch all
  // relevant polygons that need to be updated in the navmesh.
  var passableArea = this._offsetDynamicObs(passableTiles, 20);

  var cpr = NavMesh._geometry.cpr;

  // Get impassable tiles bordering the now-passable area and offset them.
  var borderingTiles = this._getBorderedTiles(updates);
  var borderingPolys = borderingTiles.map(this._getTilePoly, this);
  var surroundingArea = this._offsetDynamicObs(borderingPolys);

  // Get difference between the open area and the surrounding obstacles.
  cpr.Clear();
  var actualPassableArea = new ClipperLib.Paths();
  cpr.AddPaths(passableArea, ClipperLib.PolyType.ptSubject, true);
  cpr.AddPaths(surroundingArea, ClipperLib.PolyType.ptClip, true);
  cpr.Execute(ClipperLib.ClipType.ctDifference,
    actualPassableArea,
    ClipperLib.PolyFillType.pftNonZero,
    ClipperLib.PolyFillType.pftNonZero
  );

  var passableAreas = NavMesh._geometry.getAreas(actualPassableArea, scale);

  var passablePartition = NavMesh._geometry.partitionAreas(passableAreas);

  // Get mesh polys intersected by offsetted passable area.
  var intersection = this._getIntersectedPolys(passablePartition);
  var intersectedMeshPolys = intersection.polys;

  // Create outline with matched mesh polys.
  intersectedMeshPolys = intersectedMeshPolys.map(NavMesh._geometry.convertPolyToClipper);
  ClipperLib.JS.ScaleUpPaths(intersectedMeshPolys, scale);

  // Merge intersected mesh polys and with newly passable area.
  cpr.Clear();
  cpr.AddPaths(intersectedMeshPolys, ClipperLib.PolyType.ptSubject, true);
  cpr.AddPaths(actualPassableArea, ClipperLib.PolyType.ptSubject, true);
  var newMeshArea = new ClipperLib.Paths();
  cpr.Execute(
    ClipperLib.ClipType.ctUnion,
    newMeshArea,
    ClipperLib.PolyFillType.pftNonZero,
    null);

  // Partition the unioned mesh polys and new passable area and add
  // to the existing mesh polys.
  var meshAreas = NavMesh._geometry.getAreas(newMeshArea, scale);
  var newPolys = NavMesh._geometry.partitionAreas(meshAreas);
  Array.prototype.push.apply(this.polys, newPolys);

  this._update(this.polys, newPolys, intersection.indices);
};

/**
 * Carry out the navmesh update for impassable dynamic obstacles that
 * have been added to the navmesh.
 * @private
 * @param {Array.<TileUpdate>} updates - The tile update information.
 */
NavMesh.prototype._impassableUpdate = function(updates) {
  var scale = 100;
  // Get polygons defining these obstacles.
  var obstaclePolys = updates.map(function(update) {
    return this._getTilePoly(update);
  }, this);

  // Offset the obstacle polygons.
  var offsettedObstacles = this._offsetDynamicObs(obstaclePolys);
  var obstacleAreas = NavMesh._geometry.getAreas(offsettedObstacles);

  // Get convex partition of new obstacle areas for finding
  // intersections.
  var obstaclePartition = NavMesh._geometry.partitionAreas(obstacleAreas);

  // Get mesh polys intersected by offsetted obstacles.
  var intersection = this._getIntersectedPolys(obstaclePartition);
  var intersectedMeshPolys = intersection.polys;

  // Create outline with matched mesh polys.
  intersectedMeshPolys = intersectedMeshPolys.map(NavMesh._geometry.convertPolyToClipper);
  ClipperLib.JS.ScaleUpPaths(intersectedMeshPolys, scale);
  var cpr = NavMesh._geometry.cpr;

  // Merge matched polys
  cpr.Clear();
  cpr.AddPaths(intersectedMeshPolys, ClipperLib.PolyType.ptSubject, true);
  var mergedMeshPolys = new ClipperLib.Paths();
  cpr.Execute(
    ClipperLib.ClipType.ctUnion,
    mergedMeshPolys,
    ClipperLib.PolyFillType.pftNonZero,
    null);

  // Take difference of mesh polys and obstacle polys.
  var paths = new ClipperLib.Paths();
  cpr.Clear();
  cpr.AddPaths(mergedMeshPolys, ClipperLib.PolyType.ptSubject, true);
  cpr.AddPaths(offsettedObstacles, ClipperLib.PolyType.ptClip, true);

  cpr.Execute(ClipperLib.ClipType.ctDifference,
    paths,
    ClipperLib.PolyFillType.pftNonZero,
    ClipperLib.PolyFillType.pftNonZero
  );

  var areas = NavMesh._geometry.getAreas(paths, scale);
  // Make polys from new space.
  var polys = NavMesh._geometry.partitionAreas(areas);

  // Add to existing polygons.
  Array.prototype.push.apply(this.polys, polys);

  this._update(this.polys, polys, intersection.indices);
};

/**
 * Offsetting function for dynamic obstacles.
 * @private
 * @param {Array.<Poly>} obstacles
 * @param {number} [offset=16]
 * @return {Array.<Poly>}
 */
NavMesh.prototype._offsetDynamicObs = function(obstacles, offset) {
  if (typeof offset == 'undefined') offset = 16;
  var scale = 100;
  obstacles = obstacles.map(NavMesh._geometry.convertPolyToClipper);
  ClipperLib.JS.ScaleUpPaths(obstacles, scale);

  var cpr = NavMesh._geometry.cpr;
  var co = NavMesh._geometry.co;

  // Merge obstacles together, so obstacles that share a common edge
  // will be expanded properly.
  cpr.Clear();
  cpr.AddPaths(obstacles, ClipperLib.PolyType.ptSubject, true);
  var merged_obstacles = new ClipperLib.Paths();
  cpr.Execute(
    ClipperLib.ClipType.ctUnion,
    merged_obstacles,
    ClipperLib.PolyFillType.pftNonZero,
    null);

  // Offset obstacles.
  var offsetted_paths = new ClipperLib.Paths();

  merged_obstacles.forEach(function(obstacle) {
    var offsetted_obstacle = new ClipperLib.Paths();
    co.Clear();
    co.AddPath(obstacle, ClipperLib.JoinType.jtMiter, ClipperLib.EndType.etClosedPolygon);
    co.Execute(offsetted_obstacle, offset * scale);
    offsetted_paths.push(offsetted_obstacle[0]);
  });

  // Merge any newly-overlapping obstacles.
  cpr.Clear();
  cpr.AddPaths(offsetted_paths, ClipperLib.PolyType.ptSubject, true);
  merged_obstacles = new ClipperLib.Paths();
  cpr.Execute(
    ClipperLib.ClipType.ctUnion,
    merged_obstacles,
    ClipperLib.PolyFillType.pftNonZero,
    null);
  return merged_obstacles;
};

/**
 * Get and remove the mesh polygons impacted by the addition of new
 * obstacles. The provided obstacles should already be offsetted.
 * @private
 * @param {Array.<Poly>} obstacles - The offsetted obstacles to get
 *   the intersection of. Must be convex.
 * @return {Array.<Poly>} - The affected polys.
 */
NavMesh.prototype._getIntersectedPolys = function(obstacles) {
  var intersectedIndices = NavMesh._geometry.getIntersections(obstacles, this.polys);
  return {
    indices: intersectedIndices,
    polys: NavMesh._util.splice(this.polys, intersectedIndices)
  };
};

/**
 * Get the impassable tiles bordering updated passable tiles.
 * @private
 * @param {Array.<TileUpdate>} tiles - The updated passable tiles.
 * @return {Array.<ArrayLoc>} - The new array locations.
 */
NavMesh.prototype._getBorderedTiles = function(tiles) {
  // Track locations already being updated or added.
  var locations = {};
  tiles.forEach(function(tile) {
    locations[Point.toString(tile)] = true;
  });

  var map = this.map;
  var xUpperBound = map.length;
  var yUpperBound = map[0].length;
  // Get the locations adjacent to a given tile in the map.
  var getAdjacent = function(tile) {
    var x = tile.x;
    var y = tile.y;
    var xUp = x + 1 < xUpperBound;
    var xDown = x >= 0;
    var yUp = y + 1 < yUpperBound;
    var yDown = y >= 0;

    var adjacents = [];
    if (xUp) {
      adjacents.push({x: x + 1, y: y});
      if (yUp) {
        adjacents.push({x: x + 1, y: y + 1});
      }
      if (yDown) {
        adjacents.push({x: x + 1, y: y - 1});
      }
    }
    if (xDown) {
      adjacents.push({x: x - 1, y: y});
      if (yUp) {
        adjacents.push({x: x - 1, y: y + 1});
      }
      if (yDown) {
        adjacents.push({x: x - 1, y: y - 1});
      }
    }
    if (yUp) {
      adjacents.push({x: x, y: y + 1});
    }
    if (yDown) {
      adjacents.push({x: x, y: y - 1});
    }
    return adjacents;
  };

  // Store adjacent impassable tiles.
  var adjacent_tiles = [];
  tiles.forEach(function(tile) {
    var adjacents = getAdjacent(tile);
    adjacents.forEach(function(adjacent) {
      var id = Point.toString(adjacent);
      if (!locations[id]) {
        // Record as having been seen.
        locations[id] = true;
        var val = this.map[adjacent.x][adjacent.y];
        if (!this._isPassable(val)) {
          adjacent.v = val;
          adjacent_tiles.push(adjacent);
        }
      }
    }, this);
  }, this);
  return adjacent_tiles;
};

/**
 * Represents the outline of a shape along with its holes.
 * @typedef MapArea
 * @type {object}
 * @property {Poly} polygon - The polygon defining the exterior of
 *   the shape.
 * @property {Array.<Poly>} holes - The holes of the shape.
 */

/**
 * Offset the polygons such that there is a `offset` unit buffer
 * between the sides of the outline and around the obstacles. This
 * buffer makes it so that the mesh truly represents the movable area
 * in the map. Assumes vertices defining interior shapes (like the
 * main outline of an enclosed map) are given in CCW order and
 * obstacles are given in CW order.
 * @private
 * @param {Array.<Poly>} polys - The polygons to offset.
 * @param {number} [offset=16] - The amount to offset the polygons
 *   from the movable areas.
 * @return {Array.<MapArea>} - The shapes defining the polygons after
 *   offsetting and merging.
 */
NavMesh.prototype._offsetPolys = function(static_objects, offset) {
  // ~= ball radius / 2
  if (typeof offset == 'undefined') offset = 16;

  // Separate interior and exterior walls. The CCW shapes correspond
  // to the interior wall outlines of out map, the CW shapes are walls
  // that were traced on their outside.
  var interior_walls = [];
  var exterior_walls = static_objects.walls.filter(function(poly, index) {
    if (poly.getOrientation() == "CCW") {
      interior_walls.push(poly);
      return false;
    }
    return true;
  });

  var scale = 100;
  
  // Offset the interior walls.
  interior_walls = interior_walls.map(NavMesh._geometry.convertPolyToClipper);
  ClipperLib.JS.ScaleUpPaths(interior_walls, scale);
  
  var offsetted_interior_walls = [];
  interior_walls.forEach(function(wall) {
    var offsetted_paths = NavMesh._geometry.offsetInterior(wall, offset);
    Array.prototype.push.apply(offsetted_interior_walls, offsetted_paths);
  });

  // Reverse paths since from here on we're going to treat the
  // outlines as the exterior of a shape.
  offsetted_interior_walls.forEach(function(path) {
    path.reverse();
  });
  
  exterior_walls = exterior_walls.map(NavMesh._geometry.convertPolyToClipper);

  ClipperLib.JS.ScaleUpPaths(exterior_walls, scale);

  //var cpr = new ClipperLib.Clipper();
  var cpr = NavMesh._geometry.cpr;
  var co = NavMesh._geometry.co;
  
  var wall_fillType = ClipperLib.PolyFillType.pftEvenOdd;
  var obstacle_fillType = ClipperLib.PolyFillType.pftNonZero;
  
  // Offset exterior walls.
  var offsetted_exterior_walls = [];

  exterior_walls.forEach(function(wall) {
    var offsetted_exterior_wall = new ClipperLib.Paths();
    co.Clear();
    co.AddPath(wall, ClipperLib.JoinType.jtSquare, ClipperLib.EndType.etClosedPolygon);
    co.Execute(offsetted_exterior_wall, offset * scale);
    offsetted_exterior_walls.push(offsetted_exterior_wall[0]);
  });
  
  // Offset obstacles.
  // Obstacles are offsetted using miter join type to avoid
  // unnecessary small edges.
  var offsetted_obstacles = new ClipperLib.Paths();

  var obstacles = static_objects.obstacles.map(NavMesh._geometry.convertPolyToClipper);
  ClipperLib.JS.ScaleUpPaths(obstacles, scale);
  co.Clear();
  co.AddPaths(obstacles, ClipperLib.JoinType.jtMiter, ClipperLib.EndType.etClosedPolygon);
  co.Execute(offsetted_obstacles, offset * scale);

  // Take difference of polygons defining interior wall and polygons
  // defining exterior walls, limiting to exterior wall polygons whose
  // area is less than the interior wall polygons so the difference
  // operation doesn't remove potentially traversable areas.
  var merged_paths = [];
  offsetted_interior_walls.forEach(function(wall) {
    var area = ClipperLib.JS.AreaOfPolygon(wall, scale);
    var smaller_exterior_walls = offsetted_exterior_walls.filter(function(ext_wall) {
      return ClipperLib.JS.AreaOfPolygon(ext_wall, scale) < area;
    });
    var paths = new ClipperLib.Paths();
    cpr.Clear();
    cpr.AddPath(wall, ClipperLib.PolyType.ptSubject, true);
    cpr.AddPaths(smaller_exterior_walls, ClipperLib.PolyType.ptClip, true);
    // Obstacles are small individual solid objects that aren't at
    // risk of enclosing an interior area.
    cpr.AddPaths(offsetted_obstacles, ClipperLib.PolyType.ptClip, true);
    cpr.Execute(ClipperLib.ClipType.ctDifference,
      paths,
      ClipperLib.PolyFillType.pftNonZero,
      ClipperLib.PolyFillType.pftNonZero
    );
    Array.prototype.push.apply(merged_paths, paths);
  });

  return NavMesh._geometry.getAreas(merged_paths, scale);
};

/**
 * Sets up callbacks on the web worker promise object to initialize
 * the web worker interface once loaded.
 * @private
 */
NavMesh.prototype._setupWorker = function() {
  // Initial state.
  this.worker = new Worker(window.URL.createObjectURL(new Blob(['(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module \'"+o+"\'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (global){\n!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var e;"undefined"!=typeof window?e=window:"undefined"!=typeof global?e=global:"undefined"!=typeof self&&(e=self),e.PriorityQueue=t()}}(function(){return function t(e,i,r){function o(n,s){if(!i[n]){if(!e[n]){var u="function"==typeof require&&require;if(!s&&u)return u(n,!0);if(a)return a(n,!0);var h=new Error("Cannot find module \'"+n+"\'");throw h.code="MODULE_NOT_FOUND",h}var p=i[n]={exports:{}};e[n][0].call(p.exports,function(t){var i=e[n][1][t];return o(i?i:t)},p,p.exports,t,e,i,r)}return i[n].exports}for(var a="function"==typeof require&&require,n=0;n<r.length;n++)o(r[n]);return o}({1:[function(t,e){var i,r,o,a,n,s={}.hasOwnProperty,u=function(t,e){function i(){this.constructor=t}for(var r in e)s.call(e,r)&&(t[r]=e[r]);return i.prototype=e.prototype,t.prototype=new i,t.__super__=e.prototype,t};i=t("./PriorityQueue/AbstractPriorityQueue"),r=t("./PriorityQueue/ArrayStrategy"),a=t("./PriorityQueue/BinaryHeapStrategy"),o=t("./PriorityQueue/BHeapStrategy"),n=function(t){function e(t){t||(t={}),t.strategy||(t.strategy=a),t.comparator||(t.comparator=function(t,e){return(t||0)-(e||0)}),e.__super__.constructor.call(this,t)}return u(e,t),e}(i),n.ArrayStrategy=r,n.BinaryHeapStrategy=a,n.BHeapStrategy=o,e.exports=n},{"./PriorityQueue/AbstractPriorityQueue":2,"./PriorityQueue/ArrayStrategy":3,"./PriorityQueue/BHeapStrategy":4,"./PriorityQueue/BinaryHeapStrategy":5}],2:[function(t,e){var i;e.exports=i=function(){function t(t){if(null==(null!=t?t.strategy:void 0))throw"Must pass options.strategy, a strategy";if(null==(null!=t?t.comparator:void 0))throw"Must pass options.comparator, a comparator";this.priv=new t.strategy(t),this.length=0}return t.prototype.queue=function(t){return this.length++,void this.priv.queue(t)},t.prototype.dequeue=function(){if(!this.length)throw"Empty queue";return this.length--,this.priv.dequeue()},t.prototype.peek=function(){if(!this.length)throw"Empty queue";return this.priv.peek()},t}()},{}],3:[function(t,e){var i,r;r=function(t,e,i){var r,o,a;for(o=0,r=t.length;r>o;)a=o+r>>>1,i(t[a],e)>=0?o=a+1:r=a;return o},e.exports=i=function(){function t(t){var e;this.options=t,this.comparator=this.options.comparator,this.data=(null!=(e=this.options.initialValues)?e.slice(0):void 0)||[],this.data.sort(this.comparator).reverse()}return t.prototype.queue=function(t){var e;return e=r(this.data,t,this.comparator),void this.data.splice(e,0,t)},t.prototype.dequeue=function(){return this.data.pop()},t.prototype.peek=function(){return this.data[this.data.length-1]},t}()},{}],4:[function(t,e){var i;e.exports=i=function(){function t(t){var e,i,r,o,a,n,s,u,h;for(this.comparator=(null!=t?t.comparator:void 0)||function(t,e){return t-e},this.pageSize=(null!=t?t.pageSize:void 0)||512,this.length=0,r=0;1<<r<this.pageSize;)r+=1;if(1<<r!==this.pageSize)throw"pageSize must be a power of two";for(this._shift=r,this._emptyMemoryPageTemplate=e=[],i=a=0,u=this.pageSize;u>=0?u>a:a>u;i=u>=0?++a:--a)e.push(null);if(this._memory=[],this._mask=this.pageSize-1,t.initialValues)for(h=t.initialValues,n=0,s=h.length;s>n;n++)o=h[n],this.queue(o)}return t.prototype.queue=function(t){return this.length+=1,this._write(this.length,t),void this._bubbleUp(this.length,t)},t.prototype.dequeue=function(){var t,e;return t=this._read(1),e=this._read(this.length),this.length-=1,this.length>0&&(this._write(1,e),this._bubbleDown(1,e)),t},t.prototype.peek=function(){return this._read(1)},t.prototype._write=function(t,e){var i;for(i=t>>this._shift;i>=this._memory.length;)this._memory.push(this._emptyMemoryPageTemplate.slice(0));return this._memory[i][t&this._mask]=e},t.prototype._read=function(t){return this._memory[t>>this._shift][t&this._mask]},t.prototype._bubbleUp=function(t,e){var i,r,o,a;for(i=this.comparator;t>1&&(r=t&this._mask,t<this.pageSize||r>3?o=t&~this._mask|r>>1:2>r?(o=t-this.pageSize>>this._shift,o+=o&~(this._mask>>1),o|=this.pageSize>>1):o=t-2,a=this._read(o),!(i(a,e)<0));)this._write(o,e),this._write(t,a),t=o;return void 0},t.prototype._bubbleDown=function(t,e){var i,r,o,a,n;for(n=this.comparator;t<this.length;)if(t>this._mask&&!(t&this._mask-1)?i=r=t+2:t&this.pageSize>>1?(i=(t&~this._mask)>>1,i|=t&this._mask>>1,i=i+1<<this._shift,r=i+1):(i=t+(t&this._mask),r=i+1),i!==r&&r<=this.length)if(o=this._read(i),a=this._read(r),n(o,e)<0&&n(o,a)<=0)this._write(i,e),this._write(t,o),t=i;else{if(!(n(a,e)<0))break;this._write(r,e),this._write(t,a),t=r}else{if(!(i<=this.length))break;if(o=this._read(i),!(n(o,e)<0))break;this._write(i,e),this._write(t,o),t=i}return void 0},t}()},{}],5:[function(t,e){var i;e.exports=i=function(){function t(t){var e;this.comparator=(null!=t?t.comparator:void 0)||function(t,e){return t-e},this.length=0,this.data=(null!=(e=t.initialValues)?e.slice(0):void 0)||[],this._heapify()}return t.prototype._heapify=function(){var t,e,i;if(this.data.length>0)for(t=e=1,i=this.data.length;i>=1?i>e:e>i;t=i>=1?++e:--e)this._bubbleUp(t);return void 0},t.prototype.queue=function(t){return this.data.push(t),void this._bubbleUp(this.data.length-1)},t.prototype.dequeue=function(){var t,e;return e=this.data[0],t=this.data.pop(),this.data.length>0&&(this.data[0]=t,this._bubbleDown(0)),e},t.prototype.peek=function(){return this.data[0]},t.prototype._bubbleUp=function(t){for(var e,i;t>0&&(e=t-1>>>1,this.comparator(this.data[t],this.data[e])<0);)i=this.data[e],this.data[e]=this.data[t],this.data[t]=i,t=e;return void 0},t.prototype._bubbleDown=function(t){var e,i,r,o,a;for(e=this.data.length-1;;){if(i=(t<<1)+1,o=i+1,r=t,e>=i&&this.comparator(this.data[i],this.data[r])<0&&(r=i),e>=o&&this.comparator(this.data[o],this.data[r])<0&&(r=o),r===t)break;a=this.data[r],this.data[r]=this.data[t],this.data[t]=a,t=r}return void 0},t}()},{}]},{},[1])(1)});\n}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\n},{}],2:[function(require,module,exports){\nvar Pathfinder = require(\'./pathfinder\');\r\nvar geo = require(\'./geometry\');\r\n\r\n/**\r\n * Pathfinding web worker implementation.\r\n * @ignore\r\n */\r\nvar Point = geo.Point;\r\nvar Poly = geo.Poly;\r\n\r\n/**\r\n * Object with utility methods for converting objects from serialized\r\n * message form into the required objects.\r\n * @private\r\n */\r\nvar Convert = {};\r\n\r\n/**\r\n * The format of a Point as serialized by the Web Worker message-\r\n * passing interface.\r\n * @private\r\n * @typedef {object} PointObj\r\n * @property {number} x\r\n * @property {number} y\r\n */\r\n\r\n/**\r\n * Convert serialized Point object back to Point.\r\n * @private\r\n * @param {PointObj} obj - The serialized Point object.\r\n */\r\nConvert.toPoint = function(obj) {\r\n  return new Point(obj.x, obj.y);\r\n};\r\n\r\n/**\r\n * The format of a Poly as serialized by the Web Worker message-\r\n * passing interface.\r\n * @private\r\n * @typedef {object} PolyObj\r\n * @property {Array.<PointObj>} points - The array of serialized\r\n *   Points.\r\n * @property {boolean} hole - Whether or not the polygon is a hole.\r\n * @property {integer} numpoints - The number of points in the Poly.\r\n */\r\n\r\n /**\r\n  * Convert serialized Poly object back to Poly.\r\n  * @private\r\n  * @param {PolyObj} obj - The serialized Poly object.\r\n  */\r\nConvert.toPoly = function(obj) {\r\n  var poly = new Poly();\r\n  poly.points = obj.points.map(Convert.toPoint);\r\n  poly.hole = obj.hole;\r\n  poly.update();\r\n  return poly;\r\n};\r\n\r\nvar Logger = {};\r\n\r\n/**\r\n * Sends message to parent to be logged to console. Takes same\r\n * arguments as Bragi logger.\r\n * @private\r\n * @param {string} group - The group to associate the message with.\r\n * @param {...*} - arbitrary arguments to be passed back to the parent\r\n *   logging function.\r\n */\r\nLogger.log = function(group) {\r\n  var message = ["log"];\r\n  Array.prototype.push.apply(message, arguments);\r\n  postMessage(message);\r\n};\r\n\r\nvar Util = {};\r\n\r\nUtil.splice = function(ary, indices) {\r\n  indices = indices.sort(Util._numberCompare).reverse();\r\n  var removed = [];\r\n  indices.forEach(function(i) {\r\n    removed.push(ary.splice(i, 1)[0]);\r\n  });\r\n  return removed;\r\n};\r\n\r\nUtil._numberCompare = function(a, b) {\r\n  if (a < b) {\r\n    return -1;\r\n  } else if (a > b) {\r\n    return 1;\r\n  } else {\r\n    return 0;\r\n  }\r\n};\r\n\r\n/**\r\n * Set up various actions to take on communication.\r\n * @private\r\n * @param {Array} e - An array with the first element being a string\r\n *   identifier for the message type, and subsequent elements being\r\n *   arguments to be passed to the relevant function. Message types:\r\n *   * polys - sets the polygons to use for navigation\r\n *       - {Array.<Poly>} array of polygons defining the map\r\n *   * aStar - computes A* on above-set items\r\n *       - {Point} start location to use for search\r\n *       - {Point} end location to use for search\r\n *   * isInitialized - check if the worker is initialized.\r\n */\r\nonmessage = function(e) {\r\n  var data = e.data;\r\n  var name = data[0];\r\n  Logger.log("worker:debug", "Message received by worker:", data);\r\n  if (name == "polys") {\r\n    // Polygons defining map.\r\n    self.polys = data[1].map(Convert.toPoly);\r\n\r\n    // Initialize pathfinder module.\r\n    self.pathfinder = new Pathfinder(self.polys);\r\n  } else if (name == "polyUpdate") {\r\n    // Update to navmesh.\r\n    var newPolys = data[1].map(Convert.toPoly);\r\n    var removedPolys = data[2];\r\n\r\n    Util.splice(self.polys, removedPolys);\r\n    Array.prototype.push.apply(self.polys, newPolys);\r\n\r\n    // Re-initialize pathfinder.\r\n    self.pathfinder = new Pathfinder(self.polys);\r\n  } else if (name == "aStar") {\r\n    var source = Convert.toPoint(data[1]);\r\n    var target = Convert.toPoint(data[2]);\r\n\r\n    var path = self.pathfinder.aStar(source, target);\r\n    postMessage(["result", path]);\r\n  } else if (name == "isInitialized") {\r\n    postMessage(["initialized"]);\r\n  }\r\n};\r\n\r\nLogger.log("worker", "Worker loaded.");\r\n// Sent confirmation that worker is initialized.\r\npostMessage(["initialized"]);\r\n\n},{"./geometry":3,"./pathfinder":4}],3:[function(require,module,exports){\n/**\r\n * A point can represent a vertex in a 2d environment or a vector.\r\n * @constructor\r\n * @param {number} x - The `x` coordinate of the point.\r\n * @param {number} y - The `y` coordinate of the point.\r\n */\r\nPoint = function(x, y) {\r\n  this.x = x;\r\n  this.y = y;\r\n};\r\nexports.Point = Point;\r\n\r\n/**\r\n * Convert a point-like object into a point.\r\n * @param {PointLike} p - The point-like object to convert.\r\n * @return {Point} - The new point representing the point-like\r\n *   object.\r\n */\r\nPoint.fromPointLike = function(p) {\r\n  return new Point(p.x, p.y);\r\n};\r\n\r\n/**\r\n * String method for point-like objects.\r\n * @param {PointLike} p - The point-like object to convert.\r\n * @return {Point} - The new point representing the point-like\r\n *   object.\r\n */\r\nPoint.toString = function(p) {\r\n  return "x" + p.x + "y" + p.y;\r\n};\r\n\r\n/**\r\n * Takes a point or scalar and adds slotwise in the case of another\r\n * point, or to each parameter in the case of a scalar.\r\n * @param {(Point|number)} - The Point, or scalar, to add to this\r\n *   point.\r\n */\r\nPoint.prototype.add = function(p) {\r\n  if (typeof p == "number")\r\n    return new Point(this.x + p, this.y + p);\r\n  return new Point(this.x + p.x, this.y + p.y);\r\n};\r\n\r\n/**\r\n * Takes a point or scalar and subtracts slotwise in the case of\r\n * another point or from each parameter in the case of a scalar.\r\n * @param {(Point|number)} - The Point, or scalar, to subtract from\r\n *   this point.\r\n */\r\nPoint.prototype.sub = function(p) {\r\n  if (typeof p == "number")\r\n    return new Point(this.x - p, this.y - p);\r\n  return new Point(this.x - p.x, this.y - p.y);\r\n};\r\n\r\n/**\r\n * Takes a scalar value and multiplies each parameter of the point\r\n * by the scalar.\r\n * @param  {number} f - The number to multiple the parameters by.\r\n * @return {Point} - A new point with the calculated coordinates.\r\n */\r\nPoint.prototype.mul = function(f) {\r\n  return new Point(this.x * f, this.y * f);\r\n};\r\n\r\n/**\r\n * Takes a scalar value and divides each parameter of the point\r\n * by the scalar.\r\n * @param  {number} f - The number to divide the parameters by.\r\n * @return {Point} - A new point with the calculated coordinates.\r\n */\r\nPoint.prototype.div = function(f) {\r\n  return new Point(this.x / f, this.y / f);\r\n};\r\n\r\n/**\r\n * Takes another point and returns a boolean indicating whether the\r\n * points are equal. Two points are equal if their parameters are\r\n * equal.\r\n * @param  {Point} p - The point to check equality against.\r\n * @return {boolean} - Whether or not the two points are equal.\r\n */\r\nPoint.prototype.eq = function(p) {\r\n  return (this.x == p.x && this.y == p.y);\r\n};\r\n\r\n/**\r\n * Takes another point and returns a boolean indicating whether the\r\n * points are not equal. Two points are considered not equal if their\r\n * parameters are not equal.\r\n * @param  {Point} p - The point to check equality against.\r\n * @return {boolean} - Whether or not the two points are not equal.\r\n */\r\nPoint.prototype.neq = function(p) {\r\n  return (this.x != p.x || this.y != p.y);\r\n};\r\n\r\n// Given another point, returns the dot product.\r\nPoint.prototype.dot = function(p) {\r\n  return (this.x * p.x + this.y * p.y);\r\n};\r\n\r\n// Given another point, returns the \'cross product\', or at least the 2d\r\n// equivalent.\r\nPoint.prototype.cross = function(p) {\r\n  return (this.x * p.y - this.y * p.x);\r\n};\r\n\r\n// Given another point, returns the distance to that point.\r\nPoint.prototype.dist = function(p) {\r\n  var diff = this.sub(p);\r\n  return Math.sqrt(diff.dot(diff));\r\n};\r\n\r\n// Given another point, returns the squared distance to that point.\r\nPoint.prototype.dist2 = function(p) {\r\n  var diff = this.sub(p);\r\n  return diff.dot(diff);\r\n};\r\n\r\n/**\r\n * Returns true if the point is (0, 0).\r\n * @return {boolean} - Whether or not the point is (0, 0).\r\n */\r\nPoint.prototype.zero = function() {\r\n  return this.x == 0 && this.y == 0;\r\n};\r\n\r\nPoint.prototype.len = function() {\r\n  return this.dist(new Point(0, 0));\r\n};\r\n\r\nPoint.prototype.normalize = function() {\r\n  var n = this.dist(new Point(0, 0));\r\n  if (n > 0) return this.div(n);\r\n  return new Point(0, 0);\r\n};\r\n\r\nPoint.prototype.toString = function() {\r\n  return \'x\' + this.x + \'y\' + this.y;\r\n};\r\n\r\n/**\r\n * Return a copy of the point.\r\n * @return {Point} - The new point.\r\n */\r\nPoint.prototype.clone = function() {\r\n  return new Point(this.x, this.y);\r\n};\r\n\r\n/**\r\n * Edges are used to represent the border between two adjacent\r\n * polygons.\r\n * @constructor\r\n * @param {Point} p1 - The first point of the edge.\r\n * @param {Point} p2 - The second point of the edge.\r\n */\r\nEdge = function(p1, p2) {\r\n  this.p1 = p1;\r\n  this.p2 = p2;\r\n  this.center = p1.add(p2.sub(p1).div(2));\r\n  this.points = [this.p1, this.center, this.p2];\r\n};\r\nexports.Edge = Edge;\r\n\r\nEdge.prototype._CCW = function(p1, p2, p3) {\r\n  a = p1.x; b = p1.y;\r\n  c = p2.x; d = p2.y;\r\n  e = p3.x; f = p3.y;\r\n  return (f - b) * (c - a) > (d - b) * (e - a);\r\n};\r\n\r\n/**\r\n * from http://stackoverflow.com/a/16725715\r\n * Checks whether this edge intersects the provided edge.\r\n * @param {Edge} edge - The edge to check intersection for.\r\n * @return {boolean} - Whether or not the edges intersect.\r\n */\r\nEdge.prototype.intersects = function(edge) {\r\n  var q1 = edge.p1, q2 = edge.p2;\r\n  if (q1.eq(this.p1) || q1.eq(this.p2) || q2.eq(this.p1) || q2.eq(this.p2)) return false;\r\n  return (this._CCW(this.p1, q1, q2) != this._CCW(this.p2, q1, q2)) && (this._CCW(this.p1, this.p2, q1) != this._CCW(this.p1, this.p2, q2));\r\n};\r\n\r\n/**\r\n * Polygon class.\r\n * Can be initialized with an array of points.\r\n * @constructor\r\n * @param {Array.<Point>} [points] - The points to use to initialize\r\n *   the poly.\r\n */\r\nPoly = function(points) {\r\n  if (typeof points == \'undefined\') points = false;\r\n  this.hole = false;\r\n  this.points = null;\r\n  this.numpoints = 0;\r\n  if (points) {\r\n    this.numpoints = points.length;\r\n    this.points = points.slice();\r\n  }\r\n};\r\nexports.Poly = Poly;\r\n\r\nPoly.prototype.init = function(n) {\r\n  this.points = new Array(n);\r\n  this.numpoints = n;\r\n};\r\n\r\nPoly.prototype.update = function() {\r\n  this.numpoints = this.points.length;\r\n};\r\n\r\nPoly.prototype.triangle = function(p1, p2, p3) {\r\n  this.init(3);\r\n  this.points[0] = p1;\r\n  this.points[1] = p2;\r\n  this.points[2] = p3;\r\n};\r\n\r\n// Takes an index and returns the point at that index, or null.\r\nPoly.prototype.getPoint = function(n) {\r\n  if (this.points && this.numpoints > n)\r\n    return this.points[n];\r\n  return null;\r\n};\r\n\r\n// Set a point, fails silently otherwise. TODO: replace with bracket notation.\r\nPoly.prototype.setPoint = function(i, p) {\r\n  if (this.points && this.points.length > i) {\r\n    this.points[i] = p;\r\n  }\r\n};\r\n\r\n// Given an index i, return the index of the next point.\r\nPoly.prototype.getNextI = function(i) {\r\n  return (i + 1) % this.numpoints;\r\n};\r\n\r\nPoly.prototype.getPrevI = function(i) {\r\n  if (i == 0)\r\n    return (this.numpoints - 1);\r\n  return i - 1;\r\n};\r\n\r\n// Returns the signed area of a polygon, if the vertices are given in\r\n// CCW order then the area will be > 0, < 0 otherwise.\r\nPoly.prototype.getArea = function() {\r\n  var area = 0;\r\n  for (var i = 0; i < this.numpoints; i++) {\r\n    var i2 = this.getNextI(i);\r\n    area += this.points[i].x * this.points[i2].y - this.points[i].y * this.points[i2].x;\r\n  }\r\n  return area;\r\n};\r\n\r\nPoly.prototype.getOrientation = function() {\r\n  var area = this.getArea();\r\n  if (area > 0) return "CCW";\r\n  if (area < 0) return "CW";\r\n  return 0;\r\n};\r\n\r\nPoly.prototype.setOrientation = function(orientation) {\r\n  var current_orientation = this.getOrientation();\r\n  if (current_orientation && (current_orientation !== orientation)) {\r\n    this.invert();\r\n  }\r\n};\r\n\r\nPoly.prototype.invert = function() {\r\n  var newpoints = new Array(this.numpoints);\r\n  for (var i = 0; i < this.numpoints; i++) {\r\n    newpoints[i] = this.points[this.numpoints - i - 1];\r\n  }\r\n  this.points = newpoints;\r\n};\r\n\r\nPoly.prototype.getCenter = function() {\r\n  var x = this.points.map(function(p) { return p.x });\r\n  var y = this.points.map(function(p) { return p.y });\r\n  var minX = Math.min.apply(null, x);\r\n  var maxX = Math.max.apply(null, x);\r\n  var minY = Math.min.apply(null, y);\r\n  var maxY = Math.max.apply(null, y);\r\n  return new Point((minX + maxX)/2, (minY + maxY)/2);\r\n};\r\n\r\n// Adapted from http://stackoverflow.com/a/16283349\r\nPoly.prototype.centroid = function() {\r\n  var x = 0,\r\n      y = 0,\r\n      i,\r\n      j,\r\n      f,\r\n      point1,\r\n      point2;\r\n\r\n  for (i = 0, j = this.points.length - 1; i < this.points.length; j = i, i += 1) {\r\n    point1 = this.points[i];\r\n    point2 = this.points[j];\r\n    f = point1.x * point2.y - point2.x * point1.y;\r\n    x += (point1.x + point2.x) * f;\r\n    y += (point1.y + point2.y) * f;\r\n  }\r\n\r\n  f = this.getArea() * 3;\r\n  x = Math.abs(x);\r\n  y = Math.abs(y);\r\n  return new Point(x / f, y / f);\r\n};\r\n\r\nPoly.prototype.toString = function() {\r\n  var center = this.centroid();\r\n  return "" + center.x + " " + center.y;\r\n};\r\n\r\n/**\r\n * Checks if the given point is contained within the Polygon.\r\n * Adapted from http://stackoverflow.com/a/8721483\r\n *\r\n * @param {Point} p - The point to check.\r\n * @return {boolean} - Whether or not the point is contained within\r\n *   the polygon.\r\n */\r\nPoly.prototype.containsPoint = function(p) {\r\n  var result = false;\r\n  for (var i = 0, j = this.numpoints - 1; i < this.numpoints; j = i++) {\r\n    var p1 = this.points[j], p2 = this.points[i];\r\n    if ((p2.y > p.y) != (p1.y > p.y) &&\r\n        (p.x < (p1.x - p2.x) * (p.y - p2.y) / (p1.y - p2.y) + p2.x)) {\r\n      result = !result;\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\n/**\r\n * Clone the given polygon into a new polygon.\r\n * @return {Poly} - A clone of the polygon.\r\n */\r\nPoly.prototype.clone = function() {\r\n  return new Poly(this.points.slice().map(function(point) {\r\n    return point.clone();\r\n  }));\r\n};\r\n\r\n/**\r\n * Translate a polygon along a given vector.\r\n * @param {Point} vec - The vector along which to translate the\r\n *   polygon.\r\n * @return {Poly} - The translated polygon.\r\n */\r\nPoly.prototype.translate = function(vec) {\r\n  return new Poly(this.points.map(function(point) {\r\n    return point.add(vec);\r\n  }));\r\n};\r\n\r\n/**\r\n * Returns an array of edges representing the polygon.\r\n * @return {Array.<Edge>} - The edges of the polygon.\r\n */\r\nPoly.prototype.edges = function() {\r\n  if (!this.hasOwnProperty("cached_edges")) {\r\n    this.cached_edges = this.points.map(function(point, i) {\r\n      return new Edge(point, this.points[this.getNextI(i)]);\r\n    }, this);\r\n  }\r\n  return this.cached_edges;\r\n};\r\n\r\n/**\r\n * Naive check if other poly intersects this one, assuming both convex.\r\n * @param {Poly} poly\r\n * @return {boolean} - Whether the polygons intersect.\r\n */\r\nPoly.prototype.intersects = function(poly) {\r\n  var inside = poly.points.some(function(p) {\r\n    return this.containsPoint(p);\r\n  }, this);\r\n  inside = inside || this.points.some(function(p) {\r\n    return poly.containsPoint(p);\r\n  });\r\n  if (inside) {\r\n    return true;\r\n  } else {\r\n    var ownEdges = this.edges();\r\n    var otherEdges = poly.edges();\r\n    var intersect = ownEdges.some(function(ownEdge) {\r\n      return otherEdges.some(function(otherEdge) {\r\n        return ownEdge.intersects(otherEdge);\r\n      });\r\n    });\r\n    return intersect;\r\n  }\r\n};\r\n\r\nvar util = {};\r\nexports.util = util;\r\n\r\n/**\r\n * Given an array of polygons, returns the one that contains the point.\r\n * If no polygon is found, null is returned.\r\n * @param {Point} p - The point to find the polygon for.\r\n * @param {Array.<Poly>} polys - The polygons to search for the point.\r\n * @return {?Polygon} - The polygon containing the point.\r\n */\r\nutil.findPolyForPoint = function(p, polys) {\r\n  var i, poly;\r\n  for (i in polys) {\r\n    poly = polys[i];\r\n    if (poly.containsPoint(p)) {\r\n      return poly;\r\n    }\r\n  }\r\n  return null;\r\n};\r\n\r\n/**\r\n * Holds the properties of a collision, if one occurred.\r\n * @typedef Collision\r\n * @type {object}\r\n * @property {boolean} collides - Whether there is a collision.\r\n * @property {boolean} inside - Whether one object is inside the other.\r\n * @property {?Point} point - The point of collision, if collision\r\n *   occurs, and if `inside` is false.\r\n * @property {?Point} normal - A unit vector normal to the point\r\n *   of collision, if it occurs and if `inside` is false.\r\n */\r\n/**\r\n * If the ray intersects the circle, the distance to the intersection\r\n * along the ray is returned, otherwise false is returned.\r\n * @param {Point} p - The start of the ray.\r\n * @param {Point} ray - Unit vector extending from `p`.\r\n * @param {Point} c - The center of the circle for the object being\r\n *   checked for intersection.\r\n * @param {number} radius - The radius of the circle.\r\n * @return {Collision} - The collision information.\r\n */\r\nutil.lineCircleIntersection = function(p, ray, c, radius) {\r\n  var collision = {\r\n    collides: false,\r\n    inside: false,\r\n    point: null,\r\n    normal: null\r\n  };\r\n  var vpc = c.sub(p);\r\n\r\n  if (vpc.len() <= radius) {\r\n    // Point is inside obstacle.\r\n    collision.collides = true;\r\n    collision.inside = (vpc.len() !== radius);\r\n  } else if (ray.dot(vpc) >= 0) {\r\n    // Circle is ahead of point.\r\n    // Projection of center point onto ray.\r\n    var pc = p.add(ray.mul(ray.dot(vpc)));\r\n    // Length from c to its projection on the ray.\r\n    var len_c_pc = c.sub(pc).len();\r\n\r\n    if (len_c_pc <= radius) {\r\n      collision.collides = true;\r\n\r\n      // Distance from projected point to intersection.\r\n      var len_intersection = Math.sqrt(len_c_pc * len_c_pc + radius * radius);\r\n      collision.point = pc.sub(ray.mul(len_intersection));\r\n      collision.normal = collision.point.sub(c).normalize();\r\n    }\r\n  }\r\n  return collision;\r\n};\r\n\n},{}],4:[function(require,module,exports){\nvar geo = require(\'./geometry\');\r\nvar findPolyForPoint = geo.util.findPolyForPoint;\r\nvar PriorityQueue = require(\'priority-queue\');\r\n\r\n/**\r\n * Pathfinder implements pathfinding on a navigation mesh.\r\n * @constructor\r\n * @param {Array.<Poly>} polys - The polygons defining the navigation mesh.\r\n * @param {boolean} [init=true] - Whether or not to initialize the pathfinder.\r\n */\r\nvar Pathfinder = function(polys, init) {\r\n  if (typeof init == "undefined") init = true;\r\n  this.polys = polys;\r\n  if (init) {\r\n    this.init();\r\n  }\r\n};\r\nmodule.exports = Pathfinder;\r\n\r\nPathfinder.prototype.init = function() {\r\n  this.grid = this.generateAdjacencyGrid(this.polys);\r\n};\r\n\r\n/**\r\n * Computes path from source to target, using sides and centers of the edges\r\n * between adjacent polygons. source and target are Points and polys should\r\n * be the final partitioned map.\r\n * @param {Point} source - The start location for the search.\r\n * @param {Point} target - The target location for the search.\r\n * @return {?Array.<Point>} - A series of points representing the path from\r\n *   the source to the target. If a path is not found, `null` is returned.\r\n */\r\nPathfinder.prototype.aStar = function(source, target) {\r\n  // Compares the value of two nodes.\r\n  function nodeValue(node1, node2) {\r\n    return (node1.dist + heuristic(node1.point)) - (node2.dist + heuristic(node2.point));\r\n  }\r\n\r\n  // Distance between polygons.\r\n  function euclideanDistance(p1, p2) {\r\n    return p1.dist(p2);\r\n  }\r\n\r\n  // Distance between polygons. todo: update\r\n  function manhattanDistance(elt1, elt2) {\r\n    return (elt1.r - elt2.r) + (elt1.c - elt2.c);\r\n  }\r\n\r\n  // Takes Point and returns value.\r\n  function heuristic(p) {\r\n    return euclideanDistance(p, target);\r\n  }\r\n\r\n  var sourcePoly = findPolyForPoint(source, this.polys);\r\n\r\n  // We\'re outside of the mesh somehow. Try a few nearby points.\r\n  if (!sourcePoly) {\r\n    var offsetSource = [new Point(5, 0), new Point(-5, 0), new Point(0, -5), new Point(0, 5)];\r\n    for (var i = 0; i < offsetSource.length; i++) {\r\n      // Make new point.\r\n      var point = source.add(offsetSource[i]);\r\n      sourcePoly = findPolyForPoint(point, this.polys);\r\n      if (sourcePoly) {\r\n        source = point;\r\n        break;\r\n      }\r\n    }\r\n    if (!sourcePoly) {\r\n      return null;\r\n    }\r\n  }\r\n  var targetPoly = findPolyForPoint(target, this.polys);\r\n\r\n  // Handle trivial case.\r\n  if (sourcePoly == targetPoly) {\r\n    return [source, target];\r\n  }\r\n\r\n  // Warning, may have compatibility issues.\r\n  var discoveredPolys = new WeakSet();\r\n  var discoveredPoints = new WeakSet();\r\n  var pq = new PriorityQueue({ comparator: nodeValue });\r\n  var found = null;\r\n  // Initialize with start location.\r\n  pq.queue({dist: 0, poly: sourcePoly, point: source, parent: null});\r\n  while (pq.length > 0) {\r\n    var node = pq.dequeue();\r\n    if (node.poly == targetPoly) {\r\n      found = node;\r\n      break;\r\n    } else {\r\n      discoveredPolys.add(node.poly);\r\n      discoveredPoints.add(node.point);\r\n    }\r\n    // This may be undefined if there was no polygon found.\r\n    var neighbors = this.grid.get(node.poly);\r\n    for (var i = 0; i < neighbors.length; i++) {\r\n      var elt = neighbors[i];\r\n      var neighborFound = discoveredPolys.has(elt.poly);\r\n\r\n      for (var j = 0; j < elt.edge.points.length; j++) {\r\n        var p = elt.edge.points[j];\r\n        if (!neighborFound || !discoveredPoints.has(p))\r\n          pq.queue({dist: node.dist + euclideanDistance(p, node.point), poly: elt.poly, point: p, parent: node});\r\n      }\r\n    }\r\n  }\r\n\r\n  if (found) {\r\n    var path = [];\r\n    var current = found;\r\n    while (current.parent) {\r\n      path.unshift(current.point);\r\n      current = current.parent;\r\n    }\r\n    path.unshift(current.point);\r\n    // Add end point to path.\r\n    path.push(target);\r\n    return path;\r\n  } else {\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Holds the "neighbor" relationship of Poly objects in the partition\r\n * using the Poly\'s themselves as keys, and an array of Poly\'s as\r\n * values, where the Polys in the array are neighbors of the Poly\r\n * that was the key.\r\n * @typedef AdjacencyGrid\r\n * @type {Object.<Poly, Array<Poly>>}\r\n */\r\n\r\n/**\r\n * Given an array of Poly objects, find all neighboring polygons for\r\n * each polygon.\r\n * @private\r\n * @param {Array.<Poly>} polys - The array of polys to find neighbors\r\n *   among.\r\n * @return {AdjacencyGrid} - The "neighbor" relationships.\r\n */\r\nPathfinder.prototype.generateAdjacencyGrid = function(polys) {\r\n  var neighbors = new WeakMap();\r\n  polys.forEach(function(poly, polyI, polys) {\r\n    if (neighbors.has(poly)) {\r\n      // Maximum number of neighbors already found.\r\n      if (neighbors.get(poly).length == poly.numpoints) {\r\n        return;\r\n      }\r\n    } else {\r\n      // Initialize array.\r\n      neighbors.set(poly, new Array());\r\n    }\r\n    // Of remaining polygons, find some that are adjacent.\r\n    poly.points.forEach(function(p1, i, points) {\r\n      // Next point.\r\n      var p2 = points[poly.getNextI(i)];\r\n      for (var polyJ = polyI + 1; polyJ < polys.length; polyJ++) {\r\n        var poly2 = polys[polyJ];\r\n        // Iterate over points until match is found.\r\n        poly2.points.some(function(q1, j, points2) {\r\n          var q2 = points2[poly2.getNextI(j)];\r\n          var match = p1.eq(q2) && p2.eq(q1);\r\n          if (match) {\r\n            var edge = new Edge(p1, p2);\r\n            neighbors.get(poly).push({ poly: poly2, edge: edge });\r\n            if (!neighbors.has(poly2)) {\r\n              neighbors.set(poly2, new Array());\r\n            }\r\n            neighbors.get(poly2).push({ poly: poly, edge: edge });\r\n          }\r\n          return match;\r\n        });\r\n        if (neighbors.get(poly).length == poly.numpoints) break;\r\n      }\r\n    });\r\n  });\r\n  return neighbors;\r\n};\r\n\n},{"./geometry":3,"priority-queue":1}]},{},[2])'],{type:"text/javascript"})));
  this.worker.onmessage = this._getWorkerInterface();
  // Check if worker is already initialized.
  this.worker.postMessage(["isInitialized"]);
  this.workerInitialized = false;

  // Set up callback to update worker on navmesh update.
  this.onUpdate(function(disregard, newPolys, removedIndices) {
    if (this.worker && this.workerInitialized) {
      this.worker.postMessage(["polyUpdate", newPolys, removedIndices]);
    } else {
      this.logger.log("navmesh:debug", "Worker not loaded yet.");
    }
  }.bind(this));
};

/**
 * Handler for log messages sent by worker.
 * @private
 * @param {Array.<(string|object)>} message - Array of arguments to
 *   pass to `Logger.log`. The first element should be the group to
 *   associate the message with.
 */
NavMesh.prototype._workerLogger = function(message) {
  this.logger.log.apply(null, message);
};

/**
 * Returns the function to be used for the `onmessage` callback for
 * the web worker.
 * @private
 * @return {Function} - The `onmessage` handler for the web worker.
 */
NavMesh.prototype._getWorkerInterface = function() {
  return function(message) {
    var data = message.data;
    var name = data[0];

    // Output debug message for all messages received except "log"
    // messages.
    if (name !== "log")
      this.logger.log("navmesh:debug", "Message received from worker:", data);

    if (name == "log") {
      this._workerLogger(data.slice(1));
    } else if (name == "result") {
      var path = data[1];
      this.lastCallback(path);
    } else if (name == "initialized") {
      this.workerInitialized = true;
      // Send parsed map polygons to worker when available.
      this.onInit(function() {
        this.worker.postMessage(["polys", this.polys]);
      }.bind(this));
    }
  }.bind(this);
};

/**
 * Make utilities in polypartition available without requiring
 * that it be included in external scripts.
 */
NavMesh.poly = geo;

/**
 * Hold methods used for generating the navigation mesh.
 * @private
 */
NavMesh._geometry = {};

/**
 * Initialized Clipper for operations.
 * @private
 * @type {ClipperLib.Clipper}
 */
NavMesh._geometry.cpr = new ClipperLib.Clipper();

/**
 * Initialized ClipperOffset for operations.
 * @private
 * @type {ClipperLib.ClipperOffset}
 */
NavMesh._geometry.co = new ClipperLib.ClipperOffset();

// Defaults.
NavMesh._geometry.co.MiterLimit = 2;
NavMesh._geometry.scale = 100;

/**
 * Get a polygonal approximation of a circle of a given radius
 * centered at the provided point. Vertices of polygon are in CW
 * order.
 * @private
 * @param {number} radius - The radius for the polygon.
 * @param {Point} [point] - The point at which to center the polygon.
 *   If a point is not provided then the polygon is centered at the
 *   origin.
 * @return {Poly} - The approximated circle.
 */
NavMesh._geometry.getApproximateCircle = function(radius, point) {
  var x, y;
  if (point) {
    x = point.x;
    y = point.y;
  } else {
    x = 0;
    y = 0;
  }
  var offset = radius * Math.tan(Math.PI / 8);
  offset = Math.round10(offset, -1);
  var poly = new Poly([
    new Point(x - radius, y - offset),
    new Point(x - radius, y + offset),
    new Point(x - offset, y + radius),
    new Point(x + offset, y + radius),
    new Point(x + radius, y + offset),
    new Point(x + radius, y - offset),
    new Point(x + offset, y - radius),
    new Point(x - offset, y - radius)
  ]);
  return poly;
};

/**
 * Returns a square with side length given by double the provided
 * radius, centered at the origin. Vertices of polygon are in CW
 * order.
 * @private
 * @param {number} radius - The length of half of one side.
 * @return {Poly} - The constructed square.
 */
NavMesh._geometry.getSquare = function(radius) {
  var poly = new Poly([
    new Point(-radius, radius),
    new Point(radius, radius),
    new Point(radius, -radius),
    new Point(-radius, -radius)
  ]);
  return poly;
};

/**
 * Get the upper or lower diagonal of a square of the given
 * radius. 
 * @private
 * @param {number} radius - The length of half of one side of the
 *   square to get the diagonal of.
 * @param {string} corner - One of ne, se, nw, sw indicating which
 *   corner should be filled.
 * @return {Poly} - The diagonal shape.
 */
NavMesh._geometry.getDiagonal = function(radius, corner) {
  var types = {
    "ne": [[radius, -radius], [radius, radius], [-radius, -radius]],
    "se": [[radius, radius], [-radius, radius], [radius, -radius]],
    "sw": [[-radius, radius], [-radius, -radius], [radius, radius]],
    "nw": [[-radius, -radius], [radius, -radius], [-radius, radius]]
  };
  var points = types[corner].map(function(mul) {
    return new Point(mul[0], mul[1]);
  });
  return new Poly(points);
};

/**
 * Given two sets of polygons, return indices of the ones in the blue
 * set that are intersected by ones in red.
 * @private
 * @param {Array.<Poly>} red
 * @param {Array.<Poly>} blue
 * @return {Array.<integer>} - The indices of the intersected blue
 *   polys.
 */
NavMesh._geometry.getIntersections = function(red, blue) {
  var indices = [];
  // Naive solution.
  blue.forEach(function(poly, i) {
    var intersects = red.some(function(polyb) {
      return poly.intersects(polyb);
    });
    if (intersects) {
      indices.push(i);
    }
  });
  return indices;
};

/**
 * An Area is an object that holds a polygon representing a space
 * along with its holes. An Area can represent, for example, a
 * traversable region, if we consider the non-hole area of the
 * polygon as being traversable, or the opposite, if we consider
 * the non-hole area as being solid, blocking movement.
 * @typedef Area
 * @type {object}
 * @property {Poly} polygon - The polygon defining the outside of the
 *   area.
 * @property {Array.<Poly>} holes - The holes in the polygon for this
 *   area.
 */
/**
 * Given a PolyTree, return an array of areas assuming even-odd fill
 * ordering.
 * @private
 * @param {ClipperLib.Paths} paths - The paths output from some
 *   operation. Paths should be non-overlapping, i.e. the edges of
 *   represented polygons should not be overlapping, but polygons
 *   may be fully contained in one another. Paths should already
 *   be scaled up.
 * @param {integer} [scale=100] - The scale to use when bringing the
 *   Clipper paths down to size.
 * @return {Array.<Area>} - The areas represented by the polytree.
 */
NavMesh._geometry.getAreas = function(paths, scale) {
  if (typeof scale == 'undefined') scale = NavMesh._geometry.scale;
  // We are really only concerned with getting the paths into a
  // polytree structure.
  var cpr = NavMesh._geometry.cpr;
  cpr.Clear();
  cpr.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);
  var unioned_shapes_polytree = new ClipperLib.PolyTree();
  cpr.Execute(
    ClipperLib.ClipType.ctUnion,
    unioned_shapes_polytree,
    ClipperLib.PolyFillType.pftEvenOdd,
    null);

  var areas = [];

  var outer_polygons = unioned_shapes_polytree.Childs();

  // Organize shapes into their outer polygons and holes, assuming
  // that the first layer of polygons in the polytree represent the
  // outside edge of the desired areas.
  for (var i = 0; i < outer_polygons.length; i++) {
    var outer_polygon = outer_polygons[i];
    var contour = outer_polygon.Contour();
    ClipperLib.JS.ScaleDownPath(contour, scale);
    var area = {
      polygon: contour,
      holes: []
    };

    outer_polygon.Childs().forEach(function(child) {
      var contour = child.Contour();
      ClipperLib.JS.ScaleDownPath(child.Contour(), scale);
      // Add as a hole.
      area.holes.push(contour);

      // Add children as additional outer polygons to be expanded.
      child.Childs().forEach(function(child_outer) {
        outer_polygons.push(child_outer);
      });
    });
    areas.push(area);
  }
  
  // Convert Clipper Paths to Polys.
  areas.forEach(function(area) {
    area.polygon = NavMesh._geometry.convertClipperToPoly(area.polygon);
    area.holes = area.holes.map(NavMesh._geometry.convertClipperToPoly);
  });

  return areas;
};

/**
 * Offset a polygon inwards (as opposed to deflating it). The polygon
 * vertices should be in CCW order and the polygon should already be
 * scaled.
 * @private
 * @param {CLShape} shape - The shape to inflate inwards.
 * @param {number} offset - The amount to offset the shape.
 * @param {integer} [scale=100] - The scale for the operation.
 * @return {ClipperLib.Paths} - The resulting shape from offsetting.
 *   If the process of offsetting resulted in the interior shape
 *   closing completely, then an empty array will be returned. The
 *   returned shape will still be scaled up, for use in other
 *   operations.
 */
NavMesh._geometry.offsetInterior = function(shape, offset, scale) {
  if (typeof scale == 'undefined') scale = NavMesh._geometry.scale;

  var cpr = NavMesh._geometry.cpr;
  var co = NavMesh._geometry.co;

  // First, create a shape with the outline as the interior.
  var boundingShape = NavMesh._geometry.getBoundingShapeForPaths([shape]);

  cpr.Clear();
  cpr.AddPath(boundingShape, ClipperLib.PolyType.ptSubject, true);
  cpr.AddPath(shape, ClipperLib.PolyType.ptClip, true);

  var solution_paths = new ClipperLib.Paths();
  cpr.Execute(ClipperLib.ClipType.ctDifference,
    solution_paths,
    ClipperLib.PolyFillType.pftNonZero,
    ClipperLib.PolyFillType.pftNonZero);

  // Once we have the shape as created above, inflate it. This gives
  // better results than treating the outline as the exterior of a
  // shape and deflating it.
  var offsetted_paths = new ClipperLib.Paths();

  co.Clear();
  co.AddPaths(solution_paths, ClipperLib.JoinType.jtSquare, ClipperLib.EndType.etClosedPolygon);
  co.Execute(offsetted_paths, offset * scale);

  // If this is not true then the offsetting process shrank the
  // outline into non-existence and only the bounding shape is
  // left.
  // >= 2 in case the offsetting process isolates portions of the
  // outline (see: GamePad).
  if (offsetted_paths.length >= 2) {
    // Get only the paths defining the outlines we were interested
    // in, discarding the exterior bounding shape.
    offsetted_paths.shift();
  } else {
    offsetted_paths = new ClipperLib.Paths();
  }
  return offsetted_paths;
};

/**
 * Offset a polygon. The polygon vertices should be in CW order and
 * the polygon should already be scaled up.
 * @private
 * @param {CLShape} shape - The shape to inflate outwards.
 * @param {number} offset - The amount to offset the shape.
 * @param {integer} [scale=100] - The scale for the operation.
 * @return {ClipperLib.Paths} - The resulting shape from offsetting.
 *   If the process of offsetting resulted in the interior shape
 *   closing completely, then an empty array will be returned. The
 *   returned shape will still be scaled up, for use in other
 *   operations.
 */
NavMesh._geometry.offsetExterior = function(shape, offset, scale) {
  // TODO
};

/**
 * Generate a convex partition of the provided polygon, excluding
 * areas given by the holes.
 * @private
 * @param {Poly} outline - The polygon outline of the area to
 *   partition.
 * @param {Array.<Poly>} holes - Holes in the polygon.
 * @return {Array.<Poly>} - Polygons representing the partitioned
 *   space.
 */
NavMesh._geometry.convexPartition = function(outline, holes) {
  // Ensure proper vertex order for holes and outline.
  outline.setOrientation("CCW");
  holes.forEach(function(e) {
    e.setOrientation("CW");
    e.hole = true;
  });
  
  return partition(outline, holes);
};

/**
 * Partition the provided area.
 * @private
 * @param {Area} area - The Area to partition.
 * @return {Array.<Poly>} - Polygons representing the partitioned
 *   space.
 */
NavMesh._geometry.partitionArea = function(area) {
  return NavMesh._geometry.convexPartition(area.polygon, area.holes);
};

/**
 * Partition the provided areas.
 * @private
 * @param {Array.<Area>} areas - The areas to partition.
 * @return {Array.<Poly>} - Polygons representing the partitioned
 *   space.
 */
NavMesh._geometry.partitionAreas = function(areas) {
  var polys = areas.map(NavMesh._geometry.partitionArea);
  return NavMesh._util.flatten(polys);
};

/**
 * A point in ClipperLib is just an object with properties
 * X and Y corresponding to a point.
 * @typedef CLPoint
 * @type {object}
 * @property {integer} X - The x coordinate of the point.
 * @property {integer} Y - The y coordinate of the point.
 */
/**
 * A shape in ClipperLib is simply an array of CLPoints.
 * @typedef CLShape
 * @type {Array.<CLPoint>}
 */
/**
 * Takes a Poly and converts it into a ClipperLib polygon.
 * @private
 * @param {Poly} poly - The Poly to convert.
 * @return {CLShape} - The converted polygon.
 */
NavMesh._geometry.convertPolyToClipper = function(poly) {
  return poly.points.map(function(p) {
    return {X:p.x, Y:p.y};
  });
};

/**
 * Convert a ClipperLib shape into a Poly.
 * @private
 * @param {CLShape} clip - The shape to convert.
 * @return {Poly} - The converted shape.
 */
NavMesh._geometry.convertClipperToPoly = function(clip) {
  var points = clip.map(function(p) {
    return new Point(p.X, p.Y);
  });
  return new Poly(points);
};

/**
 * Generate a bounding shape for paths with a given buffer. If using
 * for an offsetting operation, the returned CLShape does NOT need to
 * be scaled up.
 * @private
 * @param {Array.<CLShape>} paths - The paths to get a bounding shape for.
 * @param {integer} [buffer=5] - How many units to pad the bounding
 *   rectangle.
 * @return {CLShape} - A bounding rectangle for the paths.
 */
NavMesh._geometry.getBoundingShapeForPaths = function(paths, buffer) {
  if (typeof buffer == "undefined") buffer = 5;
  var bounds = ClipperLib.Clipper.GetBounds(paths);
  bounds.left -= buffer;
  bounds.top -= buffer;
  bounds.right += buffer;
  bounds.bottom += buffer;
  var shape = [];
  shape.push({X: bounds.right, Y: bounds.bottom});
  shape.push({X: bounds.left, Y: bounds.bottom});
  shape.push({X: bounds.left, Y: bounds.top});
  shape.push({X: bounds.right, Y: bounds.top});
  return shape;
};

/**
 * Holds utility methods needed by the navmesh.
 * @private
 */
NavMesh._util = {};

/**
 * Removes and returns the items at the indices identified in
 * `indices`.
 * @private
 * @param {Array} ary - The array to remove items from.
 * @param {Array.<integer>} indices - The indices from which to
 *   remove the items from in ary. Indices should be unique and
 *   each should be less than the length of `ary` itself.
 * @return {Array} - The items removed from ary.
 */
NavMesh._util.splice = function(ary, indices) {
  indices = indices.sort(NavMesh._util._numberCompare).reverse();
  var removed = [];
  indices.forEach(function(i) {
    removed.push(ary.splice(i, 1)[0]);
  });
  return removed;
};

/**
 * Comparison function for numbers.
 * @private
 */
NavMesh._util._numberCompare = function(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
};

/**
 * Take an array of arrays and flatten it.
 * @private
 * @param  {Array.<Array.<*>>} ary - The array to flatten.
 * @return {Array.<*>} - The flattened array.
 */
NavMesh._util.flatten = function(ary) {
  return Array.prototype.concat.apply([], ary);
};

},{"./geometry":6,"./parse-map":8,"./partition":9,"./pathfinder":10,"jsclipper":1,"math-round":2}],8:[function(require,module,exports){
/**
 * @ignore
 * @module MapParser
 */

var ActionValues = require('./action-values');
var geo = require('./geometry');
var Point = geo.Point;
var Poly = geo.Poly;

/**
 * Contains utilities for generating usable map representations from
 * map tiles.
 */
var MapParser = {};

/**
 * An object with x and y properties that represents a coordinate pair.
 * @private
 * @typedef MPPoint
 * @type {object}
 * @property {number} x - The x coordinate of the location.
 * @property {number} y - The y coordinate of the location.
 */

/**
 * A Shape is an array of points, where points are objects with x and y properties which represent coordinates on the map.
 * @private
 * @typedef MPShape
 * @type {Array.<MPPoint>}
 */

/**
 * An object with r and c properties that represents a row/column
 * location in a 2d array.
 * @private
 * @typedef ArrayLoc
 * @type {object}
 * @property {integer} r - The row number of the array location.
 * @property {integer} c - The column number of the array location.
 */

/**
 * The 2d tile grid from `tagpro.map`, or a similar 2d grid resulting
 * from an operation on the original.
 * @typedef MapTiles
 * @type {Array.<Array.<number>>}
 */

/**
 * A Cell is just an array that holds the values of the four adjacent
 * cells in a 2d array, recorded in CCW order starting from the upper-
 * left quadrant. For example, given a 2d array:
 * [[1, 0, 1],
 *  [1, 0, 0],
 *  [1, 1, 1]]
 * we would generate the representation using the cells:
 * [1, 0,  [0, 1,  [1, 0,  [0, 0  
 *  1, 0]   0, 0]   1, 1]   1, 1].
 * These correspond to the parts of a tile that would be covered if
 * placed at the intersection of 4 tiles. The value 0 represents a
 * blank location, 1 indicates that the quadrant is covered.
 * To represent how such tiles would be covered in the case of diagonal
 * tiles, we use 2 to indicate that the lower diagonal of a quadrant is
 * filled, and 3 to indicate that the upper diagonal of a quadrant is
 * filled. The tiles available force the diagonals of each quadrant to
 * point to the center, so this is sufficient for describing all
 * possible overlappings.
 * @private
 * @typedef Cell
 * @type {Array.<number>}
 */

/**
 * Callback that receives each of the elements in the 2d map function.
 * @private
 * @callback mapCallback
 * @param {*} - The element from the 2d array.
 * @return {*} - The transformed element.
 */

/**
 * Applies `fn` to every individual element of the 2d array `arr`.
 * @private
 * @param {Array.<Array.<*>>} arr - The 2d array to use.
 * @param {mapCallback} fn - The function to apply to each element.
 * @return {Array.<Array.<*>>} - The 2d array after the function
 *   has been applied to each element.
 */
function map2d(arr, fn) {
  return arr.map(function(row) {
    return row.map(fn);
  });
}

/**
 * Returns 1 if a tile value is one that we want to consider as
 * a wall (we consider empty space to be a wall), or the tile value
 * itself for diagonal walls. 0 is returned otherwise.
 * @private
 * @param {number} elt - The tile value at a row/column location
 * @return {number} - The number to insert in place of the tile value.
 */
function isBadCell(elt) {
  var bad_cells = [1, 1.1, 1.2, 1.3, 1.4];
  if(bad_cells.indexOf(elt) !== -1) {
    // Ensure empty spaces get mapped to full tiles so outside of
    // map isn't traced.
    if (elt == 0) {
      return 1;
    } else {
      return elt;
    }
    return elt;
  } else {
    return 0;
  }
}

/**
 * Converts the provided array into its equivalent representation
 * using cells.
 * @private
 * @param {MapTiles} arr - 
 * @param {Array.<Array.<Cell>>} - The converted array.
 */
function generateContourGrid(arr) {
  // Generate grid for holding values.
  var contour_grid = new Array(arr.length - 1);
  for (var n = 0; n < contour_grid.length; n++) {
    contour_grid[n] = new Array(arr[0].length - 1);
  }
  var corners = [1.1, 1.2, 1.3, 1.4];
  // Specifies the resulting values for the above corner values. The index
  // of the objects in this array corresponds to the proper values for the
  // quadrant of the same index.
  var corner_values = [
    {1.1: 3, 1.2: 0, 1.3: 2, 1.4: 1},
    {1.1: 0, 1.2: 3, 1.3: 1, 1.4: 2},
    {1.1: 3, 1.2: 1, 1.3: 2, 1.4: 0},
    {1.1: 1, 1.2: 3, 1.3: 0, 1.4: 2}
  ];
  for (var i = 0; i < (arr.length - 1); i++) {
    for (var j = 0; j < (arr[0].length - 1); j++) {
      var cell = [arr[i][j], arr[i][j+1], arr[i+1][j+1], arr[i+1][j]];
      // Convert corner tiles to appropriate representation.
      cell.forEach(function(val, i, cell) {
        if (corners.indexOf(val) !== -1) {
          cell[i] = corner_values[i][val];
        }
      });

      contour_grid[i][j] = cell;
    }
  }
  return contour_grid;
}

/**
 * Callback function for testing equality of items.
 * @private
 * @callback comparisonCallback
 * @param {*} - The first item.
 * @param {*} - The second item.
 * @return {boolean} - Whether or not the items are equal.
 */

/**
 * Returns the location of obj in arr with equality determined by cmp.
 * @private
 * @param {Array.<*>} arr - The array to be searched.
 * @param {*} obj - The item to find a match for.
 * @param {comparisonCallback} cmp - The callback that defines
 *   whether `obj` matches.
 * @return {integer} - The index of the first element to match `obj`,
 *   or -1 if no such element was located.
 */
function find(arr, obj, cmp) {
  if (typeof cmp !== 'undefined') {
    for (var i = 0; i < arr.length; i++) {
      if (cmp(arr[i], obj)) {
        return i;
      }
    }
    return -1;
  }
}

/**
 * Compare two objects defining row/col locations in an array
 * and return true if they represent the same row/col location.
 * @private
 * @param {ArrayLoc} elt1
 * @param {ArrayLoc} elt2
 * @return {boolean} - Whether or not these two array locations
 *   represent the same row/column.
 */
function eltCompare(elt1, elt2) {
  return (elt1.c == elt2.c && elt1.r == elt2.r);
}

/**
 * Takes in the vertex/action information and returns an array of arrays,
 * where each array corresponds to a shape and each element of the array is
 * a vertex which is connected to it's previous and next neighbor (circular).
 * @private
 * @param {} actionInfo
 * @return {Array.<Array<ArrayLoc>>} - Array of vertex locations in 
 */
function generateShapes(actionInfo) {
  // Total number of cells.
  var total = actionInfo.length * actionInfo[0].length;
  var directions = {
    "n": [-1, 0],
    "e": [0, 1],
    "s": [1, 0],
    "w": [0, -1],
    "ne": [-1, 1],
    "se": [1, 1],
    "sw": [1, -1],
    "nw": [-1, -1]
  };
  // Takes the current location and direction at this point and
  // returns the next location to check. Returns null if this cell is
  // not part of a shape.
  function nextNeighbor(elt, dir) {
    var drow = 0, dcol = 0;
    if (dir == "none") {
      return null;
    } else {
      var offset = directions[dir];
      return {r: elt.r + offset[0], c: elt.c + offset[1]};
    }
  }

  // Get the next cell, from left to right, top to bottom. Returns null
  // if last element in array reached.
  function nextCell(elt) {
    if (elt.c + 1 < actionInfo[elt.r].length) {
      return {r: elt.r, c: elt.c + 1};
    } else if (elt.r + 1 < actionInfo.length) {
      return {r: elt.r + 1, c: 0};
    }
    return null;
  }

  // Get identifier for given node and direction
  function getIdentifier(node, dir) {
    return "r" + node.r + "c" + node.c + "d" + dir;
  }
  
  var discovered = [];
  var node = {r: 0, c: 0};
  var shapes = [];
  var current_shape = [];
  var shape_node_start = null;
  var last_action = null;
  // Object to track location + actions that have been taken.
  var taken_actions = {};
  var iterations = 0;

  // Iterate until all nodes have been visited.
  while (discovered.length !== total) {
    if (!node) {
      // Reached end.
      break;
    }
    if (iterations > total * 4) {
      // Sanity check on number of iterations. Maximum number of
      // times a single tile would be visited is 4 for a fan-like
      // pattern of triangle wall tiles.
      break;
    } else {
      iterations++;
    }
    // It's okay to be in a discovered node if shapes are adjacent,
    // we just want to keep track of the ones we've seen.
    if (find(discovered, node, eltCompare) == -1) {
      discovered.push(node);
    }

    var action = actionInfo[node.r][node.c];
    var dir;
    // If action has multiple possibilities.
    if (action instanceof Array) {
      // Part of a shape, find the info with that previous action as
      // in_dir.
      if (last_action !== "none") {
        var action_found = false;
        for (var i = 0; i < action.length; i++) {
          var this_action = action[i];
          if (this_action["loc"]["in_dir"] == last_action) {
            action = this_action;
            dir = this_action["loc"]["out_dir"];
            action_found = true;
            break;
          }
        }

        if (!action_found) {
          throw "Error!";
        }
      } else {
        // Find the first action that has not been taken previously.
        var action_found = false;
        for (var i = 0; i < action.length; i++) {
          var this_action = action[i];
          if (!taken_actions[getIdentifier(node, this_action["loc"]["out_dir"])]) {
            action = this_action
            dir = this_action["loc"]["out_dir"];
            action_found = true;
            break;
          }
        }
        if (!action_found) {
          throw "Error!";
        }
      }
    } else { // Action only has single possibility.
      dir = action.loc;
    }

    // Set node/action as having been visited.
    taken_actions[getIdentifier(node, dir)] = true;

    last_action = dir;
    var next = nextNeighbor(node, dir);
    if (next) { // Part of a shape.
      // Save location for restarting after this shape has been defined.
      var first = false;
      if (current_shape.length == 0) {
        first = true;
        shape_node_start = node;
        shape_node_start_action = last_action;
      }
      
      // Current node and direction is same as at start of shape,
      // shape has been explored.
      if (!first && eltCompare(node, shape_node_start) && last_action == shape_node_start_action) {
        shapes.push(current_shape);
        current_shape = [];
        // Get the next undiscovered node.
        node = nextCell(shape_node_start);
        while (node && (find(discovered, node, eltCompare) !== -1)) {
          node = nextCell(node);
        }
        shape_node_start = null;
      } else {
        if (action.v || first) {
          current_shape.push(node);
        }
        node = next;
      }
    } else { // Not part of a shape.
      node = nextCell(node);
      // Get the next undiscovered node.
      while (node && (find(discovered, node, eltCompare) !== -1)) {
        node = nextCell(node);
      }
    }
  } // end while

  if (discovered.length == total) {
    return shapes;
  } else {
    return null;
  }
}

// Return whether there should be a vertex at the given location and
// which location to go next, if any.
// Value returned is an object with properties 'v' and 'loc'. 'v' is a boolean
// indicating whether there is a vertex, and 'loc' gives the next location to move, if any.
// loc is a string, of none, down, left, right, up, down corresponding to
// tracing out a shape clockwise (or the interior of a shape CCW), or a function
// that takes a string corresponding to the direction taken to get to the current
// cell.
// There will never be a vertex without a next direction.
function getAction(cell) {
  var str = cell[0] + "-" + cell[1] + "-" + cell[2] + "-" + cell[3];
  return ActionValues[str];
}

/**
 * Convert an array location to a point representing the top-left
 * corner of the tile in global coordinates.
 * @private
 * @param {ArrayLoc} location - The array location to get the
 *   coordinates for.
 * @return {MPPoint} - The coordinates of the tile.
 */
function getCoordinates(location) {
  var tile_width = 40;
  var x = location.r * tile_width;
  var y = location.c * tile_width;
  return {x: x, y: y};
}

/**
 * Takes in an array of shapes and converts from contour grid layout
 * to actual coordinates.
 * @private
 * @param {Array.<Array.<ArrayLoc>>} shapes - output from generateShapes
 * @return {Array.<Array.<{{x: number, y: number}}>>}
 */
function convertShapesToCoords(shapes) {
  var tile_width = 40;

  var new_shapes = map2d(shapes, function(loc) {
    // It would be loc.r + 1 and loc.c + 1 but that has been removed
    // to account for the one-tile width of padding added in doParse.
    var row = loc.r * tile_width;
    var col = loc.c * tile_width;
    return {x: row, y: col}
  });
  return new_shapes;
}

// Given an x and y value, return a polygon (octagon) that approximates
// a spike at the tile given by that x, y location. Points in CW order.
function getSpikeShape(coord) {
  var x = coord.x + 20, y = coord.y + 20;
  var spike_radius = 14;
  // almost = spike_radius * tan(pi/8) for the vertices of a regular octagon.
  var point_offset = 5.8;
  return [
    {x: x - spike_radius, y: y - point_offset},
    {x: x - spike_radius, y: y + point_offset},
    {x: x - point_offset, y: y + spike_radius},
    {x: x + point_offset, y: y + spike_radius},
    {x: x + spike_radius, y: y + point_offset},
    {x: x + spike_radius, y: y - point_offset},
    {x: x + point_offset, y: y - spike_radius},
    {x: x - point_offset, y: y - spike_radius}
  ];
}

/**
 * Returns an array of the array locations of the spikes contained
 * in the map tiles, replacing those array locations in the original
 * map tiles with 2, which corresponds to a floor tile.
 * @private
 * @param {MapTiles} tiles - The map tiles.
 * @return {Array.<ArrayLoc>} - The array of locations that held
 *   spike tiles.
 */
MapParser.extractSpikes = function(tiles) {
  var spike_locations = [];
  tiles.forEach(function(row, row_n) {
    row.forEach(function(cell_value, index, row) {
      if (cell_value == 7) {
        spike_locations.push({r: row_n, c: index});
        row[index] = 2;
      }
    });
  });
  return spike_locations;
};

var Obstacle = function(type, ids) {
  this.type = type;
  this.vals = [];
  this.info = {};
  ids.forEach(function(id) {
    if (typeof id == "number") {
      this.vals.push(id);
      this.info[id] = this.type;
    } else {
      this.vals.push(id.num);
      this.info[id] = id.name;
    }
  }, this);
};

Obstacle.prototype.describes = function(val) {
  if(this.vals.indexOf(Math.floor(+val)) !== -1) {
    return (this.info[+val] || this.info[Math.floor(+val)]);
  } else {
    return false;
  }
};

var Obstacles = [
  new Obstacle("bomb", [10, 10.1]),
  new Obstacle("boost",
    [5, 5.1, {num: 14, name: "redboost"}, {num: 15, name: "blueboost"}]),
  new Obstacle("gate",
    [9, {num: 9.1, name: "greengate"}, {num: 9.2, name: "redgate"},
    {num: 9.3, name: "bluegate"}])
];

MapParser.extractDynamicObstacles = function(tiles) {
  var dynamic_obstacles = [];
  tiles.forEach(function(row, x) {
    row.forEach(function(tile, y) {
      Obstacles.some(function(obstacle_type) {
        var dynamic_obstacle = obstacle_type.describes(tile)
        if (dynamic_obstacle) {
          dynamic_obstacles.push({
            type: dynamic_obstacle,
            x: x,
            y: y,
            v: tile
          });
          tiles[x][y] = 0;
          return true;
        } else {
          return false;
        }
      });
    });
  });
  return dynamic_obstacles;
};

/**
 * The returned value from the map parsing function.
 * @typedef ParsedMap
 * @type {object}
 * @property {Array.<MPShape>} walls - The parsed walls.
 * @property {Array.<MPShape>} obstacles - The parsed obstacles.
 */

/**
 * Converts the 2d array defining a TagPro map into shapes.
 * @param {MapTiles} tiles - The tiles as retrieved from `tagpro.map`.
 * @return {?ParsedMap} - The result of converting the map into
 *   polygons, or null if there was an issue parsing the map.
 */
MapParser.parse = function(tiles) {
  // Make copy of tiles to preserve original array
  tiles = JSON.parse(JSON.stringify(tiles));

  // Returns a list of the spike locations and removes them from
  // the tiles.
  var spike_locations = MapParser.extractSpikes(tiles);

  var dynamic_obstacles = MapParser.extractDynamicObstacles(tiles);

  // Pad tiles with a ring of wall tiles, to ensure the map is
  // closed.
  var empty_row = [];
  for (var i = 0; i < tiles[0].length + 2; i++) {
    empty_row.push(1);
  }
  tiles.forEach(function(row) {
    row.unshift(1);
    row.push(1);
  });
  tiles.unshift(empty_row);
  tiles.push(empty_row.slice());

  // Actually doing the conversion.
  // Get rid of tile values except those for the walls.
  var threshold_tiles = map2d(tiles, isBadCell);

  // Generate contour grid, essentially a grid whose cells are at the
  // intersection of every set of 4 cells in the original map.
  var contour_grid_2 = generateContourGrid(threshold_tiles);

  // Get tile vertex and actions for each cell in contour grid.
  var tile_actions = map2d(contour_grid_2, getAction);

  var generated_shapes = generateShapes(tile_actions);
  if (!generated_shapes) {
    return null;
  }

  var actual_shapes = generated_shapes.filter(function(elt) {
    return elt.length > 0;
  });

  var converted_shapes = convertShapesToCoords(actual_shapes);

  // Get spike-approximating shapes and add to list.
  var static_obstacles = spike_locations.map(function(spike) {
    return getSpikeShape(getCoordinates(spike));
  });

  return {
    walls: this.convertShapesToPolys(converted_shapes),
    static_obstacles: this.convertShapesToPolys(static_obstacles),
    dynamic_obstacles: dynamic_obstacles
  };
};

/**
 * Convert shapes into polys.
 * @private
 * @param {Array.<Shape>} shapes - The shapes to be converted.
 * @return {Array.<Poly>} - The converted shapes.
 */
MapParser.convertShapesToPolys = function(shapes) {
  var polys = shapes.map(function(shape) {
    return MapParser.convertShapeToPoly(shape);
  });
  return polys;
};


/**
 * Convert a shape into a Poly.
 * @param {MPShape} shape - The shape to convert.
 * @return {Poly} - The converted shape.
 */
MapParser.convertShapeToPoly = function(shape) {
  var poly = new Poly();
  poly.init(shape.length);
  for (var i = 0; i < shape.length; i++) {
    var point = new Point(shape[i].x, shape[i].y);
    poly.setPoint(i, point);
  }
  return poly;
};

module.exports = MapParser;

},{"./action-values":5,"./geometry":6}],9:[function(require,module,exports){
/**
 * Holds classes for points, polygons, and utilities for operating on
 * them.
 * Adapted/copied from https://code.google.com/p/polypartition/
 * @module PolyPartition
 */
var poly2tri = require('poly2tri');
var geo = require('./geometry');

var Point = geo.Point;
var Edge = geo.Edge;
var Poly = geo.Poly;

/**
 * The Point class used by poly2tri.
 * @private
 * @typedef P2TPoint
 */

/**
 * A polygon for use with poly2tri.
 * @private
 * @typedef P2TPoly
 * @type {Array.<P2TPoint>}
 */

/**
 * Convert a polygon into format required by poly2tri.
 * @private
 * @param {Poly} poly - The polygon to convert.
 * @return {P2TPoly} - The converted polygon.
 */
function convertPolyToP2TPoly(poly) {
  return poly.points.map(function(p) {
    return new poly2tri.Point(p.x, p.y);
  });
}

/**
 * Convert a polygon/triangle returned from poly2tri back into a
 * polygon.
 * @private
 * @param {P2TPoly} p2tpoly - The polygon to convert.
 * @return {Poly} - The converted polygon.
 */
function convertP2TPolyToPoly(p2tpoly) {
  var points = p2tpoly.getPoints().map(function(p) {
    return new Point(p.x, p.y);
  });

  return new Poly(points);
}

function isConvex(p1, p2, p3) {
  var tmp = (p3.y - p1.y) * (p2.x - p1.x) - (p3.x - p1.x) * (p2.y - p1.y);
  return (tmp > 0);
}

/**
 * Takes an array of polygons that overlap themselves and others
 * at discrete corner points and separate those overlapping corners
 * slightly so the polygons are suitable for triangulation by
 * poly2tri.js. This changes the Poly objects in the array.
 * @private
 * @param {Array.<Poly>} polys - The polygons to separate.
 * @param {number} [offset=1] - The number of units the vertices
 *   should be moved away from each other.
 */
function separatePolys(polys, offset) {
  offset = offset || 1;
  var discovered = {};
  var dupes = {};
  // Offset to use in calculation.
  // Find duplicates.
  for (var s1 = 0; s1 < polys.length; s1++) {
    var poly = polys[s1];
    for (var i = 0; i < poly.numpoints; i++) {
      var point = poly.points[i].toString();
      if (!discovered.hasOwnProperty(point)) {
        discovered[point] = true;
      } else {
        dupes[point] = true;
      }
    }
  }

  // Get duplicate points.
  var dupe_points = [];
  var dupe;
  for (var s1 = 0; s1 < polys.length; s1++) {
    var poly = polys[s1];
    for (var i = 0; i < poly.numpoints; i++) {
      var point = poly.points[i];
      if (dupes.hasOwnProperty(point.toString())) {
        dupe = [point, i, poly];
        dupe_points.push(dupe);
      }
    }
  }

  // Sort elements in descending order based on their indices to
  // prevent future indices from becoming invalid when changes are made.
  dupe_points.sort(function(a, b) {
    return b[1] - a[1]
  });
  // Edit duplicates.
  var prev, next, point, index, p1, p2;
  dupe_points.forEach(function(e, i, ary) {
    point = e[0], index = e[1], poly = e[2];
    prev = poly.points[poly.getPrevI(index)];
    next = poly.points[poly.getNextI(index)];
    p1 = point.add(prev.sub(point).normalize().mul(offset));
    p2 = point.add(next.sub(point).normalize().mul(offset));
    // Insert new points.
    poly.points.splice(index, 1, p1, p2);
    poly.update();
  });
}

/**
 * Partition a polygon with (optional) holes into a set of convex
 * polygons. The vertices of the polygon must be given in CW order,
 * and the vertices of the holes must be in CCW order. Uses poly2tri
 * for the initial triangulation and Hertel-Mehlhorn to combine them
 * into convex polygons.
 * @param {Poly} poly - The polygon to use as the outline.
 * @param {Array.<Poly>} [holes] - An array of holes present in the
 *   polygon.
 * @param {number} [minArea=5] - An optional parameter that filters
 *   out polygons in the partition smaller than this value.
 * @return {Array.<Poly>} - The set of polygons defining the
 *   partition of the provided polygon.
 */
module.exports = function(poly, holes, minArea) {
  if (typeof holes == 'undefined') holes = false;
  if (typeof minArea == 'undefined') minArea = 5;

  var i11, i12, i13, i21, i22, i23;
  var parts = new Array();

  // Check if poly is already convex only if there are no holes.
  if (!holes || holes.length == 0) {
    var reflex = false;
    // Check if already convex.
    for (var i = 0; i < poly.numpoints; i++) {
      var prev = poly.getPrevI(i);
      var next = poly.getNextI(i);
      if (!isConvex(poly.getPoint(prev), poly.getPoint(i), poly.getPoint(next))) {
        reflex = true;
        break;
      }
    }
    if (!reflex) {
      parts.push(poly);
      return parts;
    }
  }

  // Separate polys to remove collinear points.
  separatePolys(holes.concat(poly));

  // Convert polygon into format required by poly2tri.
  var contour = convertPolyToP2TPoly(poly);

  if (holes) {
    // Convert holes into format required by poly2tri.
    holes = holes.map(convertPolyToP2TPoly);
  }

  var swctx = new poly2tri.SweepContext(contour);
  if (holes) {
    swctx.addHoles(holes);
  }
  var triangles = swctx.triangulate().getTriangles();
  
  // Convert poly2tri triangles back into polygons and filter out the
  // ones too small to be relevant.
  triangles = triangles.map(convertP2TPolyToPoly).filter(function(poly) {
    return poly.getArea() >= minArea;
  });

  for (var s1 = 0; s1 < triangles.length; s1++) {
    var poly1 = triangles[s1];
    var s2_index = null;
    for (i11 = 0; i11 < poly1.numpoints; i11++) {
      var d1 = poly1.getPoint(i11);
      i12 = poly1.getNextI(i11);
      var d2 = poly1.getPoint(i12);

      var isdiagonal = false;
      for (var s2 = s1; s2 < triangles.length; s2++) {
        if (s1 == s2) continue;
        var poly2 = triangles[s2];
        for (i21 = 0; i21 < poly2.numpoints; i21++) {
          if (d2.neq(poly2.getPoint(i21))) continue;
          i22 = poly2.getNextI(i21);
          if (d1.neq(poly2.getPoint(i22))) continue;
          isdiagonal = true;
          object_2_index = s2;
          break;
        }
        if (isdiagonal) break;
      }

      if (!isdiagonal) continue;
      var p1, p2, p3;
      p2 = poly1.getPoint(i11);
      i13 = poly1.getPrevI(i11);
      p1 = poly1.getPoint(i13);
      i23 = poly2.getNextI(i22);
      p3 = poly2.getPoint(i23);

      if (!isConvex(p1, p2, p3)) continue;

      p2 = poly1.getPoint(i12);
      i13 = poly1.getNextI(i12);
      p3 = poly1.getPoint(i13);
      i23 = poly2.getPrevI(i21);
      p1 = poly2.getPoint(i23);

      if (!isConvex(p1, p2, p3)) continue;

      var newpoly = new Poly();
      newpoly.init(poly1.numpoints + poly2.numpoints - 2);
      var k = 0;
      for (var j = i12; j != i11; j = poly1.getNextI(j)) {
        newpoly.setPoint(k, poly1.getPoint(j));
        k++;
      }
      for (var j = i22; j != i21; j = poly2.getNextI(j)) {
        newpoly.setPoint(k, poly2.getPoint(j));
        k++;
      }

      if (s1 > object_2_index) {
        triangles[s1] = newpoly;
        poly1 = triangles[s1];
        triangles.splice(object_2_index, 1);
      } else {
        triangles.splice(object_2_index, 1);
        triangles[s1] = newpoly;
        poly1 = triangles[s1];
      }
      i11 = -1;
    }
  }
  return triangles;
};

},{"./geometry":6,"poly2tri":3}],10:[function(require,module,exports){
var geo = require('./geometry');
var findPolyForPoint = geo.util.findPolyForPoint;
var PriorityQueue = require('priority-queue');

/**
 * Pathfinder implements pathfinding on a navigation mesh.
 * @constructor
 * @param {Array.<Poly>} polys - The polygons defining the navigation mesh.
 * @param {boolean} [init=true] - Whether or not to initialize the pathfinder.
 */
var Pathfinder = function(polys, init) {
  if (typeof init == "undefined") init = true;
  this.polys = polys;
  if (init) {
    this.init();
  }
};
module.exports = Pathfinder;

Pathfinder.prototype.init = function() {
  this.grid = this.generateAdjacencyGrid(this.polys);
};

/**
 * Computes path from source to target, using sides and centers of the edges
 * between adjacent polygons. source and target are Points and polys should
 * be the final partitioned map.
 * @param {Point} source - The start location for the search.
 * @param {Point} target - The target location for the search.
 * @return {?Array.<Point>} - A series of points representing the path from
 *   the source to the target. If a path is not found, `null` is returned.
 */
Pathfinder.prototype.aStar = function(source, target) {
  // Compares the value of two nodes.
  function nodeValue(node1, node2) {
    return (node1.dist + heuristic(node1.point)) - (node2.dist + heuristic(node2.point));
  }

  // Distance between polygons.
  function euclideanDistance(p1, p2) {
    return p1.dist(p2);
  }

  // Distance between polygons. todo: update
  function manhattanDistance(elt1, elt2) {
    return (elt1.r - elt2.r) + (elt1.c - elt2.c);
  }

  // Takes Point and returns value.
  function heuristic(p) {
    return euclideanDistance(p, target);
  }

  var sourcePoly = findPolyForPoint(source, this.polys);

  // We're outside of the mesh somehow. Try a few nearby points.
  if (!sourcePoly) {
    var offsetSource = [new Point(5, 0), new Point(-5, 0), new Point(0, -5), new Point(0, 5)];
    for (var i = 0; i < offsetSource.length; i++) {
      // Make new point.
      var point = source.add(offsetSource[i]);
      sourcePoly = findPolyForPoint(point, this.polys);
      if (sourcePoly) {
        source = point;
        break;
      }
    }
    if (!sourcePoly) {
      return null;
    }
  }
  var targetPoly = findPolyForPoint(target, this.polys);

  // Handle trivial case.
  if (sourcePoly == targetPoly) {
    return [source, target];
  }

  // Warning, may have compatibility issues.
  var discoveredPolys = new WeakSet();
  var discoveredPoints = new WeakSet();
  var pq = new PriorityQueue({ comparator: nodeValue });
  var found = null;
  // Initialize with start location.
  pq.queue({dist: 0, poly: sourcePoly, point: source, parent: null});
  while (pq.length > 0) {
    var node = pq.dequeue();
    if (node.poly == targetPoly) {
      found = node;
      break;
    } else {
      discoveredPolys.add(node.poly);
      discoveredPoints.add(node.point);
    }
    // This may be undefined if there was no polygon found.
    var neighbors = this.grid.get(node.poly);
    for (var i = 0; i < neighbors.length; i++) {
      var elt = neighbors[i];
      var neighborFound = discoveredPolys.has(elt.poly);

      for (var j = 0; j < elt.edge.points.length; j++) {
        var p = elt.edge.points[j];
        if (!neighborFound || !discoveredPoints.has(p))
          pq.queue({dist: node.dist + euclideanDistance(p, node.point), poly: elt.poly, point: p, parent: node});
      }
    }
  }

  if (found) {
    var path = [];
    var current = found;
    while (current.parent) {
      path.unshift(current.point);
      current = current.parent;
    }
    path.unshift(current.point);
    // Add end point to path.
    path.push(target);
    return path;
  } else {
    return null;
  }
};

/**
 * Holds the "neighbor" relationship of Poly objects in the partition
 * using the Poly's themselves as keys, and an array of Poly's as
 * values, where the Polys in the array are neighbors of the Poly
 * that was the key.
 * @typedef AdjacencyGrid
 * @type {Object.<Poly, Array<Poly>>}
 */

/**
 * Given an array of Poly objects, find all neighboring polygons for
 * each polygon.
 * @private
 * @param {Array.<Poly>} polys - The array of polys to find neighbors
 *   among.
 * @return {AdjacencyGrid} - The "neighbor" relationships.
 */
Pathfinder.prototype.generateAdjacencyGrid = function(polys) {
  var neighbors = new WeakMap();
  polys.forEach(function(poly, polyI, polys) {
    if (neighbors.has(poly)) {
      // Maximum number of neighbors already found.
      if (neighbors.get(poly).length == poly.numpoints) {
        return;
      }
    } else {
      // Initialize array.
      neighbors.set(poly, new Array());
    }
    // Of remaining polygons, find some that are adjacent.
    poly.points.forEach(function(p1, i, points) {
      // Next point.
      var p2 = points[poly.getNextI(i)];
      for (var polyJ = polyI + 1; polyJ < polys.length; polyJ++) {
        var poly2 = polys[polyJ];
        // Iterate over points until match is found.
        poly2.points.some(function(q1, j, points2) {
          var q2 = points2[poly2.getNextI(j)];
          var match = p1.eq(q2) && p2.eq(q1);
          if (match) {
            var edge = new Edge(p1, p2);
            neighbors.get(poly).push({ poly: poly2, edge: edge });
            if (!neighbors.has(poly2)) {
              neighbors.set(poly2, new Array());
            }
            neighbors.get(poly2).push({ poly: poly, edge: edge });
          }
          return match;
        });
        if (neighbors.get(poly).length == poly.numpoints) break;
      }
    });
  });
  return neighbors;
};

},{"./geometry":6,"priority-queue":4}]},{},[7])(7)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIvanNjbGlwcGVyLmpzIiwibGliL21hdGgtcm91bmQuanMiLCJsaWIvcG9seTJ0cmkuanMiLCJub2RlX21vZHVsZXMvanMtcHJpb3JpdHktcXVldWUvcHJpb3JpdHktcXVldWUubWluLmpzIiwic3JjL2FjdGlvbi12YWx1ZXMuanMiLCJzcmMvZ2VvbWV0cnkuanMiLCJzcmMvbmF2bWVzaC5qcyIsInNyYy9wYXJzZS1tYXAuanMiLCJzcmMvcGFydGl0aW9uLmpzIiwic3JjL3BhdGhmaW5kZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hEQTtBQUNBO0FBQ0E7Ozs7O0FDRkE7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3NUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeG1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCI7IHZhciBfX2Jyb3dzZXJpZnlfc2hpbV9yZXF1aXJlX189cmVxdWlyZTsoZnVuY3Rpb24gYnJvd3NlcmlmeVNoaW0obW9kdWxlLCBleHBvcnRzLCByZXF1aXJlLCBkZWZpbmUsIGJyb3dzZXJpZnlfc2hpbV9fZGVmaW5lX19tb2R1bGVfX2V4cG9ydF9fKSB7XG4vLyByZXYgNDUyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICogQXV0aG9yICAgIDogIEFuZ3VzIEpvaG5zb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiBWZXJzaW9uICAgOiAgNi4xLjNhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIERhdGUgICAgICA6ICAyMiBKYW51YXJ5IDIwMTQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICogV2Vic2l0ZSAgIDogIGh0dHA6Ly93d3cuYW5ndXNqLmNvbSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiBDb3B5cmlnaHQgOiAgQW5ndXMgSm9obnNvbiAyMDEwLTIwMTQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICogTGljZW5zZTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiBVc2UsIG1vZGlmaWNhdGlvbiAmIGRpc3RyaWJ1dGlvbiBpcyBzdWJqZWN0IHRvIEJvb3N0IFNvZnR3YXJlIExpY2Vuc2UgVmVyIDEuICpcbiAqIGh0dHA6Ly93d3cuYm9vc3Qub3JnL0xJQ0VOU0VfMV8wLnR4dCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiBBdHRyaWJ1dGlvbnM6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIFRoZSBjb2RlIGluIHRoaXMgbGlicmFyeSBpcyBhbiBleHRlbnNpb24gb2YgQmFsYSBWYXR0aSdzIGNsaXBwaW5nIGFsZ29yaXRobTogKlxuICogXCJBIGdlbmVyaWMgc29sdXRpb24gdG8gcG9seWdvbiBjbGlwcGluZ1wiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIENvbW11bmljYXRpb25zIG9mIHRoZSBBQ00sIFZvbCAzNSwgSXNzdWUgNyAoSnVseSAxOTkyKSBwcCA1Ni02My4gICAgICAgICAgICAgKlxuICogaHR0cDovL3BvcnRhbC5hY20ub3JnL2NpdGF0aW9uLmNmbT9pZD0xMjk5MDYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIENvbXB1dGVyIGdyYXBoaWNzIGFuZCBnZW9tZXRyaWMgbW9kZWxpbmc6IGltcGxlbWVudGF0aW9uIGFuZCBhbGdvcml0aG1zICAgICAgKlxuICogQnkgTWF4IEsuIEFnb3N0b24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiBTcHJpbmdlcjsgMSBlZGl0aW9uIChKYW51YXJ5IDQsIDIwMDUpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIGh0dHA6Ly9ib29rcy5nb29nbGUuY29tL2Jvb2tzP3E9dmF0dGkrY2xpcHBpbmcrYWdvc3RvbiAgICAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiBTZWUgYWxzbzogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIFwiUG9seWdvbiBPZmZzZXR0aW5nIGJ5IENvbXB1dGluZyBXaW5kaW5nIE51bWJlcnNcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiBQYXBlciBuby4gREVUQzIwMDUtODU1MTMgcHAuIDU2NS01NzUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIEFTTUUgMjAwNSBJbnRlcm5hdGlvbmFsIERlc2lnbiBFbmdpbmVlcmluZyBUZWNobmljYWwgQ29uZmVyZW5jZXMgICAgICAgICAgICAgKlxuICogYW5kIENvbXB1dGVycyBhbmQgSW5mb3JtYXRpb24gaW4gRW5naW5lZXJpbmcgQ29uZmVyZW5jZSAoSURFVEMvQ0lFMjAwNSkgICAgICAqXG4gKiBTZXB0ZW1iZXIgMjQtMjgsIDIwMDUgLCBMb25nIEJlYWNoLCBDYWxpZm9ybmlhLCBVU0EgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIGh0dHA6Ly93d3cubWUuYmVya2VsZXkuZWR1L35tY21haW5zL3B1YnMvREFDMDVPZmZzZXRQb2x5Z29uLnBkZiAgICAgICAgICAgICAgKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIEF1dGhvciAgICA6ICBUaW1vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICogVmVyc2lvbiAgIDogIDYuMS4zLjIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiBEYXRlICAgICAgOiAgMSBGZWJydWFyeSAyMDE0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICogVGhpcyBpcyBhIHRyYW5zbGF0aW9uIG9mIHRoZSBDIyBDbGlwcGVyIGxpYnJhcnkgdG8gSmF2YXNjcmlwdC4gICAgICAgICAgICAgICAqXG4gKiBJbnQxMjggc3RydWN0IG9mIEMjIGlzIGltcGxlbWVudGVkIHVzaW5nIEpTQk4gb2YgVG9tIFd1LiAgICAgICAgICAgICAgICAgICAgICpcbiAqIEJlY2F1c2UgSmF2YXNjcmlwdCBsYWNrcyBzdXBwb3J0IGZvciA2NC1iaXQgaW50ZWdlcnMsIHRoZSBzcGFjZSAgICAgICAgICAgICAgKlxuICogaXMgYSBsaXR0bGUgbW9yZSByZXN0cmljdGVkIHRoYW4gaW4gQyMgdmVyc2lvbi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIEMjIHZlcnNpb24gaGFzIHN1cHBvcnQgZm9yIGNvb3JkaW5hdGUgc3BhY2U6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICogKy00NjExNjg2MDE4NDI3Mzg3OTAzICggc3FydCgyXjEyNyAtMSkvMiApICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiB3aGlsZSBKYXZhc2NyaXB0IHZlcnNpb24gaGFzIHN1cHBvcnQgZm9yIHNwYWNlOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqICstNDUwMzU5OTYyNzM3MDQ5NSAoIHNxcnQoMl4xMDYgLTEpLzIgKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiBUb20gV3UncyBKU0JOIHByb3ZlZCB0byBiZSB0aGUgZmFzdGVzdCBiaWcgaW50ZWdlciBsaWJyYXJ5OiAgICAgICAgICAgICAgICAgICpcbiAqIGh0dHA6Ly9qc3BlcmYuY29tL2JpZy1pbnRlZ2VyLWxpYnJhcnktdGVzdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiBUaGlzIGNsYXNzIGNhbiBiZSBtYWRlIHNpbXBsZXIgd2hlbiAoaWYgZXZlcikgNjQtYml0IGludGVnZXIgc3VwcG9ydCBjb21lcy4gICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiBCYXNpYyBKYXZhU2NyaXB0IEJOIGxpYnJhcnkgLSBzdWJzZXQgdXNlZnVsIGZvciBSU0EgZW5jcnlwdGlvbi4gICAgICAgICAgICAgICpcbiAqIGh0dHA6Ly93d3ctY3Mtc3R1ZGVudHMuc3RhbmZvcmQuZWR1L350ancvanNibi8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICogQ29weXJpZ2h0IChjKSAyMDA1ICBUb20gV3UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiBBbGwgUmlnaHRzIFJlc2VydmVkLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIFNlZSBcIkxJQ0VOU0VcIiBmb3IgZGV0YWlsczogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiBodHRwOi8vd3d3LWNzLXN0dWRlbnRzLnN0YW5mb3JkLmVkdS9+dGp3L2pzYm4vTElDRU5TRSAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4oZnVuY3Rpb24oKXtmdW5jdGlvbiBrKGEsYixjKXtkLmJpZ2ludGVnZXJfdXNlZD0xO251bGwhPWEmJihcIm51bWJlclwiPT10eXBlb2YgYSYmXCJ1bmRlZmluZWRcIj09dHlwZW9mIGI/dGhpcy5mcm9tSW50KGEpOlwibnVtYmVyXCI9PXR5cGVvZiBhP3RoaXMuZnJvbU51bWJlcihhLGIsYyk6bnVsbD09YiYmXCJzdHJpbmdcIiE9dHlwZW9mIGE/dGhpcy5mcm9tU3RyaW5nKGEsMjU2KTp0aGlzLmZyb21TdHJpbmcoYSxiKSl9ZnVuY3Rpb24gcSgpe3JldHVybiBuZXcgayhudWxsKX1mdW5jdGlvbiBRKGEsYixjLGUsZCxnKXtmb3IoOzA8PS0tZzspe3ZhciBoPWIqdGhpc1thKytdK2NbZV0rZDtkPU1hdGguZmxvb3IoaC82NzEwODg2NCk7Y1tlKytdPWgmNjcxMDg4NjN9cmV0dXJuIGR9ZnVuY3Rpb24gUihhLGIsYyxlLGQsZyl7dmFyIGg9YiYzMjc2Nztmb3IoYj4+PTE1OzA8PS0tZzspe3ZhciBsPXRoaXNbYV0mMzI3Njcsaz10aGlzW2ErK10+PjE1LG49YipsK2sqaCxsPWgqbCsoKG4mMzI3NjcpPDxcbjE1KStjW2VdKyhkJjEwNzM3NDE4MjMpO2Q9KGw+Pj4zMCkrKG4+Pj4xNSkrYiprKyhkPj4+MzApO2NbZSsrXT1sJjEwNzM3NDE4MjN9cmV0dXJuIGR9ZnVuY3Rpb24gUyhhLGIsYyxlLGQsZyl7dmFyIGg9YiYxNjM4Mztmb3IoYj4+PTE0OzA8PS0tZzspe3ZhciBsPXRoaXNbYV0mMTYzODMsaz10aGlzW2ErK10+PjE0LG49YipsK2sqaCxsPWgqbCsoKG4mMTYzODMpPDwxNCkrY1tlXStkO2Q9KGw+PjI4KSsobj4+MTQpK2IqaztjW2UrK109bCYyNjg0MzU0NTV9cmV0dXJuIGR9ZnVuY3Rpb24gTChhLGIpe3ZhciBjPUJbYS5jaGFyQ29kZUF0KGIpXTtyZXR1cm4gbnVsbD09Yz8tMTpjfWZ1bmN0aW9uIHYoYSl7dmFyIGI9cSgpO2IuZnJvbUludChhKTtyZXR1cm4gYn1mdW5jdGlvbiBDKGEpe3ZhciBiPTEsYzswIT0oYz1hPj4+MTYpJiYoYT1jLGIrPTE2KTswIT0oYz1hPj44KSYmKGE9YyxiKz04KTswIT0oYz1hPj40KSYmKGE9YyxiKz00KTswIT0oYz1hPj4yKSYmKGE9YyxiKz0yKTswIT1cbmE+PjEmJihiKz0xKTtyZXR1cm4gYn1mdW5jdGlvbiB4KGEpe3RoaXMubT1hfWZ1bmN0aW9uIHkoYSl7dGhpcy5tPWE7dGhpcy5tcD1hLmludkRpZ2l0KCk7dGhpcy5tcGw9dGhpcy5tcCYzMjc2Nzt0aGlzLm1waD10aGlzLm1wPj4xNTt0aGlzLnVtPSgxPDxhLkRCLTE1KS0xO3RoaXMubXQyPTIqYS50fWZ1bmN0aW9uIFQoYSxiKXtyZXR1cm4gYSZifWZ1bmN0aW9uIEkoYSxiKXtyZXR1cm4gYXxifWZ1bmN0aW9uIE0oYSxiKXtyZXR1cm4gYV5ifWZ1bmN0aW9uIE4oYSxiKXtyZXR1cm4gYSZ+Yn1mdW5jdGlvbiBBKCl7fWZ1bmN0aW9uIE8oYSl7cmV0dXJuIGF9ZnVuY3Rpb24gdyhhKXt0aGlzLnIyPXEoKTt0aGlzLnEzPXEoKTtrLk9ORS5kbFNoaWZ0VG8oMiphLnQsdGhpcy5yMik7dGhpcy5tdT10aGlzLnIyLmRpdmlkZShhKTt0aGlzLm09YX12YXIgZD17fSxEPSExO1widW5kZWZpbmVkXCIhPT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cz8obW9kdWxlLmV4cG9ydHM9ZCxEPSEwKTpcblwidW5kZWZpbmVkXCIhPT10eXBlb2YgZG9jdW1lbnQ/d2luZG93LkNsaXBwZXJMaWI9ZDpzZWxmLkNsaXBwZXJMaWI9ZDt2YXIgcjtpZihEKXA9XCJjaHJvbWVcIixyPVwiTmV0c2NhcGVcIjtlbHNle3ZhciBwPW5hdmlnYXRvci51c2VyQWdlbnQudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO3I9bmF2aWdhdG9yLmFwcE5hbWV9dmFyIEUsSixGLEcsSCxQO0U9LTEhPXAuaW5kZXhPZihcImNocm9tZVwiKSYmLTE9PXAuaW5kZXhPZihcImNocm9taXVtXCIpPzE6MDtEPS0xIT1wLmluZGV4T2YoXCJjaHJvbWl1bVwiKT8xOjA7Sj0tMSE9cC5pbmRleE9mKFwic2FmYXJpXCIpJiYtMT09cC5pbmRleE9mKFwiY2hyb21lXCIpJiYtMT09cC5pbmRleE9mKFwiY2hyb21pdW1cIik/MTowO0Y9LTEhPXAuaW5kZXhPZihcImZpcmVmb3hcIik/MTowO3AuaW5kZXhPZihcImZpcmVmb3gvMTdcIik7cC5pbmRleE9mKFwiZmlyZWZveC8xNVwiKTtwLmluZGV4T2YoXCJmaXJlZm94LzNcIik7Rz0tMSE9cC5pbmRleE9mKFwib3BlcmFcIik/MTowO3AuaW5kZXhPZihcIm1zaWUgMTBcIik7XG5wLmluZGV4T2YoXCJtc2llIDlcIik7SD0tMSE9cC5pbmRleE9mKFwibXNpZSA4XCIpPzE6MDtQPS0xIT1wLmluZGV4T2YoXCJtc2llIDdcIik/MTowO3A9LTEhPXAuaW5kZXhPZihcIm1zaWUgXCIpPzE6MDtkLmJpZ2ludGVnZXJfdXNlZD1udWxsO1wiTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyXCI9PXI/KGsucHJvdG90eXBlLmFtPVIscj0zMCk6XCJOZXRzY2FwZVwiIT1yPyhrLnByb3RvdHlwZS5hbT1RLHI9MjYpOihrLnByb3RvdHlwZS5hbT1TLHI9MjgpO2sucHJvdG90eXBlLkRCPXI7ay5wcm90b3R5cGUuRE09KDE8PHIpLTE7ay5wcm90b3R5cGUuRFY9MTw8cjtrLnByb3RvdHlwZS5GVj1NYXRoLnBvdygyLDUyKTtrLnByb3RvdHlwZS5GMT01Mi1yO2sucHJvdG90eXBlLkYyPTIqci01Mjt2YXIgQj1bXSx1O3I9NDg7Zm9yKHU9MDs5Pj11OysrdSlCW3IrK109dTtyPTk3O2Zvcih1PTEwOzM2PnU7Kyt1KUJbcisrXT11O3I9NjU7Zm9yKHU9MTA7MzY+dTsrK3UpQltyKytdPXU7eC5wcm90b3R5cGUuY29udmVydD1cbmZ1bmN0aW9uKGEpe3JldHVybiAwPmEuc3x8MDw9YS5jb21wYXJlVG8odGhpcy5tKT9hLm1vZCh0aGlzLm0pOmF9O3gucHJvdG90eXBlLnJldmVydD1mdW5jdGlvbihhKXtyZXR1cm4gYX07eC5wcm90b3R5cGUucmVkdWNlPWZ1bmN0aW9uKGEpe2EuZGl2UmVtVG8odGhpcy5tLG51bGwsYSl9O3gucHJvdG90eXBlLm11bFRvPWZ1bmN0aW9uKGEsYixjKXthLm11bHRpcGx5VG8oYixjKTt0aGlzLnJlZHVjZShjKX07eC5wcm90b3R5cGUuc3FyVG89ZnVuY3Rpb24oYSxiKXthLnNxdWFyZVRvKGIpO3RoaXMucmVkdWNlKGIpfTt5LnByb3RvdHlwZS5jb252ZXJ0PWZ1bmN0aW9uKGEpe3ZhciBiPXEoKTthLmFicygpLmRsU2hpZnRUbyh0aGlzLm0udCxiKTtiLmRpdlJlbVRvKHRoaXMubSxudWxsLGIpOzA+YS5zJiYwPGIuY29tcGFyZVRvKGsuWkVSTykmJnRoaXMubS5zdWJUbyhiLGIpO3JldHVybiBifTt5LnByb3RvdHlwZS5yZXZlcnQ9ZnVuY3Rpb24oYSl7dmFyIGI9cSgpO2EuY29weVRvKGIpO1xudGhpcy5yZWR1Y2UoYik7cmV0dXJuIGJ9O3kucHJvdG90eXBlLnJlZHVjZT1mdW5jdGlvbihhKXtmb3IoO2EudDw9dGhpcy5tdDI7KWFbYS50KytdPTA7Zm9yKHZhciBiPTA7Yjx0aGlzLm0udDsrK2Ipe3ZhciBjPWFbYl0mMzI3NjcsZT1jKnRoaXMubXBsKygoYyp0aGlzLm1waCsoYVtiXT4+MTUpKnRoaXMubXBsJnRoaXMudW0pPDwxNSkmYS5ETSxjPWIrdGhpcy5tLnQ7Zm9yKGFbY10rPXRoaXMubS5hbSgwLGUsYSxiLDAsdGhpcy5tLnQpO2FbY10+PWEuRFY7KWFbY10tPWEuRFYsYVsrK2NdKyt9YS5jbGFtcCgpO2EuZHJTaGlmdFRvKHRoaXMubS50LGEpOzA8PWEuY29tcGFyZVRvKHRoaXMubSkmJmEuc3ViVG8odGhpcy5tLGEpfTt5LnByb3RvdHlwZS5tdWxUbz1mdW5jdGlvbihhLGIsYyl7YS5tdWx0aXBseVRvKGIsYyk7dGhpcy5yZWR1Y2UoYyl9O3kucHJvdG90eXBlLnNxclRvPWZ1bmN0aW9uKGEsYil7YS5zcXVhcmVUbyhiKTt0aGlzLnJlZHVjZShiKX07ay5wcm90b3R5cGUuY29weVRvPVxuZnVuY3Rpb24oYSl7Zm9yKHZhciBiPXRoaXMudC0xOzA8PWI7LS1iKWFbYl09dGhpc1tiXTthLnQ9dGhpcy50O2Eucz10aGlzLnN9O2sucHJvdG90eXBlLmZyb21JbnQ9ZnVuY3Rpb24oYSl7dGhpcy50PTE7dGhpcy5zPTA+YT8tMTowOzA8YT90aGlzWzBdPWE6LTE+YT90aGlzWzBdPWErdGhpcy5EVjp0aGlzLnQ9MH07ay5wcm90b3R5cGUuZnJvbVN0cmluZz1mdW5jdGlvbihhLGIpe3ZhciBjO2lmKDE2PT1iKWM9NDtlbHNlIGlmKDg9PWIpYz0zO2Vsc2UgaWYoMjU2PT1iKWM9ODtlbHNlIGlmKDI9PWIpYz0xO2Vsc2UgaWYoMzI9PWIpYz01O2Vsc2UgaWYoND09YiljPTI7ZWxzZXt0aGlzLmZyb21SYWRpeChhLGIpO3JldHVybn10aGlzLnM9dGhpcy50PTA7Zm9yKHZhciBlPWEubGVuZ3RoLGQ9ITEsZz0wOzA8PS0tZTspe3ZhciBoPTg9PWM/YVtlXSYyNTU6TChhLGUpOzA+aD9cIi1cIj09YS5jaGFyQXQoZSkmJihkPSEwKTooZD0hMSwwPT1nP3RoaXNbdGhpcy50KytdPWg6ZytjPnRoaXMuREI/XG4odGhpc1t0aGlzLnQtMV18PShoJigxPDx0aGlzLkRCLWcpLTEpPDxnLHRoaXNbdGhpcy50KytdPWg+PnRoaXMuREItZyk6dGhpc1t0aGlzLnQtMV18PWg8PGcsZys9YyxnPj10aGlzLkRCJiYoZy09dGhpcy5EQikpfTg9PWMmJjAhPShhWzBdJjEyOCkmJih0aGlzLnM9LTEsMDxnJiYodGhpc1t0aGlzLnQtMV18PSgxPDx0aGlzLkRCLWcpLTE8PGcpKTt0aGlzLmNsYW1wKCk7ZCYmay5aRVJPLnN1YlRvKHRoaXMsdGhpcyl9O2sucHJvdG90eXBlLmNsYW1wPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMucyZ0aGlzLkRNOzA8dGhpcy50JiZ0aGlzW3RoaXMudC0xXT09YTspLS10aGlzLnR9O2sucHJvdG90eXBlLmRsU2hpZnRUbz1mdW5jdGlvbihhLGIpe3ZhciBjO2ZvcihjPXRoaXMudC0xOzA8PWM7LS1jKWJbYythXT10aGlzW2NdO2ZvcihjPWEtMTswPD1jOy0tYyliW2NdPTA7Yi50PXRoaXMudCthO2Iucz10aGlzLnN9O2sucHJvdG90eXBlLmRyU2hpZnRUbz1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1cbmE7Yzx0aGlzLnQ7KytjKWJbYy1hXT10aGlzW2NdO2IudD1NYXRoLm1heCh0aGlzLnQtYSwwKTtiLnM9dGhpcy5zfTtrLnByb3RvdHlwZS5sU2hpZnRUbz1mdW5jdGlvbihhLGIpe3ZhciBjPWEldGhpcy5EQixlPXRoaXMuREItYyxkPSgxPDxlKS0xLGc9TWF0aC5mbG9vcihhL3RoaXMuREIpLGg9dGhpcy5zPDxjJnRoaXMuRE0sbDtmb3IobD10aGlzLnQtMTswPD1sOy0tbCliW2wrZysxXT10aGlzW2xdPj5lfGgsaD0odGhpc1tsXSZkKTw8Yztmb3IobD1nLTE7MDw9bDstLWwpYltsXT0wO2JbZ109aDtiLnQ9dGhpcy50K2crMTtiLnM9dGhpcy5zO2IuY2xhbXAoKX07ay5wcm90b3R5cGUuclNoaWZ0VG89ZnVuY3Rpb24oYSxiKXtiLnM9dGhpcy5zO3ZhciBjPU1hdGguZmxvb3IoYS90aGlzLkRCKTtpZihjPj10aGlzLnQpYi50PTA7ZWxzZXt2YXIgZT1hJXRoaXMuREIsZD10aGlzLkRCLWUsZz0oMTw8ZSktMTtiWzBdPXRoaXNbY10+PmU7Zm9yKHZhciBoPWMrMTtoPHRoaXMudDsrK2gpYltoLVxuYy0xXXw9KHRoaXNbaF0mZyk8PGQsYltoLWNdPXRoaXNbaF0+PmU7MDxlJiYoYlt0aGlzLnQtYy0xXXw9KHRoaXMucyZnKTw8ZCk7Yi50PXRoaXMudC1jO2IuY2xhbXAoKX19O2sucHJvdG90eXBlLnN1YlRvPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTAsZT0wLGQ9TWF0aC5taW4oYS50LHRoaXMudCk7YzxkOyllKz10aGlzW2NdLWFbY10sYltjKytdPWUmdGhpcy5ETSxlPj49dGhpcy5EQjtpZihhLnQ8dGhpcy50KXtmb3IoZS09YS5zO2M8dGhpcy50OyllKz10aGlzW2NdLGJbYysrXT1lJnRoaXMuRE0sZT4+PXRoaXMuREI7ZSs9dGhpcy5zfWVsc2V7Zm9yKGUrPXRoaXMucztjPGEudDspZS09YVtjXSxiW2MrK109ZSZ0aGlzLkRNLGU+Pj10aGlzLkRCO2UtPWEuc31iLnM9MD5lPy0xOjA7LTE+ZT9iW2MrK109dGhpcy5EVitlOjA8ZSYmKGJbYysrXT1lKTtiLnQ9YztiLmNsYW1wKCl9O2sucHJvdG90eXBlLm11bHRpcGx5VG89ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmFicygpLGU9XG5hLmFicygpLGQ9Yy50O2ZvcihiLnQ9ZCtlLnQ7MDw9LS1kOyliW2RdPTA7Zm9yKGQ9MDtkPGUudDsrK2QpYltkK2MudF09Yy5hbSgwLGVbZF0sYixkLDAsYy50KTtiLnM9MDtiLmNsYW1wKCk7dGhpcy5zIT1hLnMmJmsuWkVSTy5zdWJUbyhiLGIpfTtrLnByb3RvdHlwZS5zcXVhcmVUbz1mdW5jdGlvbihhKXtmb3IodmFyIGI9dGhpcy5hYnMoKSxjPWEudD0yKmIudDswPD0tLWM7KWFbY109MDtmb3IoYz0wO2M8Yi50LTE7KytjKXt2YXIgZT1iLmFtKGMsYltjXSxhLDIqYywwLDEpOyhhW2MrYi50XSs9Yi5hbShjKzEsMipiW2NdLGEsMipjKzEsZSxiLnQtYy0xKSk+PWIuRFYmJihhW2MrYi50XS09Yi5EVixhW2MrYi50KzFdPTEpfTA8YS50JiYoYVthLnQtMV0rPWIuYW0oYyxiW2NdLGEsMipjLDAsMSkpO2Eucz0wO2EuY2xhbXAoKX07ay5wcm90b3R5cGUuZGl2UmVtVG89ZnVuY3Rpb24oYSxiLGMpe3ZhciBlPWEuYWJzKCk7aWYoISgwPj1lLnQpKXt2YXIgZD10aGlzLmFicygpO2lmKGQudDxcbmUudCludWxsIT1iJiZiLmZyb21JbnQoMCksbnVsbCE9YyYmdGhpcy5jb3B5VG8oYyk7ZWxzZXtudWxsPT1jJiYoYz1xKCkpO3ZhciBnPXEoKSxoPXRoaXMuczthPWEuczt2YXIgbD10aGlzLkRCLUMoZVtlLnQtMV0pOzA8bD8oZS5sU2hpZnRUbyhsLGcpLGQubFNoaWZ0VG8obCxjKSk6KGUuY29weVRvKGcpLGQuY29weVRvKGMpKTtlPWcudDtkPWdbZS0xXTtpZigwIT1kKXt2YXIgej1kKigxPDx0aGlzLkYxKSsoMTxlP2dbZS0yXT4+dGhpcy5GMjowKSxuPXRoaXMuRlYveix6PSgxPDx0aGlzLkYxKS96LFU9MTw8dGhpcy5GMixtPWMudCxwPW0tZSxzPW51bGw9PWI/cSgpOmI7Zy5kbFNoaWZ0VG8ocCxzKTswPD1jLmNvbXBhcmVUbyhzKSYmKGNbYy50KytdPTEsYy5zdWJUbyhzLGMpKTtrLk9ORS5kbFNoaWZ0VG8oZSxzKTtmb3Iocy5zdWJUbyhnLGcpO2cudDxlOylnW2cudCsrXT0wO2Zvcig7MDw9LS1wOyl7dmFyIHI9Y1stLW1dPT1kP3RoaXMuRE06TWF0aC5mbG9vcihjW21dKm4rKGNbbS1cbjFdK1UpKnopO2lmKChjW21dKz1nLmFtKDAscixjLHAsMCxlKSk8cilmb3IoZy5kbFNoaWZ0VG8ocCxzKSxjLnN1YlRvKHMsYyk7Y1ttXTwtLXI7KWMuc3ViVG8ocyxjKX1udWxsIT1iJiYoYy5kclNoaWZ0VG8oZSxiKSxoIT1hJiZrLlpFUk8uc3ViVG8oYixiKSk7Yy50PWU7Yy5jbGFtcCgpOzA8bCYmYy5yU2hpZnRUbyhsLGMpOzA+aCYmay5aRVJPLnN1YlRvKGMsYyl9fX19O2sucHJvdG90eXBlLmludkRpZ2l0PWZ1bmN0aW9uKCl7aWYoMT50aGlzLnQpcmV0dXJuIDA7dmFyIGE9dGhpc1swXTtpZigwPT0oYSYxKSlyZXR1cm4gMDt2YXIgYj1hJjMsYj1iKigyLShhJjE1KSpiKSYxNSxiPWIqKDItKGEmMjU1KSpiKSYyNTUsYj1iKigyLSgoYSY2NTUzNSkqYiY2NTUzNSkpJjY1NTM1LGI9YiooMi1hKmIldGhpcy5EVikldGhpcy5EVjtyZXR1cm4gMDxiP3RoaXMuRFYtYjotYn07ay5wcm90b3R5cGUuaXNFdmVuPWZ1bmN0aW9uKCl7cmV0dXJuIDA9PSgwPHRoaXMudD90aGlzWzBdJjE6dGhpcy5zKX07XG5rLnByb3RvdHlwZS5leHA9ZnVuY3Rpb24oYSxiKXtpZig0Mjk0OTY3Mjk1PGF8fDE+YSlyZXR1cm4gay5PTkU7dmFyIGM9cSgpLGU9cSgpLGQ9Yi5jb252ZXJ0KHRoaXMpLGc9QyhhKS0xO2ZvcihkLmNvcHlUbyhjKTswPD0tLWc7KWlmKGIuc3FyVG8oYyxlKSwwPChhJjE8PGcpKWIubXVsVG8oZSxkLGMpO2Vsc2UgdmFyIGg9YyxjPWUsZT1oO3JldHVybiBiLnJldmVydChjKX07ay5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oYSl7aWYoMD50aGlzLnMpcmV0dXJuXCItXCIrdGhpcy5uZWdhdGUoKS50b1N0cmluZyhhKTtpZigxNj09YSlhPTQ7ZWxzZSBpZig4PT1hKWE9MztlbHNlIGlmKDI9PWEpYT0xO2Vsc2UgaWYoMzI9PWEpYT01O2Vsc2UgaWYoND09YSlhPTI7ZWxzZSByZXR1cm4gdGhpcy50b1JhZGl4KGEpO3ZhciBiPSgxPDxhKS0xLGMsZT0hMSxkPVwiXCIsZz10aGlzLnQsaD10aGlzLkRCLWcqdGhpcy5EQiVhO2lmKDA8Zy0tKWZvcihoPHRoaXMuREImJjA8KGM9dGhpc1tnXT4+XG5oKSYmKGU9ITAsZD1cIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLmNoYXJBdChjKSk7MDw9ZzspaDxhPyhjPSh0aGlzW2ddJigxPDxoKS0xKTw8YS1oLGN8PXRoaXNbLS1nXT4+KGgrPXRoaXMuREItYSkpOihjPXRoaXNbZ10+PihoLT1hKSZiLDA+PWgmJihoKz10aGlzLkRCLC0tZykpLDA8YyYmKGU9ITApLGUmJihkKz1cIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLmNoYXJBdChjKSk7cmV0dXJuIGU/ZDpcIjBcIn07ay5wcm90b3R5cGUubmVnYXRlPWZ1bmN0aW9uKCl7dmFyIGE9cSgpO2suWkVSTy5zdWJUbyh0aGlzLGEpO3JldHVybiBhfTtrLnByb3RvdHlwZS5hYnM9ZnVuY3Rpb24oKXtyZXR1cm4gMD50aGlzLnM/dGhpcy5uZWdhdGUoKTp0aGlzfTtrLnByb3RvdHlwZS5jb21wYXJlVG89ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5zLWEucztpZigwIT1iKXJldHVybiBiO3ZhciBjPXRoaXMudCxiPWMtYS50O2lmKDAhPWIpcmV0dXJuIDA+dGhpcy5zP1xuLWI6Yjtmb3IoOzA8PS0tYzspaWYoMCE9KGI9dGhpc1tjXS1hW2NdKSlyZXR1cm4gYjtyZXR1cm4gMH07ay5wcm90b3R5cGUuYml0TGVuZ3RoPWZ1bmN0aW9uKCl7cmV0dXJuIDA+PXRoaXMudD8wOnRoaXMuREIqKHRoaXMudC0xKStDKHRoaXNbdGhpcy50LTFdXnRoaXMucyZ0aGlzLkRNKX07ay5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKGEpe3ZhciBiPXEoKTt0aGlzLmFicygpLmRpdlJlbVRvKGEsbnVsbCxiKTswPnRoaXMucyYmMDxiLmNvbXBhcmVUbyhrLlpFUk8pJiZhLnN1YlRvKGIsYik7cmV0dXJuIGJ9O2sucHJvdG90eXBlLm1vZFBvd0ludD1mdW5jdGlvbihhLGIpe3ZhciBjO2M9MjU2PmF8fGIuaXNFdmVuKCk/bmV3IHgoYik6bmV3IHkoYik7cmV0dXJuIHRoaXMuZXhwKGEsYyl9O2suWkVSTz12KDApO2suT05FPXYoMSk7QS5wcm90b3R5cGUuY29udmVydD1PO0EucHJvdG90eXBlLnJldmVydD1PO0EucHJvdG90eXBlLm11bFRvPWZ1bmN0aW9uKGEsYixjKXthLm11bHRpcGx5VG8oYixcbmMpfTtBLnByb3RvdHlwZS5zcXJUbz1mdW5jdGlvbihhLGIpe2Euc3F1YXJlVG8oYil9O3cucHJvdG90eXBlLmNvbnZlcnQ9ZnVuY3Rpb24oYSl7aWYoMD5hLnN8fGEudD4yKnRoaXMubS50KXJldHVybiBhLm1vZCh0aGlzLm0pO2lmKDA+YS5jb21wYXJlVG8odGhpcy5tKSlyZXR1cm4gYTt2YXIgYj1xKCk7YS5jb3B5VG8oYik7dGhpcy5yZWR1Y2UoYik7cmV0dXJuIGJ9O3cucHJvdG90eXBlLnJldmVydD1mdW5jdGlvbihhKXtyZXR1cm4gYX07dy5wcm90b3R5cGUucmVkdWNlPWZ1bmN0aW9uKGEpe2EuZHJTaGlmdFRvKHRoaXMubS50LTEsdGhpcy5yMik7YS50PnRoaXMubS50KzEmJihhLnQ9dGhpcy5tLnQrMSxhLmNsYW1wKCkpO3RoaXMubXUubXVsdGlwbHlVcHBlclRvKHRoaXMucjIsdGhpcy5tLnQrMSx0aGlzLnEzKTtmb3IodGhpcy5tLm11bHRpcGx5TG93ZXJUbyh0aGlzLnEzLHRoaXMubS50KzEsdGhpcy5yMik7MD5hLmNvbXBhcmVUbyh0aGlzLnIyKTspYS5kQWRkT2Zmc2V0KDEsXG50aGlzLm0udCsxKTtmb3IoYS5zdWJUbyh0aGlzLnIyLGEpOzA8PWEuY29tcGFyZVRvKHRoaXMubSk7KWEuc3ViVG8odGhpcy5tLGEpfTt3LnByb3RvdHlwZS5tdWxUbz1mdW5jdGlvbihhLGIsYyl7YS5tdWx0aXBseVRvKGIsYyk7dGhpcy5yZWR1Y2UoYyl9O3cucHJvdG90eXBlLnNxclRvPWZ1bmN0aW9uKGEsYil7YS5zcXVhcmVUbyhiKTt0aGlzLnJlZHVjZShiKX07dmFyIHQ9WzIsMyw1LDcsMTEsMTMsMTcsMTksMjMsMjksMzEsMzcsNDEsNDMsNDcsNTMsNTksNjEsNjcsNzEsNzMsNzksODMsODksOTcsMTAxLDEwMywxMDcsMTA5LDExMywxMjcsMTMxLDEzNywxMzksMTQ5LDE1MSwxNTcsMTYzLDE2NywxNzMsMTc5LDE4MSwxOTEsMTkzLDE5NywxOTksMjExLDIyMywyMjcsMjI5LDIzMywyMzksMjQxLDI1MSwyNTcsMjYzLDI2OSwyNzEsMjc3LDI4MSwyODMsMjkzLDMwNywzMTEsMzEzLDMxNywzMzEsMzM3LDM0NywzNDksMzUzLDM1OSwzNjcsMzczLDM3OSwzODMsMzg5LDM5Nyw0MDEsXG40MDksNDE5LDQyMSw0MzEsNDMzLDQzOSw0NDMsNDQ5LDQ1Nyw0NjEsNDYzLDQ2Nyw0NzksNDg3LDQ5MSw0OTksNTAzLDUwOSw1MjEsNTIzLDU0MSw1NDcsNTU3LDU2Myw1NjksNTcxLDU3Nyw1ODcsNTkzLDU5OSw2MDEsNjA3LDYxMyw2MTcsNjE5LDYzMSw2NDEsNjQzLDY0Nyw2NTMsNjU5LDY2MSw2NzMsNjc3LDY4Myw2OTEsNzAxLDcwOSw3MTksNzI3LDczMyw3MzksNzQzLDc1MSw3NTcsNzYxLDc2OSw3NzMsNzg3LDc5Nyw4MDksODExLDgyMSw4MjMsODI3LDgyOSw4MzksODUzLDg1Nyw4NTksODYzLDg3Nyw4ODEsODgzLDg4Nyw5MDcsOTExLDkxOSw5MjksOTM3LDk0MSw5NDcsOTUzLDk2Nyw5NzEsOTc3LDk4Myw5OTEsOTk3XSxWPTY3MTA4ODY0L3RbdC5sZW5ndGgtMV07ay5wcm90b3R5cGUuY2h1bmtTaXplPWZ1bmN0aW9uKGEpe3JldHVybiBNYXRoLmZsb29yKE1hdGguTE4yKnRoaXMuREIvTWF0aC5sb2coYSkpfTtrLnByb3RvdHlwZS50b1JhZGl4PWZ1bmN0aW9uKGEpe251bGw9PVxuYSYmKGE9MTApO2lmKDA9PXRoaXMuc2lnbnVtKCl8fDI+YXx8MzY8YSlyZXR1cm5cIjBcIjt2YXIgYj10aGlzLmNodW5rU2l6ZShhKSxiPU1hdGgucG93KGEsYiksYz12KGIpLGU9cSgpLGQ9cSgpLGc9XCJcIjtmb3IodGhpcy5kaXZSZW1UbyhjLGUsZCk7MDxlLnNpZ251bSgpOylnPShiK2QuaW50VmFsdWUoKSkudG9TdHJpbmcoYSkuc3Vic3RyKDEpK2csZS5kaXZSZW1UbyhjLGUsZCk7cmV0dXJuIGQuaW50VmFsdWUoKS50b1N0cmluZyhhKStnfTtrLnByb3RvdHlwZS5mcm9tUmFkaXg9ZnVuY3Rpb24oYSxiKXt0aGlzLmZyb21JbnQoMCk7bnVsbD09YiYmKGI9MTApO2Zvcih2YXIgYz10aGlzLmNodW5rU2l6ZShiKSxlPU1hdGgucG93KGIsYyksZD0hMSxnPTAsaD0wLGw9MDtsPGEubGVuZ3RoOysrbCl7dmFyIHo9TChhLGwpOzA+ej9cIi1cIj09YS5jaGFyQXQobCkmJjA9PXRoaXMuc2lnbnVtKCkmJihkPSEwKTooaD1iKmgreiwrK2c+PWMmJih0aGlzLmRNdWx0aXBseShlKSx0aGlzLmRBZGRPZmZzZXQoaCxcbjApLGg9Zz0wKSl9MDxnJiYodGhpcy5kTXVsdGlwbHkoTWF0aC5wb3coYixnKSksdGhpcy5kQWRkT2Zmc2V0KGgsMCkpO2QmJmsuWkVSTy5zdWJUbyh0aGlzLHRoaXMpfTtrLnByb3RvdHlwZS5mcm9tTnVtYmVyPWZ1bmN0aW9uKGEsYixjKXtpZihcIm51bWJlclwiPT10eXBlb2YgYilpZigyPmEpdGhpcy5mcm9tSW50KDEpO2Vsc2UgZm9yKHRoaXMuZnJvbU51bWJlcihhLGMpLHRoaXMudGVzdEJpdChhLTEpfHx0aGlzLmJpdHdpc2VUbyhrLk9ORS5zaGlmdExlZnQoYS0xKSxJLHRoaXMpLHRoaXMuaXNFdmVuKCkmJnRoaXMuZEFkZE9mZnNldCgxLDApOyF0aGlzLmlzUHJvYmFibGVQcmltZShiKTspdGhpcy5kQWRkT2Zmc2V0KDIsMCksdGhpcy5iaXRMZW5ndGgoKT5hJiZ0aGlzLnN1YlRvKGsuT05FLnNoaWZ0TGVmdChhLTEpLHRoaXMpO2Vsc2V7Yz1bXTt2YXIgZT1hJjc7Yy5sZW5ndGg9KGE+PjMpKzE7Yi5uZXh0Qnl0ZXMoYyk7Y1swXT0wPGU/Y1swXSYoMTw8ZSktMTowO3RoaXMuZnJvbVN0cmluZyhjLFxuMjU2KX19O2sucHJvdG90eXBlLmJpdHdpc2VUbz1mdW5jdGlvbihhLGIsYyl7dmFyIGUsZCxnPU1hdGgubWluKGEudCx0aGlzLnQpO2ZvcihlPTA7ZTxnOysrZSljW2VdPWIodGhpc1tlXSxhW2VdKTtpZihhLnQ8dGhpcy50KXtkPWEucyZ0aGlzLkRNO2ZvcihlPWc7ZTx0aGlzLnQ7KytlKWNbZV09Yih0aGlzW2VdLGQpO2MudD10aGlzLnR9ZWxzZXtkPXRoaXMucyZ0aGlzLkRNO2ZvcihlPWc7ZTxhLnQ7KytlKWNbZV09YihkLGFbZV0pO2MudD1hLnR9Yy5zPWIodGhpcy5zLGEucyk7Yy5jbGFtcCgpfTtrLnByb3RvdHlwZS5jaGFuZ2VCaXQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1rLk9ORS5zaGlmdExlZnQoYSk7dGhpcy5iaXR3aXNlVG8oYyxiLGMpO3JldHVybiBjfTtrLnByb3RvdHlwZS5hZGRUbz1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wLGU9MCxkPU1hdGgubWluKGEudCx0aGlzLnQpO2M8ZDspZSs9dGhpc1tjXSthW2NdLGJbYysrXT1lJnRoaXMuRE0sZT4+PXRoaXMuREI7aWYoYS50PFxudGhpcy50KXtmb3IoZSs9YS5zO2M8dGhpcy50OyllKz10aGlzW2NdLGJbYysrXT1lJnRoaXMuRE0sZT4+PXRoaXMuREI7ZSs9dGhpcy5zfWVsc2V7Zm9yKGUrPXRoaXMucztjPGEudDspZSs9YVtjXSxiW2MrK109ZSZ0aGlzLkRNLGU+Pj10aGlzLkRCO2UrPWEuc31iLnM9MD5lPy0xOjA7MDxlP2JbYysrXT1lOi0xPmUmJihiW2MrK109dGhpcy5EVitlKTtiLnQ9YztiLmNsYW1wKCl9O2sucHJvdG90eXBlLmRNdWx0aXBseT1mdW5jdGlvbihhKXt0aGlzW3RoaXMudF09dGhpcy5hbSgwLGEtMSx0aGlzLDAsMCx0aGlzLnQpOysrdGhpcy50O3RoaXMuY2xhbXAoKX07ay5wcm90b3R5cGUuZEFkZE9mZnNldD1mdW5jdGlvbihhLGIpe2lmKDAhPWEpe2Zvcig7dGhpcy50PD1iOyl0aGlzW3RoaXMudCsrXT0wO2Zvcih0aGlzW2JdKz1hO3RoaXNbYl0+PXRoaXMuRFY7KXRoaXNbYl0tPXRoaXMuRFYsKytiPj10aGlzLnQmJih0aGlzW3RoaXMudCsrXT0wKSwrK3RoaXNbYl19fTtrLnByb3RvdHlwZS5tdWx0aXBseUxvd2VyVG89XG5mdW5jdGlvbihhLGIsYyl7dmFyIGU9TWF0aC5taW4odGhpcy50K2EudCxiKTtjLnM9MDtmb3IoYy50PWU7MDxlOyljWy0tZV09MDt2YXIgZDtmb3IoZD1jLnQtdGhpcy50O2U8ZDsrK2UpY1tlK3RoaXMudF09dGhpcy5hbSgwLGFbZV0sYyxlLDAsdGhpcy50KTtmb3IoZD1NYXRoLm1pbihhLnQsYik7ZTxkOysrZSl0aGlzLmFtKDAsYVtlXSxjLGUsMCxiLWUpO2MuY2xhbXAoKX07ay5wcm90b3R5cGUubXVsdGlwbHlVcHBlclRvPWZ1bmN0aW9uKGEsYixjKXstLWI7dmFyIGU9Yy50PXRoaXMudCthLnQtYjtmb3IoYy5zPTA7MDw9LS1lOyljW2VdPTA7Zm9yKGU9TWF0aC5tYXgoYi10aGlzLnQsMCk7ZTxhLnQ7KytlKWNbdGhpcy50K2UtYl09dGhpcy5hbShiLWUsYVtlXSxjLDAsMCx0aGlzLnQrZS1iKTtjLmNsYW1wKCk7Yy5kclNoaWZ0VG8oMSxjKX07ay5wcm90b3R5cGUubW9kSW50PWZ1bmN0aW9uKGEpe2lmKDA+PWEpcmV0dXJuIDA7dmFyIGI9dGhpcy5EViVhLGM9MD50aGlzLnM/YS1cbjE6MDtpZigwPHRoaXMudClpZigwPT1iKWM9dGhpc1swXSVhO2Vsc2UgZm9yKHZhciBlPXRoaXMudC0xOzA8PWU7LS1lKWM9KGIqYyt0aGlzW2VdKSVhO3JldHVybiBjfTtrLnByb3RvdHlwZS5taWxsZXJSYWJpbj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLnN1YnRyYWN0KGsuT05FKSxjPWIuZ2V0TG93ZXN0U2V0Qml0KCk7aWYoMD49YylyZXR1cm4hMTt2YXIgZT1iLnNoaWZ0UmlnaHQoYyk7YT1hKzE+PjE7YT50Lmxlbmd0aCYmKGE9dC5sZW5ndGgpO2Zvcih2YXIgZD1xKCksZz0wO2c8YTsrK2cpe2QuZnJvbUludCh0W01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSp0Lmxlbmd0aCldKTt2YXIgaD1kLm1vZFBvdyhlLHRoaXMpO2lmKDAhPWguY29tcGFyZVRvKGsuT05FKSYmMCE9aC5jb21wYXJlVG8oYikpe2Zvcih2YXIgbD0xO2wrKzxjJiYwIT1oLmNvbXBhcmVUbyhiKTspaWYoaD1oLm1vZFBvd0ludCgyLHRoaXMpLDA9PWguY29tcGFyZVRvKGsuT05FKSlyZXR1cm4hMTtpZigwIT1oLmNvbXBhcmVUbyhiKSlyZXR1cm4hMX19cmV0dXJuITB9O1xuay5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgYT1xKCk7dGhpcy5jb3B5VG8oYSk7cmV0dXJuIGF9O2sucHJvdG90eXBlLmludFZhbHVlPWZ1bmN0aW9uKCl7aWYoMD50aGlzLnMpe2lmKDE9PXRoaXMudClyZXR1cm4gdGhpc1swXS10aGlzLkRWO2lmKDA9PXRoaXMudClyZXR1cm4tMX1lbHNle2lmKDE9PXRoaXMudClyZXR1cm4gdGhpc1swXTtpZigwPT10aGlzLnQpcmV0dXJuIDB9cmV0dXJuKHRoaXNbMV0mKDE8PDMyLXRoaXMuREIpLTEpPDx0aGlzLkRCfHRoaXNbMF19O2sucHJvdG90eXBlLmJ5dGVWYWx1ZT1mdW5jdGlvbigpe3JldHVybiAwPT10aGlzLnQ/dGhpcy5zOnRoaXNbMF08PDI0Pj4yNH07ay5wcm90b3R5cGUuc2hvcnRWYWx1ZT1mdW5jdGlvbigpe3JldHVybiAwPT10aGlzLnQ/dGhpcy5zOnRoaXNbMF08PDE2Pj4xNn07ay5wcm90b3R5cGUuc2lnbnVtPWZ1bmN0aW9uKCl7cmV0dXJuIDA+dGhpcy5zPy0xOjA+PXRoaXMudHx8MT09dGhpcy50JiYwPj10aGlzWzBdP1xuMDoxfTtrLnByb3RvdHlwZS50b0J5dGVBcnJheT1mdW5jdGlvbigpe3ZhciBhPXRoaXMudCxiPVtdO2JbMF09dGhpcy5zO3ZhciBjPXRoaXMuREItYSp0aGlzLkRCJTgsZSxkPTA7aWYoMDxhLS0pZm9yKGM8dGhpcy5EQiYmKGU9dGhpc1thXT4+YykhPSh0aGlzLnMmdGhpcy5ETSk+PmMmJihiW2QrK109ZXx0aGlzLnM8PHRoaXMuREItYyk7MDw9YTspaWYoOD5jPyhlPSh0aGlzW2FdJigxPDxjKS0xKTw8OC1jLGV8PXRoaXNbLS1hXT4+KGMrPXRoaXMuREItOCkpOihlPXRoaXNbYV0+PihjLT04KSYyNTUsMD49YyYmKGMrPXRoaXMuREIsLS1hKSksMCE9KGUmMTI4KSYmKGV8PS0yNTYpLDA9PWQmJih0aGlzLnMmMTI4KSE9KGUmMTI4KSYmKytkLDA8ZHx8ZSE9dGhpcy5zKWJbZCsrXT1lO3JldHVybiBifTtrLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24oYSl7cmV0dXJuIDA9PXRoaXMuY29tcGFyZVRvKGEpfTtrLnByb3RvdHlwZS5taW49ZnVuY3Rpb24oYSl7cmV0dXJuIDA+dGhpcy5jb21wYXJlVG8oYSk/XG50aGlzOmF9O2sucHJvdG90eXBlLm1heD1mdW5jdGlvbihhKXtyZXR1cm4gMDx0aGlzLmNvbXBhcmVUbyhhKT90aGlzOmF9O2sucHJvdG90eXBlLmFuZD1mdW5jdGlvbihhKXt2YXIgYj1xKCk7dGhpcy5iaXR3aXNlVG8oYSxULGIpO3JldHVybiBifTtrLnByb3RvdHlwZS5vcj1mdW5jdGlvbihhKXt2YXIgYj1xKCk7dGhpcy5iaXR3aXNlVG8oYSxJLGIpO3JldHVybiBifTtrLnByb3RvdHlwZS54b3I9ZnVuY3Rpb24oYSl7dmFyIGI9cSgpO3RoaXMuYml0d2lzZVRvKGEsTSxiKTtyZXR1cm4gYn07ay5wcm90b3R5cGUuYW5kTm90PWZ1bmN0aW9uKGEpe3ZhciBiPXEoKTt0aGlzLmJpdHdpc2VUbyhhLE4sYik7cmV0dXJuIGJ9O2sucHJvdG90eXBlLm5vdD1mdW5jdGlvbigpe2Zvcih2YXIgYT1xKCksYj0wO2I8dGhpcy50OysrYilhW2JdPXRoaXMuRE0mfnRoaXNbYl07YS50PXRoaXMudDthLnM9fnRoaXMucztyZXR1cm4gYX07ay5wcm90b3R5cGUuc2hpZnRMZWZ0PWZ1bmN0aW9uKGEpe3ZhciBiPVxucSgpOzA+YT90aGlzLnJTaGlmdFRvKC1hLGIpOnRoaXMubFNoaWZ0VG8oYSxiKTtyZXR1cm4gYn07ay5wcm90b3R5cGUuc2hpZnRSaWdodD1mdW5jdGlvbihhKXt2YXIgYj1xKCk7MD5hP3RoaXMubFNoaWZ0VG8oLWEsYik6dGhpcy5yU2hpZnRUbyhhLGIpO3JldHVybiBifTtrLnByb3RvdHlwZS5nZXRMb3dlc3RTZXRCaXQ9ZnVuY3Rpb24oKXtmb3IodmFyIGE9MDthPHRoaXMudDsrK2EpaWYoMCE9dGhpc1thXSl7dmFyIGI9YSp0aGlzLkRCO2E9dGhpc1thXTtpZigwPT1hKWE9LTE7ZWxzZXt2YXIgYz0wOzA9PShhJjY1NTM1KSYmKGE+Pj0xNixjKz0xNik7MD09KGEmMjU1KSYmKGE+Pj04LGMrPTgpOzA9PShhJjE1KSYmKGE+Pj00LGMrPTQpOzA9PShhJjMpJiYoYT4+PTIsYys9Mik7MD09KGEmMSkmJisrYzthPWN9cmV0dXJuIGIrYX1yZXR1cm4gMD50aGlzLnM/dGhpcy50KnRoaXMuREI6LTF9O2sucHJvdG90eXBlLmJpdENvdW50PWZ1bmN0aW9uKCl7Zm9yKHZhciBhPTAsYj10aGlzLnMmXG50aGlzLkRNLGM9MDtjPHRoaXMudDsrK2Mpe2Zvcih2YXIgZT10aGlzW2NdXmIsZD0wOzAhPWU7KWUmPWUtMSwrK2Q7YSs9ZH1yZXR1cm4gYX07ay5wcm90b3R5cGUudGVzdEJpdD1mdW5jdGlvbihhKXt2YXIgYj1NYXRoLmZsb29yKGEvdGhpcy5EQik7cmV0dXJuIGI+PXRoaXMudD8wIT10aGlzLnM6MCE9KHRoaXNbYl0mMTw8YSV0aGlzLkRCKX07ay5wcm90b3R5cGUuc2V0Qml0PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmNoYW5nZUJpdChhLEkpfTtrLnByb3RvdHlwZS5jbGVhckJpdD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5jaGFuZ2VCaXQoYSxOKX07ay5wcm90b3R5cGUuZmxpcEJpdD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5jaGFuZ2VCaXQoYSxNKX07ay5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGEpe3ZhciBiPXEoKTt0aGlzLmFkZFRvKGEsYik7cmV0dXJuIGJ9O2sucHJvdG90eXBlLnN1YnRyYWN0PWZ1bmN0aW9uKGEpe3ZhciBiPXEoKTt0aGlzLnN1YlRvKGEsYik7cmV0dXJuIGJ9O1xuay5wcm90b3R5cGUubXVsdGlwbHk9ZnVuY3Rpb24oYSl7dmFyIGI9cSgpO3RoaXMubXVsdGlwbHlUbyhhLGIpO3JldHVybiBifTtrLnByb3RvdHlwZS5kaXZpZGU9ZnVuY3Rpb24oYSl7dmFyIGI9cSgpO3RoaXMuZGl2UmVtVG8oYSxiLG51bGwpO3JldHVybiBifTtrLnByb3RvdHlwZS5yZW1haW5kZXI9ZnVuY3Rpb24oYSl7dmFyIGI9cSgpO3RoaXMuZGl2UmVtVG8oYSxudWxsLGIpO3JldHVybiBifTtrLnByb3RvdHlwZS5kaXZpZGVBbmRSZW1haW5kZXI9ZnVuY3Rpb24oYSl7dmFyIGI9cSgpLGM9cSgpO3RoaXMuZGl2UmVtVG8oYSxiLGMpO3JldHVybltiLGNdfTtrLnByb3RvdHlwZS5tb2RQb3c9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmJpdExlbmd0aCgpLGUsZD12KDEpLGc7aWYoMD49YylyZXR1cm4gZDtlPTE4PmM/MTo0OD5jPzM6MTQ0PmM/NDo3Njg+Yz81OjY7Zz04PmM/bmV3IHgoYik6Yi5pc0V2ZW4oKT9uZXcgdyhiKTpuZXcgeShiKTt2YXIgaD1bXSxsPTMsaz1lLTEsbj0oMTw8XG5lKS0xO2hbMV09Zy5jb252ZXJ0KHRoaXMpO2lmKDE8ZSlmb3IoYz1xKCksZy5zcXJUbyhoWzFdLGMpO2w8PW47KWhbbF09cSgpLGcubXVsVG8oYyxoW2wtMl0saFtsXSksbCs9Mjtmb3IodmFyIG09YS50LTEscCxyPSEwLHM9cSgpLGM9QyhhW21dKS0xOzA8PW07KXtjPj1rP3A9YVttXT4+Yy1rJm46KHA9KGFbbV0mKDE8PGMrMSktMSk8PGstYywwPG0mJihwfD1hW20tMV0+PnRoaXMuREIrYy1rKSk7Zm9yKGw9ZTswPT0ocCYxKTspcD4+PTEsLS1sOzA+KGMtPWwpJiYoYys9dGhpcy5EQiwtLW0pO2lmKHIpaFtwXS5jb3B5VG8oZCkscj0hMTtlbHNle2Zvcig7MTxsOylnLnNxclRvKGQscyksZy5zcXJUbyhzLGQpLGwtPTI7MDxsP2cuc3FyVG8oZCxzKToobD1kLGQ9cyxzPWwpO2cubXVsVG8ocyxoW3BdLGQpfWZvcig7MDw9bSYmMD09KGFbbV0mMTw8Yyk7KWcuc3FyVG8oZCxzKSxsPWQsZD1zLHM9bCwwPi0tYyYmKGM9dGhpcy5EQi0xLC0tbSl9cmV0dXJuIGcucmV2ZXJ0KGQpfTtrLnByb3RvdHlwZS5tb2RJbnZlcnNlPVxuZnVuY3Rpb24oYSl7dmFyIGI9YS5pc0V2ZW4oKTtpZih0aGlzLmlzRXZlbigpJiZifHwwPT1hLnNpZ251bSgpKXJldHVybiBrLlpFUk87Zm9yKHZhciBjPWEuY2xvbmUoKSxlPXRoaXMuY2xvbmUoKSxkPXYoMSksZz12KDApLGg9digwKSxsPXYoMSk7MCE9Yy5zaWdudW0oKTspe2Zvcig7Yy5pc0V2ZW4oKTspYy5yU2hpZnRUbygxLGMpLGI/KGQuaXNFdmVuKCkmJmcuaXNFdmVuKCl8fChkLmFkZFRvKHRoaXMsZCksZy5zdWJUbyhhLGcpKSxkLnJTaGlmdFRvKDEsZCkpOmcuaXNFdmVuKCl8fGcuc3ViVG8oYSxnKSxnLnJTaGlmdFRvKDEsZyk7Zm9yKDtlLmlzRXZlbigpOyllLnJTaGlmdFRvKDEsZSksYj8oaC5pc0V2ZW4oKSYmbC5pc0V2ZW4oKXx8KGguYWRkVG8odGhpcyxoKSxsLnN1YlRvKGEsbCkpLGguclNoaWZ0VG8oMSxoKSk6bC5pc0V2ZW4oKXx8bC5zdWJUbyhhLGwpLGwuclNoaWZ0VG8oMSxsKTswPD1jLmNvbXBhcmVUbyhlKT8oYy5zdWJUbyhlLGMpLGImJmQuc3ViVG8oaCxkKSxcbmcuc3ViVG8obCxnKSk6KGUuc3ViVG8oYyxlKSxiJiZoLnN1YlRvKGQsaCksbC5zdWJUbyhnLGwpKX1pZigwIT1lLmNvbXBhcmVUbyhrLk9ORSkpcmV0dXJuIGsuWkVSTztpZigwPD1sLmNvbXBhcmVUbyhhKSlyZXR1cm4gbC5zdWJ0cmFjdChhKTtpZigwPmwuc2lnbnVtKCkpbC5hZGRUbyhhLGwpO2Vsc2UgcmV0dXJuIGw7cmV0dXJuIDA+bC5zaWdudW0oKT9sLmFkZChhKTpsfTtrLnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZXhwKGEsbmV3IEEpfTtrLnByb3RvdHlwZS5nY2Q9ZnVuY3Rpb24oYSl7dmFyIGI9MD50aGlzLnM/dGhpcy5uZWdhdGUoKTp0aGlzLmNsb25lKCk7YT0wPmEucz9hLm5lZ2F0ZSgpOmEuY2xvbmUoKTtpZigwPmIuY29tcGFyZVRvKGEpKXt2YXIgYz1iLGI9YTthPWN9dmFyIGM9Yi5nZXRMb3dlc3RTZXRCaXQoKSxlPWEuZ2V0TG93ZXN0U2V0Qml0KCk7aWYoMD5lKXJldHVybiBiO2M8ZSYmKGU9Yyk7MDxlJiYoYi5yU2hpZnRUbyhlLGIpLFxuYS5yU2hpZnRUbyhlLGEpKTtmb3IoOzA8Yi5zaWdudW0oKTspMDwoYz1iLmdldExvd2VzdFNldEJpdCgpKSYmYi5yU2hpZnRUbyhjLGIpLDA8KGM9YS5nZXRMb3dlc3RTZXRCaXQoKSkmJmEuclNoaWZ0VG8oYyxhKSwwPD1iLmNvbXBhcmVUbyhhKT8oYi5zdWJUbyhhLGIpLGIuclNoaWZ0VG8oMSxiKSk6KGEuc3ViVG8oYixhKSxhLnJTaGlmdFRvKDEsYSkpOzA8ZSYmYS5sU2hpZnRUbyhlLGEpO3JldHVybiBhfTtrLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWU9ZnVuY3Rpb24oYSl7dmFyIGIsYz10aGlzLmFicygpO2lmKDE9PWMudCYmY1swXTw9dFt0Lmxlbmd0aC0xXSl7Zm9yKGI9MDtiPHQubGVuZ3RoOysrYilpZihjWzBdPT10W2JdKXJldHVybiEwO3JldHVybiExfWlmKGMuaXNFdmVuKCkpcmV0dXJuITE7Zm9yKGI9MTtiPHQubGVuZ3RoOyl7Zm9yKHZhciBlPXRbYl0sZD1iKzE7ZDx0Lmxlbmd0aCYmZTxWOyllKj10W2QrK107Zm9yKGU9Yy5tb2RJbnQoZSk7YjxkOylpZigwPT1lJVxudFtiKytdKXJldHVybiExfXJldHVybiBjLm1pbGxlclJhYmluKGEpfTtrLnByb3RvdHlwZS5zcXVhcmU9ZnVuY3Rpb24oKXt2YXIgYT1xKCk7dGhpcy5zcXVhcmVUbyhhKTtyZXR1cm4gYX07dmFyIG09azttLnByb3RvdHlwZS5Jc05lZ2F0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuLTE9PXRoaXMuY29tcGFyZVRvKG0uWkVSTyk/ITA6ITF9O20ub3BfRXF1YWxpdHk9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gMD09YS5jb21wYXJlVG8oYik/ITA6ITF9O20ub3BfSW5lcXVhbGl0eT1mdW5jdGlvbihhLGIpe3JldHVybiAwIT1hLmNvbXBhcmVUbyhiKT8hMDohMX07bS5vcF9HcmVhdGVyVGhhbj1mdW5jdGlvbihhLGIpe3JldHVybiAwPGEuY29tcGFyZVRvKGIpPyEwOiExfTttLm9wX0xlc3NUaGFuPWZ1bmN0aW9uKGEsYil7cmV0dXJuIDA+YS5jb21wYXJlVG8oYik/ITA6ITF9O20ub3BfQWRkaXRpb249ZnVuY3Rpb24oYSxiKXtyZXR1cm4obmV3IG0oYSkpLmFkZChuZXcgbShiKSl9O20ub3BfU3VidHJhY3Rpb249XG5mdW5jdGlvbihhLGIpe3JldHVybihuZXcgbShhKSkuc3VidHJhY3QobmV3IG0oYikpfTttLkludDEyOE11bD1mdW5jdGlvbihhLGIpe3JldHVybihuZXcgbShhKSkubXVsdGlwbHkobmV3IG0oYikpfTttLm9wX0RpdmlzaW9uPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuZGl2aWRlKGIpfTttLnByb3RvdHlwZS5Ub0RvdWJsZT1mdW5jdGlvbigpe3JldHVybiBwYXJzZUZsb2F0KHRoaXMudG9TdHJpbmcoKSl9O2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBLKXZhciBLPWZ1bmN0aW9uKGEsYil7dmFyIGM7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKWZvcihjIGluIGIucHJvdG90eXBlKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgYS5wcm90b3R5cGVbY118fGEucHJvdG90eXBlW2NdPT1PYmplY3QucHJvdG90eXBlW2NdKWEucHJvdG90eXBlW2NdPWIucHJvdG90eXBlW2NdfWVsc2UgZm9yKHZhciBlPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGIucHJvdG90eXBlKSxcbmQ9MDtkPGUubGVuZ3RoO2QrKylcInVuZGVmaW5lZFwiPT10eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhLnByb3RvdHlwZSxlW2RdKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGEucHJvdG90eXBlLGVbZF0sT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiLnByb3RvdHlwZSxlW2RdKSk7Zm9yKGMgaW4gYilcInVuZGVmaW5lZFwiPT10eXBlb2YgYVtjXSYmKGFbY109YltjXSk7YS4kYmFzZUN0b3I9Yn07ZC5QYXRoPWZ1bmN0aW9uKCl7cmV0dXJuW119O2QuUGF0aHM9ZnVuY3Rpb24oKXtyZXR1cm5bXX07ZC5Eb3VibGVQb2ludD1mdW5jdGlvbigpe3ZhciBhPWFyZ3VtZW50czt0aGlzLlk9dGhpcy5YPTA7MT09YS5sZW5ndGg/KHRoaXMuWD1hWzBdLlgsdGhpcy5ZPWFbMF0uWSk6Mj09YS5sZW5ndGgmJih0aGlzLlg9YVswXSx0aGlzLlk9YVsxXSl9O2QuRG91YmxlUG9pbnQwPWZ1bmN0aW9uKCl7dGhpcy5ZPXRoaXMuWD0wfTtkLkRvdWJsZVBvaW50MT1mdW5jdGlvbihhKXt0aGlzLlg9XG5hLlg7dGhpcy5ZPWEuWX07ZC5Eb3VibGVQb2ludDI9ZnVuY3Rpb24oYSxiKXt0aGlzLlg9YTt0aGlzLlk9Yn07ZC5Qb2x5Tm9kZT1mdW5jdGlvbigpe3RoaXMubV9QYXJlbnQ9bnVsbDt0aGlzLm1fcG9seWdvbj1uZXcgZC5QYXRoO3RoaXMubV9lbmR0eXBlPXRoaXMubV9qb2ludHlwZT10aGlzLm1fSW5kZXg9MDt0aGlzLm1fQ2hpbGRzPVtdO3RoaXMuSXNPcGVuPSExfTtkLlBvbHlOb2RlLnByb3RvdHlwZS5Jc0hvbGVOb2RlPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPSEwLGI9dGhpcy5tX1BhcmVudDtudWxsIT09YjspYT0hYSxiPWIubV9QYXJlbnQ7cmV0dXJuIGF9O2QuUG9seU5vZGUucHJvdG90eXBlLkNoaWxkQ291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tX0NoaWxkcy5sZW5ndGh9O2QuUG9seU5vZGUucHJvdG90eXBlLkNvbnRvdXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tX3BvbHlnb259O2QuUG9seU5vZGUucHJvdG90eXBlLkFkZENoaWxkPWZ1bmN0aW9uKGEpe3ZhciBiPVxudGhpcy5tX0NoaWxkcy5sZW5ndGg7dGhpcy5tX0NoaWxkcy5wdXNoKGEpO2EubV9QYXJlbnQ9dGhpczthLm1fSW5kZXg9Yn07ZC5Qb2x5Tm9kZS5wcm90b3R5cGUuR2V0TmV4dD1mdW5jdGlvbigpe3JldHVybiAwPHRoaXMubV9DaGlsZHMubGVuZ3RoP3RoaXMubV9DaGlsZHNbMF06dGhpcy5HZXROZXh0U2libGluZ1VwKCl9O2QuUG9seU5vZGUucHJvdG90eXBlLkdldE5leHRTaWJsaW5nVXA9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMubV9QYXJlbnQ/bnVsbDp0aGlzLm1fSW5kZXg9PXRoaXMubV9QYXJlbnQubV9DaGlsZHMubGVuZ3RoLTE/dGhpcy5tX1BhcmVudC5HZXROZXh0U2libGluZ1VwKCk6dGhpcy5tX1BhcmVudC5tX0NoaWxkc1t0aGlzLm1fSW5kZXgrMV19O2QuUG9seU5vZGUucHJvdG90eXBlLkNoaWxkcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1fQ2hpbGRzfTtkLlBvbHlOb2RlLnByb3RvdHlwZS5QYXJlbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tX1BhcmVudH07XG5kLlBvbHlOb2RlLnByb3RvdHlwZS5Jc0hvbGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5Jc0hvbGVOb2RlKCl9O2QuUG9seVRyZWU9ZnVuY3Rpb24oKXt0aGlzLm1fQWxsUG9seXM9W107ZC5Qb2x5Tm9kZS5jYWxsKHRoaXMpfTtkLlBvbHlUcmVlLnByb3RvdHlwZS5DbGVhcj1mdW5jdGlvbigpe2Zvcih2YXIgYT0wLGI9dGhpcy5tX0FsbFBvbHlzLmxlbmd0aDthPGI7YSsrKXRoaXMubV9BbGxQb2x5c1thXT1udWxsO3RoaXMubV9BbGxQb2x5cy5sZW5ndGg9MDt0aGlzLm1fQ2hpbGRzLmxlbmd0aD0wfTtkLlBvbHlUcmVlLnByb3RvdHlwZS5HZXRGaXJzdD1mdW5jdGlvbigpe3JldHVybiAwPHRoaXMubV9DaGlsZHMubGVuZ3RoP3RoaXMubV9DaGlsZHNbMF06bnVsbH07ZC5Qb2x5VHJlZS5wcm90b3R5cGUuVG90YWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tX0FsbFBvbHlzLmxlbmd0aH07SyhkLlBvbHlUcmVlLGQuUG9seU5vZGUpO2QuTWF0aF9BYnNfSW50NjQ9ZC5NYXRoX0Fic19JbnQzMj1cbmQuTWF0aF9BYnNfRG91YmxlPWZ1bmN0aW9uKGEpe3JldHVybiBNYXRoLmFicyhhKX07ZC5NYXRoX01heF9JbnQzMl9JbnQzMj1mdW5jdGlvbihhLGIpe3JldHVybiBNYXRoLm1heChhLGIpfTtkLkNhc3RfSW50MzI9cHx8R3x8Sj9mdW5jdGlvbihhKXtyZXR1cm4gYXwwfTpmdW5jdGlvbihhKXtyZXR1cm5+fmF9O2QuQ2FzdF9JbnQ2ND1FP2Z1bmN0aW9uKGEpe3JldHVybi0yMTQ3NDgzNjQ4PmF8fDIxNDc0ODM2NDc8YT8wPmE/TWF0aC5jZWlsKGEpOk1hdGguZmxvb3IoYSk6fn5hfTpGJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBOdW1iZXIudG9JbnRlZ2VyP2Z1bmN0aW9uKGEpe3JldHVybiBOdW1iZXIudG9JbnRlZ2VyKGEpfTpQfHxIP2Z1bmN0aW9uKGEpe3JldHVybiBwYXJzZUludChhLDEwKX06cD9mdW5jdGlvbihhKXtyZXR1cm4tMjE0NzQ4MzY0OD5hfHwyMTQ3NDgzNjQ3PGE/MD5hP01hdGguY2VpbChhKTpNYXRoLmZsb29yKGEpOmF8MH06ZnVuY3Rpb24oYSl7cmV0dXJuIDA+YT9NYXRoLmNlaWwoYSk6XG5NYXRoLmZsb29yKGEpfTtkLkNsZWFyPWZ1bmN0aW9uKGEpe2EubGVuZ3RoPTB9O2QuUEk9My4xNDE1OTI2NTM1ODk3OTM7ZC5QSTI9Ni4yODMxODUzMDcxNzk1ODY7ZC5JbnRQb2ludD1mdW5jdGlvbigpe3ZhciBhO2E9YXJndW1lbnRzO3ZhciBiPWEubGVuZ3RoO3RoaXMuWT10aGlzLlg9MDsyPT1iPyh0aGlzLlg9YVswXSx0aGlzLlk9YVsxXSk6MT09Yj9hWzBdaW5zdGFuY2VvZiBkLkRvdWJsZVBvaW50PyhhPWFbMF0sdGhpcy5YPWQuQ2xpcHBlci5Sb3VuZChhLlgpLHRoaXMuWT1kLkNsaXBwZXIuUm91bmQoYS5ZKSk6KGE9YVswXSx0aGlzLlg9YS5YLHRoaXMuWT1hLlkpOnRoaXMuWT10aGlzLlg9MH07ZC5JbnRQb2ludC5vcF9FcXVhbGl0eT1mdW5jdGlvbihhLGIpe3JldHVybiBhLlg9PWIuWCYmYS5ZPT1iLll9O2QuSW50UG9pbnQub3BfSW5lcXVhbGl0eT1mdW5jdGlvbihhLGIpe3JldHVybiBhLlghPWIuWHx8YS5ZIT1iLll9O2QuSW50UG9pbnQwPWZ1bmN0aW9uKCl7dGhpcy5ZPVxudGhpcy5YPTB9O2QuSW50UG9pbnQxPWZ1bmN0aW9uKGEpe3RoaXMuWD1hLlg7dGhpcy5ZPWEuWX07ZC5JbnRQb2ludDFkcD1mdW5jdGlvbihhKXt0aGlzLlg9ZC5DbGlwcGVyLlJvdW5kKGEuWCk7dGhpcy5ZPWQuQ2xpcHBlci5Sb3VuZChhLlkpfTtkLkludFBvaW50Mj1mdW5jdGlvbihhLGIpe3RoaXMuWD1hO3RoaXMuWT1ifTtkLkludFJlY3Q9ZnVuY3Rpb24oKXt2YXIgYT1hcmd1bWVudHMsYj1hLmxlbmd0aDs0PT1iPyh0aGlzLmxlZnQ9YVswXSx0aGlzLnRvcD1hWzFdLHRoaXMucmlnaHQ9YVsyXSx0aGlzLmJvdHRvbT1hWzNdKToxPT1iPyh0aGlzLmxlZnQ9aXIubGVmdCx0aGlzLnRvcD1pci50b3AsdGhpcy5yaWdodD1pci5yaWdodCx0aGlzLmJvdHRvbT1pci5ib3R0b20pOnRoaXMuYm90dG9tPXRoaXMucmlnaHQ9dGhpcy50b3A9dGhpcy5sZWZ0PTB9O2QuSW50UmVjdDA9ZnVuY3Rpb24oKXt0aGlzLmJvdHRvbT10aGlzLnJpZ2h0PXRoaXMudG9wPXRoaXMubGVmdD0wfTtkLkludFJlY3QxPVxuZnVuY3Rpb24oYSl7dGhpcy5sZWZ0PWEubGVmdDt0aGlzLnRvcD1hLnRvcDt0aGlzLnJpZ2h0PWEucmlnaHQ7dGhpcy5ib3R0b209YS5ib3R0b219O2QuSW50UmVjdDQ9ZnVuY3Rpb24oYSxiLGMsZSl7dGhpcy5sZWZ0PWE7dGhpcy50b3A9Yjt0aGlzLnJpZ2h0PWM7dGhpcy5ib3R0b209ZX07ZC5DbGlwVHlwZT17Y3RJbnRlcnNlY3Rpb246MCxjdFVuaW9uOjEsY3REaWZmZXJlbmNlOjIsY3RYb3I6M307ZC5Qb2x5VHlwZT17cHRTdWJqZWN0OjAscHRDbGlwOjF9O2QuUG9seUZpbGxUeXBlPXtwZnRFdmVuT2RkOjAscGZ0Tm9uWmVybzoxLHBmdFBvc2l0aXZlOjIscGZ0TmVnYXRpdmU6M307ZC5Kb2luVHlwZT17anRTcXVhcmU6MCxqdFJvdW5kOjEsanRNaXRlcjoyfTtkLkVuZFR5cGU9e2V0T3BlblNxdWFyZTowLGV0T3BlblJvdW5kOjEsZXRPcGVuQnV0dDoyLGV0Q2xvc2VkTGluZTozLGV0Q2xvc2VkUG9seWdvbjo0fTtkLkVkZ2VTaWRlPXtlc0xlZnQ6MCxlc1JpZ2h0OjF9O2QuRGlyZWN0aW9uPVxue2RSaWdodFRvTGVmdDowLGRMZWZ0VG9SaWdodDoxfTtkLlRFZGdlPWZ1bmN0aW9uKCl7dGhpcy5Cb3Q9bmV3IGQuSW50UG9pbnQ7dGhpcy5DdXJyPW5ldyBkLkludFBvaW50O3RoaXMuVG9wPW5ldyBkLkludFBvaW50O3RoaXMuRGVsdGE9bmV3IGQuSW50UG9pbnQ7dGhpcy5EeD0wO3RoaXMuUG9seVR5cD1kLlBvbHlUeXBlLnB0U3ViamVjdDt0aGlzLlNpZGU9ZC5FZGdlU2lkZS5lc0xlZnQ7dGhpcy5PdXRJZHg9dGhpcy5XaW5kQ250Mj10aGlzLldpbmRDbnQ9dGhpcy5XaW5kRGVsdGE9MDt0aGlzLlByZXZJblNFTD10aGlzLk5leHRJblNFTD10aGlzLlByZXZJbkFFTD10aGlzLk5leHRJbkFFTD10aGlzLk5leHRJbkxNTD10aGlzLlByZXY9dGhpcy5OZXh0PW51bGx9O2QuSW50ZXJzZWN0Tm9kZT1mdW5jdGlvbigpe3RoaXMuRWRnZTI9dGhpcy5FZGdlMT1udWxsO3RoaXMuUHQ9bmV3IGQuSW50UG9pbnR9O2QuTXlJbnRlcnNlY3ROb2RlU29ydD1mdW5jdGlvbigpe307ZC5NeUludGVyc2VjdE5vZGVTb3J0LkNvbXBhcmU9XG5mdW5jdGlvbihhLGIpe3JldHVybiBiLlB0LlktYS5QdC5ZfTtkLkxvY2FsTWluaW1hPWZ1bmN0aW9uKCl7dGhpcy5ZPTA7dGhpcy5OZXh0PXRoaXMuUmlnaHRCb3VuZD10aGlzLkxlZnRCb3VuZD1udWxsfTtkLlNjYW5iZWFtPWZ1bmN0aW9uKCl7dGhpcy5ZPTA7dGhpcy5OZXh0PW51bGx9O2QuT3V0UmVjPWZ1bmN0aW9uKCl7dGhpcy5JZHg9MDt0aGlzLklzT3Blbj10aGlzLklzSG9sZT0hMTt0aGlzLlBvbHlOb2RlPXRoaXMuQm90dG9tUHQ9dGhpcy5QdHM9dGhpcy5GaXJzdExlZnQ9bnVsbH07ZC5PdXRQdD1mdW5jdGlvbigpe3RoaXMuSWR4PTA7dGhpcy5QdD1uZXcgZC5JbnRQb2ludDt0aGlzLlByZXY9dGhpcy5OZXh0PW51bGx9O2QuSm9pbj1mdW5jdGlvbigpe3RoaXMuT3V0UHQyPXRoaXMuT3V0UHQxPW51bGw7dGhpcy5PZmZQdD1uZXcgZC5JbnRQb2ludH07ZC5DbGlwcGVyQmFzZT1mdW5jdGlvbigpe3RoaXMubV9DdXJyZW50TE09dGhpcy5tX01pbmltYUxpc3Q9bnVsbDt0aGlzLm1fZWRnZXM9XG5bXTt0aGlzLlByZXNlcnZlQ29sbGluZWFyPXRoaXMubV9IYXNPcGVuUGF0aHM9dGhpcy5tX1VzZUZ1bGxSYW5nZT0hMTt0aGlzLm1fQ3VycmVudExNPXRoaXMubV9NaW5pbWFMaXN0PW51bGw7dGhpcy5tX0hhc09wZW5QYXRocz10aGlzLm1fVXNlRnVsbFJhbmdlPSExfTtkLkNsaXBwZXJCYXNlLmhvcml6b250YWw9LTkwMDcxOTkyNTQ3NDA5OTI7ZC5DbGlwcGVyQmFzZS5Ta2lwPS0yO2QuQ2xpcHBlckJhc2UuVW5hc3NpZ25lZD0tMTtkLkNsaXBwZXJCYXNlLnRvbGVyYW5jZT0xRS0yMDtkLkNsaXBwZXJCYXNlLmxvUmFuZ2U9NDc0NTMxMzI7ZC5DbGlwcGVyQmFzZS5oaVJhbmdlPTB4ZmZmZmZmZmZmZmZmZjtkLkNsaXBwZXJCYXNlLm5lYXJfemVybz1mdW5jdGlvbihhKXtyZXR1cm4gYT4tZC5DbGlwcGVyQmFzZS50b2xlcmFuY2UmJmE8ZC5DbGlwcGVyQmFzZS50b2xlcmFuY2V9O2QuQ2xpcHBlckJhc2UuSXNIb3Jpem9udGFsPWZ1bmN0aW9uKGEpe3JldHVybiAwPT09YS5EZWx0YS5ZfTtcbmQuQ2xpcHBlckJhc2UucHJvdG90eXBlLlBvaW50SXNWZXJ0ZXg9ZnVuY3Rpb24oYSxiKXt2YXIgYz1iO2Rve2lmKGQuSW50UG9pbnQub3BfRXF1YWxpdHkoYy5QdCxhKSlyZXR1cm4hMDtjPWMuTmV4dH13aGlsZShjIT1iKTtyZXR1cm4hMX07ZC5DbGlwcGVyQmFzZS5wcm90b3R5cGUuUG9pbnRPbkxpbmVTZWdtZW50PWZ1bmN0aW9uKGEsYixjLGUpe3JldHVybiBlP2EuWD09Yi5YJiZhLlk9PWIuWXx8YS5YPT1jLlgmJmEuWT09Yy5ZfHxhLlg+Yi5YPT1hLlg8Yy5YJiZhLlk+Yi5ZPT1hLlk8Yy5ZJiZtLm9wX0VxdWFsaXR5KG0uSW50MTI4TXVsKGEuWC1iLlgsYy5ZLWIuWSksbS5JbnQxMjhNdWwoYy5YLWIuWCxhLlktYi5ZKSk6YS5YPT1iLlgmJmEuWT09Yi5ZfHxhLlg9PWMuWCYmYS5ZPT1jLll8fGEuWD5iLlg9PWEuWDxjLlgmJmEuWT5iLlk9PWEuWTxjLlkmJihhLlgtYi5YKSooYy5ZLWIuWSk9PShjLlgtYi5YKSooYS5ZLWIuWSl9O2QuQ2xpcHBlckJhc2UucHJvdG90eXBlLlBvaW50T25Qb2x5Z29uPVxuZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZT1iOzspe2lmKHRoaXMuUG9pbnRPbkxpbmVTZWdtZW50KGEsZS5QdCxlLk5leHQuUHQsYykpcmV0dXJuITA7ZT1lLk5leHQ7aWYoZT09YilicmVha31yZXR1cm4hMX07ZC5DbGlwcGVyQmFzZS5wcm90b3R5cGUuU2xvcGVzRXF1YWw9ZC5DbGlwcGVyQmFzZS5TbG9wZXNFcXVhbD1mdW5jdGlvbigpe3ZhciBhPWFyZ3VtZW50cyxiPWEubGVuZ3RoLGMsZSxmO2lmKDM9PWIpcmV0dXJuIGI9YVswXSxjPWFbMV0sKGE9YVsyXSk/bS5vcF9FcXVhbGl0eShtLkludDEyOE11bChiLkRlbHRhLlksYy5EZWx0YS5YKSxtLkludDEyOE11bChiLkRlbHRhLlgsYy5EZWx0YS5ZKSk6ZC5DYXN0X0ludDY0KGIuRGVsdGEuWSpjLkRlbHRhLlgpPT1kLkNhc3RfSW50NjQoYi5EZWx0YS5YKmMuRGVsdGEuWSk7aWYoND09YilyZXR1cm4gYj1hWzBdLGM9YVsxXSxlPWFbMl0sKGE9YVszXSk/bS5vcF9FcXVhbGl0eShtLkludDEyOE11bChiLlktYy5ZLGMuWC1lLlgpLFxubS5JbnQxMjhNdWwoYi5YLWMuWCxjLlktZS5ZKSk6MD09PWQuQ2FzdF9JbnQ2NCgoYi5ZLWMuWSkqKGMuWC1lLlgpKS1kLkNhc3RfSW50NjQoKGIuWC1jLlgpKihjLlktZS5ZKSk7Yj1hWzBdO2M9YVsxXTtlPWFbMl07Zj1hWzNdO3JldHVybihhPWFbNF0pP20ub3BfRXF1YWxpdHkobS5JbnQxMjhNdWwoYi5ZLWMuWSxlLlgtZi5YKSxtLkludDEyOE11bChiLlgtYy5YLGUuWS1mLlkpKTowPT09ZC5DYXN0X0ludDY0KChiLlktYy5ZKSooZS5YLWYuWCkpLWQuQ2FzdF9JbnQ2NCgoYi5YLWMuWCkqKGUuWS1mLlkpKX07ZC5DbGlwcGVyQmFzZS5TbG9wZXNFcXVhbDM9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBjP20ub3BfRXF1YWxpdHkobS5JbnQxMjhNdWwoYS5EZWx0YS5ZLGIuRGVsdGEuWCksbS5JbnQxMjhNdWwoYS5EZWx0YS5YLGIuRGVsdGEuWSkpOmQuQ2FzdF9JbnQ2NChhLkRlbHRhLlkqYi5EZWx0YS5YKT09ZC5DYXN0X0ludDY0KGEuRGVsdGEuWCpiLkRlbHRhLlkpfTtkLkNsaXBwZXJCYXNlLlNsb3Blc0VxdWFsND1cbmZ1bmN0aW9uKGEsYixjLGUpe3JldHVybiBlP20ub3BfRXF1YWxpdHkobS5JbnQxMjhNdWwoYS5ZLWIuWSxiLlgtYy5YKSxtLkludDEyOE11bChhLlgtYi5YLGIuWS1jLlkpKTowPT09ZC5DYXN0X0ludDY0KChhLlktYi5ZKSooYi5YLWMuWCkpLWQuQ2FzdF9JbnQ2NCgoYS5YLWIuWCkqKGIuWS1jLlkpKX07ZC5DbGlwcGVyQmFzZS5TbG9wZXNFcXVhbDU9ZnVuY3Rpb24oYSxiLGMsZSxmKXtyZXR1cm4gZj9tLm9wX0VxdWFsaXR5KG0uSW50MTI4TXVsKGEuWS1iLlksYy5YLWUuWCksbS5JbnQxMjhNdWwoYS5YLWIuWCxjLlktZS5ZKSk6MD09PWQuQ2FzdF9JbnQ2NCgoYS5ZLWIuWSkqKGMuWC1lLlgpKS1kLkNhc3RfSW50NjQoKGEuWC1iLlgpKihjLlktZS5ZKSl9O2QuQ2xpcHBlckJhc2UucHJvdG90eXBlLkNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5EaXNwb3NlTG9jYWxNaW5pbWFMaXN0KCk7Zm9yKHZhciBhPTAsYj10aGlzLm1fZWRnZXMubGVuZ3RoO2E8YjsrK2Epe2Zvcih2YXIgYz0wLFxuZT10aGlzLm1fZWRnZXNbYV0ubGVuZ3RoO2M8ZTsrK2MpdGhpcy5tX2VkZ2VzW2FdW2NdPW51bGw7ZC5DbGVhcih0aGlzLm1fZWRnZXNbYV0pfWQuQ2xlYXIodGhpcy5tX2VkZ2VzKTt0aGlzLm1fSGFzT3BlblBhdGhzPXRoaXMubV9Vc2VGdWxsUmFuZ2U9ITF9O2QuQ2xpcHBlckJhc2UucHJvdG90eXBlLkRpc3Bvc2VMb2NhbE1pbmltYUxpc3Q9ZnVuY3Rpb24oKXtmb3IoO251bGwhPT10aGlzLm1fTWluaW1hTGlzdDspe3ZhciBhPXRoaXMubV9NaW5pbWFMaXN0Lk5leHQ7dGhpcy5tX01pbmltYUxpc3Q9bnVsbDt0aGlzLm1fTWluaW1hTGlzdD1hfXRoaXMubV9DdXJyZW50TE09bnVsbH07ZC5DbGlwcGVyQmFzZS5wcm90b3R5cGUuUmFuZ2VUZXN0PWZ1bmN0aW9uKGEsYil7aWYoYi5WYWx1ZSkoYS5YPmQuQ2xpcHBlckJhc2UuaGlSYW5nZXx8YS5ZPmQuQ2xpcHBlckJhc2UuaGlSYW5nZXx8LWEuWD5kLkNsaXBwZXJCYXNlLmhpUmFuZ2V8fC1hLlk+ZC5DbGlwcGVyQmFzZS5oaVJhbmdlKSYmXG5kLkVycm9yKFwiQ29vcmRpbmF0ZSBvdXRzaWRlIGFsbG93ZWQgcmFuZ2UgaW4gUmFuZ2VUZXN0KCkuXCIpO2Vsc2UgaWYoYS5YPmQuQ2xpcHBlckJhc2UubG9SYW5nZXx8YS5ZPmQuQ2xpcHBlckJhc2UubG9SYW5nZXx8LWEuWD5kLkNsaXBwZXJCYXNlLmxvUmFuZ2V8fC1hLlk+ZC5DbGlwcGVyQmFzZS5sb1JhbmdlKWIuVmFsdWU9ITAsdGhpcy5SYW5nZVRlc3QoYSxiKX07ZC5DbGlwcGVyQmFzZS5wcm90b3R5cGUuSW5pdEVkZ2U9ZnVuY3Rpb24oYSxiLGMsZSl7YS5OZXh0PWI7YS5QcmV2PWM7YS5DdXJyLlg9ZS5YO2EuQ3Vyci5ZPWUuWTthLk91dElkeD0tMX07ZC5DbGlwcGVyQmFzZS5wcm90b3R5cGUuSW5pdEVkZ2UyPWZ1bmN0aW9uKGEsYil7YS5DdXJyLlk+PWEuTmV4dC5DdXJyLlk/KGEuQm90Llg9YS5DdXJyLlgsYS5Cb3QuWT1hLkN1cnIuWSxhLlRvcC5YPWEuTmV4dC5DdXJyLlgsYS5Ub3AuWT1hLk5leHQuQ3Vyci5ZKTooYS5Ub3AuWD1hLkN1cnIuWCxhLlRvcC5ZPWEuQ3Vyci5ZLFxuYS5Cb3QuWD1hLk5leHQuQ3Vyci5YLGEuQm90Llk9YS5OZXh0LkN1cnIuWSk7dGhpcy5TZXREeChhKTthLlBvbHlUeXA9Yn07ZC5DbGlwcGVyQmFzZS5wcm90b3R5cGUuRmluZE5leHRMb2NNaW49ZnVuY3Rpb24oYSl7Zm9yKHZhciBiOzspe2Zvcig7ZC5JbnRQb2ludC5vcF9JbmVxdWFsaXR5KGEuQm90LGEuUHJldi5Cb3QpfHxkLkludFBvaW50Lm9wX0VxdWFsaXR5KGEuQ3VycixhLlRvcCk7KWE9YS5OZXh0O2lmKGEuRHghPWQuQ2xpcHBlckJhc2UuaG9yaXpvbnRhbCYmYS5QcmV2LkR4IT1kLkNsaXBwZXJCYXNlLmhvcml6b250YWwpYnJlYWs7Zm9yKDthLlByZXYuRHg9PWQuQ2xpcHBlckJhc2UuaG9yaXpvbnRhbDspYT1hLlByZXY7Zm9yKGI9YTthLkR4PT1kLkNsaXBwZXJCYXNlLmhvcml6b250YWw7KWE9YS5OZXh0O2lmKGEuVG9wLlkhPWEuUHJldi5Cb3QuWSl7Yi5QcmV2LkJvdC5YPGEuQm90LlgmJihhPWIpO2JyZWFrfX1yZXR1cm4gYX07ZC5DbGlwcGVyQmFzZS5wcm90b3R5cGUuUHJvY2Vzc0JvdW5kPVxuZnVuY3Rpb24oYSxiKXt2YXIgYz1hLGU9YSxmO2EuRHg9PWQuQ2xpcHBlckJhc2UuaG9yaXpvbnRhbCYmKGY9Yj9hLlByZXYuQm90Llg6YS5OZXh0LkJvdC5YLGEuQm90LlghPWYmJnRoaXMuUmV2ZXJzZUhvcml6b250YWwoYSkpO2lmKGUuT3V0SWR4IT1kLkNsaXBwZXJCYXNlLlNraXApaWYoYil7Zm9yKDtlLlRvcC5ZPT1lLk5leHQuQm90LlkmJmUuTmV4dC5PdXRJZHghPWQuQ2xpcHBlckJhc2UuU2tpcDspZT1lLk5leHQ7aWYoZS5EeD09ZC5DbGlwcGVyQmFzZS5ob3Jpem9udGFsJiZlLk5leHQuT3V0SWR4IT1kLkNsaXBwZXJCYXNlLlNraXApe2ZvcihmPWU7Zi5QcmV2LkR4PT1kLkNsaXBwZXJCYXNlLmhvcml6b250YWw7KWY9Zi5QcmV2O2YuUHJldi5Ub3AuWD09ZS5OZXh0LlRvcC5YP2J8fChlPWYuUHJldik6Zi5QcmV2LlRvcC5YPmUuTmV4dC5Ub3AuWCYmKGU9Zi5QcmV2KX1mb3IoO2EhPWU7KWEuTmV4dEluTE1MPWEuTmV4dCxhLkR4PT1kLkNsaXBwZXJCYXNlLmhvcml6b250YWwmJlxuYSE9YyYmYS5Cb3QuWCE9YS5QcmV2LlRvcC5YJiZ0aGlzLlJldmVyc2VIb3Jpem9udGFsKGEpLGE9YS5OZXh0O2EuRHg9PWQuQ2xpcHBlckJhc2UuaG9yaXpvbnRhbCYmYSE9YyYmYS5Cb3QuWCE9YS5QcmV2LlRvcC5YJiZ0aGlzLlJldmVyc2VIb3Jpem9udGFsKGEpO2U9ZS5OZXh0fWVsc2V7Zm9yKDtlLlRvcC5ZPT1lLlByZXYuQm90LlkmJmUuUHJldi5PdXRJZHghPWQuQ2xpcHBlckJhc2UuU2tpcDspZT1lLlByZXY7aWYoZS5EeD09ZC5DbGlwcGVyQmFzZS5ob3Jpem9udGFsJiZlLlByZXYuT3V0SWR4IT1kLkNsaXBwZXJCYXNlLlNraXApe2ZvcihmPWU7Zi5OZXh0LkR4PT1kLkNsaXBwZXJCYXNlLmhvcml6b250YWw7KWY9Zi5OZXh0O2YuTmV4dC5Ub3AuWD09ZS5QcmV2LlRvcC5YP2J8fChlPWYuTmV4dCk6Zi5OZXh0LlRvcC5YPmUuUHJldi5Ub3AuWCYmKGU9Zi5OZXh0KX1mb3IoO2EhPWU7KWEuTmV4dEluTE1MPWEuUHJldixhLkR4PT1kLkNsaXBwZXJCYXNlLmhvcml6b250YWwmJlxuYSE9YyYmYS5Cb3QuWCE9YS5OZXh0LlRvcC5YJiZ0aGlzLlJldmVyc2VIb3Jpem9udGFsKGEpLGE9YS5QcmV2O2EuRHg9PWQuQ2xpcHBlckJhc2UuaG9yaXpvbnRhbCYmYSE9YyYmYS5Cb3QuWCE9YS5OZXh0LlRvcC5YJiZ0aGlzLlJldmVyc2VIb3Jpem9udGFsKGEpO2U9ZS5QcmV2fWlmKGUuT3V0SWR4PT1kLkNsaXBwZXJCYXNlLlNraXApe2E9ZTtpZihiKXtmb3IoO2EuVG9wLlk9PWEuTmV4dC5Cb3QuWTspYT1hLk5leHQ7Zm9yKDthIT1lJiZhLkR4PT1kLkNsaXBwZXJCYXNlLmhvcml6b250YWw7KWE9YS5QcmV2fWVsc2V7Zm9yKDthLlRvcC5ZPT1hLlByZXYuQm90Llk7KWE9YS5QcmV2O2Zvcig7YSE9ZSYmYS5EeD09ZC5DbGlwcGVyQmFzZS5ob3Jpem9udGFsOylhPWEuTmV4dH1hPT1lP2U9Yj9hLk5leHQ6YS5QcmV2OihhPWI/ZS5OZXh0OmUuUHJldixjPW5ldyBkLkxvY2FsTWluaW1hLGMuTmV4dD1udWxsLGMuWT1hLkJvdC5ZLGMuTGVmdEJvdW5kPW51bGwsYy5SaWdodEJvdW5kPVxuYSxjLlJpZ2h0Qm91bmQuV2luZERlbHRhPTAsZT10aGlzLlByb2Nlc3NCb3VuZChjLlJpZ2h0Qm91bmQsYiksdGhpcy5JbnNlcnRMb2NhbE1pbmltYShjKSl9cmV0dXJuIGV9O2QuQ2xpcHBlckJhc2UucHJvdG90eXBlLkFkZFBhdGg9ZnVuY3Rpb24oYSxiLGMpe2N8fGIhPWQuUG9seVR5cGUucHRDbGlwfHxkLkVycm9yKFwiQWRkUGF0aDogT3BlbiBwYXRocyBtdXN0IGJlIHN1YmplY3QuXCIpO3ZhciBlPWEubGVuZ3RoLTE7aWYoYylmb3IoOzA8ZSYmZC5JbnRQb2ludC5vcF9FcXVhbGl0eShhW2VdLGFbMF0pOyktLWU7Zm9yKDswPGUmJmQuSW50UG9pbnQub3BfRXF1YWxpdHkoYVtlXSxhW2UtMV0pOyktLWU7aWYoYyYmMj5lfHwhYyYmMT5lKXJldHVybiExO2Zvcih2YXIgZj1bXSxnPTA7Zzw9ZTtnKyspZi5wdXNoKG5ldyBkLlRFZGdlKTt2YXIgaD0hMDtmWzFdLkN1cnIuWD1hWzFdLlg7ZlsxXS5DdXJyLlk9YVsxXS5ZO3ZhciBsPXtWYWx1ZTp0aGlzLm1fVXNlRnVsbFJhbmdlfTt0aGlzLlJhbmdlVGVzdChhWzBdLFxubCk7dGhpcy5tX1VzZUZ1bGxSYW5nZT1sLlZhbHVlO2wuVmFsdWU9dGhpcy5tX1VzZUZ1bGxSYW5nZTt0aGlzLlJhbmdlVGVzdChhW2VdLGwpO3RoaXMubV9Vc2VGdWxsUmFuZ2U9bC5WYWx1ZTt0aGlzLkluaXRFZGdlKGZbMF0sZlsxXSxmW2VdLGFbMF0pO3RoaXMuSW5pdEVkZ2UoZltlXSxmWzBdLGZbZS0xXSxhW2VdKTtmb3IoZz1lLTE7MTw9ZzstLWcpbC5WYWx1ZT10aGlzLm1fVXNlRnVsbFJhbmdlLHRoaXMuUmFuZ2VUZXN0KGFbZ10sbCksdGhpcy5tX1VzZUZ1bGxSYW5nZT1sLlZhbHVlLHRoaXMuSW5pdEVkZ2UoZltnXSxmW2crMV0sZltnLTFdLGFbZ10pO2ZvcihnPWE9ZT1mWzBdOzspaWYoZC5JbnRQb2ludC5vcF9FcXVhbGl0eShhLkN1cnIsYS5OZXh0LkN1cnIpKXtpZihhPT1hLk5leHQpYnJlYWs7YT09ZSYmKGU9YS5OZXh0KTtnPWE9dGhpcy5SZW1vdmVFZGdlKGEpfWVsc2V7aWYoYS5QcmV2PT1hLk5leHQpYnJlYWs7ZWxzZSBpZihjJiZkLkNsaXBwZXJCYXNlLlNsb3Blc0VxdWFsKGEuUHJldi5DdXJyLFxuYS5DdXJyLGEuTmV4dC5DdXJyLHRoaXMubV9Vc2VGdWxsUmFuZ2UpJiYoIXRoaXMuUHJlc2VydmVDb2xsaW5lYXJ8fCF0aGlzLlB0MklzQmV0d2VlblB0MUFuZFB0MyhhLlByZXYuQ3VycixhLkN1cnIsYS5OZXh0LkN1cnIpKSl7YT09ZSYmKGU9YS5OZXh0KTthPXRoaXMuUmVtb3ZlRWRnZShhKTtnPWE9YS5QcmV2O2NvbnRpbnVlfWE9YS5OZXh0O2lmKGE9PWcpYnJlYWt9aWYoIWMmJmE9PWEuTmV4dHx8YyYmYS5QcmV2PT1hLk5leHQpcmV0dXJuITE7Y3x8KHRoaXMubV9IYXNPcGVuUGF0aHM9ITAsZS5QcmV2Lk91dElkeD1kLkNsaXBwZXJCYXNlLlNraXApO2E9ZTtkbyB0aGlzLkluaXRFZGdlMihhLGIpLGE9YS5OZXh0LGgmJmEuQ3Vyci5ZIT1lLkN1cnIuWSYmKGg9ITEpO3doaWxlKGEhPWUpO2lmKGgpe2lmKGMpcmV0dXJuITE7YS5QcmV2Lk91dElkeD1kLkNsaXBwZXJCYXNlLlNraXA7YS5QcmV2LkJvdC5YPGEuUHJldi5Ub3AuWCYmdGhpcy5SZXZlcnNlSG9yaXpvbnRhbChhLlByZXYpO1xuYj1uZXcgZC5Mb2NhbE1pbmltYTtiLk5leHQ9bnVsbDtiLlk9YS5Cb3QuWTtiLkxlZnRCb3VuZD1udWxsO2IuUmlnaHRCb3VuZD1hO2IuUmlnaHRCb3VuZC5TaWRlPWQuRWRnZVNpZGUuZXNSaWdodDtmb3IoYi5SaWdodEJvdW5kLldpbmREZWx0YT0wO2EuTmV4dC5PdXRJZHghPWQuQ2xpcHBlckJhc2UuU2tpcDspYS5OZXh0SW5MTUw9YS5OZXh0LGEuQm90LlghPWEuUHJldi5Ub3AuWCYmdGhpcy5SZXZlcnNlSG9yaXpvbnRhbChhKSxhPWEuTmV4dDt0aGlzLkluc2VydExvY2FsTWluaW1hKGIpO3RoaXMubV9lZGdlcy5wdXNoKGYpO3JldHVybiEwfXRoaXMubV9lZGdlcy5wdXNoKGYpO2ZvcihoPW51bGw7Oyl7YT10aGlzLkZpbmROZXh0TG9jTWluKGEpO2lmKGE9PWgpYnJlYWs7ZWxzZSBudWxsPT1oJiYoaD1hKTtiPW5ldyBkLkxvY2FsTWluaW1hO2IuTmV4dD1udWxsO2IuWT1hLkJvdC5ZO2EuRHg8YS5QcmV2LkR4PyhiLkxlZnRCb3VuZD1hLlByZXYsYi5SaWdodEJvdW5kPWEsZj0hMSk6XG4oYi5MZWZ0Qm91bmQ9YSxiLlJpZ2h0Qm91bmQ9YS5QcmV2LGY9ITApO2IuTGVmdEJvdW5kLlNpZGU9ZC5FZGdlU2lkZS5lc0xlZnQ7Yi5SaWdodEJvdW5kLlNpZGU9ZC5FZGdlU2lkZS5lc1JpZ2h0O2IuTGVmdEJvdW5kLldpbmREZWx0YT1jP2IuTGVmdEJvdW5kLk5leHQ9PWIuUmlnaHRCb3VuZD8tMToxOjA7Yi5SaWdodEJvdW5kLldpbmREZWx0YT0tYi5MZWZ0Qm91bmQuV2luZERlbHRhO2E9dGhpcy5Qcm9jZXNzQm91bmQoYi5MZWZ0Qm91bmQsZik7ZT10aGlzLlByb2Nlc3NCb3VuZChiLlJpZ2h0Qm91bmQsIWYpO2IuTGVmdEJvdW5kLk91dElkeD09ZC5DbGlwcGVyQmFzZS5Ta2lwP2IuTGVmdEJvdW5kPW51bGw6Yi5SaWdodEJvdW5kLk91dElkeD09ZC5DbGlwcGVyQmFzZS5Ta2lwJiYoYi5SaWdodEJvdW5kPW51bGwpO3RoaXMuSW5zZXJ0TG9jYWxNaW5pbWEoYik7Znx8KGE9ZSl9cmV0dXJuITB9O2QuQ2xpcHBlckJhc2UucHJvdG90eXBlLkFkZFBhdGhzPWZ1bmN0aW9uKGEsYixcbmMpe2Zvcih2YXIgZT0hMSxkPTAsZz1hLmxlbmd0aDtkPGc7KytkKXRoaXMuQWRkUGF0aChhW2RdLGIsYykmJihlPSEwKTtyZXR1cm4gZX07ZC5DbGlwcGVyQmFzZS5wcm90b3R5cGUuUHQySXNCZXR3ZWVuUHQxQW5kUHQzPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gZC5JbnRQb2ludC5vcF9FcXVhbGl0eShhLGMpfHxkLkludFBvaW50Lm9wX0VxdWFsaXR5KGEsYil8fGQuSW50UG9pbnQub3BfRXF1YWxpdHkoYyxiKT8hMTphLlghPWMuWD9iLlg+YS5YPT1iLlg8Yy5YOmIuWT5hLlk9PWIuWTxjLll9O2QuQ2xpcHBlckJhc2UucHJvdG90eXBlLlJlbW92ZUVkZ2U9ZnVuY3Rpb24oYSl7YS5QcmV2Lk5leHQ9YS5OZXh0O2EuTmV4dC5QcmV2PWEuUHJldjt2YXIgYj1hLk5leHQ7YS5QcmV2PW51bGw7cmV0dXJuIGJ9O2QuQ2xpcHBlckJhc2UucHJvdG90eXBlLlNldER4PWZ1bmN0aW9uKGEpe2EuRGVsdGEuWD1hLlRvcC5YLWEuQm90Llg7YS5EZWx0YS5ZPWEuVG9wLlktYS5Cb3QuWTthLkR4PVxuMD09PWEuRGVsdGEuWT9kLkNsaXBwZXJCYXNlLmhvcml6b250YWw6YS5EZWx0YS5YL2EuRGVsdGEuWX07ZC5DbGlwcGVyQmFzZS5wcm90b3R5cGUuSW5zZXJ0TG9jYWxNaW5pbWE9ZnVuY3Rpb24oYSl7aWYobnVsbD09PXRoaXMubV9NaW5pbWFMaXN0KXRoaXMubV9NaW5pbWFMaXN0PWE7ZWxzZSBpZihhLlk+PXRoaXMubV9NaW5pbWFMaXN0LlkpYS5OZXh0PXRoaXMubV9NaW5pbWFMaXN0LHRoaXMubV9NaW5pbWFMaXN0PWE7ZWxzZXtmb3IodmFyIGI9dGhpcy5tX01pbmltYUxpc3Q7bnVsbCE9PWIuTmV4dCYmYS5ZPGIuTmV4dC5ZOyliPWIuTmV4dDthLk5leHQ9Yi5OZXh0O2IuTmV4dD1hfX07ZC5DbGlwcGVyQmFzZS5wcm90b3R5cGUuUG9wTG9jYWxNaW5pbWE9ZnVuY3Rpb24oKXtudWxsIT09dGhpcy5tX0N1cnJlbnRMTSYmKHRoaXMubV9DdXJyZW50TE09dGhpcy5tX0N1cnJlbnRMTS5OZXh0KX07ZC5DbGlwcGVyQmFzZS5wcm90b3R5cGUuUmV2ZXJzZUhvcml6b250YWw9ZnVuY3Rpb24oYSl7dmFyIGI9XG5hLlRvcC5YO2EuVG9wLlg9YS5Cb3QuWDthLkJvdC5YPWJ9O2QuQ2xpcHBlckJhc2UucHJvdG90eXBlLlJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5tX0N1cnJlbnRMTT10aGlzLm1fTWluaW1hTGlzdDtpZihudWxsIT10aGlzLm1fQ3VycmVudExNKWZvcih2YXIgYT10aGlzLm1fTWluaW1hTGlzdDtudWxsIT1hOyl7dmFyIGI9YS5MZWZ0Qm91bmQ7bnVsbCE9YiYmKGIuQ3Vyci5YPWIuQm90LlgsYi5DdXJyLlk9Yi5Cb3QuWSxiLlNpZGU9ZC5FZGdlU2lkZS5lc0xlZnQsYi5PdXRJZHg9ZC5DbGlwcGVyQmFzZS5VbmFzc2lnbmVkKTtiPWEuUmlnaHRCb3VuZDtudWxsIT1iJiYoYi5DdXJyLlg9Yi5Cb3QuWCxiLkN1cnIuWT1iLkJvdC5ZLGIuU2lkZT1kLkVkZ2VTaWRlLmVzUmlnaHQsYi5PdXRJZHg9ZC5DbGlwcGVyQmFzZS5VbmFzc2lnbmVkKTthPWEuTmV4dH19O2QuQ2xpcHBlcj1mdW5jdGlvbihhKXtcInVuZGVmaW5lZFwiPT10eXBlb2YgYSYmKGE9MCk7dGhpcy5tX1BvbHlPdXRzPW51bGw7dGhpcy5tX0NsaXBUeXBlPVxuZC5DbGlwVHlwZS5jdEludGVyc2VjdGlvbjt0aGlzLm1fSW50ZXJzZWN0Tm9kZUNvbXBhcmVyPXRoaXMubV9JbnRlcnNlY3RMaXN0PXRoaXMubV9Tb3J0ZWRFZGdlcz10aGlzLm1fQWN0aXZlRWRnZXM9dGhpcy5tX1NjYW5iZWFtPW51bGw7dGhpcy5tX0V4ZWN1dGVMb2NrZWQ9ITE7dGhpcy5tX1N1YmpGaWxsVHlwZT10aGlzLm1fQ2xpcEZpbGxUeXBlPWQuUG9seUZpbGxUeXBlLnBmdEV2ZW5PZGQ7dGhpcy5tX0dob3N0Sm9pbnM9dGhpcy5tX0pvaW5zPW51bGw7dGhpcy5TdHJpY3RseVNpbXBsZT10aGlzLlJldmVyc2VTb2x1dGlvbj10aGlzLm1fVXNpbmdQb2x5VHJlZT0hMTtkLkNsaXBwZXJCYXNlLmNhbGwodGhpcyk7dGhpcy5tX1NvcnRlZEVkZ2VzPXRoaXMubV9BY3RpdmVFZGdlcz10aGlzLm1fU2NhbmJlYW09bnVsbDt0aGlzLm1fSW50ZXJzZWN0TGlzdD1bXTt0aGlzLm1fSW50ZXJzZWN0Tm9kZUNvbXBhcmVyPWQuTXlJbnRlcnNlY3ROb2RlU29ydC5Db21wYXJlO3RoaXMubV9Vc2luZ1BvbHlUcmVlPVxudGhpcy5tX0V4ZWN1dGVMb2NrZWQ9ITE7dGhpcy5tX1BvbHlPdXRzPVtdO3RoaXMubV9Kb2lucz1bXTt0aGlzLm1fR2hvc3RKb2lucz1bXTt0aGlzLlJldmVyc2VTb2x1dGlvbj0wIT09KDEmYSk7dGhpcy5TdHJpY3RseVNpbXBsZT0wIT09KDImYSk7dGhpcy5QcmVzZXJ2ZUNvbGxpbmVhcj0wIT09KDQmYSl9O2QuQ2xpcHBlci5pb1JldmVyc2VTb2x1dGlvbj0xO2QuQ2xpcHBlci5pb1N0cmljdGx5U2ltcGxlPTI7ZC5DbGlwcGVyLmlvUHJlc2VydmVDb2xsaW5lYXI9NDtkLkNsaXBwZXIucHJvdG90eXBlLkNsZWFyPWZ1bmN0aW9uKCl7MCE9PXRoaXMubV9lZGdlcy5sZW5ndGgmJih0aGlzLkRpc3Bvc2VBbGxQb2x5UHRzKCksZC5DbGlwcGVyQmFzZS5wcm90b3R5cGUuQ2xlYXIuY2FsbCh0aGlzKSl9O2QuQ2xpcHBlci5wcm90b3R5cGUuRGlzcG9zZVNjYW5iZWFtTGlzdD1mdW5jdGlvbigpe2Zvcig7bnVsbCE9PXRoaXMubV9TY2FuYmVhbTspe3ZhciBhPXRoaXMubV9TY2FuYmVhbS5OZXh0O1xudGhpcy5tX1NjYW5iZWFtPW51bGw7dGhpcy5tX1NjYW5iZWFtPWF9fTtkLkNsaXBwZXIucHJvdG90eXBlLlJlc2V0PWZ1bmN0aW9uKCl7ZC5DbGlwcGVyQmFzZS5wcm90b3R5cGUuUmVzZXQuY2FsbCh0aGlzKTt0aGlzLm1fU29ydGVkRWRnZXM9dGhpcy5tX0FjdGl2ZUVkZ2VzPXRoaXMubV9TY2FuYmVhbT1udWxsO2Zvcih2YXIgYT10aGlzLm1fTWluaW1hTGlzdDtudWxsIT09YTspdGhpcy5JbnNlcnRTY2FuYmVhbShhLlkpLGE9YS5OZXh0fTtkLkNsaXBwZXIucHJvdG90eXBlLkluc2VydFNjYW5iZWFtPWZ1bmN0aW9uKGEpe2lmKG51bGw9PT10aGlzLm1fU2NhbmJlYW0pdGhpcy5tX1NjYW5iZWFtPW5ldyBkLlNjYW5iZWFtLHRoaXMubV9TY2FuYmVhbS5OZXh0PW51bGwsdGhpcy5tX1NjYW5iZWFtLlk9YTtlbHNlIGlmKGE+dGhpcy5tX1NjYW5iZWFtLlkpe3ZhciBiPW5ldyBkLlNjYW5iZWFtO2IuWT1hO2IuTmV4dD10aGlzLm1fU2NhbmJlYW07dGhpcy5tX1NjYW5iZWFtPWJ9ZWxzZXtmb3IodmFyIGM9XG50aGlzLm1fU2NhbmJlYW07bnVsbCE9PWMuTmV4dCYmYTw9Yy5OZXh0Llk7KWM9Yy5OZXh0O2EhPWMuWSYmKGI9bmV3IGQuU2NhbmJlYW0sYi5ZPWEsYi5OZXh0PWMuTmV4dCxjLk5leHQ9Yil9fTtkLkNsaXBwZXIucHJvdG90eXBlLkV4ZWN1dGU9ZnVuY3Rpb24oKXt2YXIgYT1hcmd1bWVudHMsYj1hLmxlbmd0aCxjPWFbMV1pbnN0YW5jZW9mIGQuUG9seVRyZWU7aWYoNCE9Ynx8Yyl7aWYoND09YiYmYyl7dmFyIGI9YVswXSxlPWFbMV0sYz1hWzJdLGE9YVszXTtpZih0aGlzLm1fRXhlY3V0ZUxvY2tlZClyZXR1cm4hMTt0aGlzLm1fRXhlY3V0ZUxvY2tlZD0hMDt0aGlzLm1fU3ViakZpbGxUeXBlPWM7dGhpcy5tX0NsaXBGaWxsVHlwZT1hO3RoaXMubV9DbGlwVHlwZT1iO3RoaXMubV9Vc2luZ1BvbHlUcmVlPSEwO3RyeXsoZj10aGlzLkV4ZWN1dGVJbnRlcm5hbCgpKSYmdGhpcy5CdWlsZFJlc3VsdDIoZSl9ZmluYWxseXt0aGlzLkRpc3Bvc2VBbGxQb2x5UHRzKCksdGhpcy5tX0V4ZWN1dGVMb2NrZWQ9XG4hMX1yZXR1cm4gZn1pZigyPT1iJiYhY3x8Mj09YiYmYylyZXR1cm4gYj1hWzBdLGU9YVsxXSx0aGlzLkV4ZWN1dGUoYixlLGQuUG9seUZpbGxUeXBlLnBmdEV2ZW5PZGQsZC5Qb2x5RmlsbFR5cGUucGZ0RXZlbk9kZCl9ZWxzZXtiPWFbMF07ZT1hWzFdO2M9YVsyXTthPWFbM107aWYodGhpcy5tX0V4ZWN1dGVMb2NrZWQpcmV0dXJuITE7dGhpcy5tX0hhc09wZW5QYXRocyYmZC5FcnJvcihcIkVycm9yOiBQb2x5VHJlZSBzdHJ1Y3QgaXMgbmVlZCBmb3Igb3BlbiBwYXRoIGNsaXBwaW5nLlwiKTt0aGlzLm1fRXhlY3V0ZUxvY2tlZD0hMDtkLkNsZWFyKGUpO3RoaXMubV9TdWJqRmlsbFR5cGU9Yzt0aGlzLm1fQ2xpcEZpbGxUeXBlPWE7dGhpcy5tX0NsaXBUeXBlPWI7dGhpcy5tX1VzaW5nUG9seVRyZWU9ITE7dHJ5e3ZhciBmPXRoaXMuRXhlY3V0ZUludGVybmFsKCk7ZiYmdGhpcy5CdWlsZFJlc3VsdChlKX1maW5hbGx5e3RoaXMuRGlzcG9zZUFsbFBvbHlQdHMoKSx0aGlzLm1fRXhlY3V0ZUxvY2tlZD1cbiExfXJldHVybiBmfX07ZC5DbGlwcGVyLnByb3RvdHlwZS5GaXhIb2xlTGlua2FnZT1mdW5jdGlvbihhKXtpZihudWxsIT09YS5GaXJzdExlZnQmJihhLklzSG9sZT09YS5GaXJzdExlZnQuSXNIb2xlfHxudWxsPT09YS5GaXJzdExlZnQuUHRzKSl7Zm9yKHZhciBiPWEuRmlyc3RMZWZ0O251bGwhPT1iJiYoYi5Jc0hvbGU9PWEuSXNIb2xlfHxudWxsPT09Yi5QdHMpOyliPWIuRmlyc3RMZWZ0O2EuRmlyc3RMZWZ0PWJ9fTtkLkNsaXBwZXIucHJvdG90eXBlLkV4ZWN1dGVJbnRlcm5hbD1mdW5jdGlvbigpe3RyeXt0aGlzLlJlc2V0KCk7aWYobnVsbD09PXRoaXMubV9DdXJyZW50TE0pcmV0dXJuITE7dmFyIGE9dGhpcy5Qb3BTY2FuYmVhbSgpO2Rve3RoaXMuSW5zZXJ0TG9jYWxNaW5pbWFJbnRvQUVMKGEpO2QuQ2xlYXIodGhpcy5tX0dob3N0Sm9pbnMpO3RoaXMuUHJvY2Vzc0hvcml6b250YWxzKCExKTtpZihudWxsPT09dGhpcy5tX1NjYW5iZWFtKWJyZWFrO3ZhciBiPXRoaXMuUG9wU2NhbmJlYW0oKTtcbmlmKCF0aGlzLlByb2Nlc3NJbnRlcnNlY3Rpb25zKGEsYikpcmV0dXJuITE7dGhpcy5Qcm9jZXNzRWRnZXNBdFRvcE9mU2NhbmJlYW0oYik7YT1ifXdoaWxlKG51bGwhPT10aGlzLm1fU2NhbmJlYW18fG51bGwhPT10aGlzLm1fQ3VycmVudExNKTtmb3IodmFyIGE9MCxjPXRoaXMubV9Qb2x5T3V0cy5sZW5ndGg7YTxjO2ErKyl7dmFyIGU9dGhpcy5tX1BvbHlPdXRzW2FdO251bGw9PT1lLlB0c3x8ZS5Jc09wZW58fChlLklzSG9sZV50aGlzLlJldmVyc2VTb2x1dGlvbik9PTA8dGhpcy5BcmVhKGUpJiZ0aGlzLlJldmVyc2VQb2x5UHRMaW5rcyhlLlB0cyl9dGhpcy5Kb2luQ29tbW9uRWRnZXMoKTthPTA7Zm9yKGM9dGhpcy5tX1BvbHlPdXRzLmxlbmd0aDthPGM7YSsrKWU9dGhpcy5tX1BvbHlPdXRzW2FdLG51bGw9PT1lLlB0c3x8ZS5Jc09wZW58fHRoaXMuRml4dXBPdXRQb2x5Z29uKGUpO3RoaXMuU3RyaWN0bHlTaW1wbGUmJnRoaXMuRG9TaW1wbGVQb2x5Z29ucygpO3JldHVybiEwfWZpbmFsbHl7ZC5DbGVhcih0aGlzLm1fSm9pbnMpLFxuZC5DbGVhcih0aGlzLm1fR2hvc3RKb2lucyl9fTtkLkNsaXBwZXIucHJvdG90eXBlLlBvcFNjYW5iZWFtPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5tX1NjYW5iZWFtLlk7dGhpcy5tX1NjYW5iZWFtPXRoaXMubV9TY2FuYmVhbS5OZXh0O3JldHVybiBhfTtkLkNsaXBwZXIucHJvdG90eXBlLkRpc3Bvc2VBbGxQb2x5UHRzPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPTAsYj10aGlzLm1fUG9seU91dHMubGVuZ3RoO2E8YjsrK2EpdGhpcy5EaXNwb3NlT3V0UmVjKGEpO2QuQ2xlYXIodGhpcy5tX1BvbHlPdXRzKX07ZC5DbGlwcGVyLnByb3RvdHlwZS5EaXNwb3NlT3V0UmVjPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMubV9Qb2x5T3V0c1thXTtudWxsIT09Yi5QdHMmJnRoaXMuRGlzcG9zZU91dFB0cyhiLlB0cyk7dGhpcy5tX1BvbHlPdXRzW2FdPW51bGx9O2QuQ2xpcHBlci5wcm90b3R5cGUuRGlzcG9zZU91dFB0cz1mdW5jdGlvbihhKXtpZihudWxsIT09YSlmb3IoYS5QcmV2Lk5leHQ9bnVsbDtudWxsIT09XG5hOylhPWEuTmV4dH07ZC5DbGlwcGVyLnByb3RvdHlwZS5BZGRKb2luPWZ1bmN0aW9uKGEsYixjKXt2YXIgZT1uZXcgZC5Kb2luO2UuT3V0UHQxPWE7ZS5PdXRQdDI9YjtlLk9mZlB0Llg9Yy5YO2UuT2ZmUHQuWT1jLlk7dGhpcy5tX0pvaW5zLnB1c2goZSl9O2QuQ2xpcHBlci5wcm90b3R5cGUuQWRkR2hvc3RKb2luPWZ1bmN0aW9uKGEsYil7dmFyIGM9bmV3IGQuSm9pbjtjLk91dFB0MT1hO2MuT2ZmUHQuWD1iLlg7Yy5PZmZQdC5ZPWIuWTt0aGlzLm1fR2hvc3RKb2lucy5wdXNoKGMpfTtkLkNsaXBwZXIucHJvdG90eXBlLkluc2VydExvY2FsTWluaW1hSW50b0FFTD1mdW5jdGlvbihhKXtmb3IoO251bGwhPT10aGlzLm1fQ3VycmVudExNJiZ0aGlzLm1fQ3VycmVudExNLlk9PWE7KXt2YXIgYj10aGlzLm1fQ3VycmVudExNLkxlZnRCb3VuZCxjPXRoaXMubV9DdXJyZW50TE0uUmlnaHRCb3VuZDt0aGlzLlBvcExvY2FsTWluaW1hKCk7dmFyIGU9bnVsbDtudWxsPT09Yj8odGhpcy5JbnNlcnRFZGdlSW50b0FFTChjLFxubnVsbCksdGhpcy5TZXRXaW5kaW5nQ291bnQoYyksdGhpcy5Jc0NvbnRyaWJ1dGluZyhjKSYmKGU9dGhpcy5BZGRPdXRQdChjLGMuQm90KSkpOihudWxsPT1jPyh0aGlzLkluc2VydEVkZ2VJbnRvQUVMKGIsbnVsbCksdGhpcy5TZXRXaW5kaW5nQ291bnQoYiksdGhpcy5Jc0NvbnRyaWJ1dGluZyhiKSYmKGU9dGhpcy5BZGRPdXRQdChiLGIuQm90KSkpOih0aGlzLkluc2VydEVkZ2VJbnRvQUVMKGIsbnVsbCksdGhpcy5JbnNlcnRFZGdlSW50b0FFTChjLGIpLHRoaXMuU2V0V2luZGluZ0NvdW50KGIpLGMuV2luZENudD1iLldpbmRDbnQsYy5XaW5kQ250Mj1iLldpbmRDbnQyLHRoaXMuSXNDb250cmlidXRpbmcoYikmJihlPXRoaXMuQWRkTG9jYWxNaW5Qb2x5KGIsYyxiLkJvdCkpKSx0aGlzLkluc2VydFNjYW5iZWFtKGIuVG9wLlkpKTtudWxsIT1jJiYoZC5DbGlwcGVyQmFzZS5Jc0hvcml6b250YWwoYyk/dGhpcy5BZGRFZGdlVG9TRUwoYyk6dGhpcy5JbnNlcnRTY2FuYmVhbShjLlRvcC5ZKSk7XG5pZihudWxsIT1iJiZudWxsIT1jKXtpZihudWxsIT09ZSYmZC5DbGlwcGVyQmFzZS5Jc0hvcml6b250YWwoYykmJjA8dGhpcy5tX0dob3N0Sm9pbnMubGVuZ3RoJiYwIT09Yy5XaW5kRGVsdGEpZm9yKHZhciBmPTAsZz10aGlzLm1fR2hvc3RKb2lucy5sZW5ndGg7ZjxnO2YrKyl7dmFyIGg9dGhpcy5tX0dob3N0Sm9pbnNbZl07dGhpcy5Ib3J6U2VnbWVudHNPdmVybGFwKGguT3V0UHQxLlB0LGguT2ZmUHQsYy5Cb3QsYy5Ub3ApJiZ0aGlzLkFkZEpvaW4oaC5PdXRQdDEsZSxoLk9mZlB0KX0wPD1iLk91dElkeCYmbnVsbCE9PWIuUHJldkluQUVMJiZiLlByZXZJbkFFTC5DdXJyLlg9PWIuQm90LlgmJjA8PWIuUHJldkluQUVMLk91dElkeCYmZC5DbGlwcGVyQmFzZS5TbG9wZXNFcXVhbChiLlByZXZJbkFFTCxiLHRoaXMubV9Vc2VGdWxsUmFuZ2UpJiYwIT09Yi5XaW5kRGVsdGEmJjAhPT1iLlByZXZJbkFFTC5XaW5kRGVsdGEmJihmPXRoaXMuQWRkT3V0UHQoYi5QcmV2SW5BRUwsYi5Cb3QpLFxudGhpcy5BZGRKb2luKGUsZixiLlRvcCkpO2lmKGIuTmV4dEluQUVMIT1jJiYoMDw9Yy5PdXRJZHgmJjA8PWMuUHJldkluQUVMLk91dElkeCYmZC5DbGlwcGVyQmFzZS5TbG9wZXNFcXVhbChjLlByZXZJbkFFTCxjLHRoaXMubV9Vc2VGdWxsUmFuZ2UpJiYwIT09Yy5XaW5kRGVsdGEmJjAhPT1jLlByZXZJbkFFTC5XaW5kRGVsdGEmJihmPXRoaXMuQWRkT3V0UHQoYy5QcmV2SW5BRUwsYy5Cb3QpLHRoaXMuQWRkSm9pbihlLGYsYy5Ub3ApKSxlPWIuTmV4dEluQUVMLG51bGwhPT1lKSlmb3IoO2UhPWM7KXRoaXMuSW50ZXJzZWN0RWRnZXMoYyxlLGIuQ3VyciwhMSksZT1lLk5leHRJbkFFTH19fTtkLkNsaXBwZXIucHJvdG90eXBlLkluc2VydEVkZ2VJbnRvQUVMPWZ1bmN0aW9uKGEsYil7aWYobnVsbD09PXRoaXMubV9BY3RpdmVFZGdlcylhLlByZXZJbkFFTD1udWxsLGEuTmV4dEluQUVMPW51bGwsdGhpcy5tX0FjdGl2ZUVkZ2VzPWE7ZWxzZSBpZihudWxsPT09YiYmdGhpcy5FMkluc2VydHNCZWZvcmVFMSh0aGlzLm1fQWN0aXZlRWRnZXMsXG5hKSlhLlByZXZJbkFFTD1udWxsLGEuTmV4dEluQUVMPXRoaXMubV9BY3RpdmVFZGdlcyx0aGlzLm1fQWN0aXZlRWRnZXM9dGhpcy5tX0FjdGl2ZUVkZ2VzLlByZXZJbkFFTD1hO2Vsc2V7bnVsbD09PWImJihiPXRoaXMubV9BY3RpdmVFZGdlcyk7Zm9yKDtudWxsIT09Yi5OZXh0SW5BRUwmJiF0aGlzLkUySW5zZXJ0c0JlZm9yZUUxKGIuTmV4dEluQUVMLGEpOyliPWIuTmV4dEluQUVMO2EuTmV4dEluQUVMPWIuTmV4dEluQUVMO251bGwhPT1iLk5leHRJbkFFTCYmKGIuTmV4dEluQUVMLlByZXZJbkFFTD1hKTthLlByZXZJbkFFTD1iO2IuTmV4dEluQUVMPWF9fTtkLkNsaXBwZXIucHJvdG90eXBlLkUySW5zZXJ0c0JlZm9yZUUxPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGIuQ3Vyci5YPT1hLkN1cnIuWD9iLlRvcC5ZPmEuVG9wLlk/Yi5Ub3AuWDxkLkNsaXBwZXIuVG9wWChhLGIuVG9wLlkpOmEuVG9wLlg+ZC5DbGlwcGVyLlRvcFgoYixhLlRvcC5ZKTpiLkN1cnIuWDxhLkN1cnIuWH07ZC5DbGlwcGVyLnByb3RvdHlwZS5Jc0V2ZW5PZGRGaWxsVHlwZT1cbmZ1bmN0aW9uKGEpe3JldHVybiBhLlBvbHlUeXA9PWQuUG9seVR5cGUucHRTdWJqZWN0P3RoaXMubV9TdWJqRmlsbFR5cGU9PWQuUG9seUZpbGxUeXBlLnBmdEV2ZW5PZGQ6dGhpcy5tX0NsaXBGaWxsVHlwZT09ZC5Qb2x5RmlsbFR5cGUucGZ0RXZlbk9kZH07ZC5DbGlwcGVyLnByb3RvdHlwZS5Jc0V2ZW5PZGRBbHRGaWxsVHlwZT1mdW5jdGlvbihhKXtyZXR1cm4gYS5Qb2x5VHlwPT1kLlBvbHlUeXBlLnB0U3ViamVjdD90aGlzLm1fQ2xpcEZpbGxUeXBlPT1kLlBvbHlGaWxsVHlwZS5wZnRFdmVuT2RkOnRoaXMubV9TdWJqRmlsbFR5cGU9PWQuUG9seUZpbGxUeXBlLnBmdEV2ZW5PZGR9O2QuQ2xpcHBlci5wcm90b3R5cGUuSXNDb250cmlidXRpbmc9ZnVuY3Rpb24oYSl7dmFyIGIsYzthLlBvbHlUeXA9PWQuUG9seVR5cGUucHRTdWJqZWN0PyhiPXRoaXMubV9TdWJqRmlsbFR5cGUsYz10aGlzLm1fQ2xpcEZpbGxUeXBlKTooYj10aGlzLm1fQ2xpcEZpbGxUeXBlLGM9dGhpcy5tX1N1YmpGaWxsVHlwZSk7XG5zd2l0Y2goYil7Y2FzZSBkLlBvbHlGaWxsVHlwZS5wZnRFdmVuT2RkOmlmKDA9PT1hLldpbmREZWx0YSYmMSE9YS5XaW5kQ250KXJldHVybiExO2JyZWFrO2Nhc2UgZC5Qb2x5RmlsbFR5cGUucGZ0Tm9uWmVybzppZigxIT1NYXRoLmFicyhhLldpbmRDbnQpKXJldHVybiExO2JyZWFrO2Nhc2UgZC5Qb2x5RmlsbFR5cGUucGZ0UG9zaXRpdmU6aWYoMSE9YS5XaW5kQ250KXJldHVybiExO2JyZWFrO2RlZmF1bHQ6aWYoLTEhPWEuV2luZENudClyZXR1cm4hMX1zd2l0Y2godGhpcy5tX0NsaXBUeXBlKXtjYXNlIGQuQ2xpcFR5cGUuY3RJbnRlcnNlY3Rpb246c3dpdGNoKGMpe2Nhc2UgZC5Qb2x5RmlsbFR5cGUucGZ0RXZlbk9kZDpjYXNlIGQuUG9seUZpbGxUeXBlLnBmdE5vblplcm86cmV0dXJuIDAhPT1hLldpbmRDbnQyO2Nhc2UgZC5Qb2x5RmlsbFR5cGUucGZ0UG9zaXRpdmU6cmV0dXJuIDA8YS5XaW5kQ250MjtkZWZhdWx0OnJldHVybiAwPmEuV2luZENudDJ9Y2FzZSBkLkNsaXBUeXBlLmN0VW5pb246c3dpdGNoKGMpe2Nhc2UgZC5Qb2x5RmlsbFR5cGUucGZ0RXZlbk9kZDpjYXNlIGQuUG9seUZpbGxUeXBlLnBmdE5vblplcm86cmV0dXJuIDA9PT1cbmEuV2luZENudDI7Y2FzZSBkLlBvbHlGaWxsVHlwZS5wZnRQb3NpdGl2ZTpyZXR1cm4gMD49YS5XaW5kQ250MjtkZWZhdWx0OnJldHVybiAwPD1hLldpbmRDbnQyfWNhc2UgZC5DbGlwVHlwZS5jdERpZmZlcmVuY2U6aWYoYS5Qb2x5VHlwPT1kLlBvbHlUeXBlLnB0U3ViamVjdClzd2l0Y2goYyl7Y2FzZSBkLlBvbHlGaWxsVHlwZS5wZnRFdmVuT2RkOmNhc2UgZC5Qb2x5RmlsbFR5cGUucGZ0Tm9uWmVybzpyZXR1cm4gMD09PWEuV2luZENudDI7Y2FzZSBkLlBvbHlGaWxsVHlwZS5wZnRQb3NpdGl2ZTpyZXR1cm4gMD49YS5XaW5kQ250MjtkZWZhdWx0OnJldHVybiAwPD1hLldpbmRDbnQyfWVsc2Ugc3dpdGNoKGMpe2Nhc2UgZC5Qb2x5RmlsbFR5cGUucGZ0RXZlbk9kZDpjYXNlIGQuUG9seUZpbGxUeXBlLnBmdE5vblplcm86cmV0dXJuIDAhPT1hLldpbmRDbnQyO2Nhc2UgZC5Qb2x5RmlsbFR5cGUucGZ0UG9zaXRpdmU6cmV0dXJuIDA8YS5XaW5kQ250MjtkZWZhdWx0OnJldHVybiAwPlxuYS5XaW5kQ250Mn1jYXNlIGQuQ2xpcFR5cGUuY3RYb3I6aWYoMD09PWEuV2luZERlbHRhKXN3aXRjaChjKXtjYXNlIGQuUG9seUZpbGxUeXBlLnBmdEV2ZW5PZGQ6Y2FzZSBkLlBvbHlGaWxsVHlwZS5wZnROb25aZXJvOnJldHVybiAwPT09YS5XaW5kQ250MjtjYXNlIGQuUG9seUZpbGxUeXBlLnBmdFBvc2l0aXZlOnJldHVybiAwPj1hLldpbmRDbnQyO2RlZmF1bHQ6cmV0dXJuIDA8PWEuV2luZENudDJ9fXJldHVybiEwfTtkLkNsaXBwZXIucHJvdG90eXBlLlNldFdpbmRpbmdDb3VudD1mdW5jdGlvbihhKXtmb3IodmFyIGI9YS5QcmV2SW5BRUw7bnVsbCE9PWImJihiLlBvbHlUeXAhPWEuUG9seVR5cHx8MD09PWIuV2luZERlbHRhKTspYj1iLlByZXZJbkFFTDtpZihudWxsPT09YilhLldpbmRDbnQ9MD09PWEuV2luZERlbHRhPzE6YS5XaW5kRGVsdGEsYS5XaW5kQ250Mj0wLGI9dGhpcy5tX0FjdGl2ZUVkZ2VzO2Vsc2V7aWYoMD09PWEuV2luZERlbHRhJiZ0aGlzLm1fQ2xpcFR5cGUhPVxuZC5DbGlwVHlwZS5jdFVuaW9uKWEuV2luZENudD0xO2Vsc2UgaWYodGhpcy5Jc0V2ZW5PZGRGaWxsVHlwZShhKSlpZigwPT09YS5XaW5kRGVsdGEpe2Zvcih2YXIgYz0hMCxlPWIuUHJldkluQUVMO251bGwhPT1lOyllLlBvbHlUeXA9PWIuUG9seVR5cCYmMCE9PWUuV2luZERlbHRhJiYoYz0hYyksZT1lLlByZXZJbkFFTDthLldpbmRDbnQ9Yz8wOjF9ZWxzZSBhLldpbmRDbnQ9YS5XaW5kRGVsdGE7ZWxzZSAwPmIuV2luZENudCpiLldpbmREZWx0YT8xPE1hdGguYWJzKGIuV2luZENudCk/YS5XaW5kQ250PTA+Yi5XaW5kRGVsdGEqYS5XaW5kRGVsdGE/Yi5XaW5kQ250OmIuV2luZENudCthLldpbmREZWx0YTphLldpbmRDbnQ9MD09PWEuV2luZERlbHRhPzE6YS5XaW5kRGVsdGE6YS5XaW5kQ250PTA9PT1hLldpbmREZWx0YT8wPmIuV2luZENudD9iLldpbmRDbnQtMTpiLldpbmRDbnQrMTowPmIuV2luZERlbHRhKmEuV2luZERlbHRhP2IuV2luZENudDpiLldpbmRDbnQrYS5XaW5kRGVsdGE7XG5hLldpbmRDbnQyPWIuV2luZENudDI7Yj1iLk5leHRJbkFFTH1pZih0aGlzLklzRXZlbk9kZEFsdEZpbGxUeXBlKGEpKWZvcig7YiE9YTspMCE9PWIuV2luZERlbHRhJiYoYS5XaW5kQ250Mj0wPT09YS5XaW5kQ250Mj8xOjApLGI9Yi5OZXh0SW5BRUw7ZWxzZSBmb3IoO2IhPWE7KWEuV2luZENudDIrPWIuV2luZERlbHRhLGI9Yi5OZXh0SW5BRUx9O2QuQ2xpcHBlci5wcm90b3R5cGUuQWRkRWRnZVRvU0VMPWZ1bmN0aW9uKGEpe251bGw9PT10aGlzLm1fU29ydGVkRWRnZXM/KHRoaXMubV9Tb3J0ZWRFZGdlcz1hLGEuUHJldkluU0VMPW51bGwsYS5OZXh0SW5TRUw9bnVsbCk6KGEuTmV4dEluU0VMPXRoaXMubV9Tb3J0ZWRFZGdlcyxhLlByZXZJblNFTD1udWxsLHRoaXMubV9Tb3J0ZWRFZGdlcz10aGlzLm1fU29ydGVkRWRnZXMuUHJldkluU0VMPWEpfTtkLkNsaXBwZXIucHJvdG90eXBlLkNvcHlBRUxUb1NFTD1mdW5jdGlvbigpe3ZhciBhPXRoaXMubV9BY3RpdmVFZGdlcztmb3IodGhpcy5tX1NvcnRlZEVkZ2VzPVxuYTtudWxsIT09YTspYS5QcmV2SW5TRUw9YS5QcmV2SW5BRUwsYT1hLk5leHRJblNFTD1hLk5leHRJbkFFTH07ZC5DbGlwcGVyLnByb3RvdHlwZS5Td2FwUG9zaXRpb25zSW5BRUw9ZnVuY3Rpb24oYSxiKXtpZihhLk5leHRJbkFFTCE9YS5QcmV2SW5BRUwmJmIuTmV4dEluQUVMIT1iLlByZXZJbkFFTCl7aWYoYS5OZXh0SW5BRUw9PWIpe3ZhciBjPWIuTmV4dEluQUVMO251bGwhPT1jJiYoYy5QcmV2SW5BRUw9YSk7dmFyIGU9YS5QcmV2SW5BRUw7bnVsbCE9PWUmJihlLk5leHRJbkFFTD1iKTtiLlByZXZJbkFFTD1lO2IuTmV4dEluQUVMPWE7YS5QcmV2SW5BRUw9YjthLk5leHRJbkFFTD1jfWVsc2UgYi5OZXh0SW5BRUw9PWE/KGM9YS5OZXh0SW5BRUwsbnVsbCE9PWMmJihjLlByZXZJbkFFTD1iKSxlPWIuUHJldkluQUVMLG51bGwhPT1lJiYoZS5OZXh0SW5BRUw9YSksYS5QcmV2SW5BRUw9ZSxhLk5leHRJbkFFTD1iLGIuUHJldkluQUVMPWEsYi5OZXh0SW5BRUw9Yyk6KGM9YS5OZXh0SW5BRUwsXG5lPWEuUHJldkluQUVMLGEuTmV4dEluQUVMPWIuTmV4dEluQUVMLG51bGwhPT1hLk5leHRJbkFFTCYmKGEuTmV4dEluQUVMLlByZXZJbkFFTD1hKSxhLlByZXZJbkFFTD1iLlByZXZJbkFFTCxudWxsIT09YS5QcmV2SW5BRUwmJihhLlByZXZJbkFFTC5OZXh0SW5BRUw9YSksYi5OZXh0SW5BRUw9YyxudWxsIT09Yi5OZXh0SW5BRUwmJihiLk5leHRJbkFFTC5QcmV2SW5BRUw9YiksYi5QcmV2SW5BRUw9ZSxudWxsIT09Yi5QcmV2SW5BRUwmJihiLlByZXZJbkFFTC5OZXh0SW5BRUw9YikpO251bGw9PT1hLlByZXZJbkFFTD90aGlzLm1fQWN0aXZlRWRnZXM9YTpudWxsPT09Yi5QcmV2SW5BRUwmJih0aGlzLm1fQWN0aXZlRWRnZXM9Yil9fTtkLkNsaXBwZXIucHJvdG90eXBlLlN3YXBQb3NpdGlvbnNJblNFTD1mdW5jdGlvbihhLGIpe2lmKG51bGwhPT1hLk5leHRJblNFTHx8bnVsbCE9PWEuUHJldkluU0VMKWlmKG51bGwhPT1iLk5leHRJblNFTHx8bnVsbCE9PWIuUHJldkluU0VMKXtpZihhLk5leHRJblNFTD09XG5iKXt2YXIgYz1iLk5leHRJblNFTDtudWxsIT09YyYmKGMuUHJldkluU0VMPWEpO3ZhciBlPWEuUHJldkluU0VMO251bGwhPT1lJiYoZS5OZXh0SW5TRUw9Yik7Yi5QcmV2SW5TRUw9ZTtiLk5leHRJblNFTD1hO2EuUHJldkluU0VMPWI7YS5OZXh0SW5TRUw9Y31lbHNlIGIuTmV4dEluU0VMPT1hPyhjPWEuTmV4dEluU0VMLG51bGwhPT1jJiYoYy5QcmV2SW5TRUw9YiksZT1iLlByZXZJblNFTCxudWxsIT09ZSYmKGUuTmV4dEluU0VMPWEpLGEuUHJldkluU0VMPWUsYS5OZXh0SW5TRUw9YixiLlByZXZJblNFTD1hLGIuTmV4dEluU0VMPWMpOihjPWEuTmV4dEluU0VMLGU9YS5QcmV2SW5TRUwsYS5OZXh0SW5TRUw9Yi5OZXh0SW5TRUwsbnVsbCE9PWEuTmV4dEluU0VMJiYoYS5OZXh0SW5TRUwuUHJldkluU0VMPWEpLGEuUHJldkluU0VMPWIuUHJldkluU0VMLG51bGwhPT1hLlByZXZJblNFTCYmKGEuUHJldkluU0VMLk5leHRJblNFTD1hKSxiLk5leHRJblNFTD1jLG51bGwhPT1iLk5leHRJblNFTCYmXG4oYi5OZXh0SW5TRUwuUHJldkluU0VMPWIpLGIuUHJldkluU0VMPWUsbnVsbCE9PWIuUHJldkluU0VMJiYoYi5QcmV2SW5TRUwuTmV4dEluU0VMPWIpKTtudWxsPT09YS5QcmV2SW5TRUw/dGhpcy5tX1NvcnRlZEVkZ2VzPWE6bnVsbD09PWIuUHJldkluU0VMJiYodGhpcy5tX1NvcnRlZEVkZ2VzPWIpfX07ZC5DbGlwcGVyLnByb3RvdHlwZS5BZGRMb2NhbE1heFBvbHk9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuQWRkT3V0UHQoYSxjKTswPT1iLldpbmREZWx0YSYmdGhpcy5BZGRPdXRQdChiLGMpO2EuT3V0SWR4PT1iLk91dElkeD8oYS5PdXRJZHg9LTEsYi5PdXRJZHg9LTEpOmEuT3V0SWR4PGIuT3V0SWR4P3RoaXMuQXBwZW5kUG9seWdvbihhLGIpOnRoaXMuQXBwZW5kUG9seWdvbihiLGEpfTtkLkNsaXBwZXIucHJvdG90eXBlLkFkZExvY2FsTWluUG9seT1mdW5jdGlvbihhLGIsYyl7dmFyIGUsZjtkLkNsaXBwZXJCYXNlLklzSG9yaXpvbnRhbChiKXx8YS5EeD5iLkR4PyhlPXRoaXMuQWRkT3V0UHQoYSxcbmMpLGIuT3V0SWR4PWEuT3V0SWR4LGEuU2lkZT1kLkVkZ2VTaWRlLmVzTGVmdCxiLlNpZGU9ZC5FZGdlU2lkZS5lc1JpZ2h0LGY9YSxhPWYuUHJldkluQUVMPT1iP2IuUHJldkluQUVMOmYuUHJldkluQUVMKTooZT10aGlzLkFkZE91dFB0KGIsYyksYS5PdXRJZHg9Yi5PdXRJZHgsYS5TaWRlPWQuRWRnZVNpZGUuZXNSaWdodCxiLlNpZGU9ZC5FZGdlU2lkZS5lc0xlZnQsZj1iLGE9Zi5QcmV2SW5BRUw9PWE/YS5QcmV2SW5BRUw6Zi5QcmV2SW5BRUwpO251bGwhPT1hJiYwPD1hLk91dElkeCYmZC5DbGlwcGVyLlRvcFgoYSxjLlkpPT1kLkNsaXBwZXIuVG9wWChmLGMuWSkmJmQuQ2xpcHBlckJhc2UuU2xvcGVzRXF1YWwoZixhLHRoaXMubV9Vc2VGdWxsUmFuZ2UpJiYwIT09Zi5XaW5kRGVsdGEmJjAhPT1hLldpbmREZWx0YSYmKGM9dGhpcy5BZGRPdXRQdChhLGMpLHRoaXMuQWRkSm9pbihlLGMsZi5Ub3ApKTtyZXR1cm4gZX07ZC5DbGlwcGVyLnByb3RvdHlwZS5DcmVhdGVPdXRSZWM9ZnVuY3Rpb24oKXt2YXIgYT1cbm5ldyBkLk91dFJlYzthLklkeD0tMTthLklzSG9sZT0hMTthLklzT3Blbj0hMTthLkZpcnN0TGVmdD1udWxsO2EuUHRzPW51bGw7YS5Cb3R0b21QdD1udWxsO2EuUG9seU5vZGU9bnVsbDt0aGlzLm1fUG9seU91dHMucHVzaChhKTthLklkeD10aGlzLm1fUG9seU91dHMubGVuZ3RoLTE7cmV0dXJuIGF9O2QuQ2xpcHBlci5wcm90b3R5cGUuQWRkT3V0UHQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLlNpZGU9PWQuRWRnZVNpZGUuZXNMZWZ0O2lmKDA+YS5PdXRJZHgpe3ZhciBlPXRoaXMuQ3JlYXRlT3V0UmVjKCk7ZS5Jc09wZW49MD09PWEuV2luZERlbHRhO3ZhciBmPW5ldyBkLk91dFB0O2UuUHRzPWY7Zi5JZHg9ZS5JZHg7Zi5QdC5YPWIuWDtmLlB0Llk9Yi5ZO2YuTmV4dD1mO2YuUHJldj1mO2UuSXNPcGVufHx0aGlzLlNldEhvbGVTdGF0ZShhLGUpO2EuT3V0SWR4PWUuSWR4fWVsc2V7dmFyIGU9dGhpcy5tX1BvbHlPdXRzW2EuT3V0SWR4XSxnPWUuUHRzO2lmKGMmJmQuSW50UG9pbnQub3BfRXF1YWxpdHkoYixcbmcuUHQpKXJldHVybiBnO2lmKCFjJiZkLkludFBvaW50Lm9wX0VxdWFsaXR5KGIsZy5QcmV2LlB0KSlyZXR1cm4gZy5QcmV2O2Y9bmV3IGQuT3V0UHQ7Zi5JZHg9ZS5JZHg7Zi5QdC5YPWIuWDtmLlB0Llk9Yi5ZO2YuTmV4dD1nO2YuUHJldj1nLlByZXY7Zi5QcmV2Lk5leHQ9ZjtnLlByZXY9ZjtjJiYoZS5QdHM9Zil9cmV0dXJuIGZ9O2QuQ2xpcHBlci5wcm90b3R5cGUuU3dhcFBvaW50cz1mdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBkLkludFBvaW50KGEuVmFsdWUpO2EuVmFsdWUuWD1iLlZhbHVlLlg7YS5WYWx1ZS5ZPWIuVmFsdWUuWTtiLlZhbHVlLlg9Yy5YO2IuVmFsdWUuWT1jLll9O2QuQ2xpcHBlci5wcm90b3R5cGUuSG9yelNlZ21lbnRzT3ZlcmxhcD1mdW5jdGlvbihhLGIsYyxlKXtyZXR1cm4gYS5YPmMuWD09YS5YPGUuWD8hMDpiLlg+Yy5YPT1iLlg8ZS5YPyEwOmMuWD5hLlg9PWMuWDxiLlg/ITA6ZS5YPmEuWD09ZS5YPGIuWD8hMDphLlg9PWMuWCYmYi5YPT1lLlg/ITA6YS5YPT1cbmUuWCYmYi5YPT1jLlg/ITA6ITF9O2QuQ2xpcHBlci5wcm90b3R5cGUuSW5zZXJ0UG9seVB0QmV0d2Vlbj1mdW5jdGlvbihhLGIsYyl7dmFyIGU9bmV3IGQuT3V0UHQ7ZS5QdC5YPWMuWDtlLlB0Llk9Yy5ZO2I9PWEuTmV4dD8oYS5OZXh0PWUsYi5QcmV2PWUsZS5OZXh0PWIsZS5QcmV2PWEpOihiLk5leHQ9ZSxhLlByZXY9ZSxlLk5leHQ9YSxlLlByZXY9Yik7cmV0dXJuIGV9O2QuQ2xpcHBlci5wcm90b3R5cGUuU2V0SG9sZVN0YXRlPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPSExLGU9YS5QcmV2SW5BRUw7bnVsbCE9PWU7KTA8PWUuT3V0SWR4JiYwIT1lLldpbmREZWx0YSYmKGM9IWMsbnVsbD09PWIuRmlyc3RMZWZ0JiYoYi5GaXJzdExlZnQ9dGhpcy5tX1BvbHlPdXRzW2UuT3V0SWR4XSkpLGU9ZS5QcmV2SW5BRUw7YyYmKGIuSXNIb2xlPSEwKX07ZC5DbGlwcGVyLnByb3RvdHlwZS5HZXREeD1mdW5jdGlvbihhLGIpe3JldHVybiBhLlk9PWIuWT9kLkNsaXBwZXJCYXNlLmhvcml6b250YWw6XG4oYi5YLWEuWCkvKGIuWS1hLlkpfTtkLkNsaXBwZXIucHJvdG90eXBlLkZpcnN0SXNCb3R0b21QdD1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1hLlByZXY7ZC5JbnRQb2ludC5vcF9FcXVhbGl0eShjLlB0LGEuUHQpJiZjIT1hOyljPWMuUHJldjtmb3IodmFyIGU9TWF0aC5hYnModGhpcy5HZXREeChhLlB0LGMuUHQpKSxjPWEuTmV4dDtkLkludFBvaW50Lm9wX0VxdWFsaXR5KGMuUHQsYS5QdCkmJmMhPWE7KWM9Yy5OZXh0O2Zvcih2YXIgZj1NYXRoLmFicyh0aGlzLkdldER4KGEuUHQsYy5QdCkpLGM9Yi5QcmV2O2QuSW50UG9pbnQub3BfRXF1YWxpdHkoYy5QdCxiLlB0KSYmYyE9YjspYz1jLlByZXY7Zm9yKHZhciBnPU1hdGguYWJzKHRoaXMuR2V0RHgoYi5QdCxjLlB0KSksYz1iLk5leHQ7ZC5JbnRQb2ludC5vcF9FcXVhbGl0eShjLlB0LGIuUHQpJiZjIT1iOyljPWMuTmV4dDtjPU1hdGguYWJzKHRoaXMuR2V0RHgoYi5QdCxjLlB0KSk7cmV0dXJuIGU+PWcmJmU+PWN8fGY+PWcmJmY+PVxuY307ZC5DbGlwcGVyLnByb3RvdHlwZS5HZXRCb3R0b21QdD1mdW5jdGlvbihhKXtmb3IodmFyIGI9bnVsbCxjPWEuTmV4dDtjIT1hOyljLlB0Llk+YS5QdC5ZPyhhPWMsYj1udWxsKTpjLlB0Llk9PWEuUHQuWSYmYy5QdC5YPD1hLlB0LlgmJihjLlB0Llg8YS5QdC5YPyhiPW51bGwsYT1jKTpjLk5leHQhPWEmJmMuUHJldiE9YSYmKGI9YykpLGM9Yy5OZXh0O2lmKG51bGwhPT1iKWZvcig7YiE9YzspZm9yKHRoaXMuRmlyc3RJc0JvdHRvbVB0KGMsYil8fChhPWIpLGI9Yi5OZXh0O2QuSW50UG9pbnQub3BfSW5lcXVhbGl0eShiLlB0LGEuUHQpOyliPWIuTmV4dDtyZXR1cm4gYX07ZC5DbGlwcGVyLnByb3RvdHlwZS5HZXRMb3dlcm1vc3RSZWM9ZnVuY3Rpb24oYSxiKXtudWxsPT09YS5Cb3R0b21QdCYmKGEuQm90dG9tUHQ9dGhpcy5HZXRCb3R0b21QdChhLlB0cykpO251bGw9PT1iLkJvdHRvbVB0JiYoYi5Cb3R0b21QdD10aGlzLkdldEJvdHRvbVB0KGIuUHRzKSk7dmFyIGM9YS5Cb3R0b21QdCxcbmU9Yi5Cb3R0b21QdDtyZXR1cm4gYy5QdC5ZPmUuUHQuWT9hOmMuUHQuWTxlLlB0Llk/YjpjLlB0Llg8ZS5QdC5YP2E6Yy5QdC5YPmUuUHQuWD9iOmMuTmV4dD09Yz9iOmUuTmV4dD09ZT9hOnRoaXMuRmlyc3RJc0JvdHRvbVB0KGMsZSk/YTpifTtkLkNsaXBwZXIucHJvdG90eXBlLlBhcmFtMVJpZ2h0T2ZQYXJhbTI9ZnVuY3Rpb24oYSxiKXtkbyBpZihhPWEuRmlyc3RMZWZ0LGE9PWIpcmV0dXJuITA7d2hpbGUobnVsbCE9PWEpO3JldHVybiExfTtkLkNsaXBwZXIucHJvdG90eXBlLkdldE91dFJlYz1mdW5jdGlvbihhKXtmb3IoYT10aGlzLm1fUG9seU91dHNbYV07YSE9dGhpcy5tX1BvbHlPdXRzW2EuSWR4XTspYT10aGlzLm1fUG9seU91dHNbYS5JZHhdO3JldHVybiBhfTtkLkNsaXBwZXIucHJvdG90eXBlLkFwcGVuZFBvbHlnb249ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLm1fUG9seU91dHNbYS5PdXRJZHhdLGU9dGhpcy5tX1BvbHlPdXRzW2IuT3V0SWR4XSxmO2Y9dGhpcy5QYXJhbTFSaWdodE9mUGFyYW0yKGMsXG5lKT9lOnRoaXMuUGFyYW0xUmlnaHRPZlBhcmFtMihlLGMpP2M6dGhpcy5HZXRMb3dlcm1vc3RSZWMoYyxlKTt2YXIgZz1jLlB0cyxoPWcuUHJldixsPWUuUHRzLGs9bC5QcmV2O2EuU2lkZT09ZC5FZGdlU2lkZS5lc0xlZnQ/KGIuU2lkZT09ZC5FZGdlU2lkZS5lc0xlZnQ/KHRoaXMuUmV2ZXJzZVBvbHlQdExpbmtzKGwpLGwuTmV4dD1nLGcuUHJldj1sLGguTmV4dD1rLGsuUHJldj1oLGMuUHRzPWspOihrLk5leHQ9ZyxnLlByZXY9ayxsLlByZXY9aCxoLk5leHQ9bCxjLlB0cz1sKSxnPWQuRWRnZVNpZGUuZXNMZWZ0KTooYi5TaWRlPT1kLkVkZ2VTaWRlLmVzUmlnaHQ/KHRoaXMuUmV2ZXJzZVBvbHlQdExpbmtzKGwpLGguTmV4dD1rLGsuUHJldj1oLGwuTmV4dD1nLGcuUHJldj1sKTooaC5OZXh0PWwsbC5QcmV2PWgsZy5QcmV2PWssay5OZXh0PWcpLGc9ZC5FZGdlU2lkZS5lc1JpZ2h0KTtjLkJvdHRvbVB0PW51bGw7Zj09ZSYmKGUuRmlyc3RMZWZ0IT1jJiYoYy5GaXJzdExlZnQ9ZS5GaXJzdExlZnQpLFxuYy5Jc0hvbGU9ZS5Jc0hvbGUpO2UuUHRzPW51bGw7ZS5Cb3R0b21QdD1udWxsO2UuRmlyc3RMZWZ0PWM7Zj1hLk91dElkeDtoPWIuT3V0SWR4O2EuT3V0SWR4PS0xO2IuT3V0SWR4PS0xO2ZvcihsPXRoaXMubV9BY3RpdmVFZGdlcztudWxsIT09bDspe2lmKGwuT3V0SWR4PT1oKXtsLk91dElkeD1mO2wuU2lkZT1nO2JyZWFrfWw9bC5OZXh0SW5BRUx9ZS5JZHg9Yy5JZHh9O2QuQ2xpcHBlci5wcm90b3R5cGUuUmV2ZXJzZVBvbHlQdExpbmtzPWZ1bmN0aW9uKGEpe2lmKG51bGwhPT1hKXt2YXIgYixjO2I9YTtkbyBjPWIuTmV4dCxiLk5leHQ9Yi5QcmV2LGI9Yi5QcmV2PWM7d2hpbGUoYiE9YSl9fTtkLkNsaXBwZXIuU3dhcFNpZGVzPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5TaWRlO2EuU2lkZT1iLlNpZGU7Yi5TaWRlPWN9O2QuQ2xpcHBlci5Td2FwUG9seUluZGV4ZXM9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLk91dElkeDthLk91dElkeD1iLk91dElkeDtiLk91dElkeD1jfTtkLkNsaXBwZXIucHJvdG90eXBlLkludGVyc2VjdEVkZ2VzPVxuZnVuY3Rpb24oYSxiLGMsZSl7dmFyIGY9IWUmJm51bGw9PT1hLk5leHRJbkxNTCYmYS5Ub3AuWD09Yy5YJiZhLlRvcC5ZPT1jLlk7ZT0hZSYmbnVsbD09PWIuTmV4dEluTE1MJiZiLlRvcC5YPT1jLlgmJmIuVG9wLlk9PWMuWTt2YXIgZz0wPD1hLk91dElkeCxoPTA8PWIuT3V0SWR4O2lmKDA9PT1hLldpbmREZWx0YXx8MD09PWIuV2luZERlbHRhKTA9PT1hLldpbmREZWx0YSYmMD09PWIuV2luZERlbHRhPyhmfHxlKSYmZyYmaCYmdGhpcy5BZGRMb2NhbE1heFBvbHkoYSxiLGMpOmEuUG9seVR5cD09Yi5Qb2x5VHlwJiZhLldpbmREZWx0YSE9Yi5XaW5kRGVsdGEmJnRoaXMubV9DbGlwVHlwZT09ZC5DbGlwVHlwZS5jdFVuaW9uPzA9PT1hLldpbmREZWx0YT9oJiYodGhpcy5BZGRPdXRQdChhLGMpLGcmJihhLk91dElkeD0tMSkpOmcmJih0aGlzLkFkZE91dFB0KGIsYyksaCYmKGIuT3V0SWR4PS0xKSk6YS5Qb2x5VHlwIT1iLlBvbHlUeXAmJigwIT09YS5XaW5kRGVsdGF8fDEhPU1hdGguYWJzKGIuV2luZENudCl8fFxudGhpcy5tX0NsaXBUeXBlPT1kLkNsaXBUeXBlLmN0VW5pb24mJjAhPT1iLldpbmRDbnQyPzAhPT1iLldpbmREZWx0YXx8MSE9TWF0aC5hYnMoYS5XaW5kQ250KXx8dGhpcy5tX0NsaXBUeXBlPT1kLkNsaXBUeXBlLmN0VW5pb24mJjAhPT1hLldpbmRDbnQyfHwodGhpcy5BZGRPdXRQdChiLGMpLGgmJihiLk91dElkeD0tMSkpOih0aGlzLkFkZE91dFB0KGEsYyksZyYmKGEuT3V0SWR4PS0xKSkpLGYmJigwPmEuT3V0SWR4P3RoaXMuRGVsZXRlRnJvbUFFTChhKTpkLkVycm9yKFwiRXJyb3IgaW50ZXJzZWN0aW5nIHBvbHlsaW5lc1wiKSksZSYmKDA+Yi5PdXRJZHg/dGhpcy5EZWxldGVGcm9tQUVMKGIpOmQuRXJyb3IoXCJFcnJvciBpbnRlcnNlY3RpbmcgcG9seWxpbmVzXCIpKTtlbHNle2lmKGEuUG9seVR5cD09Yi5Qb2x5VHlwKWlmKHRoaXMuSXNFdmVuT2RkRmlsbFR5cGUoYSkpe3ZhciBsPWEuV2luZENudDthLldpbmRDbnQ9Yi5XaW5kQ250O2IuV2luZENudD1sfWVsc2UgYS5XaW5kQ250PVxuMD09PWEuV2luZENudCtiLldpbmREZWx0YT8tYS5XaW5kQ250OmEuV2luZENudCtiLldpbmREZWx0YSxiLldpbmRDbnQ9MD09PWIuV2luZENudC1hLldpbmREZWx0YT8tYi5XaW5kQ250OmIuV2luZENudC1hLldpbmREZWx0YTtlbHNlIHRoaXMuSXNFdmVuT2RkRmlsbFR5cGUoYik/YS5XaW5kQ250Mj0wPT09YS5XaW5kQ250Mj8xOjA6YS5XaW5kQ250Mis9Yi5XaW5kRGVsdGEsdGhpcy5Jc0V2ZW5PZGRGaWxsVHlwZShhKT9iLldpbmRDbnQyPTA9PT1iLldpbmRDbnQyPzE6MDpiLldpbmRDbnQyLT1hLldpbmREZWx0YTt2YXIgayxuLG07YS5Qb2x5VHlwPT1kLlBvbHlUeXBlLnB0U3ViamVjdD8oaz10aGlzLm1fU3ViakZpbGxUeXBlLG09dGhpcy5tX0NsaXBGaWxsVHlwZSk6KGs9dGhpcy5tX0NsaXBGaWxsVHlwZSxtPXRoaXMubV9TdWJqRmlsbFR5cGUpO2IuUG9seVR5cD09ZC5Qb2x5VHlwZS5wdFN1YmplY3Q/KG49dGhpcy5tX1N1YmpGaWxsVHlwZSxsPXRoaXMubV9DbGlwRmlsbFR5cGUpOlxuKG49dGhpcy5tX0NsaXBGaWxsVHlwZSxsPXRoaXMubV9TdWJqRmlsbFR5cGUpO3N3aXRjaChrKXtjYXNlIGQuUG9seUZpbGxUeXBlLnBmdFBvc2l0aXZlOms9YS5XaW5kQ250O2JyZWFrO2Nhc2UgZC5Qb2x5RmlsbFR5cGUucGZ0TmVnYXRpdmU6az0tYS5XaW5kQ250O2JyZWFrO2RlZmF1bHQ6az1NYXRoLmFicyhhLldpbmRDbnQpfXN3aXRjaChuKXtjYXNlIGQuUG9seUZpbGxUeXBlLnBmdFBvc2l0aXZlOm49Yi5XaW5kQ250O2JyZWFrO2Nhc2UgZC5Qb2x5RmlsbFR5cGUucGZ0TmVnYXRpdmU6bj0tYi5XaW5kQ250O2JyZWFrO2RlZmF1bHQ6bj1NYXRoLmFicyhiLldpbmRDbnQpfWlmKGcmJmgpZnx8ZXx8MCE9PWsmJjEhPWt8fDAhPT1uJiYxIT1ufHxhLlBvbHlUeXAhPWIuUG9seVR5cCYmdGhpcy5tX0NsaXBUeXBlIT1kLkNsaXBUeXBlLmN0WG9yP3RoaXMuQWRkTG9jYWxNYXhQb2x5KGEsYixjKToodGhpcy5BZGRPdXRQdChhLGMpLHRoaXMuQWRkT3V0UHQoYixjKSxkLkNsaXBwZXIuU3dhcFNpZGVzKGEsXG5iKSxkLkNsaXBwZXIuU3dhcFBvbHlJbmRleGVzKGEsYikpO2Vsc2UgaWYoZyl7aWYoMD09PW58fDE9PW4pdGhpcy5BZGRPdXRQdChhLGMpLGQuQ2xpcHBlci5Td2FwU2lkZXMoYSxiKSxkLkNsaXBwZXIuU3dhcFBvbHlJbmRleGVzKGEsYil9ZWxzZSBpZihoKXtpZigwPT09a3x8MT09ayl0aGlzLkFkZE91dFB0KGIsYyksZC5DbGlwcGVyLlN3YXBTaWRlcyhhLGIpLGQuQ2xpcHBlci5Td2FwUG9seUluZGV4ZXMoYSxiKX1lbHNlIGlmKCEoMCE9PWsmJjEhPWt8fDAhPT1uJiYxIT1ufHxmfHxlKSl7c3dpdGNoKG0pe2Nhc2UgZC5Qb2x5RmlsbFR5cGUucGZ0UG9zaXRpdmU6Zz1hLldpbmRDbnQyO2JyZWFrO2Nhc2UgZC5Qb2x5RmlsbFR5cGUucGZ0TmVnYXRpdmU6Zz0tYS5XaW5kQ250MjticmVhaztkZWZhdWx0Omc9TWF0aC5hYnMoYS5XaW5kQ250Mil9c3dpdGNoKGwpe2Nhc2UgZC5Qb2x5RmlsbFR5cGUucGZ0UG9zaXRpdmU6aD1iLldpbmRDbnQyO2JyZWFrO2Nhc2UgZC5Qb2x5RmlsbFR5cGUucGZ0TmVnYXRpdmU6aD1cbi1iLldpbmRDbnQyO2JyZWFrO2RlZmF1bHQ6aD1NYXRoLmFicyhiLldpbmRDbnQyKX1pZihhLlBvbHlUeXAhPWIuUG9seVR5cCl0aGlzLkFkZExvY2FsTWluUG9seShhLGIsYyk7ZWxzZSBpZigxPT1rJiYxPT1uKXN3aXRjaCh0aGlzLm1fQ2xpcFR5cGUpe2Nhc2UgZC5DbGlwVHlwZS5jdEludGVyc2VjdGlvbjowPGcmJjA8aCYmdGhpcy5BZGRMb2NhbE1pblBvbHkoYSxiLGMpO2JyZWFrO2Nhc2UgZC5DbGlwVHlwZS5jdFVuaW9uOjA+PWcmJjA+PWgmJnRoaXMuQWRkTG9jYWxNaW5Qb2x5KGEsYixjKTticmVhaztjYXNlIGQuQ2xpcFR5cGUuY3REaWZmZXJlbmNlOihhLlBvbHlUeXA9PWQuUG9seVR5cGUucHRDbGlwJiYwPGcmJjA8aHx8YS5Qb2x5VHlwPT1kLlBvbHlUeXBlLnB0U3ViamVjdCYmMD49ZyYmMD49aCkmJnRoaXMuQWRkTG9jYWxNaW5Qb2x5KGEsYixjKTticmVhaztjYXNlIGQuQ2xpcFR5cGUuY3RYb3I6dGhpcy5BZGRMb2NhbE1pblBvbHkoYSxiLGMpfWVsc2UgZC5DbGlwcGVyLlN3YXBTaWRlcyhhLFxuYil9ZiE9ZSYmKGYmJjA8PWEuT3V0SWR4fHxlJiYwPD1iLk91dElkeCkmJihkLkNsaXBwZXIuU3dhcFNpZGVzKGEsYiksZC5DbGlwcGVyLlN3YXBQb2x5SW5kZXhlcyhhLGIpKTtmJiZ0aGlzLkRlbGV0ZUZyb21BRUwoYSk7ZSYmdGhpcy5EZWxldGVGcm9tQUVMKGIpfX07ZC5DbGlwcGVyLnByb3RvdHlwZS5EZWxldGVGcm9tQUVMPWZ1bmN0aW9uKGEpe3ZhciBiPWEuUHJldkluQUVMLGM9YS5OZXh0SW5BRUw7aWYobnVsbCE9PWJ8fG51bGwhPT1jfHxhPT10aGlzLm1fQWN0aXZlRWRnZXMpbnVsbCE9PWI/Yi5OZXh0SW5BRUw9Yzp0aGlzLm1fQWN0aXZlRWRnZXM9YyxudWxsIT09YyYmKGMuUHJldkluQUVMPWIpLGEuTmV4dEluQUVMPW51bGwsYS5QcmV2SW5BRUw9bnVsbH07ZC5DbGlwcGVyLnByb3RvdHlwZS5EZWxldGVGcm9tU0VMPWZ1bmN0aW9uKGEpe3ZhciBiPWEuUHJldkluU0VMLGM9YS5OZXh0SW5TRUw7aWYobnVsbCE9PWJ8fG51bGwhPT1jfHxhPT10aGlzLm1fU29ydGVkRWRnZXMpbnVsbCE9PVxuYj9iLk5leHRJblNFTD1jOnRoaXMubV9Tb3J0ZWRFZGdlcz1jLG51bGwhPT1jJiYoYy5QcmV2SW5TRUw9YiksYS5OZXh0SW5TRUw9bnVsbCxhLlByZXZJblNFTD1udWxsfTtkLkNsaXBwZXIucHJvdG90eXBlLlVwZGF0ZUVkZ2VJbnRvQUVMPWZ1bmN0aW9uKGEpe251bGw9PT1hLk5leHRJbkxNTCYmZC5FcnJvcihcIlVwZGF0ZUVkZ2VJbnRvQUVMOiBpbnZhbGlkIGNhbGxcIik7dmFyIGI9YS5QcmV2SW5BRUwsYz1hLk5leHRJbkFFTDthLk5leHRJbkxNTC5PdXRJZHg9YS5PdXRJZHg7bnVsbCE9PWI/Yi5OZXh0SW5BRUw9YS5OZXh0SW5MTUw6dGhpcy5tX0FjdGl2ZUVkZ2VzPWEuTmV4dEluTE1MO251bGwhPT1jJiYoYy5QcmV2SW5BRUw9YS5OZXh0SW5MTUwpO2EuTmV4dEluTE1MLlNpZGU9YS5TaWRlO2EuTmV4dEluTE1MLldpbmREZWx0YT1hLldpbmREZWx0YTthLk5leHRJbkxNTC5XaW5kQ250PWEuV2luZENudDthLk5leHRJbkxNTC5XaW5kQ250Mj1hLldpbmRDbnQyO2E9YS5OZXh0SW5MTUw7XG5hLkN1cnIuWD1hLkJvdC5YO2EuQ3Vyci5ZPWEuQm90Llk7YS5QcmV2SW5BRUw9YjthLk5leHRJbkFFTD1jO2QuQ2xpcHBlckJhc2UuSXNIb3Jpem9udGFsKGEpfHx0aGlzLkluc2VydFNjYW5iZWFtKGEuVG9wLlkpO3JldHVybiBhfTtkLkNsaXBwZXIucHJvdG90eXBlLlByb2Nlc3NIb3Jpem9udGFscz1mdW5jdGlvbihhKXtmb3IodmFyIGI9dGhpcy5tX1NvcnRlZEVkZ2VzO251bGwhPT1iOyl0aGlzLkRlbGV0ZUZyb21TRUwoYiksdGhpcy5Qcm9jZXNzSG9yaXpvbnRhbChiLGEpLGI9dGhpcy5tX1NvcnRlZEVkZ2VzfTtkLkNsaXBwZXIucHJvdG90eXBlLkdldEhvcnpEaXJlY3Rpb249ZnVuY3Rpb24oYSxiKXthLkJvdC5YPGEuVG9wLlg/KGIuTGVmdD1hLkJvdC5YLGIuUmlnaHQ9YS5Ub3AuWCxiLkRpcj1kLkRpcmVjdGlvbi5kTGVmdFRvUmlnaHQpOihiLkxlZnQ9YS5Ub3AuWCxiLlJpZ2h0PWEuQm90LlgsYi5EaXI9ZC5EaXJlY3Rpb24uZFJpZ2h0VG9MZWZ0KX07ZC5DbGlwcGVyLnByb3RvdHlwZS5QcmVwYXJlSG9yekpvaW5zPVxuZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLm1fUG9seU91dHNbYS5PdXRJZHhdLlB0czthLlNpZGUhPWQuRWRnZVNpZGUuZXNMZWZ0JiYoYz1jLlByZXYpO2ImJihkLkludFBvaW50Lm9wX0VxdWFsaXR5KGMuUHQsYS5Ub3ApP3RoaXMuQWRkR2hvc3RKb2luKGMsYS5Cb3QpOnRoaXMuQWRkR2hvc3RKb2luKGMsYS5Ub3ApKX07ZC5DbGlwcGVyLnByb3RvdHlwZS5Qcm9jZXNzSG9yaXpvbnRhbD1mdW5jdGlvbihhLGIpe3ZhciBjPXtEaXI6bnVsbCxMZWZ0Om51bGwsUmlnaHQ6bnVsbH07dGhpcy5HZXRIb3J6RGlyZWN0aW9uKGEsYyk7Zm9yKHZhciBlPWMuRGlyLGY9Yy5MZWZ0LGc9Yy5SaWdodCxoPWEsbD1udWxsO251bGwhPT1oLk5leHRJbkxNTCYmZC5DbGlwcGVyQmFzZS5Jc0hvcml6b250YWwoaC5OZXh0SW5MTUwpOyloPWguTmV4dEluTE1MO2ZvcihudWxsPT09aC5OZXh0SW5MTUwmJihsPXRoaXMuR2V0TWF4aW1hUGFpcihoKSk7Oyl7Zm9yKHZhciBrPWE9PWgsbj10aGlzLkdldE5leHRJbkFFTChhLFxuZSk7bnVsbCE9PW4mJiEobi5DdXJyLlg9PWEuVG9wLlgmJm51bGwhPT1hLk5leHRJbkxNTCYmbi5EeDxhLk5leHRJbkxNTC5EeCk7KXtjPXRoaXMuR2V0TmV4dEluQUVMKG4sZSk7aWYoZT09ZC5EaXJlY3Rpb24uZExlZnRUb1JpZ2h0JiZuLkN1cnIuWDw9Z3x8ZT09ZC5EaXJlY3Rpb24uZFJpZ2h0VG9MZWZ0JiZuLkN1cnIuWD49Zil7MDw9YS5PdXRJZHgmJjAhPWEuV2luZERlbHRhJiZ0aGlzLlByZXBhcmVIb3J6Sm9pbnMoYSxiKTtpZihuPT1sJiZrKXtlPT1kLkRpcmVjdGlvbi5kTGVmdFRvUmlnaHQ/dGhpcy5JbnRlcnNlY3RFZGdlcyhhLG4sbi5Ub3AsITEpOnRoaXMuSW50ZXJzZWN0RWRnZXMobixhLG4uVG9wLCExKTswPD1sLk91dElkeCYmZC5FcnJvcihcIlByb2Nlc3NIb3Jpem9udGFsIGVycm9yXCIpO3JldHVybn1pZihlPT1kLkRpcmVjdGlvbi5kTGVmdFRvUmlnaHQpe3ZhciBtPW5ldyBkLkludFBvaW50KG4uQ3Vyci5YLGEuQ3Vyci5ZKTt0aGlzLkludGVyc2VjdEVkZ2VzKGEsXG5uLG0sITApfWVsc2UgbT1uZXcgZC5JbnRQb2ludChuLkN1cnIuWCxhLkN1cnIuWSksdGhpcy5JbnRlcnNlY3RFZGdlcyhuLGEsbSwhMCk7dGhpcy5Td2FwUG9zaXRpb25zSW5BRUwoYSxuKX1lbHNlIGlmKGU9PWQuRGlyZWN0aW9uLmRMZWZ0VG9SaWdodCYmbi5DdXJyLlg+PWd8fGU9PWQuRGlyZWN0aW9uLmRSaWdodFRvTGVmdCYmbi5DdXJyLlg8PWYpYnJlYWs7bj1jfTA8PWEuT3V0SWR4JiYwIT09YS5XaW5kRGVsdGEmJnRoaXMuUHJlcGFyZUhvcnpKb2lucyhhLGIpO2lmKG51bGwhPT1hLk5leHRJbkxNTCYmZC5DbGlwcGVyQmFzZS5Jc0hvcml6b250YWwoYS5OZXh0SW5MTUwpKWE9dGhpcy5VcGRhdGVFZGdlSW50b0FFTChhKSwwPD1hLk91dElkeCYmdGhpcy5BZGRPdXRQdChhLGEuQm90KSxjPXtEaXI6ZSxMZWZ0OmYsUmlnaHQ6Z30sdGhpcy5HZXRIb3J6RGlyZWN0aW9uKGEsYyksZT1jLkRpcixmPWMuTGVmdCxnPWMuUmlnaHQ7ZWxzZSBicmVha31udWxsIT09YS5OZXh0SW5MTUw/XG4wPD1hLk91dElkeD8oZT10aGlzLkFkZE91dFB0KGEsYS5Ub3ApLGE9dGhpcy5VcGRhdGVFZGdlSW50b0FFTChhKSwwIT09YS5XaW5kRGVsdGEmJihmPWEuUHJldkluQUVMLGM9YS5OZXh0SW5BRUwsbnVsbCE9PWYmJmYuQ3Vyci5YPT1hLkJvdC5YJiZmLkN1cnIuWT09YS5Cb3QuWSYmMCE9PWYuV2luZERlbHRhJiYwPD1mLk91dElkeCYmZi5DdXJyLlk+Zi5Ub3AuWSYmZC5DbGlwcGVyQmFzZS5TbG9wZXNFcXVhbChhLGYsdGhpcy5tX1VzZUZ1bGxSYW5nZSk/KGM9dGhpcy5BZGRPdXRQdChmLGEuQm90KSx0aGlzLkFkZEpvaW4oZSxjLGEuVG9wKSk6bnVsbCE9PWMmJmMuQ3Vyci5YPT1hLkJvdC5YJiZjLkN1cnIuWT09YS5Cb3QuWSYmMCE9PWMuV2luZERlbHRhJiYwPD1jLk91dElkeCYmYy5DdXJyLlk+Yy5Ub3AuWSYmZC5DbGlwcGVyQmFzZS5TbG9wZXNFcXVhbChhLGMsdGhpcy5tX1VzZUZ1bGxSYW5nZSkmJihjPXRoaXMuQWRkT3V0UHQoYyxhLkJvdCksdGhpcy5BZGRKb2luKGUsYyxcbmEuVG9wKSkpKTp0aGlzLlVwZGF0ZUVkZ2VJbnRvQUVMKGEpOm51bGwhPT1sPzA8PWwuT3V0SWR4PyhlPT1kLkRpcmVjdGlvbi5kTGVmdFRvUmlnaHQ/dGhpcy5JbnRlcnNlY3RFZGdlcyhhLGwsYS5Ub3AsITEpOnRoaXMuSW50ZXJzZWN0RWRnZXMobCxhLGEuVG9wLCExKSwwPD1sLk91dElkeCYmZC5FcnJvcihcIlByb2Nlc3NIb3Jpem9udGFsIGVycm9yXCIpKToodGhpcy5EZWxldGVGcm9tQUVMKGEpLHRoaXMuRGVsZXRlRnJvbUFFTChsKSk6KDA8PWEuT3V0SWR4JiZ0aGlzLkFkZE91dFB0KGEsYS5Ub3ApLHRoaXMuRGVsZXRlRnJvbUFFTChhKSl9O2QuQ2xpcHBlci5wcm90b3R5cGUuR2V0TmV4dEluQUVMPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGI9PWQuRGlyZWN0aW9uLmRMZWZ0VG9SaWdodD9hLk5leHRJbkFFTDphLlByZXZJbkFFTH07ZC5DbGlwcGVyLnByb3RvdHlwZS5Jc01pbmltYT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9PWEmJmEuUHJldi5OZXh0SW5MTUwhPWEmJmEuTmV4dC5OZXh0SW5MTUwhPVxuYX07ZC5DbGlwcGVyLnByb3RvdHlwZS5Jc01heGltYT1mdW5jdGlvbihhLGIpe3JldHVybiBudWxsIT09YSYmYS5Ub3AuWT09YiYmbnVsbD09PWEuTmV4dEluTE1MfTtkLkNsaXBwZXIucHJvdG90eXBlLklzSW50ZXJtZWRpYXRlPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuVG9wLlk9PWImJm51bGwhPT1hLk5leHRJbkxNTH07ZC5DbGlwcGVyLnByb3RvdHlwZS5HZXRNYXhpbWFQYWlyPWZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7ZC5JbnRQb2ludC5vcF9FcXVhbGl0eShhLk5leHQuVG9wLGEuVG9wKSYmbnVsbD09PWEuTmV4dC5OZXh0SW5MTUw/Yj1hLk5leHQ6ZC5JbnRQb2ludC5vcF9FcXVhbGl0eShhLlByZXYuVG9wLGEuVG9wKSYmbnVsbD09PWEuUHJldi5OZXh0SW5MTUwmJihiPWEuUHJldik7cmV0dXJuIG51bGw9PT1ifHwtMiE9Yi5PdXRJZHgmJihiLk5leHRJbkFFTCE9Yi5QcmV2SW5BRUx8fGQuQ2xpcHBlckJhc2UuSXNIb3Jpem9udGFsKGIpKT9iOm51bGx9O2QuQ2xpcHBlci5wcm90b3R5cGUuUHJvY2Vzc0ludGVyc2VjdGlvbnM9XG5mdW5jdGlvbihhLGIpe2lmKG51bGw9PXRoaXMubV9BY3RpdmVFZGdlcylyZXR1cm4hMDt0cnl7dGhpcy5CdWlsZEludGVyc2VjdExpc3QoYSxiKTtpZigwPT10aGlzLm1fSW50ZXJzZWN0TGlzdC5sZW5ndGgpcmV0dXJuITA7aWYoMT09dGhpcy5tX0ludGVyc2VjdExpc3QubGVuZ3RofHx0aGlzLkZpeHVwSW50ZXJzZWN0aW9uT3JkZXIoKSl0aGlzLlByb2Nlc3NJbnRlcnNlY3RMaXN0KCk7ZWxzZSByZXR1cm4hMX1jYXRjaChjKXt0aGlzLm1fU29ydGVkRWRnZXM9bnVsbCx0aGlzLm1fSW50ZXJzZWN0TGlzdC5sZW5ndGg9MCxkLkVycm9yKFwiUHJvY2Vzc0ludGVyc2VjdGlvbnMgZXJyb3JcIil9dGhpcy5tX1NvcnRlZEVkZ2VzPW51bGw7cmV0dXJuITB9O2QuQ2xpcHBlci5wcm90b3R5cGUuQnVpbGRJbnRlcnNlY3RMaXN0PWZ1bmN0aW9uKGEsYil7aWYobnVsbCE9PXRoaXMubV9BY3RpdmVFZGdlcyl7dmFyIGM9dGhpcy5tX0FjdGl2ZUVkZ2VzO2Zvcih0aGlzLm1fU29ydGVkRWRnZXM9YztudWxsIT09XG5jOyljLlByZXZJblNFTD1jLlByZXZJbkFFTCxjLk5leHRJblNFTD1jLk5leHRJbkFFTCxjLkN1cnIuWD1kLkNsaXBwZXIuVG9wWChjLGIpLGM9Yy5OZXh0SW5BRUw7Zm9yKHZhciBlPSEwO2UmJm51bGwhPT10aGlzLm1fU29ydGVkRWRnZXM7KXtlPSExO2ZvcihjPXRoaXMubV9Tb3J0ZWRFZGdlcztudWxsIT09Yy5OZXh0SW5TRUw7KXt2YXIgZj1jLk5leHRJblNFTCxnPW5ldyBkLkludFBvaW50O2MuQ3Vyci5YPmYuQ3Vyci5YPyghdGhpcy5JbnRlcnNlY3RQb2ludChjLGYsZykmJmMuQ3Vyci5YPmYuQ3Vyci5YKzEmJmQuRXJyb3IoXCJJbnRlcnNlY3Rpb24gZXJyb3JcIiksZy5ZPmEmJihnLlk9YSxNYXRoLmFicyhjLkR4KT5NYXRoLmFicyhmLkR4KT9nLlg9ZC5DbGlwcGVyLlRvcFgoZixhKTpnLlg9ZC5DbGlwcGVyLlRvcFgoYyxhKSksZT1uZXcgZC5JbnRlcnNlY3ROb2RlLGUuRWRnZTE9YyxlLkVkZ2UyPWYsZS5QdC5YPWcuWCxlLlB0Llk9Zy5ZLHRoaXMubV9JbnRlcnNlY3RMaXN0LnB1c2goZSksXG50aGlzLlN3YXBQb3NpdGlvbnNJblNFTChjLGYpLGU9ITApOmM9Zn1pZihudWxsIT09Yy5QcmV2SW5TRUwpYy5QcmV2SW5TRUwuTmV4dEluU0VMPW51bGw7ZWxzZSBicmVha310aGlzLm1fU29ydGVkRWRnZXM9bnVsbH19O2QuQ2xpcHBlci5wcm90b3R5cGUuRWRnZXNBZGphY2VudD1mdW5jdGlvbihhKXtyZXR1cm4gYS5FZGdlMS5OZXh0SW5TRUw9PWEuRWRnZTJ8fGEuRWRnZTEuUHJldkluU0VMPT1hLkVkZ2UyfTtkLkNsaXBwZXIuSW50ZXJzZWN0Tm9kZVNvcnQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi5QdC5ZLWEuUHQuWX07ZC5DbGlwcGVyLnByb3RvdHlwZS5GaXh1cEludGVyc2VjdGlvbk9yZGVyPWZ1bmN0aW9uKCl7dGhpcy5tX0ludGVyc2VjdExpc3Quc29ydCh0aGlzLm1fSW50ZXJzZWN0Tm9kZUNvbXBhcmVyKTt0aGlzLkNvcHlBRUxUb1NFTCgpO2Zvcih2YXIgYT10aGlzLm1fSW50ZXJzZWN0TGlzdC5sZW5ndGgsYj0wO2I8YTtiKyspe2lmKCF0aGlzLkVkZ2VzQWRqYWNlbnQodGhpcy5tX0ludGVyc2VjdExpc3RbYl0pKXtmb3IodmFyIGM9XG5iKzE7YzxhJiYhdGhpcy5FZGdlc0FkamFjZW50KHRoaXMubV9JbnRlcnNlY3RMaXN0W2NdKTspYysrO2lmKGM9PWEpcmV0dXJuITE7dmFyIGU9dGhpcy5tX0ludGVyc2VjdExpc3RbYl07dGhpcy5tX0ludGVyc2VjdExpc3RbYl09dGhpcy5tX0ludGVyc2VjdExpc3RbY107dGhpcy5tX0ludGVyc2VjdExpc3RbY109ZX10aGlzLlN3YXBQb3NpdGlvbnNJblNFTCh0aGlzLm1fSW50ZXJzZWN0TGlzdFtiXS5FZGdlMSx0aGlzLm1fSW50ZXJzZWN0TGlzdFtiXS5FZGdlMil9cmV0dXJuITB9O2QuQ2xpcHBlci5wcm90b3R5cGUuUHJvY2Vzc0ludGVyc2VjdExpc3Q9ZnVuY3Rpb24oKXtmb3IodmFyIGE9MCxiPXRoaXMubV9JbnRlcnNlY3RMaXN0Lmxlbmd0aDthPGI7YSsrKXt2YXIgYz10aGlzLm1fSW50ZXJzZWN0TGlzdFthXTt0aGlzLkludGVyc2VjdEVkZ2VzKGMuRWRnZTEsYy5FZGdlMixjLlB0LCEwKTt0aGlzLlN3YXBQb3NpdGlvbnNJbkFFTChjLkVkZ2UxLGMuRWRnZTIpfXRoaXMubV9JbnRlcnNlY3RMaXN0Lmxlbmd0aD1cbjB9O0U9ZnVuY3Rpb24oYSl7cmV0dXJuIDA+YT9NYXRoLmNlaWwoYS0wLjUpOk1hdGgucm91bmQoYSl9O0Y9ZnVuY3Rpb24oYSl7cmV0dXJuIDA+YT9NYXRoLmNlaWwoYS0wLjUpOk1hdGguZmxvb3IoYSswLjUpfTtHPWZ1bmN0aW9uKGEpe3JldHVybiAwPmE/LU1hdGgucm91bmQoTWF0aC5hYnMoYSkpOk1hdGgucm91bmQoYSl9O0g9ZnVuY3Rpb24oYSl7aWYoMD5hKXJldHVybiBhLT0wLjUsLTIxNDc0ODM2NDg+YT9NYXRoLmNlaWwoYSk6YXwwO2ErPTAuNTtyZXR1cm4gMjE0NzQ4MzY0NzxhP01hdGguZmxvb3IoYSk6YXwwfTtkLkNsaXBwZXIuUm91bmQ9cD9FOkQ/RzpKP0g6RjtkLkNsaXBwZXIuVG9wWD1mdW5jdGlvbihhLGIpe3JldHVybiBiPT1hLlRvcC5ZP2EuVG9wLlg6YS5Cb3QuWCtkLkNsaXBwZXIuUm91bmQoYS5EeCooYi1hLkJvdC5ZKSl9O2QuQ2xpcHBlci5wcm90b3R5cGUuSW50ZXJzZWN0UG9pbnQ9ZnVuY3Rpb24oYSxiLGMpe2MuWD0wO2MuWT0wO3ZhciBlLGY7aWYoZC5DbGlwcGVyQmFzZS5TbG9wZXNFcXVhbChhLFxuYix0aGlzLm1fVXNlRnVsbFJhbmdlKXx8YS5EeD09Yi5EeClyZXR1cm4gYi5Cb3QuWT5hLkJvdC5ZPyhjLlg9Yi5Cb3QuWCxjLlk9Yi5Cb3QuWSk6KGMuWD1hLkJvdC5YLGMuWT1hLkJvdC5ZKSwhMTtpZigwPT09YS5EZWx0YS5YKWMuWD1hLkJvdC5YLGQuQ2xpcHBlckJhc2UuSXNIb3Jpem9udGFsKGIpP2MuWT1iLkJvdC5ZOihmPWIuQm90LlktYi5Cb3QuWC9iLkR4LGMuWT1kLkNsaXBwZXIuUm91bmQoYy5YL2IuRHgrZikpO2Vsc2UgaWYoMD09PWIuRGVsdGEuWCljLlg9Yi5Cb3QuWCxkLkNsaXBwZXJCYXNlLklzSG9yaXpvbnRhbChhKT9jLlk9YS5Cb3QuWTooZT1hLkJvdC5ZLWEuQm90LlgvYS5EeCxjLlk9ZC5DbGlwcGVyLlJvdW5kKGMuWC9hLkR4K2UpKTtlbHNle2U9YS5Cb3QuWC1hLkJvdC5ZKmEuRHg7Zj1iLkJvdC5YLWIuQm90LlkqYi5EeDt2YXIgZz0oZi1lKS8oYS5EeC1iLkR4KTtjLlk9ZC5DbGlwcGVyLlJvdW5kKGcpO01hdGguYWJzKGEuRHgpPE1hdGguYWJzKGIuRHgpP1xuYy5YPWQuQ2xpcHBlci5Sb3VuZChhLkR4KmcrZSk6Yy5YPWQuQ2xpcHBlci5Sb3VuZChiLkR4KmcrZil9aWYoYy5ZPGEuVG9wLll8fGMuWTxiLlRvcC5ZKXtpZihhLlRvcC5ZPmIuVG9wLlkpcmV0dXJuIGMuWT1hLlRvcC5ZLGMuWD1kLkNsaXBwZXIuVG9wWChiLGEuVG9wLlkpLGMuWDxhLlRvcC5YO2MuWT1iLlRvcC5ZO01hdGguYWJzKGEuRHgpPE1hdGguYWJzKGIuRHgpP2MuWD1kLkNsaXBwZXIuVG9wWChhLGMuWSk6Yy5YPWQuQ2xpcHBlci5Ub3BYKGIsYy5ZKX1yZXR1cm4hMH07ZC5DbGlwcGVyLnByb3RvdHlwZS5Qcm9jZXNzRWRnZXNBdFRvcE9mU2NhbmJlYW09ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPXRoaXMubV9BY3RpdmVFZGdlcztudWxsIT09Yjspe3ZhciBjPXRoaXMuSXNNYXhpbWEoYixhKTtjJiYoYz10aGlzLkdldE1heGltYVBhaXIoYiksYz1udWxsPT09Y3x8IWQuQ2xpcHBlckJhc2UuSXNIb3Jpem9udGFsKGMpKTtpZihjKXt2YXIgZT1iLlByZXZJbkFFTDt0aGlzLkRvTWF4aW1hKGIpO1xuYj1udWxsPT09ZT90aGlzLm1fQWN0aXZlRWRnZXM6ZS5OZXh0SW5BRUx9ZWxzZSB0aGlzLklzSW50ZXJtZWRpYXRlKGIsYSkmJmQuQ2xpcHBlckJhc2UuSXNIb3Jpem9udGFsKGIuTmV4dEluTE1MKT8oYj10aGlzLlVwZGF0ZUVkZ2VJbnRvQUVMKGIpLDA8PWIuT3V0SWR4JiZ0aGlzLkFkZE91dFB0KGIsYi5Cb3QpLHRoaXMuQWRkRWRnZVRvU0VMKGIpKTooYi5DdXJyLlg9ZC5DbGlwcGVyLlRvcFgoYixhKSxiLkN1cnIuWT1hKSx0aGlzLlN0cmljdGx5U2ltcGxlJiYoZT1iLlByZXZJbkFFTCwwPD1iLk91dElkeCYmMCE9PWIuV2luZERlbHRhJiZudWxsIT09ZSYmMDw9ZS5PdXRJZHgmJmUuQ3Vyci5YPT1iLkN1cnIuWCYmMCE9PWUuV2luZERlbHRhJiYoYz10aGlzLkFkZE91dFB0KGUsYi5DdXJyKSxlPXRoaXMuQWRkT3V0UHQoYixiLkN1cnIpLHRoaXMuQWRkSm9pbihjLGUsYi5DdXJyKSkpLGI9Yi5OZXh0SW5BRUx9dGhpcy5Qcm9jZXNzSG9yaXpvbnRhbHMoITApO2ZvcihiPXRoaXMubV9BY3RpdmVFZGdlcztudWxsIT09XG5iOyl7aWYodGhpcy5Jc0ludGVybWVkaWF0ZShiLGEpKXtjPW51bGw7MDw9Yi5PdXRJZHgmJihjPXRoaXMuQWRkT3V0UHQoYixiLlRvcCkpO3ZhciBiPXRoaXMuVXBkYXRlRWRnZUludG9BRUwoYiksZT1iLlByZXZJbkFFTCxmPWIuTmV4dEluQUVMO251bGwhPT1lJiZlLkN1cnIuWD09Yi5Cb3QuWCYmZS5DdXJyLlk9PWIuQm90LlkmJm51bGwhPT1jJiYwPD1lLk91dElkeCYmZS5DdXJyLlk+ZS5Ub3AuWSYmZC5DbGlwcGVyQmFzZS5TbG9wZXNFcXVhbChiLGUsdGhpcy5tX1VzZUZ1bGxSYW5nZSkmJjAhPT1iLldpbmREZWx0YSYmMCE9PWUuV2luZERlbHRhPyhlPXRoaXMuQWRkT3V0UHQoZSxiLkJvdCksdGhpcy5BZGRKb2luKGMsZSxiLlRvcCkpOm51bGwhPT1mJiZmLkN1cnIuWD09Yi5Cb3QuWCYmZi5DdXJyLlk9PWIuQm90LlkmJm51bGwhPT1jJiYwPD1mLk91dElkeCYmZi5DdXJyLlk+Zi5Ub3AuWSYmZC5DbGlwcGVyQmFzZS5TbG9wZXNFcXVhbChiLGYsdGhpcy5tX1VzZUZ1bGxSYW5nZSkmJlxuMCE9PWIuV2luZERlbHRhJiYwIT09Zi5XaW5kRGVsdGEmJihlPXRoaXMuQWRkT3V0UHQoZixiLkJvdCksdGhpcy5BZGRKb2luKGMsZSxiLlRvcCkpfWI9Yi5OZXh0SW5BRUx9fTtkLkNsaXBwZXIucHJvdG90eXBlLkRvTWF4aW1hPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuR2V0TWF4aW1hUGFpcihhKTtpZihudWxsPT09YikwPD1hLk91dElkeCYmdGhpcy5BZGRPdXRQdChhLGEuVG9wKSx0aGlzLkRlbGV0ZUZyb21BRUwoYSk7ZWxzZXtmb3IodmFyIGM9YS5OZXh0SW5BRUw7bnVsbCE9PWMmJmMhPWI7KXRoaXMuSW50ZXJzZWN0RWRnZXMoYSxjLGEuVG9wLCEwKSx0aGlzLlN3YXBQb3NpdGlvbnNJbkFFTChhLGMpLGM9YS5OZXh0SW5BRUw7LTE9PWEuT3V0SWR4JiYtMT09Yi5PdXRJZHg/KHRoaXMuRGVsZXRlRnJvbUFFTChhKSx0aGlzLkRlbGV0ZUZyb21BRUwoYikpOjA8PWEuT3V0SWR4JiYwPD1iLk91dElkeD90aGlzLkludGVyc2VjdEVkZ2VzKGEsYixhLlRvcCwhMSk6MD09PWEuV2luZERlbHRhP1xuKDA8PWEuT3V0SWR4JiYodGhpcy5BZGRPdXRQdChhLGEuVG9wKSxhLk91dElkeD0tMSksdGhpcy5EZWxldGVGcm9tQUVMKGEpLDA8PWIuT3V0SWR4JiYodGhpcy5BZGRPdXRQdChiLGEuVG9wKSxiLk91dElkeD0tMSksdGhpcy5EZWxldGVGcm9tQUVMKGIpKTpkLkVycm9yKFwiRG9NYXhpbWEgZXJyb3JcIil9fTtkLkNsaXBwZXIuUmV2ZXJzZVBhdGhzPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wLGM9YS5sZW5ndGg7YjxjO2IrKylhW2JdLnJldmVyc2UoKX07ZC5DbGlwcGVyLk9yaWVudGF0aW9uPWZ1bmN0aW9uKGEpe3JldHVybiAwPD1kLkNsaXBwZXIuQXJlYShhKX07ZC5DbGlwcGVyLnByb3RvdHlwZS5Qb2ludENvdW50PWZ1bmN0aW9uKGEpe2lmKG51bGw9PT1hKXJldHVybiAwO3ZhciBiPTAsYz1hO2RvIGIrKyxjPWMuTmV4dDt3aGlsZShjIT1hKTtyZXR1cm4gYn07ZC5DbGlwcGVyLnByb3RvdHlwZS5CdWlsZFJlc3VsdD1mdW5jdGlvbihhKXtkLkNsZWFyKGEpO2Zvcih2YXIgYj0wLGM9XG50aGlzLm1fUG9seU91dHMubGVuZ3RoO2I8YztiKyspe3ZhciBlPXRoaXMubV9Qb2x5T3V0c1tiXTtpZihudWxsIT09ZS5QdHMpe3ZhciBlPWUuUHRzLlByZXYsZj10aGlzLlBvaW50Q291bnQoZSk7aWYoISgyPmYpKXtmb3IodmFyIGc9QXJyYXkoZiksaD0wO2g8ZjtoKyspZ1toXT1lLlB0LGU9ZS5QcmV2O2EucHVzaChnKX19fX07ZC5DbGlwcGVyLnByb3RvdHlwZS5CdWlsZFJlc3VsdDI9ZnVuY3Rpb24oYSl7YS5DbGVhcigpO2Zvcih2YXIgYj0wLGM9dGhpcy5tX1BvbHlPdXRzLmxlbmd0aDtiPGM7YisrKXt2YXIgZT10aGlzLm1fUG9seU91dHNbYl0sZj10aGlzLlBvaW50Q291bnQoZS5QdHMpO2lmKCEoZS5Jc09wZW4mJjI+Znx8IWUuSXNPcGVuJiYzPmYpKXt0aGlzLkZpeEhvbGVMaW5rYWdlKGUpO3ZhciBnPW5ldyBkLlBvbHlOb2RlO2EubV9BbGxQb2x5cy5wdXNoKGcpO2UuUG9seU5vZGU9ZztnLm1fcG9seWdvbi5sZW5ndGg9Zjtmb3IodmFyIGU9ZS5QdHMuUHJldixoPTA7aDxcbmY7aCsrKWcubV9wb2x5Z29uW2hdPWUuUHQsZT1lLlByZXZ9fWI9MDtmb3IoYz10aGlzLm1fUG9seU91dHMubGVuZ3RoO2I8YztiKyspZT10aGlzLm1fUG9seU91dHNbYl0sbnVsbCE9PWUuUG9seU5vZGUmJihlLklzT3Blbj8oZS5Qb2x5Tm9kZS5Jc09wZW49ITAsYS5BZGRDaGlsZChlLlBvbHlOb2RlKSk6bnVsbCE9PWUuRmlyc3RMZWZ0JiZudWxsIT1lLkZpcnN0TGVmdC5Qb2x5Tm9kZT9lLkZpcnN0TGVmdC5Qb2x5Tm9kZS5BZGRDaGlsZChlLlBvbHlOb2RlKTphLkFkZENoaWxkKGUuUG9seU5vZGUpKX07ZC5DbGlwcGVyLnByb3RvdHlwZS5GaXh1cE91dFBvbHlnb249ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbDthLkJvdHRvbVB0PW51bGw7Zm9yKHZhciBjPWEuUHRzOzspe2lmKGMuUHJldj09Y3x8Yy5QcmV2PT1jLk5leHQpe3RoaXMuRGlzcG9zZU91dFB0cyhjKTthLlB0cz1udWxsO3JldHVybn1pZihkLkludFBvaW50Lm9wX0VxdWFsaXR5KGMuUHQsYy5OZXh0LlB0KXx8ZC5JbnRQb2ludC5vcF9FcXVhbGl0eShjLlB0LFxuYy5QcmV2LlB0KXx8ZC5DbGlwcGVyQmFzZS5TbG9wZXNFcXVhbChjLlByZXYuUHQsYy5QdCxjLk5leHQuUHQsdGhpcy5tX1VzZUZ1bGxSYW5nZSkmJighdGhpcy5QcmVzZXJ2ZUNvbGxpbmVhcnx8IXRoaXMuUHQySXNCZXR3ZWVuUHQxQW5kUHQzKGMuUHJldi5QdCxjLlB0LGMuTmV4dC5QdCkpKWI9bnVsbCxjLlByZXYuTmV4dD1jLk5leHQsYz1jLk5leHQuUHJldj1jLlByZXY7ZWxzZSBpZihjPT1iKWJyZWFrO2Vsc2UgbnVsbD09PWImJihiPWMpLGM9Yy5OZXh0fWEuUHRzPWN9O2QuQ2xpcHBlci5wcm90b3R5cGUuRHVwT3V0UHQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1uZXcgZC5PdXRQdDtjLlB0Llg9YS5QdC5YO2MuUHQuWT1hLlB0Llk7Yy5JZHg9YS5JZHg7Yj8oYy5OZXh0PWEuTmV4dCxjLlByZXY9YSxhLk5leHQuUHJldj1jLGEuTmV4dD1jKTooYy5QcmV2PWEuUHJldixjLk5leHQ9YSxhLlByZXYuTmV4dD1jLGEuUHJldj1jKTtyZXR1cm4gY307ZC5DbGlwcGVyLnByb3RvdHlwZS5HZXRPdmVybGFwPVxuZnVuY3Rpb24oYSxiLGMsZSxkKXthPGI/YzxlPyhkLkxlZnQ9TWF0aC5tYXgoYSxjKSxkLlJpZ2h0PU1hdGgubWluKGIsZSkpOihkLkxlZnQ9TWF0aC5tYXgoYSxlKSxkLlJpZ2h0PU1hdGgubWluKGIsYykpOmM8ZT8oZC5MZWZ0PU1hdGgubWF4KGIsYyksZC5SaWdodD1NYXRoLm1pbihhLGUpKTooZC5MZWZ0PU1hdGgubWF4KGIsZSksZC5SaWdodD1NYXRoLm1pbihhLGMpKTtyZXR1cm4gZC5MZWZ0PGQuUmlnaHR9O2QuQ2xpcHBlci5wcm90b3R5cGUuSm9pbkhvcno9ZnVuY3Rpb24oYSxiLGMsZSxmLGcpe3ZhciBoPWEuUHQuWD5iLlB0Llg/ZC5EaXJlY3Rpb24uZFJpZ2h0VG9MZWZ0OmQuRGlyZWN0aW9uLmRMZWZ0VG9SaWdodDtlPWMuUHQuWD5lLlB0Llg/ZC5EaXJlY3Rpb24uZFJpZ2h0VG9MZWZ0OmQuRGlyZWN0aW9uLmRMZWZ0VG9SaWdodDtpZihoPT1lKXJldHVybiExO2lmKGg9PWQuRGlyZWN0aW9uLmRMZWZ0VG9SaWdodCl7Zm9yKDthLk5leHQuUHQuWDw9Zi5YJiZhLk5leHQuUHQuWD49XG5hLlB0LlgmJmEuTmV4dC5QdC5ZPT1mLlk7KWE9YS5OZXh0O2cmJmEuUHQuWCE9Zi5YJiYoYT1hLk5leHQpO2I9dGhpcy5EdXBPdXRQdChhLCFnKTtkLkludFBvaW50Lm9wX0luZXF1YWxpdHkoYi5QdCxmKSYmKGE9YixhLlB0Llg9Zi5YLGEuUHQuWT1mLlksYj10aGlzLkR1cE91dFB0KGEsIWcpKX1lbHNle2Zvcig7YS5OZXh0LlB0Llg+PWYuWCYmYS5OZXh0LlB0Llg8PWEuUHQuWCYmYS5OZXh0LlB0Llk9PWYuWTspYT1hLk5leHQ7Z3x8YS5QdC5YPT1mLlh8fChhPWEuTmV4dCk7Yj10aGlzLkR1cE91dFB0KGEsZyk7ZC5JbnRQb2ludC5vcF9JbmVxdWFsaXR5KGIuUHQsZikmJihhPWIsYS5QdC5YPWYuWCxhLlB0Llk9Zi5ZLGI9dGhpcy5EdXBPdXRQdChhLGcpKX1pZihlPT1kLkRpcmVjdGlvbi5kTGVmdFRvUmlnaHQpe2Zvcig7Yy5OZXh0LlB0Llg8PWYuWCYmYy5OZXh0LlB0Llg+PWMuUHQuWCYmYy5OZXh0LlB0Llk9PWYuWTspYz1jLk5leHQ7ZyYmYy5QdC5YIT1mLlgmJihjPWMuTmV4dCk7XG5lPXRoaXMuRHVwT3V0UHQoYywhZyk7ZC5JbnRQb2ludC5vcF9JbmVxdWFsaXR5KGUuUHQsZikmJihjPWUsYy5QdC5YPWYuWCxjLlB0Llk9Zi5ZLGU9dGhpcy5EdXBPdXRQdChjLCFnKSl9ZWxzZXtmb3IoO2MuTmV4dC5QdC5YPj1mLlgmJmMuTmV4dC5QdC5YPD1jLlB0LlgmJmMuTmV4dC5QdC5ZPT1mLlk7KWM9Yy5OZXh0O2d8fGMuUHQuWD09Zi5YfHwoYz1jLk5leHQpO2U9dGhpcy5EdXBPdXRQdChjLGcpO2QuSW50UG9pbnQub3BfSW5lcXVhbGl0eShlLlB0LGYpJiYoYz1lLGMuUHQuWD1mLlgsYy5QdC5ZPWYuWSxlPXRoaXMuRHVwT3V0UHQoYyxnKSl9aD09ZC5EaXJlY3Rpb24uZExlZnRUb1JpZ2h0PT1nPyhhLlByZXY9YyxjLk5leHQ9YSxiLk5leHQ9ZSxlLlByZXY9Yik6KGEuTmV4dD1jLGMuUHJldj1hLGIuUHJldj1lLGUuTmV4dD1iKTtyZXR1cm4hMH07ZC5DbGlwcGVyLnByb3RvdHlwZS5Kb2luUG9pbnRzPWZ1bmN0aW9uKGEsYixjKXt2YXIgZT1hLk91dFB0MSxmPW5ldyBkLk91dFB0LFxuZz1hLk91dFB0MixoPW5ldyBkLk91dFB0O2lmKChoPWEuT3V0UHQxLlB0Llk9PWEuT2ZmUHQuWSkmJmQuSW50UG9pbnQub3BfRXF1YWxpdHkoYS5PZmZQdCxhLk91dFB0MS5QdCkmJmQuSW50UG9pbnQub3BfRXF1YWxpdHkoYS5PZmZQdCxhLk91dFB0Mi5QdCkpe2ZvcihmPWEuT3V0UHQxLk5leHQ7ZiE9ZSYmZC5JbnRQb2ludC5vcF9FcXVhbGl0eShmLlB0LGEuT2ZmUHQpOylmPWYuTmV4dDtmPWYuUHQuWT5hLk9mZlB0Llk7Zm9yKGg9YS5PdXRQdDIuTmV4dDtoIT1nJiZkLkludFBvaW50Lm9wX0VxdWFsaXR5KGguUHQsYS5PZmZQdCk7KWg9aC5OZXh0O2lmKGY9PWguUHQuWT5hLk9mZlB0LlkpcmV0dXJuITE7Zj8oZj10aGlzLkR1cE91dFB0KGUsITEpLGg9dGhpcy5EdXBPdXRQdChnLCEwKSxlLlByZXY9ZyxnLk5leHQ9ZSxmLk5leHQ9aCxoLlByZXY9Zik6KGY9dGhpcy5EdXBPdXRQdChlLCEwKSxoPXRoaXMuRHVwT3V0UHQoZywhMSksZS5OZXh0PWcsZy5QcmV2PWUsZi5QcmV2PWgsXG5oLk5leHQ9Zik7YS5PdXRQdDE9ZTthLk91dFB0Mj1mO3JldHVybiEwfWlmKGgpe2ZvcihmPWU7ZS5QcmV2LlB0Llk9PWUuUHQuWSYmZS5QcmV2IT1mJiZlLlByZXYhPWc7KWU9ZS5QcmV2O2Zvcig7Zi5OZXh0LlB0Llk9PWYuUHQuWSYmZi5OZXh0IT1lJiZmLk5leHQhPWc7KWY9Zi5OZXh0O2lmKGYuTmV4dD09ZXx8Zi5OZXh0PT1nKXJldHVybiExO2ZvcihoPWc7Zy5QcmV2LlB0Llk9PWcuUHQuWSYmZy5QcmV2IT1oJiZnLlByZXYhPWY7KWc9Zy5QcmV2O2Zvcig7aC5OZXh0LlB0Llk9PWguUHQuWSYmaC5OZXh0IT1nJiZoLk5leHQhPWU7KWg9aC5OZXh0O2lmKGguTmV4dD09Z3x8aC5OZXh0PT1lKXJldHVybiExO2M9e0xlZnQ6bnVsbCxSaWdodDpudWxsfTtpZighdGhpcy5HZXRPdmVybGFwKGUuUHQuWCxmLlB0LlgsZy5QdC5YLGguUHQuWCxjKSlyZXR1cm4hMTtiPWMuTGVmdDt2YXIgbD1jLlJpZ2h0O2M9bmV3IGQuSW50UG9pbnQ7ZS5QdC5YPj1iJiZlLlB0Llg8PWw/KGMuWD1lLlB0LlgsXG5jLlk9ZS5QdC5ZLGI9ZS5QdC5YPmYuUHQuWCk6Zy5QdC5YPj1iJiZnLlB0Llg8PWw/KGMuWD1nLlB0LlgsYy5ZPWcuUHQuWSxiPWcuUHQuWD5oLlB0LlgpOmYuUHQuWD49YiYmZi5QdC5YPD1sPyhjLlg9Zi5QdC5YLGMuWT1mLlB0LlksYj1mLlB0Llg+ZS5QdC5YKTooYy5YPWguUHQuWCxjLlk9aC5QdC5ZLGI9aC5QdC5YPmcuUHQuWCk7YS5PdXRQdDE9ZTthLk91dFB0Mj1nO3JldHVybiB0aGlzLkpvaW5Ib3J6KGUsZixnLGgsYyxiKX1mb3IoZj1lLk5leHQ7ZC5JbnRQb2ludC5vcF9FcXVhbGl0eShmLlB0LGUuUHQpJiZmIT1lOylmPWYuTmV4dDtpZihsPWYuUHQuWT5lLlB0Lll8fCFkLkNsaXBwZXJCYXNlLlNsb3Blc0VxdWFsKGUuUHQsZi5QdCxhLk9mZlB0LHRoaXMubV9Vc2VGdWxsUmFuZ2UpKXtmb3IoZj1lLlByZXY7ZC5JbnRQb2ludC5vcF9FcXVhbGl0eShmLlB0LGUuUHQpJiZmIT1lOylmPWYuUHJldjtpZihmLlB0Llk+ZS5QdC5ZfHwhZC5DbGlwcGVyQmFzZS5TbG9wZXNFcXVhbChlLlB0LFxuZi5QdCxhLk9mZlB0LHRoaXMubV9Vc2VGdWxsUmFuZ2UpKXJldHVybiExfWZvcihoPWcuTmV4dDtkLkludFBvaW50Lm9wX0VxdWFsaXR5KGguUHQsZy5QdCkmJmghPWc7KWg9aC5OZXh0O3ZhciBrPWguUHQuWT5nLlB0Lll8fCFkLkNsaXBwZXJCYXNlLlNsb3Blc0VxdWFsKGcuUHQsaC5QdCxhLk9mZlB0LHRoaXMubV9Vc2VGdWxsUmFuZ2UpO2lmKGspe2ZvcihoPWcuUHJldjtkLkludFBvaW50Lm9wX0VxdWFsaXR5KGguUHQsZy5QdCkmJmghPWc7KWg9aC5QcmV2O2lmKGguUHQuWT5nLlB0Lll8fCFkLkNsaXBwZXJCYXNlLlNsb3Blc0VxdWFsKGcuUHQsaC5QdCxhLk9mZlB0LHRoaXMubV9Vc2VGdWxsUmFuZ2UpKXJldHVybiExfWlmKGY9PWV8fGg9PWd8fGY9PWh8fGI9PWMmJmw9PWspcmV0dXJuITE7bD8oZj10aGlzLkR1cE91dFB0KGUsITEpLGg9dGhpcy5EdXBPdXRQdChnLCEwKSxlLlByZXY9ZyxnLk5leHQ9ZSxmLk5leHQ9aCxoLlByZXY9Zik6KGY9dGhpcy5EdXBPdXRQdChlLCEwKSxcbmg9dGhpcy5EdXBPdXRQdChnLCExKSxlLk5leHQ9ZyxnLlByZXY9ZSxmLlByZXY9aCxoLk5leHQ9Zik7YS5PdXRQdDE9ZTthLk91dFB0Mj1mO3JldHVybiEwfTtkLkNsaXBwZXIuR2V0Qm91bmRzPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wLGM9YS5sZW5ndGg7YjxjJiYwPT1hW2JdLmxlbmd0aDspYisrO2lmKGI9PWMpcmV0dXJuIG5ldyBkLkludFJlY3QoMCwwLDAsMCk7dmFyIGU9bmV3IGQuSW50UmVjdDtlLmxlZnQ9YVtiXVswXS5YO2UucmlnaHQ9ZS5sZWZ0O2UudG9wPWFbYl1bMF0uWTtmb3IoZS5ib3R0b209ZS50b3A7YjxjO2IrKylmb3IodmFyIGY9MCxnPWFbYl0ubGVuZ3RoO2Y8ZztmKyspYVtiXVtmXS5YPGUubGVmdD9lLmxlZnQ9YVtiXVtmXS5YOmFbYl1bZl0uWD5lLnJpZ2h0JiYoZS5yaWdodD1hW2JdW2ZdLlgpLGFbYl1bZl0uWTxlLnRvcD9lLnRvcD1hW2JdW2ZdLlk6YVtiXVtmXS5ZPmUuYm90dG9tJiYoZS5ib3R0b209YVtiXVtmXS5ZKTtyZXR1cm4gZX07ZC5DbGlwcGVyLnByb3RvdHlwZS5HZXRCb3VuZHMyPVxuZnVuY3Rpb24oYSl7dmFyIGI9YSxjPW5ldyBkLkludFJlY3Q7Yy5sZWZ0PWEuUHQuWDtjLnJpZ2h0PWEuUHQuWDtjLnRvcD1hLlB0Llk7Yy5ib3R0b209YS5QdC5ZO2ZvcihhPWEuTmV4dDthIT1iOylhLlB0Llg8Yy5sZWZ0JiYoYy5sZWZ0PWEuUHQuWCksYS5QdC5YPmMucmlnaHQmJihjLnJpZ2h0PWEuUHQuWCksYS5QdC5ZPGMudG9wJiYoYy50b3A9YS5QdC5ZKSxhLlB0Llk+Yy5ib3R0b20mJihjLmJvdHRvbT1hLlB0LlkpLGE9YS5OZXh0O3JldHVybiBjfTtkLkNsaXBwZXIuUG9pbnRJblBvbHlnb249ZnVuY3Rpb24oYSxiKXt2YXIgYz0wLGU9Yi5sZW5ndGg7aWYoMz5lKXJldHVybiAwO2Zvcih2YXIgZD1iWzBdLGc9MTtnPD1lOysrZyl7dmFyIGg9Zz09ZT9iWzBdOmJbZ107aWYoaC5ZPT1hLlkmJihoLlg9PWEuWHx8ZC5ZPT1hLlkmJmguWD5hLlg9PWQuWDxhLlgpKXJldHVybi0xO2lmKGQuWTxhLlkhPWguWTxhLlkpaWYoZC5YPj1hLlgpaWYoaC5YPmEuWCljPTEtYztlbHNle3ZhciBsPVxuKGQuWC1hLlgpKihoLlktYS5ZKS0oaC5YLWEuWCkqKGQuWS1hLlkpO2lmKDA9PWwpcmV0dXJuLTE7MDxsPT1oLlk+ZC5ZJiYoYz0xLWMpfWVsc2UgaWYoaC5YPmEuWCl7bD0oZC5YLWEuWCkqKGguWS1hLlkpLShoLlgtYS5YKSooZC5ZLWEuWSk7aWYoMD09bClyZXR1cm4tMTswPGw9PWguWT5kLlkmJihjPTEtYyl9ZD1ofXJldHVybiBjfTtkLkNsaXBwZXIucHJvdG90eXBlLlBvaW50SW5Qb2x5Z29uPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTAsZT1iOzspe3ZhciBkPWIuUHQuWCxnPWIuUHQuWSxoPWIuTmV4dC5QdC5YLGw9Yi5OZXh0LlB0Llk7aWYobD09YS5ZJiYoaD09YS5YfHxnPT1hLlkmJmg+YS5YPT1kPGEuWCkpcmV0dXJuLTE7aWYoZzxhLlkhPWw8YS5ZKWlmKGQ+PWEuWClpZihoPmEuWCljPTEtYztlbHNle2Q9KGQtYS5YKSoobC1hLlkpLShoLWEuWCkqKGctYS5ZKTtpZigwPT1kKXJldHVybi0xOzA8ZD09bD5nJiYoYz0xLWMpfWVsc2UgaWYoaD5hLlgpe2Q9KGQtYS5YKSoobC1cbmEuWSktKGgtYS5YKSooZy1hLlkpO2lmKDA9PWQpcmV0dXJuLTE7MDxkPT1sPmcmJihjPTEtYyl9Yj1iLk5leHQ7aWYoZT09YilicmVha31yZXR1cm4gY307ZC5DbGlwcGVyLnByb3RvdHlwZS5Qb2x5MkNvbnRhaW5zUG9seTE9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hO2Rve3ZhciBlPXRoaXMuUG9pbnRJblBvbHlnb24oYy5QdCxiKTtpZigwPD1lKXJldHVybiAwIT1lO2M9Yy5OZXh0fXdoaWxlKGMhPWEpO3JldHVybiEwfTtkLkNsaXBwZXIucHJvdG90eXBlLkZpeHVwRmlyc3RMZWZ0czE9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9MCxlPXRoaXMubV9Qb2x5T3V0cy5sZW5ndGg7YzxlO2MrKyl7dmFyIGQ9dGhpcy5tX1BvbHlPdXRzW2NdO251bGwhPT1kLlB0cyYmZC5GaXJzdExlZnQ9PWEmJnRoaXMuUG9seTJDb250YWluc1BvbHkxKGQuUHRzLGIuUHRzKSYmKGQuRmlyc3RMZWZ0PWIpfX07ZC5DbGlwcGVyLnByb3RvdHlwZS5GaXh1cEZpcnN0TGVmdHMyPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPVxuMCxlPXRoaXMubV9Qb2x5T3V0cyxkPWUubGVuZ3RoLGc9ZVtjXTtjPGQ7YysrLGc9ZVtjXSlnLkZpcnN0TGVmdD09YSYmKGcuRmlyc3RMZWZ0PWIpfTtkLkNsaXBwZXIuUGFyc2VGaXJzdExlZnQ9ZnVuY3Rpb24oYSl7Zm9yKDtudWxsIT1hJiZudWxsPT1hLlB0czspYT1hLkZpcnN0TGVmdDtyZXR1cm4gYX07ZC5DbGlwcGVyLnByb3RvdHlwZS5Kb2luQ29tbW9uRWRnZXM9ZnVuY3Rpb24oKXtmb3IodmFyIGE9MCxiPXRoaXMubV9Kb2lucy5sZW5ndGg7YTxiO2ErKyl7dmFyIGM9dGhpcy5tX0pvaW5zW2FdLGU9dGhpcy5HZXRPdXRSZWMoYy5PdXRQdDEuSWR4KSxmPXRoaXMuR2V0T3V0UmVjKGMuT3V0UHQyLklkeCk7aWYobnVsbCE9ZS5QdHMmJm51bGwhPWYuUHRzKXt2YXIgZztnPWU9PWY/ZTp0aGlzLlBhcmFtMVJpZ2h0T2ZQYXJhbTIoZSxmKT9mOnRoaXMuUGFyYW0xUmlnaHRPZlBhcmFtMihmLGUpP2U6dGhpcy5HZXRMb3dlcm1vc3RSZWMoZSxmKTtpZih0aGlzLkpvaW5Qb2ludHMoYyxcbmUsZikpaWYoZT09Zil7ZS5QdHM9Yy5PdXRQdDE7ZS5Cb3R0b21QdD1udWxsO2Y9dGhpcy5DcmVhdGVPdXRSZWMoKTtmLlB0cz1jLk91dFB0Mjt0aGlzLlVwZGF0ZU91dFB0SWR4cyhmKTtpZih0aGlzLm1fVXNpbmdQb2x5VHJlZSl7Zz0wO2Zvcih2YXIgaD10aGlzLm1fUG9seU91dHMubGVuZ3RoO2c8aC0xO2crKyl7dmFyIGw9dGhpcy5tX1BvbHlPdXRzW2ddO251bGwhPWwuUHRzJiZkLkNsaXBwZXIuUGFyc2VGaXJzdExlZnQobC5GaXJzdExlZnQpPT1lJiZsLklzSG9sZSE9ZS5Jc0hvbGUmJnRoaXMuUG9seTJDb250YWluc1BvbHkxKGwuUHRzLGMuT3V0UHQyKSYmKGwuRmlyc3RMZWZ0PWYpfX10aGlzLlBvbHkyQ29udGFpbnNQb2x5MShmLlB0cyxlLlB0cyk/KGYuSXNIb2xlPSFlLklzSG9sZSxmLkZpcnN0TGVmdD1lLHRoaXMubV9Vc2luZ1BvbHlUcmVlJiZ0aGlzLkZpeHVwRmlyc3RMZWZ0czIoZixlKSwoZi5Jc0hvbGVedGhpcy5SZXZlcnNlU29sdXRpb24pPT0wPHRoaXMuQXJlYShmKSYmXG50aGlzLlJldmVyc2VQb2x5UHRMaW5rcyhmLlB0cykpOnRoaXMuUG9seTJDb250YWluc1BvbHkxKGUuUHRzLGYuUHRzKT8oZi5Jc0hvbGU9ZS5Jc0hvbGUsZS5Jc0hvbGU9IWYuSXNIb2xlLGYuRmlyc3RMZWZ0PWUuRmlyc3RMZWZ0LGUuRmlyc3RMZWZ0PWYsdGhpcy5tX1VzaW5nUG9seVRyZWUmJnRoaXMuRml4dXBGaXJzdExlZnRzMihlLGYpLChlLklzSG9sZV50aGlzLlJldmVyc2VTb2x1dGlvbik9PTA8dGhpcy5BcmVhKGUpJiZ0aGlzLlJldmVyc2VQb2x5UHRMaW5rcyhlLlB0cykpOihmLklzSG9sZT1lLklzSG9sZSxmLkZpcnN0TGVmdD1lLkZpcnN0TGVmdCx0aGlzLm1fVXNpbmdQb2x5VHJlZSYmdGhpcy5GaXh1cEZpcnN0TGVmdHMxKGUsZikpfWVsc2UgZi5QdHM9bnVsbCxmLkJvdHRvbVB0PW51bGwsZi5JZHg9ZS5JZHgsZS5Jc0hvbGU9Zy5Jc0hvbGUsZz09ZiYmKGUuRmlyc3RMZWZ0PWYuRmlyc3RMZWZ0KSxmLkZpcnN0TGVmdD1lLHRoaXMubV9Vc2luZ1BvbHlUcmVlJiZ0aGlzLkZpeHVwRmlyc3RMZWZ0czIoZixcbmUpfX19O2QuQ2xpcHBlci5wcm90b3R5cGUuVXBkYXRlT3V0UHRJZHhzPWZ1bmN0aW9uKGEpe3ZhciBiPWEuUHRzO2RvIGIuSWR4PWEuSWR4LGI9Yi5QcmV2O3doaWxlKGIhPWEuUHRzKX07ZC5DbGlwcGVyLnByb3RvdHlwZS5Eb1NpbXBsZVBvbHlnb25zPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPTA7YTx0aGlzLm1fUG9seU91dHMubGVuZ3RoOyl7dmFyIGI9dGhpcy5tX1BvbHlPdXRzW2ErK10sYz1iLlB0cztpZihudWxsIT09Yyl7ZG97Zm9yKHZhciBlPWMuTmV4dDtlIT1iLlB0czspe2lmKGQuSW50UG9pbnQub3BfRXF1YWxpdHkoYy5QdCxlLlB0KSYmZS5OZXh0IT1jJiZlLlByZXYhPWMpe3ZhciBmPWMuUHJldixnPWUuUHJldjtjLlByZXY9ZztnLk5leHQ9YztlLlByZXY9ZjtmLk5leHQ9ZTtiLlB0cz1jO2Y9dGhpcy5DcmVhdGVPdXRSZWMoKTtmLlB0cz1lO3RoaXMuVXBkYXRlT3V0UHRJZHhzKGYpO3RoaXMuUG9seTJDb250YWluc1BvbHkxKGYuUHRzLGIuUHRzKT8oZi5Jc0hvbGU9IWIuSXNIb2xlLFxuZi5GaXJzdExlZnQ9Yik6dGhpcy5Qb2x5MkNvbnRhaW5zUG9seTEoYi5QdHMsZi5QdHMpPyhmLklzSG9sZT1iLklzSG9sZSxiLklzSG9sZT0hZi5Jc0hvbGUsZi5GaXJzdExlZnQ9Yi5GaXJzdExlZnQsYi5GaXJzdExlZnQ9Zik6KGYuSXNIb2xlPWIuSXNIb2xlLGYuRmlyc3RMZWZ0PWIuRmlyc3RMZWZ0KTtlPWN9ZT1lLk5leHR9Yz1jLk5leHR9d2hpbGUoYyE9Yi5QdHMpfX19O2QuQ2xpcHBlci5BcmVhPWZ1bmN0aW9uKGEpe3ZhciBiPWEubGVuZ3RoO2lmKDM+YilyZXR1cm4gMDtmb3IodmFyIGM9MCxlPTAsZD1iLTE7ZTxiOysrZSljKz0oYVtkXS5YK2FbZV0uWCkqKGFbZF0uWS1hW2VdLlkpLGQ9ZTtyZXR1cm4gMC41Ki1jfTtkLkNsaXBwZXIucHJvdG90eXBlLkFyZWE9ZnVuY3Rpb24oYSl7dmFyIGI9YS5QdHM7aWYobnVsbD09YilyZXR1cm4gMDt2YXIgYz0wO2RvIGMrPShiLlByZXYuUHQuWCtiLlB0LlgpKihiLlByZXYuUHQuWS1iLlB0LlkpLGI9Yi5OZXh0O3doaWxlKGIhPWEuUHRzKTtcbnJldHVybiAwLjUqY307ZC5DbGlwcGVyLlNpbXBsaWZ5UG9seWdvbj1mdW5jdGlvbihhLGIpe3ZhciBjPVtdLGU9bmV3IGQuQ2xpcHBlcigwKTtlLlN0cmljdGx5U2ltcGxlPSEwO2UuQWRkUGF0aChhLGQuUG9seVR5cGUucHRTdWJqZWN0LCEwKTtlLkV4ZWN1dGUoZC5DbGlwVHlwZS5jdFVuaW9uLGMsYixiKTtyZXR1cm4gY307ZC5DbGlwcGVyLlNpbXBsaWZ5UG9seWdvbnM9ZnVuY3Rpb24oYSxiKXtcInVuZGVmaW5lZFwiPT10eXBlb2YgYiYmKGI9ZC5Qb2x5RmlsbFR5cGUucGZ0RXZlbk9kZCk7dmFyIGM9W10sZT1uZXcgZC5DbGlwcGVyKDApO2UuU3RyaWN0bHlTaW1wbGU9ITA7ZS5BZGRQYXRocyhhLGQuUG9seVR5cGUucHRTdWJqZWN0LCEwKTtlLkV4ZWN1dGUoZC5DbGlwVHlwZS5jdFVuaW9uLGMsYixiKTtyZXR1cm4gY307ZC5DbGlwcGVyLkRpc3RhbmNlU3FyZD1mdW5jdGlvbihhLGIpe3ZhciBjPWEuWC1iLlgsZT1hLlktYi5ZO3JldHVybiBjKmMrZSplfTtkLkNsaXBwZXIuRGlzdGFuY2VGcm9tTGluZVNxcmQ9XG5mdW5jdGlvbihhLGIsYyl7dmFyIGU9Yi5ZLWMuWTtjPWMuWC1iLlg7Yj1lKmIuWCtjKmIuWTtiPWUqYS5YK2MqYS5ZLWI7cmV0dXJuIGIqYi8oZSplK2MqYyl9O2QuQ2xpcHBlci5TbG9wZXNOZWFyQ29sbGluZWFyPWZ1bmN0aW9uKGEsYixjLGUpe3JldHVybiBkLkNsaXBwZXIuRGlzdGFuY2VGcm9tTGluZVNxcmQoYixhLGMpPGV9O2QuQ2xpcHBlci5Qb2ludHNBcmVDbG9zZT1mdW5jdGlvbihhLGIsYyl7dmFyIGU9YS5YLWIuWDthPWEuWS1iLlk7cmV0dXJuIGUqZSthKmE8PWN9O2QuQ2xpcHBlci5FeGNsdWRlT3A9ZnVuY3Rpb24oYSl7dmFyIGI9YS5QcmV2O2IuTmV4dD1hLk5leHQ7YS5OZXh0LlByZXY9YjtiLklkeD0wO3JldHVybiBifTtkLkNsaXBwZXIuQ2xlYW5Qb2x5Z29uPWZ1bmN0aW9uKGEsYil7XCJ1bmRlZmluZWRcIj09dHlwZW9mIGImJihiPTEuNDE1KTt2YXIgYz1hLmxlbmd0aDtpZigwPT1jKXJldHVybltdO2Zvcih2YXIgZT1BcnJheShjKSxmPTA7ZjxjOysrZillW2ZdPVxubmV3IGQuT3V0UHQ7Zm9yKGY9MDtmPGM7KytmKWVbZl0uUHQ9YVtmXSxlW2ZdLk5leHQ9ZVsoZisxKSVjXSxlW2ZdLk5leHQuUHJldj1lW2ZdLGVbZl0uSWR4PTA7Zj1iKmI7Zm9yKGU9ZVswXTswPT1lLklkeCYmZS5OZXh0IT1lLlByZXY7KWQuQ2xpcHBlci5Qb2ludHNBcmVDbG9zZShlLlB0LGUuUHJldi5QdCxmKT8oZT1kLkNsaXBwZXIuRXhjbHVkZU9wKGUpLGMtLSk6ZC5DbGlwcGVyLlBvaW50c0FyZUNsb3NlKGUuUHJldi5QdCxlLk5leHQuUHQsZik/KGQuQ2xpcHBlci5FeGNsdWRlT3AoZS5OZXh0KSxlPWQuQ2xpcHBlci5FeGNsdWRlT3AoZSksYy09Mik6ZC5DbGlwcGVyLlNsb3Blc05lYXJDb2xsaW5lYXIoZS5QcmV2LlB0LGUuUHQsZS5OZXh0LlB0LGYpPyhlPWQuQ2xpcHBlci5FeGNsdWRlT3AoZSksYy0tKTooZS5JZHg9MSxlPWUuTmV4dCk7Mz5jJiYoYz0wKTtmb3IodmFyIGc9QXJyYXkoYyksZj0wO2Y8YzsrK2YpZ1tmXT1uZXcgZC5JbnRQb2ludChlLlB0KSxlPWUuTmV4dDtcbnJldHVybiBnfTtkLkNsaXBwZXIuQ2xlYW5Qb2x5Z29ucz1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1BcnJheShhLmxlbmd0aCksZT0wLGY9YS5sZW5ndGg7ZTxmO2UrKyljW2VdPWQuQ2xpcHBlci5DbGVhblBvbHlnb24oYVtlXSxiKTtyZXR1cm4gY307ZC5DbGlwcGVyLk1pbmtvd3NraT1mdW5jdGlvbihhLGIsYyxlKXt2YXIgZj1lPzE6MCxnPWEubGVuZ3RoLGg9Yi5sZW5ndGg7ZT1bXTtpZihjKWZvcihjPTA7YzxoO2MrKyl7Zm9yKHZhciBsPUFycmF5KGcpLGs9MCxuPWEubGVuZ3RoLG09YVtrXTtrPG47aysrLG09YVtrXSlsW2tdPW5ldyBkLkludFBvaW50KGJbY10uWCttLlgsYltjXS5ZK20uWSk7ZS5wdXNoKGwpfWVsc2UgZm9yKGM9MDtjPGg7YysrKXtsPUFycmF5KGcpO2s9MDtuPWEubGVuZ3RoO2ZvcihtPWFba107azxuO2srKyxtPWFba10pbFtrXT1uZXcgZC5JbnRQb2ludChiW2NdLlgtbS5YLGJbY10uWS1tLlkpO2UucHVzaChsKX1hPVtdO2ZvcihjPTA7YzxoLTErZjtjKyspZm9yKGs9XG4wO2s8ZztrKyspYj1bXSxiLnB1c2goZVtjJWhdW2slZ10pLGIucHVzaChlWyhjKzEpJWhdW2slZ10pLGIucHVzaChlWyhjKzEpJWhdWyhrKzEpJWddKSxiLnB1c2goZVtjJWhdWyhrKzEpJWddKSxkLkNsaXBwZXIuT3JpZW50YXRpb24oYil8fGIucmV2ZXJzZSgpLGEucHVzaChiKTtmPW5ldyBkLkNsaXBwZXIoMCk7Zi5BZGRQYXRocyhhLGQuUG9seVR5cGUucHRTdWJqZWN0LCEwKTtmLkV4ZWN1dGUoZC5DbGlwVHlwZS5jdFVuaW9uLGUsZC5Qb2x5RmlsbFR5cGUucGZ0Tm9uWmVybyxkLlBvbHlGaWxsVHlwZS5wZnROb25aZXJvKTtyZXR1cm4gZX07ZC5DbGlwcGVyLk1pbmtvd3NraVN1bT1mdW5jdGlvbigpe3ZhciBhPWFyZ3VtZW50cyxiPWEubGVuZ3RoO2lmKDM9PWIpe3ZhciBjPWFbMF0sZT1hWzJdO3JldHVybiBkLkNsaXBwZXIuTWlua293c2tpKGMsYVsxXSwhMCxlKX1pZig0PT1iKXtmb3IodmFyIGM9YVswXSxmPWFbMV0sYj1hWzJdLGU9YVszXSxhPW5ldyBkLkNsaXBwZXIsZyxcbmg9MCxsPWYubGVuZ3RoO2g8bDsrK2gpZz1kLkNsaXBwZXIuTWlua293c2tpKGMsZltoXSwhMCxlKSxhLkFkZFBhdGhzKGcsZC5Qb2x5VHlwZS5wdFN1YmplY3QsITApO2UmJmEuQWRkUGF0aHMoZixkLlBvbHlUeXBlLnB0Q2xpcCwhMCk7Yz1uZXcgZC5QYXRoczthLkV4ZWN1dGUoZC5DbGlwVHlwZS5jdFVuaW9uLGMsYixiKTtyZXR1cm4gY319O2QuQ2xpcHBlci5NaW5rb3dza2lEaWZmPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gZC5DbGlwcGVyLk1pbmtvd3NraShhLGIsITEsYyl9O2QuQ2xpcHBlci5Qb2x5VHJlZVRvUGF0aHM9ZnVuY3Rpb24oYSl7dmFyIGI9W107ZC5DbGlwcGVyLkFkZFBvbHlOb2RlVG9QYXRocyhhLGQuQ2xpcHBlci5Ob2RlVHlwZS5udEFueSxiKTtyZXR1cm4gYn07ZC5DbGlwcGVyLkFkZFBvbHlOb2RlVG9QYXRocz1mdW5jdGlvbihhLGIsYyl7dmFyIGU9ITA7c3dpdGNoKGIpe2Nhc2UgZC5DbGlwcGVyLk5vZGVUeXBlLm50T3BlbjpyZXR1cm47Y2FzZSBkLkNsaXBwZXIuTm9kZVR5cGUubnRDbG9zZWQ6ZT1cbiFhLklzT3Blbn0wPGEubV9wb2x5Z29uLmxlbmd0aCYmZSYmYy5wdXNoKGEubV9wb2x5Z29uKTtlPTA7YT1hLkNoaWxkcygpO2Zvcih2YXIgZj1hLmxlbmd0aCxnPWFbZV07ZTxmO2UrKyxnPWFbZV0pZC5DbGlwcGVyLkFkZFBvbHlOb2RlVG9QYXRocyhnLGIsYyl9O2QuQ2xpcHBlci5PcGVuUGF0aHNGcm9tUG9seVRyZWU9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPW5ldyBkLlBhdGhzLGM9MCxlPWEuQ2hpbGRDb3VudCgpO2M8ZTtjKyspYS5DaGlsZHMoKVtjXS5Jc09wZW4mJmIucHVzaChhLkNoaWxkcygpW2NdLm1fcG9seWdvbik7cmV0dXJuIGJ9O2QuQ2xpcHBlci5DbG9zZWRQYXRoc0Zyb21Qb2x5VHJlZT1mdW5jdGlvbihhKXt2YXIgYj1uZXcgZC5QYXRocztkLkNsaXBwZXIuQWRkUG9seU5vZGVUb1BhdGhzKGEsZC5DbGlwcGVyLk5vZGVUeXBlLm50Q2xvc2VkLGIpO3JldHVybiBifTtLKGQuQ2xpcHBlcixkLkNsaXBwZXJCYXNlKTtkLkNsaXBwZXIuTm9kZVR5cGU9e250QW55OjAsbnRPcGVuOjEsXG5udENsb3NlZDoyfTtkLkNsaXBwZXJPZmZzZXQ9ZnVuY3Rpb24oYSxiKXtcInVuZGVmaW5lZFwiPT10eXBlb2YgYSYmKGE9Mik7XCJ1bmRlZmluZWRcIj09dHlwZW9mIGImJihiPWQuQ2xpcHBlck9mZnNldC5kZWZfYXJjX3RvbGVyYW5jZSk7dGhpcy5tX2Rlc3RQb2x5cz1uZXcgZC5QYXRoczt0aGlzLm1fc3JjUG9seT1uZXcgZC5QYXRoO3RoaXMubV9kZXN0UG9seT1uZXcgZC5QYXRoO3RoaXMubV9ub3JtYWxzPVtdO3RoaXMubV9TdGVwc1BlclJhZD10aGlzLm1fbWl0ZXJMaW09dGhpcy5tX2Nvcz10aGlzLm1fc2luPXRoaXMubV9zaW5BPXRoaXMubV9kZWx0YT0wO3RoaXMubV9sb3dlc3Q9bmV3IGQuSW50UG9pbnQ7dGhpcy5tX3BvbHlOb2Rlcz1uZXcgZC5Qb2x5Tm9kZTt0aGlzLk1pdGVyTGltaXQ9YTt0aGlzLkFyY1RvbGVyYW5jZT1iO3RoaXMubV9sb3dlc3QuWD0tMX07ZC5DbGlwcGVyT2Zmc2V0LnR3b19waT02LjI4MzE4NTMwNzE3OTU5O2QuQ2xpcHBlck9mZnNldC5kZWZfYXJjX3RvbGVyYW5jZT1cbjAuMjU7ZC5DbGlwcGVyT2Zmc2V0LnByb3RvdHlwZS5DbGVhcj1mdW5jdGlvbigpe2QuQ2xlYXIodGhpcy5tX3BvbHlOb2Rlcy5DaGlsZHMoKSk7dGhpcy5tX2xvd2VzdC5YPS0xfTtkLkNsaXBwZXJPZmZzZXQuUm91bmQ9ZC5DbGlwcGVyLlJvdW5kO2QuQ2xpcHBlck9mZnNldC5wcm90b3R5cGUuQWRkUGF0aD1mdW5jdGlvbihhLGIsYyl7dmFyIGU9YS5sZW5ndGgtMTtpZighKDA+ZSkpe3ZhciBmPW5ldyBkLlBvbHlOb2RlO2YubV9qb2ludHlwZT1iO2YubV9lbmR0eXBlPWM7aWYoYz09ZC5FbmRUeXBlLmV0Q2xvc2VkTGluZXx8Yz09ZC5FbmRUeXBlLmV0Q2xvc2VkUG9seWdvbilmb3IoOzA8ZSYmZC5JbnRQb2ludC5vcF9FcXVhbGl0eShhWzBdLGFbZV0pOyllLS07Zi5tX3BvbHlnb24ucHVzaChhWzBdKTt2YXIgZz0wO2I9MDtmb3IodmFyIGg9MTtoPD1lO2grKylkLkludFBvaW50Lm9wX0luZXF1YWxpdHkoZi5tX3BvbHlnb25bZ10sYVtoXSkmJihnKyssZi5tX3BvbHlnb24ucHVzaChhW2hdKSxcbmFbaF0uWT5mLm1fcG9seWdvbltiXS5ZfHxhW2hdLlk9PWYubV9wb2x5Z29uW2JdLlkmJmFbaF0uWDxmLm1fcG9seWdvbltiXS5YKSYmKGI9Zyk7aWYoIShjPT1kLkVuZFR5cGUuZXRDbG9zZWRQb2x5Z29uJiYyPmd8fGMhPWQuRW5kVHlwZS5ldENsb3NlZFBvbHlnb24mJjA+ZykmJih0aGlzLm1fcG9seU5vZGVzLkFkZENoaWxkKGYpLGM9PWQuRW5kVHlwZS5ldENsb3NlZFBvbHlnb24pKWlmKDA+dGhpcy5tX2xvd2VzdC5YKXRoaXMubV9sb3dlc3Q9bmV3IGQuSW50UG9pbnQoMCxiKTtlbHNlIGlmKGE9dGhpcy5tX3BvbHlOb2Rlcy5DaGlsZHMoKVt0aGlzLm1fbG93ZXN0LlhdLm1fcG9seWdvblt0aGlzLm1fbG93ZXN0LlldLGYubV9wb2x5Z29uW2JdLlk+YS5ZfHxmLm1fcG9seWdvbltiXS5ZPT1hLlkmJmYubV9wb2x5Z29uW2JdLlg8YS5YKXRoaXMubV9sb3dlc3Q9bmV3IGQuSW50UG9pbnQodGhpcy5tX3BvbHlOb2Rlcy5DaGlsZENvdW50KCktMSxiKX19O2QuQ2xpcHBlck9mZnNldC5wcm90b3R5cGUuQWRkUGF0aHM9XG5mdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBlPTAsZD1hLmxlbmd0aDtlPGQ7ZSsrKXRoaXMuQWRkUGF0aChhW2VdLGIsYyl9O2QuQ2xpcHBlck9mZnNldC5wcm90b3R5cGUuRml4T3JpZW50YXRpb25zPWZ1bmN0aW9uKCl7aWYoMDw9dGhpcy5tX2xvd2VzdC5YJiYhZC5DbGlwcGVyLk9yaWVudGF0aW9uKHRoaXMubV9wb2x5Tm9kZXMuQ2hpbGRzKClbdGhpcy5tX2xvd2VzdC5YXS5tX3BvbHlnb24pKWZvcih2YXIgYT0wO2E8dGhpcy5tX3BvbHlOb2Rlcy5DaGlsZENvdW50KCk7YSsrKXt2YXIgYj10aGlzLm1fcG9seU5vZGVzLkNoaWxkcygpW2FdOyhiLm1fZW5kdHlwZT09ZC5FbmRUeXBlLmV0Q2xvc2VkUG9seWdvbnx8Yi5tX2VuZHR5cGU9PWQuRW5kVHlwZS5ldENsb3NlZExpbmUmJmQuQ2xpcHBlci5PcmllbnRhdGlvbihiLm1fcG9seWdvbikpJiZiLm1fcG9seWdvbi5yZXZlcnNlKCl9ZWxzZSBmb3IoYT0wO2E8dGhpcy5tX3BvbHlOb2Rlcy5DaGlsZENvdW50KCk7YSsrKWI9dGhpcy5tX3BvbHlOb2Rlcy5DaGlsZHMoKVthXSxcbmIubV9lbmR0eXBlIT1kLkVuZFR5cGUuZXRDbG9zZWRMaW5lfHxkLkNsaXBwZXIuT3JpZW50YXRpb24oYi5tX3BvbHlnb24pfHxiLm1fcG9seWdvbi5yZXZlcnNlKCl9O2QuQ2xpcHBlck9mZnNldC5HZXRVbml0Tm9ybWFsPWZ1bmN0aW9uKGEsYil7dmFyIGM9Yi5YLWEuWCxlPWIuWS1hLlk7aWYoMD09YyYmMD09ZSlyZXR1cm4gbmV3IGQuRG91YmxlUG9pbnQoMCwwKTt2YXIgZj0xL01hdGguc3FydChjKmMrZSplKTtyZXR1cm4gbmV3IGQuRG91YmxlUG9pbnQoZSpmLC0oYypmKSl9O2QuQ2xpcHBlck9mZnNldC5wcm90b3R5cGUuRG9PZmZzZXQ9ZnVuY3Rpb24oYSl7dGhpcy5tX2Rlc3RQb2x5cz1bXTt0aGlzLm1fZGVsdGE9YTtpZihkLkNsaXBwZXJCYXNlLm5lYXJfemVybyhhKSlmb3IodmFyIGI9MDtiPHRoaXMubV9wb2x5Tm9kZXMuQ2hpbGRDb3VudCgpO2IrKyl7dmFyIGM9dGhpcy5tX3BvbHlOb2Rlcy5DaGlsZHMoKVtiXTtjLm1fZW5kdHlwZT09ZC5FbmRUeXBlLmV0Q2xvc2VkUG9seWdvbiYmXG50aGlzLm1fZGVzdFBvbHlzLnB1c2goYy5tX3BvbHlnb24pfWVsc2V7dGhpcy5tX21pdGVyTGltPTI8dGhpcy5NaXRlckxpbWl0PzIvKHRoaXMuTWl0ZXJMaW1pdCp0aGlzLk1pdGVyTGltaXQpOjAuNTt2YXIgYj0wPj10aGlzLkFyY1RvbGVyYW5jZT9kLkNsaXBwZXJPZmZzZXQuZGVmX2FyY190b2xlcmFuY2U6dGhpcy5BcmNUb2xlcmFuY2U+TWF0aC5hYnMoYSkqZC5DbGlwcGVyT2Zmc2V0LmRlZl9hcmNfdG9sZXJhbmNlP01hdGguYWJzKGEpKmQuQ2xpcHBlck9mZnNldC5kZWZfYXJjX3RvbGVyYW5jZTp0aGlzLkFyY1RvbGVyYW5jZSxlPTMuMTQxNTkyNjUzNTg5NzkvTWF0aC5hY29zKDEtYi9NYXRoLmFicyhhKSk7dGhpcy5tX3Npbj1NYXRoLnNpbihkLkNsaXBwZXJPZmZzZXQudHdvX3BpL2UpO3RoaXMubV9jb3M9TWF0aC5jb3MoZC5DbGlwcGVyT2Zmc2V0LnR3b19waS9lKTt0aGlzLm1fU3RlcHNQZXJSYWQ9ZS9kLkNsaXBwZXJPZmZzZXQudHdvX3BpOzA+YSYmKHRoaXMubV9zaW49XG4tdGhpcy5tX3Npbik7Zm9yKGI9MDtiPHRoaXMubV9wb2x5Tm9kZXMuQ2hpbGRDb3VudCgpO2IrKyl7Yz10aGlzLm1fcG9seU5vZGVzLkNoaWxkcygpW2JdO3RoaXMubV9zcmNQb2x5PWMubV9wb2x5Z29uO3ZhciBmPXRoaXMubV9zcmNQb2x5Lmxlbmd0aDtpZighKDA9PWZ8fDA+PWEmJigzPmZ8fGMubV9lbmR0eXBlIT1kLkVuZFR5cGUuZXRDbG9zZWRQb2x5Z29uKSkpe3RoaXMubV9kZXN0UG9seT1bXTtpZigxPT1mKWlmKGMubV9qb2ludHlwZT09ZC5Kb2luVHlwZS5qdFJvdW5kKWZvcih2YXIgYz0xLGY9MCxnPTE7Zzw9ZTtnKyspe3RoaXMubV9kZXN0UG9seS5wdXNoKG5ldyBkLkludFBvaW50KGQuQ2xpcHBlck9mZnNldC5Sb3VuZCh0aGlzLm1fc3JjUG9seVswXS5YK2MqYSksZC5DbGlwcGVyT2Zmc2V0LlJvdW5kKHRoaXMubV9zcmNQb2x5WzBdLlkrZiphKSkpO3ZhciBoPWMsYz1jKnRoaXMubV9jb3MtdGhpcy5tX3NpbipmLGY9aCp0aGlzLm1fc2luK2YqdGhpcy5tX2Nvc31lbHNlIGZvcihmPVxuYz0tMSxnPTA7ND5nOysrZyl0aGlzLm1fZGVzdFBvbHkucHVzaChuZXcgZC5JbnRQb2ludChkLkNsaXBwZXJPZmZzZXQuUm91bmQodGhpcy5tX3NyY1BvbHlbMF0uWCtjKmEpLGQuQ2xpcHBlck9mZnNldC5Sb3VuZCh0aGlzLm1fc3JjUG9seVswXS5ZK2YqYSkpKSwwPmM/Yz0xOjA+Zj9mPTE6Yz0tMTtlbHNle2ZvcihnPXRoaXMubV9ub3JtYWxzLmxlbmd0aD0wO2c8Zi0xO2crKyl0aGlzLm1fbm9ybWFscy5wdXNoKGQuQ2xpcHBlck9mZnNldC5HZXRVbml0Tm9ybWFsKHRoaXMubV9zcmNQb2x5W2ddLHRoaXMubV9zcmNQb2x5W2crMV0pKTtjLm1fZW5kdHlwZT09ZC5FbmRUeXBlLmV0Q2xvc2VkTGluZXx8Yy5tX2VuZHR5cGU9PWQuRW5kVHlwZS5ldENsb3NlZFBvbHlnb24/dGhpcy5tX25vcm1hbHMucHVzaChkLkNsaXBwZXJPZmZzZXQuR2V0VW5pdE5vcm1hbCh0aGlzLm1fc3JjUG9seVtmLTFdLHRoaXMubV9zcmNQb2x5WzBdKSk6dGhpcy5tX25vcm1hbHMucHVzaChuZXcgZC5Eb3VibGVQb2ludCh0aGlzLm1fbm9ybWFsc1tmLVxuMl0pKTtpZihjLm1fZW5kdHlwZT09ZC5FbmRUeXBlLmV0Q2xvc2VkUG9seWdvbilmb3IoaD1mLTEsZz0wO2c8ZjtnKyspaD10aGlzLk9mZnNldFBvaW50KGcsaCxjLm1fam9pbnR5cGUpO2Vsc2UgaWYoYy5tX2VuZHR5cGU9PWQuRW5kVHlwZS5ldENsb3NlZExpbmUpe2g9Zi0xO2ZvcihnPTA7ZzxmO2crKyloPXRoaXMuT2Zmc2V0UG9pbnQoZyxoLGMubV9qb2ludHlwZSk7dGhpcy5tX2Rlc3RQb2x5cy5wdXNoKHRoaXMubV9kZXN0UG9seSk7dGhpcy5tX2Rlc3RQb2x5PVtdO2g9dGhpcy5tX25vcm1hbHNbZi0xXTtmb3IoZz1mLTE7MDxnO2ctLSl0aGlzLm1fbm9ybWFsc1tnXT1uZXcgZC5Eb3VibGVQb2ludCgtdGhpcy5tX25vcm1hbHNbZy0xXS5YLC10aGlzLm1fbm9ybWFsc1tnLTFdLlkpO3RoaXMubV9ub3JtYWxzWzBdPW5ldyBkLkRvdWJsZVBvaW50KC1oLlgsLWguWSk7aD0wO2ZvcihnPWYtMTswPD1nO2ctLSloPXRoaXMuT2Zmc2V0UG9pbnQoZyxoLGMubV9qb2ludHlwZSl9ZWxzZXtoPVxuMDtmb3IoZz0xO2c8Zi0xOysrZyloPXRoaXMuT2Zmc2V0UG9pbnQoZyxoLGMubV9qb2ludHlwZSk7Yy5tX2VuZHR5cGU9PWQuRW5kVHlwZS5ldE9wZW5CdXR0PyhnPWYtMSxoPW5ldyBkLkludFBvaW50KGQuQ2xpcHBlck9mZnNldC5Sb3VuZCh0aGlzLm1fc3JjUG9seVtnXS5YK3RoaXMubV9ub3JtYWxzW2ddLlgqYSksZC5DbGlwcGVyT2Zmc2V0LlJvdW5kKHRoaXMubV9zcmNQb2x5W2ddLlkrdGhpcy5tX25vcm1hbHNbZ10uWSphKSksdGhpcy5tX2Rlc3RQb2x5LnB1c2goaCksaD1uZXcgZC5JbnRQb2ludChkLkNsaXBwZXJPZmZzZXQuUm91bmQodGhpcy5tX3NyY1BvbHlbZ10uWC10aGlzLm1fbm9ybWFsc1tnXS5YKmEpLGQuQ2xpcHBlck9mZnNldC5Sb3VuZCh0aGlzLm1fc3JjUG9seVtnXS5ZLXRoaXMubV9ub3JtYWxzW2ddLlkqYSkpLHRoaXMubV9kZXN0UG9seS5wdXNoKGgpKTooZz1mLTEsaD1mLTIsdGhpcy5tX3NpbkE9MCx0aGlzLm1fbm9ybWFsc1tnXT1uZXcgZC5Eb3VibGVQb2ludCgtdGhpcy5tX25vcm1hbHNbZ10uWCxcbi10aGlzLm1fbm9ybWFsc1tnXS5ZKSxjLm1fZW5kdHlwZT09ZC5FbmRUeXBlLmV0T3BlblNxdWFyZT90aGlzLkRvU3F1YXJlKGcsaCk6dGhpcy5Eb1JvdW5kKGcsaCkpO2ZvcihnPWYtMTswPGc7Zy0tKXRoaXMubV9ub3JtYWxzW2ddPW5ldyBkLkRvdWJsZVBvaW50KC10aGlzLm1fbm9ybWFsc1tnLTFdLlgsLXRoaXMubV9ub3JtYWxzW2ctMV0uWSk7dGhpcy5tX25vcm1hbHNbMF09bmV3IGQuRG91YmxlUG9pbnQoLXRoaXMubV9ub3JtYWxzWzFdLlgsLXRoaXMubV9ub3JtYWxzWzFdLlkpO2g9Zi0xO2ZvcihnPWgtMTswPGc7LS1nKWg9dGhpcy5PZmZzZXRQb2ludChnLGgsYy5tX2pvaW50eXBlKTtjLm1fZW5kdHlwZT09ZC5FbmRUeXBlLmV0T3BlbkJ1dHQ/KGg9bmV3IGQuSW50UG9pbnQoZC5DbGlwcGVyT2Zmc2V0LlJvdW5kKHRoaXMubV9zcmNQb2x5WzBdLlgtdGhpcy5tX25vcm1hbHNbMF0uWCphKSxkLkNsaXBwZXJPZmZzZXQuUm91bmQodGhpcy5tX3NyY1BvbHlbMF0uWS10aGlzLm1fbm9ybWFsc1swXS5ZKlxuYSkpLHRoaXMubV9kZXN0UG9seS5wdXNoKGgpLGg9bmV3IGQuSW50UG9pbnQoZC5DbGlwcGVyT2Zmc2V0LlJvdW5kKHRoaXMubV9zcmNQb2x5WzBdLlgrdGhpcy5tX25vcm1hbHNbMF0uWCphKSxkLkNsaXBwZXJPZmZzZXQuUm91bmQodGhpcy5tX3NyY1BvbHlbMF0uWSt0aGlzLm1fbm9ybWFsc1swXS5ZKmEpKSx0aGlzLm1fZGVzdFBvbHkucHVzaChoKSk6KHRoaXMubV9zaW5BPTAsYy5tX2VuZHR5cGU9PWQuRW5kVHlwZS5ldE9wZW5TcXVhcmU/dGhpcy5Eb1NxdWFyZSgwLDEpOnRoaXMuRG9Sb3VuZCgwLDEpKX19dGhpcy5tX2Rlc3RQb2x5cy5wdXNoKHRoaXMubV9kZXN0UG9seSl9fX19O2QuQ2xpcHBlck9mZnNldC5wcm90b3R5cGUuRXhlY3V0ZT1mdW5jdGlvbigpe3ZhciBhPWFyZ3VtZW50cztpZihhWzBdaW5zdGFuY2VvZiBkLlBvbHlUcmVlKWlmKGI9YVswXSxjPWFbMV0sYi5DbGVhcigpLHRoaXMuRml4T3JpZW50YXRpb25zKCksdGhpcy5Eb09mZnNldChjKSxhPW5ldyBkLkNsaXBwZXIoMCksXG5hLkFkZFBhdGhzKHRoaXMubV9kZXN0UG9seXMsZC5Qb2x5VHlwZS5wdFN1YmplY3QsITApLDA8YylhLkV4ZWN1dGUoZC5DbGlwVHlwZS5jdFVuaW9uLGIsZC5Qb2x5RmlsbFR5cGUucGZ0UG9zaXRpdmUsZC5Qb2x5RmlsbFR5cGUucGZ0UG9zaXRpdmUpO2Vsc2UgaWYoYz1kLkNsaXBwZXIuR2V0Qm91bmRzKHRoaXMubV9kZXN0UG9seXMpLGU9bmV3IGQuUGF0aCxlLnB1c2gobmV3IGQuSW50UG9pbnQoYy5sZWZ0LTEwLGMuYm90dG9tKzEwKSksZS5wdXNoKG5ldyBkLkludFBvaW50KGMucmlnaHQrMTAsYy5ib3R0b20rMTApKSxlLnB1c2gobmV3IGQuSW50UG9pbnQoYy5yaWdodCsxMCxjLnRvcC0xMCkpLGUucHVzaChuZXcgZC5JbnRQb2ludChjLmxlZnQtMTAsYy50b3AtMTApKSxhLkFkZFBhdGgoZSxkLlBvbHlUeXBlLnB0U3ViamVjdCwhMCksYS5SZXZlcnNlU29sdXRpb249ITAsYS5FeGVjdXRlKGQuQ2xpcFR5cGUuY3RVbmlvbixiLGQuUG9seUZpbGxUeXBlLnBmdE5lZ2F0aXZlLGQuUG9seUZpbGxUeXBlLnBmdE5lZ2F0aXZlKSxcbjE9PWIuQ2hpbGRDb3VudCgpJiYwPGIuQ2hpbGRzKClbMF0uQ2hpbGRDb3VudCgpKWZvcihhPWIuQ2hpbGRzKClbMF0sYi5DaGlsZHMoKVswXT1hLkNoaWxkcygpWzBdLGM9MTtjPGEuQ2hpbGRDb3VudCgpO2MrKyliLkFkZENoaWxkKGEuQ2hpbGRzKClbY10pO2Vsc2UgYi5DbGVhcigpO2Vsc2V7dmFyIGI9YVswXSxjPWFbMV07ZC5DbGVhcihiKTt0aGlzLkZpeE9yaWVudGF0aW9ucygpO3RoaXMuRG9PZmZzZXQoYyk7YT1uZXcgZC5DbGlwcGVyKDApO2EuQWRkUGF0aHModGhpcy5tX2Rlc3RQb2x5cyxkLlBvbHlUeXBlLnB0U3ViamVjdCwhMCk7aWYoMDxjKWEuRXhlY3V0ZShkLkNsaXBUeXBlLmN0VW5pb24sYixkLlBvbHlGaWxsVHlwZS5wZnRQb3NpdGl2ZSxkLlBvbHlGaWxsVHlwZS5wZnRQb3NpdGl2ZSk7ZWxzZXt2YXIgYz1kLkNsaXBwZXIuR2V0Qm91bmRzKHRoaXMubV9kZXN0UG9seXMpLGU9bmV3IGQuUGF0aDtlLnB1c2gobmV3IGQuSW50UG9pbnQoYy5sZWZ0LTEwLGMuYm90dG9tK1xuMTApKTtlLnB1c2gobmV3IGQuSW50UG9pbnQoYy5yaWdodCsxMCxjLmJvdHRvbSsxMCkpO2UucHVzaChuZXcgZC5JbnRQb2ludChjLnJpZ2h0KzEwLGMudG9wLTEwKSk7ZS5wdXNoKG5ldyBkLkludFBvaW50KGMubGVmdC0xMCxjLnRvcC0xMCkpO2EuQWRkUGF0aChlLGQuUG9seVR5cGUucHRTdWJqZWN0LCEwKTthLlJldmVyc2VTb2x1dGlvbj0hMDthLkV4ZWN1dGUoZC5DbGlwVHlwZS5jdFVuaW9uLGIsZC5Qb2x5RmlsbFR5cGUucGZ0TmVnYXRpdmUsZC5Qb2x5RmlsbFR5cGUucGZ0TmVnYXRpdmUpOzA8Yi5sZW5ndGgmJmIuc3BsaWNlKDAsMSl9fX07ZC5DbGlwcGVyT2Zmc2V0LnByb3RvdHlwZS5PZmZzZXRQb2ludD1mdW5jdGlvbihhLGIsYyl7dGhpcy5tX3NpbkE9dGhpcy5tX25vcm1hbHNbYl0uWCp0aGlzLm1fbm9ybWFsc1thXS5ZLXRoaXMubV9ub3JtYWxzW2FdLlgqdGhpcy5tX25vcm1hbHNbYl0uWTtpZig1RS01PnRoaXMubV9zaW5BJiYtNUUtNTx0aGlzLm1fc2luQSlyZXR1cm4gYjtcbjE8dGhpcy5tX3NpbkE/dGhpcy5tX3NpbkE9MTotMT50aGlzLm1fc2luQSYmKHRoaXMubV9zaW5BPS0xKTtpZigwPnRoaXMubV9zaW5BKnRoaXMubV9kZWx0YSl0aGlzLm1fZGVzdFBvbHkucHVzaChuZXcgZC5JbnRQb2ludChkLkNsaXBwZXJPZmZzZXQuUm91bmQodGhpcy5tX3NyY1BvbHlbYV0uWCt0aGlzLm1fbm9ybWFsc1tiXS5YKnRoaXMubV9kZWx0YSksZC5DbGlwcGVyT2Zmc2V0LlJvdW5kKHRoaXMubV9zcmNQb2x5W2FdLlkrdGhpcy5tX25vcm1hbHNbYl0uWSp0aGlzLm1fZGVsdGEpKSksdGhpcy5tX2Rlc3RQb2x5LnB1c2gobmV3IGQuSW50UG9pbnQodGhpcy5tX3NyY1BvbHlbYV0pKSx0aGlzLm1fZGVzdFBvbHkucHVzaChuZXcgZC5JbnRQb2ludChkLkNsaXBwZXJPZmZzZXQuUm91bmQodGhpcy5tX3NyY1BvbHlbYV0uWCt0aGlzLm1fbm9ybWFsc1thXS5YKnRoaXMubV9kZWx0YSksZC5DbGlwcGVyT2Zmc2V0LlJvdW5kKHRoaXMubV9zcmNQb2x5W2FdLlkrdGhpcy5tX25vcm1hbHNbYV0uWSpcbnRoaXMubV9kZWx0YSkpKTtlbHNlIHN3aXRjaChjKXtjYXNlIGQuSm9pblR5cGUuanRNaXRlcjpjPTErKHRoaXMubV9ub3JtYWxzW2FdLlgqdGhpcy5tX25vcm1hbHNbYl0uWCt0aGlzLm1fbm9ybWFsc1thXS5ZKnRoaXMubV9ub3JtYWxzW2JdLlkpO2M+PXRoaXMubV9taXRlckxpbT90aGlzLkRvTWl0ZXIoYSxiLGMpOnRoaXMuRG9TcXVhcmUoYSxiKTticmVhaztjYXNlIGQuSm9pblR5cGUuanRTcXVhcmU6dGhpcy5Eb1NxdWFyZShhLGIpO2JyZWFrO2Nhc2UgZC5Kb2luVHlwZS5qdFJvdW5kOnRoaXMuRG9Sb3VuZChhLGIpfXJldHVybiBhfTtkLkNsaXBwZXJPZmZzZXQucHJvdG90eXBlLkRvU3F1YXJlPWZ1bmN0aW9uKGEsYil7dmFyIGM9TWF0aC50YW4oTWF0aC5hdGFuMih0aGlzLm1fc2luQSx0aGlzLm1fbm9ybWFsc1tiXS5YKnRoaXMubV9ub3JtYWxzW2FdLlgrdGhpcy5tX25vcm1hbHNbYl0uWSp0aGlzLm1fbm9ybWFsc1thXS5ZKS80KTt0aGlzLm1fZGVzdFBvbHkucHVzaChuZXcgZC5JbnRQb2ludChkLkNsaXBwZXJPZmZzZXQuUm91bmQodGhpcy5tX3NyY1BvbHlbYV0uWCtcbnRoaXMubV9kZWx0YSoodGhpcy5tX25vcm1hbHNbYl0uWC10aGlzLm1fbm9ybWFsc1tiXS5ZKmMpKSxkLkNsaXBwZXJPZmZzZXQuUm91bmQodGhpcy5tX3NyY1BvbHlbYV0uWSt0aGlzLm1fZGVsdGEqKHRoaXMubV9ub3JtYWxzW2JdLlkrdGhpcy5tX25vcm1hbHNbYl0uWCpjKSkpKTt0aGlzLm1fZGVzdFBvbHkucHVzaChuZXcgZC5JbnRQb2ludChkLkNsaXBwZXJPZmZzZXQuUm91bmQodGhpcy5tX3NyY1BvbHlbYV0uWCt0aGlzLm1fZGVsdGEqKHRoaXMubV9ub3JtYWxzW2FdLlgrdGhpcy5tX25vcm1hbHNbYV0uWSpjKSksZC5DbGlwcGVyT2Zmc2V0LlJvdW5kKHRoaXMubV9zcmNQb2x5W2FdLlkrdGhpcy5tX2RlbHRhKih0aGlzLm1fbm9ybWFsc1thXS5ZLXRoaXMubV9ub3JtYWxzW2FdLlgqYykpKSl9O2QuQ2xpcHBlck9mZnNldC5wcm90b3R5cGUuRG9NaXRlcj1mdW5jdGlvbihhLGIsYyl7Yz10aGlzLm1fZGVsdGEvYzt0aGlzLm1fZGVzdFBvbHkucHVzaChuZXcgZC5JbnRQb2ludChkLkNsaXBwZXJPZmZzZXQuUm91bmQodGhpcy5tX3NyY1BvbHlbYV0uWCtcbih0aGlzLm1fbm9ybWFsc1tiXS5YK3RoaXMubV9ub3JtYWxzW2FdLlgpKmMpLGQuQ2xpcHBlck9mZnNldC5Sb3VuZCh0aGlzLm1fc3JjUG9seVthXS5ZKyh0aGlzLm1fbm9ybWFsc1tiXS5ZK3RoaXMubV9ub3JtYWxzW2FdLlkpKmMpKSl9O2QuQ2xpcHBlck9mZnNldC5wcm90b3R5cGUuRG9Sb3VuZD1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1NYXRoLmF0YW4yKHRoaXMubV9zaW5BLHRoaXMubV9ub3JtYWxzW2JdLlgqdGhpcy5tX25vcm1hbHNbYV0uWCt0aGlzLm1fbm9ybWFsc1tiXS5ZKnRoaXMubV9ub3JtYWxzW2FdLlkpLGM9ZC5DYXN0X0ludDMyKGQuQ2xpcHBlck9mZnNldC5Sb3VuZCh0aGlzLm1fU3RlcHNQZXJSYWQqTWF0aC5hYnMoYykpKSxlPXRoaXMubV9ub3JtYWxzW2JdLlgsZj10aGlzLm1fbm9ybWFsc1tiXS5ZLGcsaD0wO2g8YzsrK2gpdGhpcy5tX2Rlc3RQb2x5LnB1c2gobmV3IGQuSW50UG9pbnQoZC5DbGlwcGVyT2Zmc2V0LlJvdW5kKHRoaXMubV9zcmNQb2x5W2FdLlgrXG5lKnRoaXMubV9kZWx0YSksZC5DbGlwcGVyT2Zmc2V0LlJvdW5kKHRoaXMubV9zcmNQb2x5W2FdLlkrZip0aGlzLm1fZGVsdGEpKSksZz1lLGU9ZSp0aGlzLm1fY29zLXRoaXMubV9zaW4qZixmPWcqdGhpcy5tX3NpbitmKnRoaXMubV9jb3M7dGhpcy5tX2Rlc3RQb2x5LnB1c2gobmV3IGQuSW50UG9pbnQoZC5DbGlwcGVyT2Zmc2V0LlJvdW5kKHRoaXMubV9zcmNQb2x5W2FdLlgrdGhpcy5tX25vcm1hbHNbYV0uWCp0aGlzLm1fZGVsdGEpLGQuQ2xpcHBlck9mZnNldC5Sb3VuZCh0aGlzLm1fc3JjUG9seVthXS5ZK3RoaXMubV9ub3JtYWxzW2FdLlkqdGhpcy5tX2RlbHRhKSkpfTtkLkVycm9yPWZ1bmN0aW9uKGEpe3RyeXt0aHJvdyBFcnJvcihhKTt9Y2F0Y2goYil7YWxlcnQoYi5tZXNzYWdlKX19O2QuSlM9e307ZC5KUy5BcmVhT2ZQb2x5Z29uPWZ1bmN0aW9uKGEsYil7Ynx8KGI9MSk7cmV0dXJuIGQuQ2xpcHBlci5BcmVhKGEpLyhiKmIpfTtkLkpTLkFyZWFPZlBvbHlnb25zPWZ1bmN0aW9uKGEsXG5iKXtifHwoYj0xKTtmb3IodmFyIGM9MCxlPTA7ZTxhLmxlbmd0aDtlKyspYys9ZC5DbGlwcGVyLkFyZWEoYVtlXSk7cmV0dXJuIGMvKGIqYil9O2QuSlMuQm91bmRzT2ZQYXRoPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGQuSlMuQm91bmRzT2ZQYXRocyhbYV0sYil9O2QuSlMuQm91bmRzT2ZQYXRocz1mdW5jdGlvbihhLGIpe2J8fChiPTEpO3ZhciBjPWQuQ2xpcHBlci5HZXRCb3VuZHMoYSk7Yy5sZWZ0Lz1iO2MuYm90dG9tLz1iO2MucmlnaHQvPWI7Yy50b3AvPWI7cmV0dXJuIGN9O2QuSlMuQ2xlYW49ZnVuY3Rpb24oYSxiKXtpZighKGEgaW5zdGFuY2VvZiBBcnJheSkpcmV0dXJuW107dmFyIGM9YVswXWluc3RhbmNlb2YgQXJyYXk7YT1kLkpTLkNsb25lKGEpO2lmKFwibnVtYmVyXCIhPXR5cGVvZiBifHxudWxsPT09YilyZXR1cm4gZC5FcnJvcihcIkRlbHRhIGlzIG5vdCBhIG51bWJlciBpbiBDbGVhbigpLlwiKSxhO2lmKDA9PT1hLmxlbmd0aHx8MT09YS5sZW5ndGgmJjA9PT1hWzBdLmxlbmd0aHx8XG4wPmIpcmV0dXJuIGE7Y3x8KGE9W2FdKTtmb3IodmFyIGU9YS5sZW5ndGgsZixnLGgsbCxrLG4sbSxwPVtdLHE9MDtxPGU7cSsrKWlmKGc9YVtxXSxmPWcubGVuZ3RoLDAhPT1mKWlmKDM+ZiloPWcscC5wdXNoKGgpO2Vsc2V7aD1nO2w9YipiO2s9Z1swXTtmb3IobT1uPTE7bTxmO20rKykoZ1ttXS5YLWsuWCkqKGdbbV0uWC1rLlgpKyhnW21dLlktay5ZKSooZ1ttXS5ZLWsuWSk8PWx8fChoW25dPWdbbV0saz1nW21dLG4rKyk7az1nW24tMV07KGdbMF0uWC1rLlgpKihnWzBdLlgtay5YKSsoZ1swXS5ZLWsuWSkqKGdbMF0uWS1rLlkpPD1sJiZuLS07bjxmJiZoLnNwbGljZShuLGYtbik7aC5sZW5ndGgmJnAucHVzaChoKX0hYyYmcC5sZW5ndGg/cD1wWzBdOmN8fDAhPT1wLmxlbmd0aD9jJiYwPT09cC5sZW5ndGgmJihwPVtbXV0pOnA9W107cmV0dXJuIHB9O2QuSlMuQ2xvbmU9ZnVuY3Rpb24oYSl7aWYoIShhIGluc3RhbmNlb2YgQXJyYXkpfHwwPT09YS5sZW5ndGgpcmV0dXJuW107aWYoMT09XG5hLmxlbmd0aCYmMD09PWFbMF0ubGVuZ3RoKXJldHVybltbXV07dmFyIGI9YVswXWluc3RhbmNlb2YgQXJyYXk7Ynx8KGE9W2FdKTt2YXIgYz1hLmxlbmd0aCxlLGQsZyxoLGw9QXJyYXkoYyk7Zm9yKGQ9MDtkPGM7ZCsrKXtlPWFbZF0ubGVuZ3RoO2g9QXJyYXkoZSk7Zm9yKGc9MDtnPGU7ZysrKWhbZ109e1g6YVtkXVtnXS5YLFk6YVtkXVtnXS5ZfTtsW2RdPWh9Ynx8KGw9bFswXSk7cmV0dXJuIGx9O2QuSlMuTGlnaHRlbj1mdW5jdGlvbihhLGIpe2lmKCEoYSBpbnN0YW5jZW9mIEFycmF5KSlyZXR1cm5bXTtpZihcIm51bWJlclwiIT10eXBlb2YgYnx8bnVsbD09PWIpcmV0dXJuIGQuRXJyb3IoXCJUb2xlcmFuY2UgaXMgbm90IGEgbnVtYmVyIGluIExpZ2h0ZW4oKS5cIiksZC5KUy5DbG9uZShhKTtpZigwPT09YS5sZW5ndGh8fDE9PWEubGVuZ3RoJiYwPT09YVswXS5sZW5ndGh8fDA+YilyZXR1cm4gZC5KUy5DbG9uZShhKTthWzBdaW5zdGFuY2VvZiBBcnJheXx8KGE9W2FdKTt2YXIgYyxlLFxuZixnLGgsbCxrLG0scCxxLHIscyx0LHUsdix4PWEubGVuZ3RoLHk9YipiLHc9W107Zm9yKGM9MDtjPHg7YysrKWlmKGY9YVtjXSxsPWYubGVuZ3RoLDAhPWwpe2ZvcihnPTA7MUU2Pmc7ZysrKXtoPVtdO2w9Zi5sZW5ndGg7ZltsLTFdLlghPWZbMF0uWHx8ZltsLTFdLlkhPWZbMF0uWT8ocj0xLGYucHVzaCh7WDpmWzBdLlgsWTpmWzBdLll9KSxsPWYubGVuZ3RoKTpyPTA7cT1bXTtmb3IoZT0wO2U8bC0yO2UrKyl7az1mW2VdO3A9ZltlKzFdO209ZltlKzJdO3U9ay5YO3Y9ay5ZO2s9bS5YLXU7cz1tLlktdjtpZigwIT09a3x8MCE9PXMpdD0oKHAuWC11KSprKyhwLlktdikqcykvKGsqaytzKnMpLDE8dD8odT1tLlgsdj1tLlkpOjA8dCYmKHUrPWsqdCx2Kz1zKnQpO2s9cC5YLXU7cz1wLlktdjttPWsqaytzKnM7bTw9eSYmKHFbZSsxXT0xLGUrKyl9aC5wdXNoKHtYOmZbMF0uWCxZOmZbMF0uWX0pO2ZvcihlPTE7ZTxsLTE7ZSsrKXFbZV18fGgucHVzaCh7WDpmW2VdLlgsWTpmW2VdLll9KTtcbmgucHVzaCh7WDpmW2wtMV0uWCxZOmZbbC0xXS5ZfSk7ciYmZi5wb3AoKTtpZihxLmxlbmd0aClmPWg7ZWxzZSBicmVha31sPWgubGVuZ3RoO2hbbC0xXS5YPT1oWzBdLlgmJmhbbC0xXS5ZPT1oWzBdLlkmJmgucG9wKCk7MjxoLmxlbmd0aCYmdy5wdXNoKGgpfSFhWzBdaW5zdGFuY2VvZiBBcnJheSYmKHc9d1swXSk7XCJ1bmRlZmluZWRcIj09dHlwZW9mIHcmJih3PVtbXV0pO3JldHVybiB3fTtkLkpTLlBlcmltZXRlck9mUGF0aD1mdW5jdGlvbihhLGIsYyl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGEpcmV0dXJuIDA7dmFyIGU9TWF0aC5zcXJ0LGQ9MCxnLGgsaz0wLG09Zz0wO2g9MDt2YXIgbj1hLmxlbmd0aDtpZigyPm4pcmV0dXJuIDA7YiYmKGFbbl09YVswXSxuKyspO2Zvcig7LS1uOylnPWFbbl0saz1nLlgsZz1nLlksaD1hW24tMV0sbT1oLlgsaD1oLlksZCs9ZSgoay1tKSooay1tKSsoZy1oKSooZy1oKSk7YiYmYS5wb3AoKTtyZXR1cm4gZC9jfTtkLkpTLlBlcmltZXRlck9mUGF0aHM9XG5mdW5jdGlvbihhLGIsYyl7Y3x8KGM9MSk7Zm9yKHZhciBlPTAsZj0wO2Y8YS5sZW5ndGg7ZisrKWUrPWQuSlMuUGVyaW1ldGVyT2ZQYXRoKGFbZl0sYixjKTtyZXR1cm4gZX07ZC5KUy5TY2FsZURvd25QYXRoPWZ1bmN0aW9uKGEsYil7dmFyIGMsZDtifHwoYj0xKTtmb3IoYz1hLmxlbmd0aDtjLS07KWQ9YVtjXSxkLlgvPWIsZC5ZLz1ifTtkLkpTLlNjYWxlRG93blBhdGhzPWZ1bmN0aW9uKGEsYil7dmFyIGMsZCxmO2J8fChiPTEpO2ZvcihjPWEubGVuZ3RoO2MtLTspZm9yKGQ9YVtjXS5sZW5ndGg7ZC0tOylmPWFbY11bZF0sZi5YLz1iLGYuWS89Yn07ZC5KUy5TY2FsZVVwUGF0aD1mdW5jdGlvbihhLGIpe3ZhciBjLGQsZj1NYXRoLnJvdW5kO2J8fChiPTEpO2ZvcihjPWEubGVuZ3RoO2MtLTspZD1hW2NdLGQuWD1mKGQuWCpiKSxkLlk9ZihkLlkqYil9O2QuSlMuU2NhbGVVcFBhdGhzPWZ1bmN0aW9uKGEsYil7dmFyIGMsZCxmLGc9TWF0aC5yb3VuZDtifHwoYj0xKTtmb3IoYz1hLmxlbmd0aDtjLS07KWZvcihkPVxuYVtjXS5sZW5ndGg7ZC0tOylmPWFbY11bZF0sZi5YPWcoZi5YKmIpLGYuWT1nKGYuWSpiKX07ZC5FeFBvbHlnb25zPWZ1bmN0aW9uKCl7cmV0dXJuW119O2QuRXhQb2x5Z29uPWZ1bmN0aW9uKCl7dGhpcy5ob2xlcz10aGlzLm91dGVyPW51bGx9O2QuSlMuQWRkT3V0ZXJQb2x5Tm9kZVRvRXhQb2x5Z29ucz1mdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBkLkV4UG9seWdvbjtjLm91dGVyPWEuQ29udG91cigpO3ZhciBlPWEuQ2hpbGRzKCksZj1lLmxlbmd0aDtjLmhvbGVzPUFycmF5KGYpO3ZhciBnLGgsayxtLG47Zm9yKGg9MDtoPGY7aCsrKWZvcihnPWVbaF0sYy5ob2xlc1toXT1nLkNvbnRvdXIoKSxrPTAsbT1nLkNoaWxkcygpLG49bS5sZW5ndGg7azxuO2srKylnPW1ba10sZC5KUy5BZGRPdXRlclBvbHlOb2RlVG9FeFBvbHlnb25zKGcsYik7Yi5wdXNoKGMpfTtkLkpTLkV4UG9seWdvbnNUb1BhdGhzPWZ1bmN0aW9uKGEpe3ZhciBiLGMsZSxmLGc9bmV3IGQuUGF0aHM7Yj0wO2ZvcihlPVxuYS5sZW5ndGg7YjxlO2IrKylmb3IoZy5wdXNoKGFbYl0ub3V0ZXIpLGM9MCxmPWFbYl0uaG9sZXMubGVuZ3RoO2M8ZjtjKyspZy5wdXNoKGFbYl0uaG9sZXNbY10pO3JldHVybiBnfTtkLkpTLlBvbHlUcmVlVG9FeFBvbHlnb25zPWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBkLkV4UG9seWdvbnMsYyxlLGY7Yz0wO2U9YS5DaGlsZHMoKTtmb3IoZj1lLmxlbmd0aDtjPGY7YysrKWE9ZVtjXSxkLkpTLkFkZE91dGVyUG9seU5vZGVUb0V4UG9seWdvbnMoYSxiKTtyZXR1cm4gYn19KSgpO1xuXG47IGJyb3dzZXJpZnlfc2hpbV9fZGVmaW5lX19tb2R1bGVfX2V4cG9ydF9fKHR5cGVvZiBDbGlwcGVyTGliICE9IFwidW5kZWZpbmVkXCIgPyBDbGlwcGVyTGliIDogd2luZG93LkNsaXBwZXJMaWIpO1xuXG59KS5jYWxsKGdsb2JhbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmdW5jdGlvbiBkZWZpbmVFeHBvcnQoZXgpIHsgbW9kdWxlLmV4cG9ydHMgPSBleDsgfSk7XG4iLCIvLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvcm91bmRcclxuOyhmdW5jdGlvbigpIHtcclxuICAvKipcclxuICAgKiBEZWNpbWFsIGFkanVzdG1lbnQgb2YgYSBudW1iZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gIHR5cGUgIFRoZSB0eXBlIG9mIGFkanVzdG1lbnQuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9ICB2YWx1ZSBUaGUgbnVtYmVyLlxyXG4gICAqIEBwYXJhbSB7SW50ZWdlcn0gZXhwICAgVGhlIGV4cG9uZW50ICh0aGUgMTAgbG9nYXJpdGhtIG9mIHRoZSBhZGp1c3RtZW50IGJhc2UpLlxyXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhZGp1c3RlZCB2YWx1ZS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBkZWNpbWFsQWRqdXN0KHR5cGUsIHZhbHVlLCBleHApIHtcclxuICAgIC8vIElmIHRoZSBleHAgaXMgdW5kZWZpbmVkIG9yIHplcm8uLi5cclxuICAgIGlmICh0eXBlb2YgZXhwID09PSAndW5kZWZpbmVkJyB8fCArZXhwID09PSAwKSB7XHJcbiAgICAgIHJldHVybiBNYXRoW3R5cGVdKHZhbHVlKTtcclxuICAgIH1cclxuICAgIHZhbHVlID0gK3ZhbHVlO1xyXG4gICAgZXhwID0gK2V4cDtcclxuICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXIgb3IgdGhlIGV4cCBpcyBub3QgYW4gaW50ZWdlci4uLlxyXG4gICAgaWYgKGlzTmFOKHZhbHVlKSB8fCAhKHR5cGVvZiBleHAgPT09ICdudW1iZXInICYmIGV4cCAlIDEgPT09IDApKSB7XHJcbiAgICAgIHJldHVybiBOYU47XHJcbiAgICB9XHJcbiAgICAvLyBTaGlmdFxyXG4gICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpLnNwbGl0KCdlJyk7XHJcbiAgICB2YWx1ZSA9IE1hdGhbdHlwZV0oKyh2YWx1ZVswXSArICdlJyArICh2YWx1ZVsxXSA/ICgrdmFsdWVbMV0gLSBleHApIDogLWV4cCkpKTtcclxuICAgIC8vIFNoaWZ0IGJhY2tcclxuICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnZScpO1xyXG4gICAgcmV0dXJuICsodmFsdWVbMF0gKyAnZScgKyAodmFsdWVbMV0gPyAoK3ZhbHVlWzFdICsgZXhwKSA6IGV4cCkpO1xyXG4gIH1cclxuXHJcbiAgLy8gRGVjaW1hbCByb3VuZFxyXG4gIGlmICghTWF0aC5yb3VuZDEwKSB7XHJcbiAgICBNYXRoLnJvdW5kMTAgPSBmdW5jdGlvbih2YWx1ZSwgZXhwKSB7XHJcbiAgICAgIHJldHVybiBkZWNpbWFsQWRqdXN0KCdyb3VuZCcsIHZhbHVlLCBleHApO1xyXG4gICAgfTtcclxuICB9XHJcbiAgLy8gRGVjaW1hbCBmbG9vclxyXG4gIGlmICghTWF0aC5mbG9vcjEwKSB7XHJcbiAgICBNYXRoLmZsb29yMTAgPSBmdW5jdGlvbih2YWx1ZSwgZXhwKSB7XHJcbiAgICAgIHJldHVybiBkZWNpbWFsQWRqdXN0KCdmbG9vcicsIHZhbHVlLCBleHApO1xyXG4gICAgfTtcclxuICB9XHJcbiAgLy8gRGVjaW1hbCBjZWlsXHJcbiAgaWYgKCFNYXRoLmNlaWwxMCkge1xyXG4gICAgTWF0aC5jZWlsMTAgPSBmdW5jdGlvbih2YWx1ZSwgZXhwKSB7XHJcbiAgICAgIHJldHVybiBkZWNpbWFsQWRqdXN0KCdjZWlsJywgdmFsdWUsIGV4cCk7XHJcbiAgICB9O1xyXG4gIH1cclxufSkoKTtcclxuIiwiLyohIHBvbHkydHJpIHYxLjMuNSB8IChjKSAyMDA5LTIwMTQgUG9seTJUcmkgQ29udHJpYnV0b3JzICovXHJcbiFmdW5jdGlvbih0KXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyltb2R1bGUuZXhwb3J0cz10KCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKHQpO2Vsc2V7dmFyIG47XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz9uPXdpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP249Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiYobj1zZWxmKSxuLnBvbHkydHJpPXQoKX19KGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uIHQobixlLGkpe2Z1bmN0aW9uIG8ocyxwKXtpZighZVtzXSl7aWYoIW5bc10pe3ZhciBhPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIXAmJmEpcmV0dXJuIGEocywhMCk7aWYocilyZXR1cm4gcihzLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK3MrXCInXCIpfXZhciBoPWVbc109e2V4cG9ydHM6e319O25bc11bMF0uY2FsbChoLmV4cG9ydHMsZnVuY3Rpb24odCl7dmFyIGU9bltzXVsxXVt0XTtyZXR1cm4gbyhlP2U6dCl9LGgsaC5leHBvcnRzLHQsbixlLGkpfXJldHVybiBlW3NdLmV4cG9ydHN9Zm9yKHZhciByPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUscz0wO3M8aS5sZW5ndGg7cysrKW8oaVtzXSk7cmV0dXJuIG99KHsxOltmdW5jdGlvbih0LG4pe24uZXhwb3J0cz17dmVyc2lvbjpcIjEuMy41XCJ9fSx7fV0sMjpbZnVuY3Rpb24odCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgZT1mdW5jdGlvbih0LG4pe3RoaXMucG9pbnQ9dCx0aGlzLnRyaWFuZ2xlPW58fG51bGwsdGhpcy5uZXh0PW51bGwsdGhpcy5wcmV2PW51bGwsdGhpcy52YWx1ZT10Lnh9LGk9ZnVuY3Rpb24odCxuKXt0aGlzLmhlYWRfPXQsdGhpcy50YWlsXz1uLHRoaXMuc2VhcmNoX25vZGVfPXR9O2kucHJvdG90eXBlLmhlYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oZWFkX30saS5wcm90b3R5cGUuc2V0SGVhZD1mdW5jdGlvbih0KXt0aGlzLmhlYWRfPXR9LGkucHJvdG90eXBlLnRhaWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50YWlsX30saS5wcm90b3R5cGUuc2V0VGFpbD1mdW5jdGlvbih0KXt0aGlzLnRhaWxfPXR9LGkucHJvdG90eXBlLnNlYXJjaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNlYXJjaF9ub2RlX30saS5wcm90b3R5cGUuc2V0U2VhcmNoPWZ1bmN0aW9uKHQpe3RoaXMuc2VhcmNoX25vZGVfPXR9LGkucHJvdG90eXBlLmZpbmRTZWFyY2hOb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VhcmNoX25vZGVffSxpLnByb3RvdHlwZS5sb2NhdGVOb2RlPWZ1bmN0aW9uKHQpe3ZhciBuPXRoaXMuc2VhcmNoX25vZGVfO2lmKHQ8bi52YWx1ZSl7Zm9yKDtuPW4ucHJldjspaWYodD49bi52YWx1ZSlyZXR1cm4gdGhpcy5zZWFyY2hfbm9kZV89bixufWVsc2UgZm9yKDtuPW4ubmV4dDspaWYodDxuLnZhbHVlKXJldHVybiB0aGlzLnNlYXJjaF9ub2RlXz1uLnByZXYsbi5wcmV2O3JldHVybiBudWxsfSxpLnByb3RvdHlwZS5sb2NhdGVQb2ludD1mdW5jdGlvbih0KXt2YXIgbj10LngsZT10aGlzLmZpbmRTZWFyY2hOb2RlKG4pLGk9ZS5wb2ludC54O2lmKG49PT1pKXtpZih0IT09ZS5wb2ludClpZih0PT09ZS5wcmV2LnBvaW50KWU9ZS5wcmV2O2Vsc2V7aWYodCE9PWUubmV4dC5wb2ludCl0aHJvdyBuZXcgRXJyb3IoXCJwb2x5MnRyaSBJbnZhbGlkIEFkdmFuY2luZ0Zyb250LmxvY2F0ZVBvaW50KCkgY2FsbFwiKTtlPWUubmV4dH19ZWxzZSBpZihpPm4pZm9yKDsoZT1lLnByZXYpJiZ0IT09ZS5wb2ludDspO2Vsc2UgZm9yKDsoZT1lLm5leHQpJiZ0IT09ZS5wb2ludDspO3JldHVybiBlJiYodGhpcy5zZWFyY2hfbm9kZV89ZSksZX0sbi5leHBvcnRzPWksbi5leHBvcnRzLk5vZGU9ZX0se31dLDM6W2Z1bmN0aW9uKHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZSh0LG4pe2lmKCF0KXRocm93IG5ldyBFcnJvcihufHxcIkFzc2VydCBGYWlsZWRcIil9bi5leHBvcnRzPWV9LHt9XSw0OltmdW5jdGlvbih0LG4pe1widXNlIHN0cmljdFwiO3ZhciBlPXQoXCIuL3h5XCIpLGk9ZnVuY3Rpb24odCxuKXt0aGlzLng9K3R8fDAsdGhpcy55PStufHwwLHRoaXMuX3AydF9lZGdlX2xpc3Q9bnVsbH07aS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gZS50b1N0cmluZ0Jhc2UodGhpcyl9LGkucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybnt4OnRoaXMueCx5OnRoaXMueX19LGkucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBpKHRoaXMueCx0aGlzLnkpfSxpLnByb3RvdHlwZS5zZXRfemVybz1mdW5jdGlvbigpe3JldHVybiB0aGlzLng9MCx0aGlzLnk9MCx0aGlzfSxpLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24odCxuKXtyZXR1cm4gdGhpcy54PSt0fHwwLHRoaXMueT0rbnx8MCx0aGlzfSxpLnByb3RvdHlwZS5uZWdhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy54PS10aGlzLngsdGhpcy55PS10aGlzLnksdGhpc30saS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLngrPXQueCx0aGlzLnkrPXQueSx0aGlzfSxpLnByb3RvdHlwZS5zdWI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMueC09dC54LHRoaXMueS09dC55LHRoaXN9LGkucHJvdG90eXBlLm11bD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy54Kj10LHRoaXMueSo9dCx0aGlzfSxpLnByb3RvdHlwZS5sZW5ndGg9ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSl9LGkucHJvdG90eXBlLm5vcm1hbGl6ZT1mdW5jdGlvbigpe3ZhciB0PXRoaXMubGVuZ3RoKCk7cmV0dXJuIHRoaXMueC89dCx0aGlzLnkvPXQsdH0saS5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLng9PT10LngmJnRoaXMueT09PXQueX0saS5uZWdhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBpKC10LngsLXQueSl9LGkuYWRkPWZ1bmN0aW9uKHQsbil7cmV0dXJuIG5ldyBpKHQueCtuLngsdC55K24ueSl9LGkuc3ViPWZ1bmN0aW9uKHQsbil7cmV0dXJuIG5ldyBpKHQueC1uLngsdC55LW4ueSl9LGkubXVsPWZ1bmN0aW9uKHQsbil7cmV0dXJuIG5ldyBpKHQqbi54LHQqbi55KX0saS5jcm9zcz1mdW5jdGlvbih0LG4pe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0P1wibnVtYmVyXCI9PXR5cGVvZiBuP3QqbjpuZXcgaSgtdCpuLnksdCpuLngpOlwibnVtYmVyXCI9PXR5cGVvZiBuP25ldyBpKG4qdC55LC1uKnQueCk6dC54Km4ueS10Lnkqbi54fSxpLnRvU3RyaW5nPWUudG9TdHJpbmcsaS5jb21wYXJlPWUuY29tcGFyZSxpLmNtcD1lLmNvbXBhcmUsaS5lcXVhbHM9ZS5lcXVhbHMsaS5kb3Q9ZnVuY3Rpb24odCxuKXtyZXR1cm4gdC54Km4ueCt0Lnkqbi55fSxuLmV4cG9ydHM9aX0se1wiLi94eVwiOjExfV0sNTpbZnVuY3Rpb24odCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgZT10KFwiLi94eVwiKSxpPWZ1bmN0aW9uKHQsbil7dGhpcy5uYW1lPVwiUG9pbnRFcnJvclwiLHRoaXMucG9pbnRzPW49bnx8W10sdGhpcy5tZXNzYWdlPXR8fFwiSW52YWxpZCBQb2ludHMhXCI7Zm9yKHZhciBpPTA7aTxuLmxlbmd0aDtpKyspdGhpcy5tZXNzYWdlKz1cIiBcIitlLnRvU3RyaW5nKG5baV0pfTtpLnByb3RvdHlwZT1uZXcgRXJyb3IsaS5wcm90b3R5cGUuY29uc3RydWN0b3I9aSxuLmV4cG9ydHM9aX0se1wiLi94eVwiOjExfV0sNjpbZnVuY3Rpb24odCxuLGUpeyhmdW5jdGlvbihuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1uLnBvbHkydHJpO2Uubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBuLnBvbHkydHJpPWksZX0sZS5WRVJTSU9OPXQoXCIuLi9kaXN0L3ZlcnNpb24uanNvblwiKS52ZXJzaW9uLGUuUG9pbnRFcnJvcj10KFwiLi9wb2ludGVycm9yXCIpLGUuUG9pbnQ9dChcIi4vcG9pbnRcIiksZS5UcmlhbmdsZT10KFwiLi90cmlhbmdsZVwiKSxlLlN3ZWVwQ29udGV4dD10KFwiLi9zd2VlcGNvbnRleHRcIik7dmFyIG89dChcIi4vc3dlZXBcIik7ZS50cmlhbmd1bGF0ZT1vLnRyaWFuZ3VsYXRlLGUuc3dlZXA9e1RyaWFuZ3VsYXRlOm8udHJpYW5ndWxhdGV9fSkuY2FsbCh0aGlzLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6e30pfSx7XCIuLi9kaXN0L3ZlcnNpb24uanNvblwiOjEsXCIuL3BvaW50XCI6NCxcIi4vcG9pbnRlcnJvclwiOjUsXCIuL3N3ZWVwXCI6NyxcIi4vc3dlZXBjb250ZXh0XCI6OCxcIi4vdHJpYW5nbGVcIjo5fV0sNzpbZnVuY3Rpb24odCxuLGUpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGkodCl7dC5pbml0VHJpYW5ndWxhdGlvbigpLHQuY3JlYXRlQWR2YW5jaW5nRnJvbnQoKSxvKHQpLHIodCl9ZnVuY3Rpb24gbyh0KXt2YXIgbixlPXQucG9pbnRDb3VudCgpO2ZvcihuPTE7ZT5uOysrbilmb3IodmFyIGk9dC5nZXRQb2ludChuKSxvPXModCxpKSxyPWkuX3AydF9lZGdlX2xpc3QsYT0wO3ImJmE8ci5sZW5ndGg7KythKXAodCxyW2FdLG8pfWZ1bmN0aW9uIHIodCl7Zm9yKHZhciBuPXQuZnJvbnQoKS5oZWFkKCkubmV4dC50cmlhbmdsZSxlPXQuZnJvbnQoKS5oZWFkKCkubmV4dC5wb2ludDshbi5nZXRDb25zdHJhaW5lZEVkZ2VDVyhlKTspbj1uLm5laWdoYm9yQ0NXKGUpO3QubWVzaENsZWFuKG4pfWZ1bmN0aW9uIHModCxuKXt2YXIgZT10LmxvY2F0ZU5vZGUobiksaT11KHQsbixlKTtyZXR1cm4gbi54PD1lLnBvaW50LngrRiYmZCh0LGUpLGcodCxpKSxpfWZ1bmN0aW9uIHAodCxuLGUpe3QuZWRnZV9ldmVudC5jb25zdHJhaW5lZF9lZGdlPW4sdC5lZGdlX2V2ZW50LnJpZ2h0PW4ucC54Pm4ucS54LGgoZS50cmlhbmdsZSxuLnAsbi5xKXx8KEModCxuLGUpLGEodCxuLnAsbi5xLGUudHJpYW5nbGUsbi5xKSl9ZnVuY3Rpb24gYSh0LG4sZSxpLG8pe2lmKCFoKGksbixlKSl7dmFyIHI9aS5wb2ludENDVyhvKSxzPXooZSxyLG4pO2lmKHM9PT1NLkNPTExJTkVBUil0aHJvdyBuZXcgRChcInBvbHkydHJpIEVkZ2VFdmVudDogQ29sbGluZWFyIG5vdCBzdXBwb3J0ZWQhXCIsW2UscixuXSk7dmFyIHA9aS5wb2ludENXKG8pLHU9eihlLHAsbik7aWYodT09PU0uQ09MTElORUFSKXRocm93IG5ldyBEKFwicG9seTJ0cmkgRWRnZUV2ZW50OiBDb2xsaW5lYXIgbm90IHN1cHBvcnRlZCFcIixbZSxwLG5dKTtzPT09dT8oaT1zPT09TS5DVz9pLm5laWdoYm9yQ0NXKG8pOmkubmVpZ2hib3JDVyhvKSxhKHQsbixlLGksbykpOnEodCxuLGUsaSxvKX19ZnVuY3Rpb24gaCh0LG4sZSl7dmFyIGk9dC5lZGdlSW5kZXgobixlKTtpZigtMSE9PWkpe3QubWFya0NvbnN0cmFpbmVkRWRnZUJ5SW5kZXgoaSk7dmFyIG89dC5nZXROZWlnaGJvcihpKTtyZXR1cm4gbyYmby5tYXJrQ29uc3RyYWluZWRFZGdlQnlQb2ludHMobixlKSwhMH1yZXR1cm4hMX1mdW5jdGlvbiB1KHQsbixlKXt2YXIgaT1uZXcgTyhuLGUucG9pbnQsZS5uZXh0LnBvaW50KTtpLm1hcmtOZWlnaGJvcihlLnRyaWFuZ2xlKSx0LmFkZFRvTWFwKGkpO3ZhciBvPW5ldyBCKG4pO3JldHVybiBvLm5leHQ9ZS5uZXh0LG8ucHJldj1lLGUubmV4dC5wcmV2PW8sZS5uZXh0PW8sbCh0LGkpfHx0Lm1hcFRyaWFuZ2xlVG9Ob2RlcyhpKSxvfWZ1bmN0aW9uIGQodCxuKXt2YXIgZT1uZXcgTyhuLnByZXYucG9pbnQsbi5wb2ludCxuLm5leHQucG9pbnQpO2UubWFya05laWdoYm9yKG4ucHJldi50cmlhbmdsZSksZS5tYXJrTmVpZ2hib3Iobi50cmlhbmdsZSksdC5hZGRUb01hcChlKSxuLnByZXYubmV4dD1uLm5leHQsbi5uZXh0LnByZXY9bi5wcmV2LGwodCxlKXx8dC5tYXBUcmlhbmdsZVRvTm9kZXMoZSl9ZnVuY3Rpb24gZyh0LG4pe2Zvcih2YXIgZT1uLm5leHQ7ZS5uZXh0JiYhaihlLnBvaW50LGUubmV4dC5wb2ludCxlLnByZXYucG9pbnQpOylkKHQsZSksZT1lLm5leHQ7Zm9yKGU9bi5wcmV2O2UucHJldiYmIWooZS5wb2ludCxlLm5leHQucG9pbnQsZS5wcmV2LnBvaW50KTspZCh0LGUpLGU9ZS5wcmV2O24ubmV4dCYmbi5uZXh0Lm5leHQmJmYobikmJnkodCxuKX1mdW5jdGlvbiBmKHQpe3ZhciBuPXQucG9pbnQueC10Lm5leHQubmV4dC5wb2ludC54LGU9dC5wb2ludC55LXQubmV4dC5uZXh0LnBvaW50Lnk7cmV0dXJuIFMoZT49MCxcInVub3JkZXJlZCB5XCIpLG4+PTB8fE1hdGguYWJzKG4pPGV9ZnVuY3Rpb24gbCh0LG4pe2Zvcih2YXIgZT0wOzM+ZTsrK2UpaWYoIW4uZGVsYXVuYXlfZWRnZVtlXSl7dmFyIGk9bi5nZXROZWlnaGJvcihlKTtpZihpKXt2YXIgbz1uLmdldFBvaW50KGUpLHI9aS5vcHBvc2l0ZVBvaW50KG4sbykscz1pLmluZGV4KHIpO2lmKGkuY29uc3RyYWluZWRfZWRnZVtzXXx8aS5kZWxhdW5heV9lZGdlW3NdKXtuLmNvbnN0cmFpbmVkX2VkZ2VbZV09aS5jb25zdHJhaW5lZF9lZGdlW3NdO2NvbnRpbnVlfXZhciBwPWMobyxuLnBvaW50Q0NXKG8pLG4ucG9pbnRDVyhvKSxyKTtpZihwKXtuLmRlbGF1bmF5X2VkZ2VbZV09ITAsaS5kZWxhdW5heV9lZGdlW3NdPSEwLF8obixvLGkscik7dmFyIGE9IWwodCxuKTtyZXR1cm4gYSYmdC5tYXBUcmlhbmdsZVRvTm9kZXMobiksYT0hbCh0LGkpLGEmJnQubWFwVHJpYW5nbGVUb05vZGVzKGkpLG4uZGVsYXVuYXlfZWRnZVtlXT0hMSxpLmRlbGF1bmF5X2VkZ2Vbc109ITEsITB9fX1yZXR1cm4hMX1mdW5jdGlvbiBjKHQsbixlLGkpe3ZhciBvPXQueC1pLngscj10LnktaS55LHM9bi54LWkueCxwPW4ueS1pLnksYT1vKnAsaD1zKnIsdT1hLWg7aWYoMD49dSlyZXR1cm4hMTt2YXIgZD1lLngtaS54LGc9ZS55LWkueSxmPWQqcixsPW8qZyxjPWYtbDtpZigwPj1jKXJldHVybiExO3ZhciBfPXMqZyx5PWQqcCx4PW8qbytyKnIsdj1zKnMrcCpwLEM9ZCpkK2cqZyxiPXgqKF8teSkrdipjK0MqdTtyZXR1cm4gYj4wfWZ1bmN0aW9uIF8odCxuLGUsaSl7dmFyIG8scixzLHA7bz10Lm5laWdoYm9yQ0NXKG4pLHI9dC5uZWlnaGJvckNXKG4pLHM9ZS5uZWlnaGJvckNDVyhpKSxwPWUubmVpZ2hib3JDVyhpKTt2YXIgYSxoLHUsZDthPXQuZ2V0Q29uc3RyYWluZWRFZGdlQ0NXKG4pLGg9dC5nZXRDb25zdHJhaW5lZEVkZ2VDVyhuKSx1PWUuZ2V0Q29uc3RyYWluZWRFZGdlQ0NXKGkpLGQ9ZS5nZXRDb25zdHJhaW5lZEVkZ2VDVyhpKTt2YXIgZyxmLGwsYztnPXQuZ2V0RGVsYXVuYXlFZGdlQ0NXKG4pLGY9dC5nZXREZWxhdW5heUVkZ2VDVyhuKSxsPWUuZ2V0RGVsYXVuYXlFZGdlQ0NXKGkpLGM9ZS5nZXREZWxhdW5heUVkZ2VDVyhpKSx0LmxlZ2FsaXplKG4saSksZS5sZWdhbGl6ZShpLG4pLGUuc2V0RGVsYXVuYXlFZGdlQ0NXKG4sZyksdC5zZXREZWxhdW5heUVkZ2VDVyhuLGYpLHQuc2V0RGVsYXVuYXlFZGdlQ0NXKGksbCksZS5zZXREZWxhdW5heUVkZ2VDVyhpLGMpLGUuc2V0Q29uc3RyYWluZWRFZGdlQ0NXKG4sYSksdC5zZXRDb25zdHJhaW5lZEVkZ2VDVyhuLGgpLHQuc2V0Q29uc3RyYWluZWRFZGdlQ0NXKGksdSksZS5zZXRDb25zdHJhaW5lZEVkZ2VDVyhpLGQpLHQuY2xlYXJOZWlnaGJvcnMoKSxlLmNsZWFyTmVpZ2hib3JzKCksbyYmZS5tYXJrTmVpZ2hib3IobyksciYmdC5tYXJrTmVpZ2hib3IocikscyYmdC5tYXJrTmVpZ2hib3IocykscCYmZS5tYXJrTmVpZ2hib3IocCksdC5tYXJrTmVpZ2hib3IoZSl9ZnVuY3Rpb24geSh0LG4pe2Zvcih0LmJhc2luLmxlZnRfbm9kZT16KG4ucG9pbnQsbi5uZXh0LnBvaW50LG4ubmV4dC5uZXh0LnBvaW50KT09PU0uQ0NXP24ubmV4dC5uZXh0Om4ubmV4dCx0LmJhc2luLmJvdHRvbV9ub2RlPXQuYmFzaW4ubGVmdF9ub2RlO3QuYmFzaW4uYm90dG9tX25vZGUubmV4dCYmdC5iYXNpbi5ib3R0b21fbm9kZS5wb2ludC55Pj10LmJhc2luLmJvdHRvbV9ub2RlLm5leHQucG9pbnQueTspdC5iYXNpbi5ib3R0b21fbm9kZT10LmJhc2luLmJvdHRvbV9ub2RlLm5leHQ7aWYodC5iYXNpbi5ib3R0b21fbm9kZSE9PXQuYmFzaW4ubGVmdF9ub2RlKXtmb3IodC5iYXNpbi5yaWdodF9ub2RlPXQuYmFzaW4uYm90dG9tX25vZGU7dC5iYXNpbi5yaWdodF9ub2RlLm5leHQmJnQuYmFzaW4ucmlnaHRfbm9kZS5wb2ludC55PHQuYmFzaW4ucmlnaHRfbm9kZS5uZXh0LnBvaW50Lnk7KXQuYmFzaW4ucmlnaHRfbm9kZT10LmJhc2luLnJpZ2h0X25vZGUubmV4dDt0LmJhc2luLnJpZ2h0X25vZGUhPT10LmJhc2luLmJvdHRvbV9ub2RlJiYodC5iYXNpbi53aWR0aD10LmJhc2luLnJpZ2h0X25vZGUucG9pbnQueC10LmJhc2luLmxlZnRfbm9kZS5wb2ludC54LHQuYmFzaW4ubGVmdF9oaWdoZXN0PXQuYmFzaW4ubGVmdF9ub2RlLnBvaW50Lnk+dC5iYXNpbi5yaWdodF9ub2RlLnBvaW50LnkseCh0LHQuYmFzaW4uYm90dG9tX25vZGUpKX19ZnVuY3Rpb24geCh0LG4pe2lmKCF2KHQsbikpe2QodCxuKTt2YXIgZTtpZihuLnByZXYhPT10LmJhc2luLmxlZnRfbm9kZXx8bi5uZXh0IT09dC5iYXNpbi5yaWdodF9ub2RlKXtpZihuLnByZXY9PT10LmJhc2luLmxlZnRfbm9kZSl7aWYoZT16KG4ucG9pbnQsbi5uZXh0LnBvaW50LG4ubmV4dC5uZXh0LnBvaW50KSxlPT09TS5DVylyZXR1cm47bj1uLm5leHR9ZWxzZSBpZihuLm5leHQ9PT10LmJhc2luLnJpZ2h0X25vZGUpe2lmKGU9eihuLnBvaW50LG4ucHJldi5wb2ludCxuLnByZXYucHJldi5wb2ludCksZT09PU0uQ0NXKXJldHVybjtuPW4ucHJldn1lbHNlIG49bi5wcmV2LnBvaW50Lnk8bi5uZXh0LnBvaW50Lnk/bi5wcmV2Om4ubmV4dDt4KHQsbil9fX1mdW5jdGlvbiB2KHQsbil7dmFyIGU7cmV0dXJuIGU9dC5iYXNpbi5sZWZ0X2hpZ2hlc3Q/dC5iYXNpbi5sZWZ0X25vZGUucG9pbnQueS1uLnBvaW50Lnk6dC5iYXNpbi5yaWdodF9ub2RlLnBvaW50Lnktbi5wb2ludC55LHQuYmFzaW4ud2lkdGg+ZT8hMDohMX1mdW5jdGlvbiBDKHQsbixlKXt0LmVkZ2VfZXZlbnQucmlnaHQ/Yih0LG4sZSk6RSh0LG4sZSl9ZnVuY3Rpb24gYih0LG4sZSl7Zm9yKDtlLm5leHQucG9pbnQueDxuLnAueDspeihuLnEsZS5uZXh0LnBvaW50LG4ucCk9PT1NLkNDVz9tKHQsbixlKTplPWUubmV4dH1mdW5jdGlvbiBtKHQsbixlKXtlLnBvaW50Lng8bi5wLngmJih6KGUucG9pbnQsZS5uZXh0LnBvaW50LGUubmV4dC5uZXh0LnBvaW50KT09PU0uQ0NXP1codCxuLGUpOih3KHQsbixlKSxtKHQsbixlKSkpfWZ1bmN0aW9uIFcodCxuLGUpe2QodCxlLm5leHQpLGUubmV4dC5wb2ludCE9PW4ucCYmeihuLnEsZS5uZXh0LnBvaW50LG4ucCk9PT1NLkNDVyYmeihlLnBvaW50LGUubmV4dC5wb2ludCxlLm5leHQubmV4dC5wb2ludCk9PT1NLkNDVyYmVyh0LG4sZSl9ZnVuY3Rpb24gdyh0LG4sZSl7eihlLm5leHQucG9pbnQsZS5uZXh0Lm5leHQucG9pbnQsZS5uZXh0Lm5leHQubmV4dC5wb2ludCk9PT1NLkNDVz9XKHQsbixlLm5leHQpOnoobi5xLGUubmV4dC5uZXh0LnBvaW50LG4ucCk9PT1NLkNDVyYmdyh0LG4sZS5uZXh0KX1mdW5jdGlvbiBFKHQsbixlKXtmb3IoO2UucHJldi5wb2ludC54Pm4ucC54Oyl6KG4ucSxlLnByZXYucG9pbnQsbi5wKT09PU0uQ1c/UCh0LG4sZSk6ZT1lLnByZXZ9ZnVuY3Rpb24gUCh0LG4sZSl7ZS5wb2ludC54Pm4ucC54JiYoeihlLnBvaW50LGUucHJldi5wb2ludCxlLnByZXYucHJldi5wb2ludCk9PT1NLkNXP1QodCxuLGUpOihOKHQsbixlKSxQKHQsbixlKSkpfWZ1bmN0aW9uIE4odCxuLGUpe3ooZS5wcmV2LnBvaW50LGUucHJldi5wcmV2LnBvaW50LGUucHJldi5wcmV2LnByZXYucG9pbnQpPT09TS5DVz9UKHQsbixlLnByZXYpOnoobi5xLGUucHJldi5wcmV2LnBvaW50LG4ucCk9PT1NLkNXJiZOKHQsbixlLnByZXYpfWZ1bmN0aW9uIFQodCxuLGUpe2QodCxlLnByZXYpLGUucHJldi5wb2ludCE9PW4ucCYmeihuLnEsZS5wcmV2LnBvaW50LG4ucCk9PT1NLkNXJiZ6KGUucG9pbnQsZS5wcmV2LnBvaW50LGUucHJldi5wcmV2LnBvaW50KT09PU0uQ1cmJlQodCxuLGUpfWZ1bmN0aW9uIHEodCxuLGUsaSxvKXt2YXIgcj1pLm5laWdoYm9yQWNyb3NzKG8pO1MocixcIkZMSVAgZmFpbGVkIGR1ZSB0byBtaXNzaW5nIHRyaWFuZ2xlIVwiKTt2YXIgcz1yLm9wcG9zaXRlUG9pbnQoaSxvKTtpZihpLmdldENvbnN0cmFpbmVkRWRnZUFjcm9zcyhvKSl7dmFyIHA9aS5pbmRleChvKTt0aHJvdyBuZXcgRChcInBvbHkydHJpIEludGVyc2VjdGluZyBDb25zdHJhaW50c1wiLFtvLHMsaS5nZXRQb2ludCgocCsxKSUzKSxpLmdldFBvaW50KChwKzIpJTMpXSl9aWYoSChvLGkucG9pbnRDQ1cobyksaS5wb2ludENXKG8pLHMpKWlmKF8oaSxvLHIscyksdC5tYXBUcmlhbmdsZVRvTm9kZXMoaSksdC5tYXBUcmlhbmdsZVRvTm9kZXMociksbz09PWUmJnM9PT1uKWU9PT10LmVkZ2VfZXZlbnQuY29uc3RyYWluZWRfZWRnZS5xJiZuPT09dC5lZGdlX2V2ZW50LmNvbnN0cmFpbmVkX2VkZ2UucCYmKGkubWFya0NvbnN0cmFpbmVkRWRnZUJ5UG9pbnRzKG4sZSksci5tYXJrQ29uc3RyYWluZWRFZGdlQnlQb2ludHMobixlKSxsKHQsaSksbCh0LHIpKTtlbHNle3ZhciBoPXooZSxzLG4pO2k9SSh0LGgsaSxyLG8scykscSh0LG4sZSxpLG8pfWVsc2V7dmFyIHU9ayhuLGUscixzKTtBKHQsbixlLGkscix1KSxhKHQsbixlLGksbyl9fWZ1bmN0aW9uIEkodCxuLGUsaSxvLHIpe3ZhciBzO3JldHVybiBuPT09TS5DQ1c/KHM9aS5lZGdlSW5kZXgobyxyKSxpLmRlbGF1bmF5X2VkZ2Vbc109ITAsbCh0LGkpLGkuY2xlYXJEZWxhdW5heUVkZ2VzKCksZSk6KHM9ZS5lZGdlSW5kZXgobyxyKSxlLmRlbGF1bmF5X2VkZ2Vbc109ITAsbCh0LGUpLGUuY2xlYXJEZWxhdW5heUVkZ2VzKCksaSl9ZnVuY3Rpb24gayh0LG4sZSxpKXt2YXIgbz16KG4saSx0KTtpZihvPT09TS5DVylyZXR1cm4gZS5wb2ludENDVyhpKTtpZihvPT09TS5DQ1cpcmV0dXJuIGUucG9pbnRDVyhpKTt0aHJvdyBuZXcgRChcInBvbHkydHJpIFtVbnN1cHBvcnRlZF0gbmV4dEZsaXBQb2ludDogb3Bwb3NpbmcgcG9pbnQgb24gY29uc3RyYWluZWQgZWRnZSFcIixbbixpLHRdKX1mdW5jdGlvbiBBKHQsbixlLGksbyxyKXt2YXIgcz1vLm5laWdoYm9yQWNyb3NzKHIpO1MocyxcIkZMSVAgZmFpbGVkIGR1ZSB0byBtaXNzaW5nIHRyaWFuZ2xlXCIpO3ZhciBwPXMub3Bwb3NpdGVQb2ludChvLHIpO2lmKEgoZSxpLnBvaW50Q0NXKGUpLGkucG9pbnRDVyhlKSxwKSlxKHQsZSxwLHMscCk7ZWxzZXt2YXIgYT1rKG4sZSxzLHApO0EodCxuLGUsaSxzLGEpfX12YXIgUz10KFwiLi9hc3NlcnRcIiksRD10KFwiLi9wb2ludGVycm9yXCIpLE89dChcIi4vdHJpYW5nbGVcIiksQj10KFwiLi9hZHZhbmNpbmdmcm9udFwiKS5Ob2RlLEw9dChcIi4vdXRpbHNcIiksRj1MLkVQU0lMT04sTT1MLk9yaWVudGF0aW9uLHo9TC5vcmllbnQyZCxIPUwuaW5TY2FuQXJlYSxqPUwuaXNBbmdsZU9idHVzZTtlLnRyaWFuZ3VsYXRlPWl9LHtcIi4vYWR2YW5jaW5nZnJvbnRcIjoyLFwiLi9hc3NlcnRcIjozLFwiLi9wb2ludGVycm9yXCI6NSxcIi4vdHJpYW5nbGVcIjo5LFwiLi91dGlsc1wiOjEwfV0sODpbZnVuY3Rpb24odCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgZT10KFwiLi9wb2ludGVycm9yXCIpLGk9dChcIi4vcG9pbnRcIiksbz10KFwiLi90cmlhbmdsZVwiKSxyPXQoXCIuL3N3ZWVwXCIpLHM9dChcIi4vYWR2YW5jaW5nZnJvbnRcIikscD1zLk5vZGUsYT0uMyxoPWZ1bmN0aW9uKHQsbil7aWYodGhpcy5wPXQsdGhpcy5xPW4sdC55Pm4ueSl0aGlzLnE9dCx0aGlzLnA9bjtlbHNlIGlmKHQueT09PW4ueSlpZih0Lng+bi54KXRoaXMucT10LHRoaXMucD1uO2Vsc2UgaWYodC54PT09bi54KXRocm93IG5ldyBlKFwicG9seTJ0cmkgSW52YWxpZCBFZGdlIGNvbnN0cnVjdG9yOiByZXBlYXRlZCBwb2ludHMhXCIsW3RdKTt0aGlzLnEuX3AydF9lZGdlX2xpc3R8fCh0aGlzLnEuX3AydF9lZGdlX2xpc3Q9W10pLHRoaXMucS5fcDJ0X2VkZ2VfbGlzdC5wdXNoKHRoaXMpfSx1PWZ1bmN0aW9uKCl7dGhpcy5sZWZ0X25vZGU9bnVsbCx0aGlzLmJvdHRvbV9ub2RlPW51bGwsdGhpcy5yaWdodF9ub2RlPW51bGwsdGhpcy53aWR0aD0wLHRoaXMubGVmdF9oaWdoZXN0PSExfTt1LnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMubGVmdF9ub2RlPW51bGwsdGhpcy5ib3R0b21fbm9kZT1udWxsLHRoaXMucmlnaHRfbm9kZT1udWxsLHRoaXMud2lkdGg9MCx0aGlzLmxlZnRfaGlnaGVzdD0hMX07dmFyIGQ9ZnVuY3Rpb24oKXt0aGlzLmNvbnN0cmFpbmVkX2VkZ2U9bnVsbCx0aGlzLnJpZ2h0PSExfSxnPWZ1bmN0aW9uKHQsbil7bj1ufHx7fSx0aGlzLnRyaWFuZ2xlc189W10sdGhpcy5tYXBfPVtdLHRoaXMucG9pbnRzXz1uLmNsb25lQXJyYXlzP3Quc2xpY2UoMCk6dCx0aGlzLmVkZ2VfbGlzdD1bXSx0aGlzLnBtaW5fPXRoaXMucG1heF89bnVsbCx0aGlzLmZyb250Xz1udWxsLHRoaXMuaGVhZF89bnVsbCx0aGlzLnRhaWxfPW51bGwsdGhpcy5hZl9oZWFkXz1udWxsLHRoaXMuYWZfbWlkZGxlXz1udWxsLHRoaXMuYWZfdGFpbF89bnVsbCx0aGlzLmJhc2luPW5ldyB1LHRoaXMuZWRnZV9ldmVudD1uZXcgZCx0aGlzLmluaXRFZGdlcyh0aGlzLnBvaW50c18pfTtnLnByb3RvdHlwZS5hZGRIb2xlPWZ1bmN0aW9uKHQpe3RoaXMuaW5pdEVkZ2VzKHQpO3ZhciBuLGU9dC5sZW5ndGg7Zm9yKG49MDtlPm47bisrKXRoaXMucG9pbnRzXy5wdXNoKHRbbl0pO3JldHVybiB0aGlzfSxnLnByb3RvdHlwZS5BZGRIb2xlPWcucHJvdG90eXBlLmFkZEhvbGUsZy5wcm90b3R5cGUuYWRkSG9sZXM9ZnVuY3Rpb24odCl7dmFyIG4sZT10Lmxlbmd0aDtmb3Iobj0wO2U+bjtuKyspdGhpcy5pbml0RWRnZXModFtuXSk7cmV0dXJuIHRoaXMucG9pbnRzXz10aGlzLnBvaW50c18uY29uY2F0LmFwcGx5KHRoaXMucG9pbnRzXyx0KSx0aGlzfSxnLnByb3RvdHlwZS5hZGRQb2ludD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5wb2ludHNfLnB1c2godCksdGhpc30sZy5wcm90b3R5cGUuQWRkUG9pbnQ9Zy5wcm90b3R5cGUuYWRkUG9pbnQsZy5wcm90b3R5cGUuYWRkUG9pbnRzPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnBvaW50c189dGhpcy5wb2ludHNfLmNvbmNhdCh0KSx0aGlzfSxnLnByb3RvdHlwZS50cmlhbmd1bGF0ZT1mdW5jdGlvbigpe3JldHVybiByLnRyaWFuZ3VsYXRlKHRoaXMpLHRoaXN9LGcucHJvdG90eXBlLmdldEJvdW5kaW5nQm94PWZ1bmN0aW9uKCl7cmV0dXJue21pbjp0aGlzLnBtaW5fLG1heDp0aGlzLnBtYXhffX0sZy5wcm90b3R5cGUuZ2V0VHJpYW5nbGVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJpYW5nbGVzX30sZy5wcm90b3R5cGUuR2V0VHJpYW5nbGVzPWcucHJvdG90eXBlLmdldFRyaWFuZ2xlcyxnLnByb3RvdHlwZS5mcm9udD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmZyb250X30sZy5wcm90b3R5cGUucG9pbnRDb3VudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBvaW50c18ubGVuZ3RofSxnLnByb3RvdHlwZS5oZWFkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGVhZF99LGcucHJvdG90eXBlLnNldEhlYWQ9ZnVuY3Rpb24odCl7dGhpcy5oZWFkXz10fSxnLnByb3RvdHlwZS50YWlsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGFpbF99LGcucHJvdG90eXBlLnNldFRhaWw9ZnVuY3Rpb24odCl7dGhpcy50YWlsXz10fSxnLnByb3RvdHlwZS5nZXRNYXA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXBffSxnLnByb3RvdHlwZS5pbml0VHJpYW5ndWxhdGlvbj1mdW5jdGlvbigpe3ZhciB0LG49dGhpcy5wb2ludHNfWzBdLngsZT10aGlzLnBvaW50c19bMF0ueCxvPXRoaXMucG9pbnRzX1swXS55LHI9dGhpcy5wb2ludHNfWzBdLnkscz10aGlzLnBvaW50c18ubGVuZ3RoO2Zvcih0PTE7cz50O3QrKyl7dmFyIHA9dGhpcy5wb2ludHNfW3RdO3AueD5uJiYobj1wLngpLHAueDxlJiYoZT1wLngpLHAueT5vJiYobz1wLnkpLHAueTxyJiYocj1wLnkpfXRoaXMucG1pbl89bmV3IGkoZSxyKSx0aGlzLnBtYXhfPW5ldyBpKG4sbyk7dmFyIGg9YSoobi1lKSx1PWEqKG8tcik7dGhpcy5oZWFkXz1uZXcgaShuK2gsci11KSx0aGlzLnRhaWxfPW5ldyBpKGUtaCxyLXUpLHRoaXMucG9pbnRzXy5zb3J0KGkuY29tcGFyZSl9LGcucHJvdG90eXBlLmluaXRFZGdlcz1mdW5jdGlvbih0KXt2YXIgbixlPXQubGVuZ3RoO2ZvcihuPTA7ZT5uOysrbil0aGlzLmVkZ2VfbGlzdC5wdXNoKG5ldyBoKHRbbl0sdFsobisxKSVlXSkpfSxnLnByb3RvdHlwZS5nZXRQb2ludD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5wb2ludHNfW3RdfSxnLnByb3RvdHlwZS5hZGRUb01hcD1mdW5jdGlvbih0KXt0aGlzLm1hcF8ucHVzaCh0KX0sZy5wcm90b3R5cGUubG9jYXRlTm9kZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5mcm9udF8ubG9jYXRlTm9kZSh0LngpfSxnLnByb3RvdHlwZS5jcmVhdGVBZHZhbmNpbmdGcm9udD1mdW5jdGlvbigpe3ZhciB0LG4sZSxpPW5ldyBvKHRoaXMucG9pbnRzX1swXSx0aGlzLnRhaWxfLHRoaXMuaGVhZF8pO3RoaXMubWFwXy5wdXNoKGkpLHQ9bmV3IHAoaS5nZXRQb2ludCgxKSxpKSxuPW5ldyBwKGkuZ2V0UG9pbnQoMCksaSksZT1uZXcgcChpLmdldFBvaW50KDIpKSx0aGlzLmZyb250Xz1uZXcgcyh0LGUpLHQubmV4dD1uLG4ubmV4dD1lLG4ucHJldj10LGUucHJldj1ufSxnLnByb3RvdHlwZS5yZW1vdmVOb2RlPWZ1bmN0aW9uKCl7fSxnLnByb3RvdHlwZS5tYXBUcmlhbmdsZVRvTm9kZXM9ZnVuY3Rpb24odCl7Zm9yKHZhciBuPTA7Mz5uOysrbilpZighdC5nZXROZWlnaGJvcihuKSl7dmFyIGU9dGhpcy5mcm9udF8ubG9jYXRlUG9pbnQodC5wb2ludENXKHQuZ2V0UG9pbnQobikpKTtlJiYoZS50cmlhbmdsZT10KX19LGcucHJvdG90eXBlLnJlbW92ZUZyb21NYXA9ZnVuY3Rpb24odCl7dmFyIG4sZT10aGlzLm1hcF8saT1lLmxlbmd0aDtmb3Iobj0wO2k+bjtuKyspaWYoZVtuXT09PXQpe2Uuc3BsaWNlKG4sMSk7YnJlYWt9fSxnLnByb3RvdHlwZS5tZXNoQ2xlYW49ZnVuY3Rpb24odCl7Zm9yKHZhciBuLGUsaT1bdF07bj1pLnBvcCgpOylpZighbi5pc0ludGVyaW9yKCkpZm9yKG4uc2V0SW50ZXJpb3IoITApLHRoaXMudHJpYW5nbGVzXy5wdXNoKG4pLGU9MDszPmU7ZSsrKW4uY29uc3RyYWluZWRfZWRnZVtlXXx8aS5wdXNoKG4uZ2V0TmVpZ2hib3IoZSkpfSxuLmV4cG9ydHM9Z30se1wiLi9hZHZhbmNpbmdmcm9udFwiOjIsXCIuL3BvaW50XCI6NCxcIi4vcG9pbnRlcnJvclwiOjUsXCIuL3N3ZWVwXCI6NyxcIi4vdHJpYW5nbGVcIjo5fV0sOTpbZnVuY3Rpb24odCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgZT10KFwiLi94eVwiKSxpPWZ1bmN0aW9uKHQsbixlKXt0aGlzLnBvaW50c189W3QsbixlXSx0aGlzLm5laWdoYm9yc189W251bGwsbnVsbCxudWxsXSx0aGlzLmludGVyaW9yXz0hMSx0aGlzLmNvbnN0cmFpbmVkX2VkZ2U9WyExLCExLCExXSx0aGlzLmRlbGF1bmF5X2VkZ2U9WyExLCExLCExXX0sbz1lLnRvU3RyaW5nO2kucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJbXCIrbyh0aGlzLnBvaW50c19bMF0pK28odGhpcy5wb2ludHNfWzFdKStvKHRoaXMucG9pbnRzX1syXSkrXCJdXCJ9LGkucHJvdG90eXBlLmdldFBvaW50PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnBvaW50c19bdF19LGkucHJvdG90eXBlLkdldFBvaW50PWkucHJvdG90eXBlLmdldFBvaW50LGkucHJvdG90eXBlLmdldFBvaW50cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBvaW50c199LGkucHJvdG90eXBlLmdldE5laWdoYm9yPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm5laWdoYm9yc19bdF19LGkucHJvdG90eXBlLmNvbnRhaW5zUG9pbnQ9ZnVuY3Rpb24odCl7dmFyIG49dGhpcy5wb2ludHNfO3JldHVybiB0PT09blswXXx8dD09PW5bMV18fHQ9PT1uWzJdfSxpLnByb3RvdHlwZS5jb250YWluc0VkZ2U9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29udGFpbnNQb2ludCh0LnApJiZ0aGlzLmNvbnRhaW5zUG9pbnQodC5xKX0saS5wcm90b3R5cGUuY29udGFpbnNQb2ludHM9ZnVuY3Rpb24odCxuKXtyZXR1cm4gdGhpcy5jb250YWluc1BvaW50KHQpJiZ0aGlzLmNvbnRhaW5zUG9pbnQobil9LGkucHJvdG90eXBlLmlzSW50ZXJpb3I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnRlcmlvcl99LGkucHJvdG90eXBlLnNldEludGVyaW9yPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmludGVyaW9yXz10LHRoaXN9LGkucHJvdG90eXBlLm1hcmtOZWlnaGJvclBvaW50ZXJzPWZ1bmN0aW9uKHQsbixlKXt2YXIgaT10aGlzLnBvaW50c187aWYodD09PWlbMl0mJm49PT1pWzFdfHx0PT09aVsxXSYmbj09PWlbMl0pdGhpcy5uZWlnaGJvcnNfWzBdPWU7ZWxzZSBpZih0PT09aVswXSYmbj09PWlbMl18fHQ9PT1pWzJdJiZuPT09aVswXSl0aGlzLm5laWdoYm9yc19bMV09ZTtlbHNle2lmKCEodD09PWlbMF0mJm49PT1pWzFdfHx0PT09aVsxXSYmbj09PWlbMF0pKXRocm93IG5ldyBFcnJvcihcInBvbHkydHJpIEludmFsaWQgVHJpYW5nbGUubWFya05laWdoYm9yUG9pbnRlcnMoKSBjYWxsXCIpO3RoaXMubmVpZ2hib3JzX1syXT1lfX0saS5wcm90b3R5cGUubWFya05laWdoYm9yPWZ1bmN0aW9uKHQpe3ZhciBuPXRoaXMucG9pbnRzXzt0LmNvbnRhaW5zUG9pbnRzKG5bMV0sblsyXSk/KHRoaXMubmVpZ2hib3JzX1swXT10LHQubWFya05laWdoYm9yUG9pbnRlcnMoblsxXSxuWzJdLHRoaXMpKTp0LmNvbnRhaW5zUG9pbnRzKG5bMF0sblsyXSk/KHRoaXMubmVpZ2hib3JzX1sxXT10LHQubWFya05laWdoYm9yUG9pbnRlcnMoblswXSxuWzJdLHRoaXMpKTp0LmNvbnRhaW5zUG9pbnRzKG5bMF0sblsxXSkmJih0aGlzLm5laWdoYm9yc19bMl09dCx0Lm1hcmtOZWlnaGJvclBvaW50ZXJzKG5bMF0sblsxXSx0aGlzKSl9LGkucHJvdG90eXBlLmNsZWFyTmVpZ2hib3JzPWZ1bmN0aW9uKCl7dGhpcy5uZWlnaGJvcnNfWzBdPW51bGwsdGhpcy5uZWlnaGJvcnNfWzFdPW51bGwsdGhpcy5uZWlnaGJvcnNfWzJdPW51bGx9LGkucHJvdG90eXBlLmNsZWFyRGVsYXVuYXlFZGdlcz1mdW5jdGlvbigpe3RoaXMuZGVsYXVuYXlfZWRnZVswXT0hMSx0aGlzLmRlbGF1bmF5X2VkZ2VbMV09ITEsdGhpcy5kZWxhdW5heV9lZGdlWzJdPSExfSxpLnByb3RvdHlwZS5wb2ludENXPWZ1bmN0aW9uKHQpe3ZhciBuPXRoaXMucG9pbnRzXztyZXR1cm4gdD09PW5bMF0/blsyXTp0PT09blsxXT9uWzBdOnQ9PT1uWzJdP25bMV06bnVsbH0saS5wcm90b3R5cGUucG9pbnRDQ1c9ZnVuY3Rpb24odCl7dmFyIG49dGhpcy5wb2ludHNfO3JldHVybiB0PT09blswXT9uWzFdOnQ9PT1uWzFdP25bMl06dD09PW5bMl0/blswXTpudWxsfSxpLnByb3RvdHlwZS5uZWlnaGJvckNXPWZ1bmN0aW9uKHQpe3JldHVybiB0PT09dGhpcy5wb2ludHNfWzBdP3RoaXMubmVpZ2hib3JzX1sxXTp0PT09dGhpcy5wb2ludHNfWzFdP3RoaXMubmVpZ2hib3JzX1syXTp0aGlzLm5laWdoYm9yc19bMF19LGkucHJvdG90eXBlLm5laWdoYm9yQ0NXPWZ1bmN0aW9uKHQpe3JldHVybiB0PT09dGhpcy5wb2ludHNfWzBdP3RoaXMubmVpZ2hib3JzX1syXTp0PT09dGhpcy5wb2ludHNfWzFdP3RoaXMubmVpZ2hib3JzX1swXTp0aGlzLm5laWdoYm9yc19bMV19LGkucHJvdG90eXBlLmdldENvbnN0cmFpbmVkRWRnZUNXPWZ1bmN0aW9uKHQpe3JldHVybiB0PT09dGhpcy5wb2ludHNfWzBdP3RoaXMuY29uc3RyYWluZWRfZWRnZVsxXTp0PT09dGhpcy5wb2ludHNfWzFdP3RoaXMuY29uc3RyYWluZWRfZWRnZVsyXTp0aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMF19LGkucHJvdG90eXBlLmdldENvbnN0cmFpbmVkRWRnZUNDVz1mdW5jdGlvbih0KXtyZXR1cm4gdD09PXRoaXMucG9pbnRzX1swXT90aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMl06dD09PXRoaXMucG9pbnRzX1sxXT90aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMF06dGhpcy5jb25zdHJhaW5lZF9lZGdlWzFdfSxpLnByb3RvdHlwZS5nZXRDb25zdHJhaW5lZEVkZ2VBY3Jvc3M9ZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT10aGlzLnBvaW50c19bMF0/dGhpcy5jb25zdHJhaW5lZF9lZGdlWzBdOnQ9PT10aGlzLnBvaW50c19bMV0/dGhpcy5jb25zdHJhaW5lZF9lZGdlWzFdOnRoaXMuY29uc3RyYWluZWRfZWRnZVsyXX0saS5wcm90b3R5cGUuc2V0Q29uc3RyYWluZWRFZGdlQ1c9ZnVuY3Rpb24odCxuKXt0PT09dGhpcy5wb2ludHNfWzBdP3RoaXMuY29uc3RyYWluZWRfZWRnZVsxXT1uOnQ9PT10aGlzLnBvaW50c19bMV0/dGhpcy5jb25zdHJhaW5lZF9lZGdlWzJdPW46dGhpcy5jb25zdHJhaW5lZF9lZGdlWzBdPW59LGkucHJvdG90eXBlLnNldENvbnN0cmFpbmVkRWRnZUNDVz1mdW5jdGlvbih0LG4pe3Q9PT10aGlzLnBvaW50c19bMF0/dGhpcy5jb25zdHJhaW5lZF9lZGdlWzJdPW46dD09PXRoaXMucG9pbnRzX1sxXT90aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMF09bjp0aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMV09bn0saS5wcm90b3R5cGUuZ2V0RGVsYXVuYXlFZGdlQ1c9ZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT10aGlzLnBvaW50c19bMF0/dGhpcy5kZWxhdW5heV9lZGdlWzFdOnQ9PT10aGlzLnBvaW50c19bMV0/dGhpcy5kZWxhdW5heV9lZGdlWzJdOnRoaXMuZGVsYXVuYXlfZWRnZVswXX0saS5wcm90b3R5cGUuZ2V0RGVsYXVuYXlFZGdlQ0NXPWZ1bmN0aW9uKHQpe3JldHVybiB0PT09dGhpcy5wb2ludHNfWzBdP3RoaXMuZGVsYXVuYXlfZWRnZVsyXTp0PT09dGhpcy5wb2ludHNfWzFdP3RoaXMuZGVsYXVuYXlfZWRnZVswXTp0aGlzLmRlbGF1bmF5X2VkZ2VbMV19LGkucHJvdG90eXBlLnNldERlbGF1bmF5RWRnZUNXPWZ1bmN0aW9uKHQsbil7dD09PXRoaXMucG9pbnRzX1swXT90aGlzLmRlbGF1bmF5X2VkZ2VbMV09bjp0PT09dGhpcy5wb2ludHNfWzFdP3RoaXMuZGVsYXVuYXlfZWRnZVsyXT1uOnRoaXMuZGVsYXVuYXlfZWRnZVswXT1ufSxpLnByb3RvdHlwZS5zZXREZWxhdW5heUVkZ2VDQ1c9ZnVuY3Rpb24odCxuKXt0PT09dGhpcy5wb2ludHNfWzBdP3RoaXMuZGVsYXVuYXlfZWRnZVsyXT1uOnQ9PT10aGlzLnBvaW50c19bMV0/dGhpcy5kZWxhdW5heV9lZGdlWzBdPW46dGhpcy5kZWxhdW5heV9lZGdlWzFdPW59LGkucHJvdG90eXBlLm5laWdoYm9yQWNyb3NzPWZ1bmN0aW9uKHQpe3JldHVybiB0PT09dGhpcy5wb2ludHNfWzBdP3RoaXMubmVpZ2hib3JzX1swXTp0PT09dGhpcy5wb2ludHNfWzFdP3RoaXMubmVpZ2hib3JzX1sxXTp0aGlzLm5laWdoYm9yc19bMl19LGkucHJvdG90eXBlLm9wcG9zaXRlUG9pbnQ9ZnVuY3Rpb24odCxuKXt2YXIgZT10LnBvaW50Q1cobik7cmV0dXJuIHRoaXMucG9pbnRDVyhlKX0saS5wcm90b3R5cGUubGVnYWxpemU9ZnVuY3Rpb24odCxuKXt2YXIgZT10aGlzLnBvaW50c187aWYodD09PWVbMF0pZVsxXT1lWzBdLGVbMF09ZVsyXSxlWzJdPW47ZWxzZSBpZih0PT09ZVsxXSllWzJdPWVbMV0sZVsxXT1lWzBdLGVbMF09bjtlbHNle2lmKHQhPT1lWzJdKXRocm93IG5ldyBFcnJvcihcInBvbHkydHJpIEludmFsaWQgVHJpYW5nbGUubGVnYWxpemUoKSBjYWxsXCIpO2VbMF09ZVsyXSxlWzJdPWVbMV0sZVsxXT1ufX0saS5wcm90b3R5cGUuaW5kZXg9ZnVuY3Rpb24odCl7dmFyIG49dGhpcy5wb2ludHNfO2lmKHQ9PT1uWzBdKXJldHVybiAwO2lmKHQ9PT1uWzFdKXJldHVybiAxO2lmKHQ9PT1uWzJdKXJldHVybiAyO3Rocm93IG5ldyBFcnJvcihcInBvbHkydHJpIEludmFsaWQgVHJpYW5nbGUuaW5kZXgoKSBjYWxsXCIpfSxpLnByb3RvdHlwZS5lZGdlSW5kZXg9ZnVuY3Rpb24odCxuKXt2YXIgZT10aGlzLnBvaW50c187aWYodD09PWVbMF0pe2lmKG49PT1lWzFdKXJldHVybiAyO2lmKG49PT1lWzJdKXJldHVybiAxfWVsc2UgaWYodD09PWVbMV0pe2lmKG49PT1lWzJdKXJldHVybiAwO2lmKG49PT1lWzBdKXJldHVybiAyfWVsc2UgaWYodD09PWVbMl0pe2lmKG49PT1lWzBdKXJldHVybiAxO2lmKG49PT1lWzFdKXJldHVybiAwfXJldHVybi0xfSxpLnByb3RvdHlwZS5tYXJrQ29uc3RyYWluZWRFZGdlQnlJbmRleD1mdW5jdGlvbih0KXt0aGlzLmNvbnN0cmFpbmVkX2VkZ2VbdF09ITB9LGkucHJvdG90eXBlLm1hcmtDb25zdHJhaW5lZEVkZ2VCeUVkZ2U9ZnVuY3Rpb24odCl7dGhpcy5tYXJrQ29uc3RyYWluZWRFZGdlQnlQb2ludHModC5wLHQucSl9LGkucHJvdG90eXBlLm1hcmtDb25zdHJhaW5lZEVkZ2VCeVBvaW50cz1mdW5jdGlvbih0LG4pe3ZhciBlPXRoaXMucG9pbnRzXztuPT09ZVswXSYmdD09PWVbMV18fG49PT1lWzFdJiZ0PT09ZVswXT90aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMl09ITA6bj09PWVbMF0mJnQ9PT1lWzJdfHxuPT09ZVsyXSYmdD09PWVbMF0/dGhpcy5jb25zdHJhaW5lZF9lZGdlWzFdPSEwOihuPT09ZVsxXSYmdD09PWVbMl18fG49PT1lWzJdJiZ0PT09ZVsxXSkmJih0aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMF09ITApfSxuLmV4cG9ydHM9aX0se1wiLi94eVwiOjExfV0sMTA6W2Z1bmN0aW9uKHQsbixlKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKHQsbixlKXt2YXIgaT0odC54LWUueCkqKG4ueS1lLnkpLG89KHQueS1lLnkpKihuLngtZS54KSxyPWktbztyZXR1cm4gcj4tcyYmcz5yP3AuQ09MTElORUFSOnI+MD9wLkNDVzpwLkNXfWZ1bmN0aW9uIG8odCxuLGUsaSl7dmFyIG89KHQueC1uLngpKihpLnktbi55KS0oaS54LW4ueCkqKHQueS1uLnkpO2lmKG8+PS1zKXJldHVybiExO3ZhciByPSh0LngtZS54KSooaS55LWUueSktKGkueC1lLngpKih0LnktZS55KTtyZXR1cm4gcz49cj8hMTohMH1mdW5jdGlvbiByKHQsbixlKXt2YXIgaT1uLngtdC54LG89bi55LXQueSxyPWUueC10Lngscz1lLnktdC55O3JldHVybiAwPmkqcitvKnN9dmFyIHM9MWUtMTI7ZS5FUFNJTE9OPXM7dmFyIHA9e0NXOjEsQ0NXOi0xLENPTExJTkVBUjowfTtlLk9yaWVudGF0aW9uPXAsZS5vcmllbnQyZD1pLGUuaW5TY2FuQXJlYT1vLGUuaXNBbmdsZU9idHVzZT1yfSx7fV0sMTE6W2Z1bmN0aW9uKHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZSh0KXtyZXR1cm5cIihcIit0LngrXCI7XCIrdC55K1wiKVwifWZ1bmN0aW9uIGkodCl7dmFyIG49dC50b1N0cmluZygpO3JldHVyblwiW29iamVjdCBPYmplY3RdXCI9PT1uP2UodCk6bn1mdW5jdGlvbiBvKHQsbil7cmV0dXJuIHQueT09PW4ueT90Lngtbi54OnQueS1uLnl9ZnVuY3Rpb24gcih0LG4pe3JldHVybiB0Lng9PT1uLngmJnQueT09PW4ueX1uLmV4cG9ydHM9e3RvU3RyaW5nOmksdG9TdHJpbmdCYXNlOmUsY29tcGFyZTpvLGVxdWFsczpyfX0se31dfSx7fSxbNl0pKDYpfSk7XHJcbiIsIiFmdW5jdGlvbih0KXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz10KCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtdLHQpO2Vsc2V7dmFyIGU7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz9lPXdpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2U9Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiYoZT1zZWxmKSxlLlByaW9yaXR5UXVldWU9dCgpfX0oZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24gdChlLGkscil7ZnVuY3Rpb24gbyhuLHMpe2lmKCFpW25dKXtpZighZVtuXSl7dmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighcyYmdSlyZXR1cm4gdShuLCEwKTtpZihhKXJldHVybiBhKG4sITApO3ZhciBoPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbitcIidcIik7dGhyb3cgaC5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGh9dmFyIHA9aVtuXT17ZXhwb3J0czp7fX07ZVtuXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbih0KXt2YXIgaT1lW25dWzFdW3RdO3JldHVybiBvKGk/aTp0KX0scCxwLmV4cG9ydHMsdCxlLGkscil9cmV0dXJuIGlbbl0uZXhwb3J0c31mb3IodmFyIGE9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxuPTA7bjxyLmxlbmd0aDtuKyspbyhyW25dKTtyZXR1cm4gb30oezE6W2Z1bmN0aW9uKHQsZSl7dmFyIGkscixvLGEsbixzPXt9Lmhhc093blByb3BlcnR5LHU9ZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBpKCl7dGhpcy5jb25zdHJ1Y3Rvcj10fWZvcih2YXIgciBpbiBlKXMuY2FsbChlLHIpJiYodFtyXT1lW3JdKTtyZXR1cm4gaS5wcm90b3R5cGU9ZS5wcm90b3R5cGUsdC5wcm90b3R5cGU9bmV3IGksdC5fX3N1cGVyX189ZS5wcm90b3R5cGUsdH07aT10KFwiLi9Qcmlvcml0eVF1ZXVlL0Fic3RyYWN0UHJpb3JpdHlRdWV1ZVwiKSxyPXQoXCIuL1ByaW9yaXR5UXVldWUvQXJyYXlTdHJhdGVneVwiKSxhPXQoXCIuL1ByaW9yaXR5UXVldWUvQmluYXJ5SGVhcFN0cmF0ZWd5XCIpLG89dChcIi4vUHJpb3JpdHlRdWV1ZS9CSGVhcFN0cmF0ZWd5XCIpLG49ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXt0fHwodD17fSksdC5zdHJhdGVneXx8KHQuc3RyYXRlZ3k9YSksdC5jb21wYXJhdG9yfHwodC5jb21wYXJhdG9yPWZ1bmN0aW9uKHQsZSl7cmV0dXJuKHR8fDApLShlfHwwKX0pLGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyx0KX1yZXR1cm4gdShlLHQpLGV9KGkpLG4uQXJyYXlTdHJhdGVneT1yLG4uQmluYXJ5SGVhcFN0cmF0ZWd5PWEsbi5CSGVhcFN0cmF0ZWd5PW8sZS5leHBvcnRzPW59LHtcIi4vUHJpb3JpdHlRdWV1ZS9BYnN0cmFjdFByaW9yaXR5UXVldWVcIjoyLFwiLi9Qcmlvcml0eVF1ZXVlL0FycmF5U3RyYXRlZ3lcIjozLFwiLi9Qcmlvcml0eVF1ZXVlL0JIZWFwU3RyYXRlZ3lcIjo0LFwiLi9Qcmlvcml0eVF1ZXVlL0JpbmFyeUhlYXBTdHJhdGVneVwiOjV9XSwyOltmdW5jdGlvbih0LGUpe3ZhciBpO2UuZXhwb3J0cz1pPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZihudWxsPT0obnVsbCE9dD90LnN0cmF0ZWd5OnZvaWQgMCkpdGhyb3dcIk11c3QgcGFzcyBvcHRpb25zLnN0cmF0ZWd5LCBhIHN0cmF0ZWd5XCI7aWYobnVsbD09KG51bGwhPXQ/dC5jb21wYXJhdG9yOnZvaWQgMCkpdGhyb3dcIk11c3QgcGFzcyBvcHRpb25zLmNvbXBhcmF0b3IsIGEgY29tcGFyYXRvclwiO3RoaXMucHJpdj1uZXcgdC5zdHJhdGVneSh0KSx0aGlzLmxlbmd0aD0wfXJldHVybiB0LnByb3RvdHlwZS5xdWV1ZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5sZW5ndGgrKyx2b2lkIHRoaXMucHJpdi5xdWV1ZSh0KX0sdC5wcm90b3R5cGUuZGVxdWV1ZT1mdW5jdGlvbigpe2lmKCF0aGlzLmxlbmd0aCl0aHJvd1wiRW1wdHkgcXVldWVcIjtyZXR1cm4gdGhpcy5sZW5ndGgtLSx0aGlzLnByaXYuZGVxdWV1ZSgpfSx0LnByb3RvdHlwZS5wZWVrPWZ1bmN0aW9uKCl7aWYoIXRoaXMubGVuZ3RoKXRocm93XCJFbXB0eSBxdWV1ZVwiO3JldHVybiB0aGlzLnByaXYucGVlaygpfSx0fSgpfSx7fV0sMzpbZnVuY3Rpb24odCxlKXt2YXIgaSxyO3I9ZnVuY3Rpb24odCxlLGkpe3ZhciByLG8sYTtmb3Iobz0wLHI9dC5sZW5ndGg7cj5vOylhPW8rcj4+PjEsaSh0W2FdLGUpPj0wP289YSsxOnI9YTtyZXR1cm4gb30sZS5leHBvcnRzPWk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3ZhciBlO3RoaXMub3B0aW9ucz10LHRoaXMuY29tcGFyYXRvcj10aGlzLm9wdGlvbnMuY29tcGFyYXRvcix0aGlzLmRhdGE9KG51bGwhPShlPXRoaXMub3B0aW9ucy5pbml0aWFsVmFsdWVzKT9lLnNsaWNlKDApOnZvaWQgMCl8fFtdLHRoaXMuZGF0YS5zb3J0KHRoaXMuY29tcGFyYXRvcikucmV2ZXJzZSgpfXJldHVybiB0LnByb3RvdHlwZS5xdWV1ZT1mdW5jdGlvbih0KXt2YXIgZTtyZXR1cm4gZT1yKHRoaXMuZGF0YSx0LHRoaXMuY29tcGFyYXRvciksdm9pZCB0aGlzLmRhdGEuc3BsaWNlKGUsMCx0KX0sdC5wcm90b3R5cGUuZGVxdWV1ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGEucG9wKCl9LHQucHJvdG90eXBlLnBlZWs9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhW3RoaXMuZGF0YS5sZW5ndGgtMV19LHR9KCl9LHt9XSw0OltmdW5jdGlvbih0LGUpe3ZhciBpO2UuZXhwb3J0cz1pPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt2YXIgZSxpLHIsbyxhLG4scyx1LGg7Zm9yKHRoaXMuY29tcGFyYXRvcj0obnVsbCE9dD90LmNvbXBhcmF0b3I6dm9pZCAwKXx8ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC1lfSx0aGlzLnBhZ2VTaXplPShudWxsIT10P3QucGFnZVNpemU6dm9pZCAwKXx8NTEyLHRoaXMubGVuZ3RoPTAscj0wOzE8PHI8dGhpcy5wYWdlU2l6ZTspcis9MTtpZigxPDxyIT09dGhpcy5wYWdlU2l6ZSl0aHJvd1wicGFnZVNpemUgbXVzdCBiZSBhIHBvd2VyIG9mIHR3b1wiO2Zvcih0aGlzLl9zaGlmdD1yLHRoaXMuX2VtcHR5TWVtb3J5UGFnZVRlbXBsYXRlPWU9W10saT1hPTAsdT10aGlzLnBhZ2VTaXplO3U+PTA/dT5hOmE+dTtpPXU+PTA/KythOi0tYSllLnB1c2gobnVsbCk7aWYodGhpcy5fbWVtb3J5PVtdLHRoaXMuX21hc2s9dGhpcy5wYWdlU2l6ZS0xLHQuaW5pdGlhbFZhbHVlcylmb3IoaD10LmluaXRpYWxWYWx1ZXMsbj0wLHM9aC5sZW5ndGg7cz5uO24rKylvPWhbbl0sdGhpcy5xdWV1ZShvKX1yZXR1cm4gdC5wcm90b3R5cGUucXVldWU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubGVuZ3RoKz0xLHRoaXMuX3dyaXRlKHRoaXMubGVuZ3RoLHQpLHZvaWQgdGhpcy5fYnViYmxlVXAodGhpcy5sZW5ndGgsdCl9LHQucHJvdG90eXBlLmRlcXVldWU9ZnVuY3Rpb24oKXt2YXIgdCxlO3JldHVybiB0PXRoaXMuX3JlYWQoMSksZT10aGlzLl9yZWFkKHRoaXMubGVuZ3RoKSx0aGlzLmxlbmd0aC09MSx0aGlzLmxlbmd0aD4wJiYodGhpcy5fd3JpdGUoMSxlKSx0aGlzLl9idWJibGVEb3duKDEsZSkpLHR9LHQucHJvdG90eXBlLnBlZWs9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVhZCgxKX0sdC5wcm90b3R5cGUuX3dyaXRlPWZ1bmN0aW9uKHQsZSl7dmFyIGk7Zm9yKGk9dD4+dGhpcy5fc2hpZnQ7aT49dGhpcy5fbWVtb3J5Lmxlbmd0aDspdGhpcy5fbWVtb3J5LnB1c2godGhpcy5fZW1wdHlNZW1vcnlQYWdlVGVtcGxhdGUuc2xpY2UoMCkpO3JldHVybiB0aGlzLl9tZW1vcnlbaV1bdCZ0aGlzLl9tYXNrXT1lfSx0LnByb3RvdHlwZS5fcmVhZD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fbWVtb3J5W3Q+PnRoaXMuX3NoaWZ0XVt0JnRoaXMuX21hc2tdfSx0LnByb3RvdHlwZS5fYnViYmxlVXA9ZnVuY3Rpb24odCxlKXt2YXIgaSxyLG8sYTtmb3IoaT10aGlzLmNvbXBhcmF0b3I7dD4xJiYocj10JnRoaXMuX21hc2ssdDx0aGlzLnBhZ2VTaXplfHxyPjM/bz10Jn50aGlzLl9tYXNrfHI+PjE6Mj5yPyhvPXQtdGhpcy5wYWdlU2l6ZT4+dGhpcy5fc2hpZnQsbys9byZ+KHRoaXMuX21hc2s+PjEpLG98PXRoaXMucGFnZVNpemU+PjEpOm89dC0yLGE9dGhpcy5fcmVhZChvKSwhKGkoYSxlKTwwKSk7KXRoaXMuX3dyaXRlKG8sZSksdGhpcy5fd3JpdGUodCxhKSx0PW87cmV0dXJuIHZvaWQgMH0sdC5wcm90b3R5cGUuX2J1YmJsZURvd249ZnVuY3Rpb24odCxlKXt2YXIgaSxyLG8sYSxuO2ZvcihuPXRoaXMuY29tcGFyYXRvcjt0PHRoaXMubGVuZ3RoOylpZih0PnRoaXMuX21hc2smJiEodCZ0aGlzLl9tYXNrLTEpP2k9cj10KzI6dCZ0aGlzLnBhZ2VTaXplPj4xPyhpPSh0Jn50aGlzLl9tYXNrKT4+MSxpfD10JnRoaXMuX21hc2s+PjEsaT1pKzE8PHRoaXMuX3NoaWZ0LHI9aSsxKTooaT10Kyh0JnRoaXMuX21hc2spLHI9aSsxKSxpIT09ciYmcjw9dGhpcy5sZW5ndGgpaWYobz10aGlzLl9yZWFkKGkpLGE9dGhpcy5fcmVhZChyKSxuKG8sZSk8MCYmbihvLGEpPD0wKXRoaXMuX3dyaXRlKGksZSksdGhpcy5fd3JpdGUodCxvKSx0PWk7ZWxzZXtpZighKG4oYSxlKTwwKSlicmVhazt0aGlzLl93cml0ZShyLGUpLHRoaXMuX3dyaXRlKHQsYSksdD1yfWVsc2V7aWYoIShpPD10aGlzLmxlbmd0aCkpYnJlYWs7aWYobz10aGlzLl9yZWFkKGkpLCEobihvLGUpPDApKWJyZWFrO3RoaXMuX3dyaXRlKGksZSksdGhpcy5fd3JpdGUodCxvKSx0PWl9cmV0dXJuIHZvaWQgMH0sdH0oKX0se31dLDU6W2Z1bmN0aW9uKHQsZSl7dmFyIGk7ZS5leHBvcnRzPWk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3ZhciBlO3RoaXMuY29tcGFyYXRvcj0obnVsbCE9dD90LmNvbXBhcmF0b3I6dm9pZCAwKXx8ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC1lfSx0aGlzLmxlbmd0aD0wLHRoaXMuZGF0YT0obnVsbCE9KGU9dC5pbml0aWFsVmFsdWVzKT9lLnNsaWNlKDApOnZvaWQgMCl8fFtdLHRoaXMuX2hlYXBpZnkoKX1yZXR1cm4gdC5wcm90b3R5cGUuX2hlYXBpZnk9ZnVuY3Rpb24oKXt2YXIgdCxlLGk7aWYodGhpcy5kYXRhLmxlbmd0aD4wKWZvcih0PWU9MSxpPXRoaXMuZGF0YS5sZW5ndGg7aT49MT9pPmU6ZT5pO3Q9aT49MT8rK2U6LS1lKXRoaXMuX2J1YmJsZVVwKHQpO3JldHVybiB2b2lkIDB9LHQucHJvdG90eXBlLnF1ZXVlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRhdGEucHVzaCh0KSx2b2lkIHRoaXMuX2J1YmJsZVVwKHRoaXMuZGF0YS5sZW5ndGgtMSl9LHQucHJvdG90eXBlLmRlcXVldWU9ZnVuY3Rpb24oKXt2YXIgdCxlO3JldHVybiBlPXRoaXMuZGF0YVswXSx0PXRoaXMuZGF0YS5wb3AoKSx0aGlzLmRhdGEubGVuZ3RoPjAmJih0aGlzLmRhdGFbMF09dCx0aGlzLl9idWJibGVEb3duKDApKSxlfSx0LnByb3RvdHlwZS5wZWVrPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YVswXX0sdC5wcm90b3R5cGUuX2J1YmJsZVVwPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxpO3Q+MCYmKGU9dC0xPj4+MSx0aGlzLmNvbXBhcmF0b3IodGhpcy5kYXRhW3RdLHRoaXMuZGF0YVtlXSk8MCk7KWk9dGhpcy5kYXRhW2VdLHRoaXMuZGF0YVtlXT10aGlzLmRhdGFbdF0sdGhpcy5kYXRhW3RdPWksdD1lO3JldHVybiB2b2lkIDB9LHQucHJvdG90eXBlLl9idWJibGVEb3duPWZ1bmN0aW9uKHQpe3ZhciBlLGkscixvLGE7Zm9yKGU9dGhpcy5kYXRhLmxlbmd0aC0xOzspe2lmKGk9KHQ8PDEpKzEsbz1pKzEscj10LGU+PWkmJnRoaXMuY29tcGFyYXRvcih0aGlzLmRhdGFbaV0sdGhpcy5kYXRhW3JdKTwwJiYocj1pKSxlPj1vJiZ0aGlzLmNvbXBhcmF0b3IodGhpcy5kYXRhW29dLHRoaXMuZGF0YVtyXSk8MCYmKHI9bykscj09PXQpYnJlYWs7YT10aGlzLmRhdGFbcl0sdGhpcy5kYXRhW3JdPXRoaXMuZGF0YVt0XSx0aGlzLmRhdGFbdF09YSx0PXJ9cmV0dXJuIHZvaWQgMH0sdH0oKX0se31dfSx7fSxbMV0pKDEpfSk7IiwiLyogXHJcbiAqIFRoZXNlIGFjdGlvbiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgMjU2IHN0YXRlcyBwb3NzaWJsZSBnaXZlbiBlbXB0eVxyXG4gKiB0aWxlcywgZGlhZ29uYWwgdGlsZXMsIGFuZCBzcXVhcmUgdGlsZXMuIEdlbmVyYXRlZCB1c2luZyBkaWFnb25hbHMuanMuXHJcbiAqIFRoZXJlIGFyZSB0d28gcG9zc2libGUgZm9ybXMgZm9yIGFuIGFjdGlvbiB2YWx1ZS4gT25lIGlzIGFzIGEgc2luZ2xlIG9iamVjdC5cclxuICogSWYgYW4gaXRlbSBoYXMgb25seSBhIHNpbmdsZSBvYmplY3QsIHRoZW4gdGhlcmUgaXMgb25seSBvbmUgcG9zc2libGUgZW50cmFuY2UvXHJcbiAqIGV4aXQgcG9zc2libGUgZnJvbSB0aGF0IGFycmFuZ2VtZW50IG9mIHRpbGVzLiBJZiBhbiBpdGVtIGhhcyBhbiBhcnJheSBvZlxyXG4gKiBvYmplY3RzIHRoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGVudHJhbmNlL2V4aXRzIHBvc3NpYmxlLiBFYWNoIG9mIHRoZSBvYmplY3RzXHJcbiAqIGluIGFuIGFycmF5IG9mIHRoaXMgc29ydCBoYXMgYSAnbG9jJyBwcm9wZXJ0eSB0aGF0IGl0c2VsZiBpcyBhbiBvYmplY3Qgd2l0aFxyXG4gKiBwcm9wZXJ0aWVzICdpbl9kaXInIGFuZCAnb3V0X2RpcicgY29ycmVzcG9uZGluZyB0byB0aGUgdmFsdWVzIHRvIGdldCBpbnRvIHRoZVxyXG4gKiBjZWxsIGFuZCB0aGUgdmFsdWUgdGhhdCBzaG91bGQgYmUgdGFrZW4gdG8gZ2V0IG91dCBvZiBpdC4gRWFjaCBvZiB0aGUgb2JqZWN0c1xyXG4gKiBhbHNvIGhhcyBhIHByb3BlcnR5ICd2JyB3aGljaCBpcyBhIGJvb2xlYW4gY29ycmVzcG9uZGluZyB0byB3aGV0aGVyIHRoZXJlIGlzIFxyXG4gKiBhIHZlcnRleCBhdCBhIHRpbGUgd2l0aCB0aGlzIGFycmFuZ2VtZW50LiBUaGUgbG9jYXRpb25zIGNhbiBiZSBuLCBlLCBzLCB3LCBuZSxcclxuICogbncsIHNlLCBzdy5cclxuICogVGhlIGtleXMgb2YgdGhpcyBvYmplY3QgYXJlIHN0cmluZ3MgZ2VuZXJhdGVkIHVzaW5nIHRoZSBudW1iZXIgdmFsdWVzIG9mIGFcclxuICogY29udG91ciB0aWxlIHN0YXJ0aW5nIGZyb20gdGhlIHRvcCBsZWZ0IGFuZCBtb3ZpbmcgY2xvY2t3aXNlLCBzZXBhcmF0ZWQgYnkgaHlwaGVucy5cclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0ge1wiMC0wLTAtMFwiOntcInZcIjpmYWxzZSxcImxvY1wiOlwibm9uZVwifSxcIjEtMC0wLTBcIjp7XCJ2XCI6dHJ1ZSxcImxvY1wiOlwid1wifSxcIjItMC0wLTBcIjp7XCJ2XCI6dHJ1ZSxcImxvY1wiOlwid1wifSxcIjMtMC0wLTBcIjp7XCJ2XCI6dHJ1ZSxcImxvY1wiOlwibndcIn0sXCIwLTEtMC0wXCI6e1widlwiOnRydWUsXCJsb2NcIjpcIm5cIn0sXCIxLTEtMC0wXCI6e1widlwiOmZhbHNlLFwibG9jXCI6XCJ3XCJ9LFwiMi0xLTAtMFwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic2VcIixcIm91dF9kaXJcIjpcIndcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJ3XCIsXCJvdXRfZGlyXCI6XCJuXCJ9fV0sXCIzLTEtMC0wXCI6e1widlwiOnRydWUsXCJsb2NcIjpcIm53XCJ9LFwiMC0yLTAtMFwiOntcInZcIjp0cnVlLFwibG9jXCI6XCJuZVwifSxcIjEtMi0wLTBcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNcIixcIm91dF9kaXJcIjpcIndcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJ3XCIsXCJvdXRfZGlyXCI6XCJuZVwifX1dLFwiMi0yLTAtMFwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic2VcIixcIm91dF9kaXJcIjpcIndcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJ3XCIsXCJvdXRfZGlyXCI6XCJuZVwifX1dLFwiMy0yLTAtMFwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwid1wiLFwib3V0X2RpclwiOlwibmVcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzXCIsXCJvdXRfZGlyXCI6XCJud1wifX1dLFwiMC0zLTAtMFwiOntcInZcIjp0cnVlLFwibG9jXCI6XCJuXCJ9LFwiMS0zLTAtMFwiOntcInZcIjp0cnVlLFwibG9jXCI6XCJ3XCJ9LFwiMi0zLTAtMFwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic2VcIixcIm91dF9kaXJcIjpcIndcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzd1wiLFwib3V0X2RpclwiOlwiblwifX1dLFwiMy0zLTAtMFwiOntcInZcIjp0cnVlLFwibG9jXCI6XCJud1wifSxcIjAtMC0xLTBcIjp7XCJ2XCI6dHJ1ZSxcImxvY1wiOlwiZVwifSxcIjEtMC0xLTBcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNcIixcIm91dF9kaXJcIjpcIndcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuXCIsXCJvdXRfZGlyXCI6XCJlXCJ9fV0sXCIyLTAtMS0wXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzZVwiLFwib3V0X2RpclwiOlwid1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5cIixcIm91dF9kaXJcIjpcImVcIn19XSxcIjMtMC0xLTBcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5cIixcIm91dF9kaXJcIjpcImVcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzXCIsXCJvdXRfZGlyXCI6XCJud1wifX1dLFwiMC0xLTEtMFwiOntcInZcIjpmYWxzZSxcImxvY1wiOlwiblwifSxcIjEtMS0xLTBcIjp7XCJ2XCI6dHJ1ZSxcImxvY1wiOlwid1wifSxcIjItMS0xLTBcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNlXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fSx7XCJ2XCI6ZmFsc2UsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5cIixcIm91dF9kaXJcIjpcIm5cIn19XSxcIjMtMS0xLTBcIjp7XCJ2XCI6dHJ1ZSxcImxvY1wiOlwibndcIn0sXCIwLTItMS0wXCI6e1widlwiOnRydWUsXCJsb2NcIjpcIm5lXCJ9LFwiMS0yLTEtMFwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiblwiLFwib3V0X2RpclwiOlwibmVcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fV0sXCIyLTItMS0wXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzZVwiLFwib3V0X2RpclwiOlwid1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5cIixcIm91dF9kaXJcIjpcIm5lXCJ9fV0sXCIzLTItMS0wXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuXCIsXCJvdXRfZGlyXCI6XCJuZVwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNcIixcIm91dF9kaXJcIjpcIm53XCJ9fV0sXCIwLTMtMS0wXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuXCIsXCJvdXRfZGlyXCI6XCJlXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic3dcIixcIm91dF9kaXJcIjpcImVcIn19XSxcIjEtMy0xLTBcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5cIixcIm91dF9kaXJcIjpcImVcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzd1wiLFwib3V0X2RpclwiOlwiZVwifX1dLFwiMi0zLTEtMFwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic2VcIixcIm91dF9kaXJcIjpcIndcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuXCIsXCJvdXRfZGlyXCI6XCJlXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic3dcIixcIm91dF9kaXJcIjpcImVcIn19XSxcIjMtMy0xLTBcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5cIixcIm91dF9kaXJcIjpcImVcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzd1wiLFwib3V0X2RpclwiOlwiZVwifX1dLFwiMC0wLTItMFwiOntcInZcIjp0cnVlLFwibG9jXCI6XCJzZVwifSxcIjEtMC0yLTBcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNcIixcIm91dF9kaXJcIjpcIndcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuXCIsXCJvdXRfZGlyXCI6XCJzZVwifX1dLFwiMi0wLTItMFwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic2VcIixcIm91dF9kaXJcIjpcIndcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuXCIsXCJvdXRfZGlyXCI6XCJzZVwifX1dLFwiMy0wLTItMFwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic1wiLFwib3V0X2RpclwiOlwibndcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuXCIsXCJvdXRfZGlyXCI6XCJzZVwifX1dLFwiMC0xLTItMFwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwid1wiLFwib3V0X2RpclwiOlwiblwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5cIixcIm91dF9kaXJcIjpcInNlXCJ9fV0sXCIxLTEtMi0wXCI6W3tcInZcIjpmYWxzZSxcImxvY1wiOntcImluX2RpclwiOlwid1wiLFwib3V0X2RpclwiOlwid1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5cIixcIm91dF9kaXJcIjpcInNlXCJ9fV0sXCIyLTEtMi0wXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzZVwiLFwib3V0X2RpclwiOlwid1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIndcIixcIm91dF9kaXJcIjpcIm5cIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuXCIsXCJvdXRfZGlyXCI6XCJzZVwifX1dLFwiMy0xLTItMFwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwid1wiLFwib3V0X2RpclwiOlwibndcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuXCIsXCJvdXRfZGlyXCI6XCJzZVwifX1dLFwiMC0yLTItMFwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiblwiLFwib3V0X2RpclwiOlwic2VcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJ3XCIsXCJvdXRfZGlyXCI6XCJuZVwifX1dLFwiMS0yLTItMFwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic1wiLFwib3V0X2RpclwiOlwid1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5cIixcIm91dF9kaXJcIjpcInNlXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwid1wiLFwib3V0X2RpclwiOlwibmVcIn19XSxcIjItMi0yLTBcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNlXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiblwiLFwib3V0X2RpclwiOlwic2VcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJ3XCIsXCJvdXRfZGlyXCI6XCJuZVwifX1dLFwiMy0yLTItMFwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiblwiLFwib3V0X2RpclwiOlwic2VcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzXCIsXCJvdXRfZGlyXCI6XCJud1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIndcIixcIm91dF9kaXJcIjpcIm5lXCJ9fV0sXCIwLTMtMi0wXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzd1wiLFwib3V0X2RpclwiOlwiblwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5cIixcIm91dF9kaXJcIjpcInNlXCJ9fV0sXCIxLTMtMi0wXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzd1wiLFwib3V0X2RpclwiOlwid1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5cIixcIm91dF9kaXJcIjpcInNlXCJ9fV0sXCIyLTMtMi0wXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzZVwiLFwib3V0X2RpclwiOlwid1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInN3XCIsXCJvdXRfZGlyXCI6XCJuXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiblwiLFwib3V0X2RpclwiOlwic2VcIn19XSxcIjMtMy0yLTBcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInN3XCIsXCJvdXRfZGlyXCI6XCJud1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5cIixcIm91dF9kaXJcIjpcInNlXCJ9fV0sXCIwLTAtMy0wXCI6e1widlwiOnRydWUsXCJsb2NcIjpcImVcIn0sXCIxLTAtMy0wXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcImVcIn19XSxcIjItMC0zLTBcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNlXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcImVcIn19XSxcIjMtMC0zLTBcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm53XCIsXCJvdXRfZGlyXCI6XCJlXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic1wiLFwib3V0X2RpclwiOlwibndcIn19XSxcIjAtMS0zLTBcIjp7XCJ2XCI6dHJ1ZSxcImxvY1wiOlwiblwifSxcIjEtMS0zLTBcIjp7XCJ2XCI6dHJ1ZSxcImxvY1wiOlwid1wifSxcIjItMS0zLTBcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNlXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcIm5cIn19XSxcIjMtMS0zLTBcIjp7XCJ2XCI6ZmFsc2UsXCJsb2NcIjpcIm53XCJ9LFwiMC0yLTMtMFwiOntcInZcIjp0cnVlLFwibG9jXCI6XCJuZVwifSxcIjEtMi0zLTBcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm53XCIsXCJvdXRfZGlyXCI6XCJuZVwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNcIixcIm91dF9kaXJcIjpcIndcIn19XSxcIjItMi0zLTBcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNlXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcIm5lXCJ9fV0sXCIzLTItMy0wXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJud1wiLFwib3V0X2RpclwiOlwibmVcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzXCIsXCJvdXRfZGlyXCI6XCJud1wifX1dLFwiMC0zLTMtMFwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic3dcIixcIm91dF9kaXJcIjpcIm5cIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJud1wiLFwib3V0X2RpclwiOlwiZVwifX1dLFwiMS0zLTMtMFwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic3dcIixcIm91dF9kaXJcIjpcImVcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJud1wiLFwib3V0X2RpclwiOlwiZVwifX1dLFwiMi0zLTMtMFwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic2VcIixcIm91dF9kaXJcIjpcIndcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzd1wiLFwib3V0X2RpclwiOlwiblwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm53XCIsXCJvdXRfZGlyXCI6XCJlXCJ9fV0sXCIzLTMtMy0wXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzd1wiLFwib3V0X2RpclwiOlwiZVwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm53XCIsXCJvdXRfZGlyXCI6XCJlXCJ9fV0sXCIwLTAtMC0xXCI6e1widlwiOnRydWUsXCJsb2NcIjpcInNcIn0sXCIxLTAtMC0xXCI6e1widlwiOmZhbHNlLFwibG9jXCI6XCJzXCJ9LFwiMi0wLTAtMVwiOntcInZcIjp0cnVlLFwibG9jXCI6XCJzXCJ9LFwiMy0wLTAtMVwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiZVwiLFwib3V0X2RpclwiOlwic1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNcIixcIm91dF9kaXJcIjpcIm53XCJ9fV0sXCIwLTEtMC0xXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJlXCIsXCJvdXRfZGlyXCI6XCJzXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwid1wiLFwib3V0X2RpclwiOlwiblwifX1dLFwiMS0xLTAtMVwiOntcInZcIjp0cnVlLFwibG9jXCI6XCJzXCJ9LFwiMi0xLTAtMVwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic2VcIixcIm91dF9kaXJcIjpcIm5cIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJ3XCIsXCJvdXRfZGlyXCI6XCJuXCJ9fV0sXCIzLTEtMC0xXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJlXCIsXCJvdXRfZGlyXCI6XCJzXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwid1wiLFwib3V0X2RpclwiOlwibndcIn19XSxcIjAtMi0wLTFcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcImVcIixcIm91dF9kaXJcIjpcInNcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJ3XCIsXCJvdXRfZGlyXCI6XCJuZVwifX1dLFwiMS0yLTAtMVwiOlt7XCJ2XCI6ZmFsc2UsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNcIixcIm91dF9kaXJcIjpcInNcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJ3XCIsXCJvdXRfZGlyXCI6XCJuZVwifX1dLFwiMi0yLTAtMVwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic2VcIixcIm91dF9kaXJcIjpcInNcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJ3XCIsXCJvdXRfZGlyXCI6XCJuZVwifX1dLFwiMy0yLTAtMVwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiZVwiLFwib3V0X2RpclwiOlwic1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIndcIixcIm91dF9kaXJcIjpcIm5lXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic1wiLFwib3V0X2RpclwiOlwibndcIn19XSxcIjAtMy0wLTFcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcImVcIixcIm91dF9kaXJcIjpcInNcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzd1wiLFwib3V0X2RpclwiOlwiblwifX1dLFwiMS0zLTAtMVwiOntcInZcIjp0cnVlLFwibG9jXCI6XCJzXCJ9LFwiMi0zLTAtMVwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic2VcIixcIm91dF9kaXJcIjpcIm5cIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzd1wiLFwib3V0X2RpclwiOlwiblwifX1dLFwiMy0zLTAtMVwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiZVwiLFwib3V0X2RpclwiOlwic1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInN3XCIsXCJvdXRfZGlyXCI6XCJud1wifX1dLFwiMC0wLTEtMVwiOntcInZcIjpmYWxzZSxcImxvY1wiOlwiZVwifSxcIjEtMC0xLTFcIjp7XCJ2XCI6dHJ1ZSxcImxvY1wiOlwiZVwifSxcIjItMC0xLTFcIjp7XCJ2XCI6dHJ1ZSxcImxvY1wiOlwiZVwifSxcIjMtMC0xLTFcIjpbe1widlwiOmZhbHNlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJlXCIsXCJvdXRfZGlyXCI6XCJlXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic1wiLFwib3V0X2RpclwiOlwibndcIn19XSxcIjAtMS0xLTFcIjp7XCJ2XCI6dHJ1ZSxcImxvY1wiOlwiblwifSxcIjEtMS0xLTFcIjp7XCJ2XCI6ZmFsc2UsXCJsb2NcIjpcIm5vbmVcIn0sXCIyLTEtMS0xXCI6e1widlwiOnRydWUsXCJsb2NcIjpcIm5cIn0sXCIzLTEtMS0xXCI6e1widlwiOnRydWUsXCJsb2NcIjpcIm53XCJ9LFwiMC0yLTEtMVwiOntcInZcIjp0cnVlLFwibG9jXCI6XCJuZVwifSxcIjEtMi0xLTFcIjp7XCJ2XCI6dHJ1ZSxcImxvY1wiOlwibmVcIn0sXCIyLTItMS0xXCI6e1widlwiOnRydWUsXCJsb2NcIjpcIm5lXCJ9LFwiMy0yLTEtMVwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiZVwiLFwib3V0X2RpclwiOlwibmVcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzXCIsXCJvdXRfZGlyXCI6XCJud1wifX1dLFwiMC0zLTEtMVwiOlt7XCJ2XCI6ZmFsc2UsXCJsb2NcIjp7XCJpbl9kaXJcIjpcImVcIixcIm91dF9kaXJcIjpcImVcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzd1wiLFwib3V0X2RpclwiOlwiZVwifX1dLFwiMS0zLTEtMVwiOntcInZcIjp0cnVlLFwibG9jXCI6XCJlXCJ9LFwiMi0zLTEtMVwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic2VcIixcIm91dF9kaXJcIjpcIm5cIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzd1wiLFwib3V0X2RpclwiOlwiZVwifX1dLFwiMy0zLTEtMVwiOlt7XCJ2XCI6ZmFsc2UsXCJsb2NcIjp7XCJpbl9kaXJcIjpcImVcIixcIm91dF9kaXJcIjpcImVcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzd1wiLFwib3V0X2RpclwiOlwiZVwifX1dLFwiMC0wLTItMVwiOntcInZcIjp0cnVlLFwibG9jXCI6XCJzZVwifSxcIjEtMC0yLTFcIjp7XCJ2XCI6dHJ1ZSxcImxvY1wiOlwic2VcIn0sXCIyLTAtMi0xXCI6e1widlwiOmZhbHNlLFwibG9jXCI6XCJzZVwifSxcIjMtMC0yLTFcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcImVcIixcIm91dF9kaXJcIjpcInNlXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic1wiLFwib3V0X2RpclwiOlwibndcIn19XSxcIjAtMS0yLTFcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcImVcIixcIm91dF9kaXJcIjpcInNlXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwid1wiLFwib3V0X2RpclwiOlwiblwifX1dLFwiMS0xLTItMVwiOntcInZcIjp0cnVlLFwibG9jXCI6XCJzZVwifSxcIjItMS0yLTFcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNlXCIsXCJvdXRfZGlyXCI6XCJuXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwid1wiLFwib3V0X2RpclwiOlwiblwifX1dLFwiMy0xLTItMVwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiZVwiLFwib3V0X2RpclwiOlwic2VcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJ3XCIsXCJvdXRfZGlyXCI6XCJud1wifX1dLFwiMC0yLTItMVwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiZVwiLFwib3V0X2RpclwiOlwic2VcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJ3XCIsXCJvdXRfZGlyXCI6XCJuZVwifX1dLFwiMS0yLTItMVwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic1wiLFwib3V0X2RpclwiOlwic2VcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJ3XCIsXCJvdXRfZGlyXCI6XCJuZVwifX1dLFwiMi0yLTItMVwiOlt7XCJ2XCI6ZmFsc2UsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNlXCIsXCJvdXRfZGlyXCI6XCJzZVwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIndcIixcIm91dF9kaXJcIjpcIm5lXCJ9fV0sXCIzLTItMi0xXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJlXCIsXCJvdXRfZGlyXCI6XCJzZVwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNcIixcIm91dF9kaXJcIjpcIm53XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwid1wiLFwib3V0X2RpclwiOlwibmVcIn19XSxcIjAtMy0yLTFcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcImVcIixcIm91dF9kaXJcIjpcInNlXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic3dcIixcIm91dF9kaXJcIjpcIm5cIn19XSxcIjEtMy0yLTFcIjp7XCJ2XCI6dHJ1ZSxcImxvY1wiOlwic2VcIn0sXCIyLTMtMi0xXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzZVwiLFwib3V0X2RpclwiOlwiblwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInN3XCIsXCJvdXRfZGlyXCI6XCJuXCJ9fV0sXCIzLTMtMi0xXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJlXCIsXCJvdXRfZGlyXCI6XCJzZVwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInN3XCIsXCJvdXRfZGlyXCI6XCJud1wifX1dLFwiMC0wLTMtMVwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiZVwiLFwib3V0X2RpclwiOlwic1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm53XCIsXCJvdXRfZGlyXCI6XCJzXCJ9fV0sXCIxLTAtMy0xXCI6W3tcInZcIjpmYWxzZSxcImxvY1wiOntcImluX2RpclwiOlwic1wiLFwib3V0X2RpclwiOlwic1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm53XCIsXCJvdXRfZGlyXCI6XCJzXCJ9fV0sXCIyLTAtMy0xXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzZVwiLFwib3V0X2RpclwiOlwic1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm53XCIsXCJvdXRfZGlyXCI6XCJzXCJ9fV0sXCIzLTAtMy0xXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJlXCIsXCJvdXRfZGlyXCI6XCJzXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcInNcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzXCIsXCJvdXRfZGlyXCI6XCJud1wifX1dLFwiMC0xLTMtMVwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiZVwiLFwib3V0X2RpclwiOlwic1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm53XCIsXCJvdXRfZGlyXCI6XCJzXCJ9fV0sXCIxLTEtMy0xXCI6e1widlwiOnRydWUsXCJsb2NcIjpcInNcIn0sXCIyLTEtMy0xXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzZVwiLFwib3V0X2RpclwiOlwiblwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm53XCIsXCJvdXRfZGlyXCI6XCJzXCJ9fV0sXCIzLTEtMy0xXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJlXCIsXCJvdXRfZGlyXCI6XCJzXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcInNcIn19XSxcIjAtMi0zLTFcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcImVcIixcIm91dF9kaXJcIjpcInNcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJud1wiLFwib3V0X2RpclwiOlwic1wifX1dLFwiMS0yLTMtMVwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcInNcIn19LHtcInZcIjpmYWxzZSxcImxvY1wiOntcImluX2RpclwiOlwic1wiLFwib3V0X2RpclwiOlwic1wifX1dLFwiMi0yLTMtMVwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic2VcIixcIm91dF9kaXJcIjpcInNcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJud1wiLFwib3V0X2RpclwiOlwic1wifX1dLFwiMy0yLTMtMVwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiZVwiLFwib3V0X2RpclwiOlwic1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm53XCIsXCJvdXRfZGlyXCI6XCJzXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic1wiLFwib3V0X2RpclwiOlwibndcIn19XSxcIjAtMy0zLTFcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcImVcIixcIm91dF9kaXJcIjpcInNcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzd1wiLFwib3V0X2RpclwiOlwiblwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm53XCIsXCJvdXRfZGlyXCI6XCJzXCJ9fV0sXCIxLTMtMy0xXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzd1wiLFwib3V0X2RpclwiOlwiZVwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm53XCIsXCJvdXRfZGlyXCI6XCJzXCJ9fV0sXCIyLTMtMy0xXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzZVwiLFwib3V0X2RpclwiOlwiblwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInN3XCIsXCJvdXRfZGlyXCI6XCJuXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcInNcIn19XSxcIjMtMy0zLTFcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcImVcIixcIm91dF9kaXJcIjpcInNcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzd1wiLFwib3V0X2RpclwiOlwiZVwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm53XCIsXCJvdXRfZGlyXCI6XCJzXCJ9fV0sXCIwLTAtMC0yXCI6e1widlwiOnRydWUsXCJsb2NcIjpcInNcIn0sXCIxLTAtMC0yXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibmVcIixcIm91dF9kaXJcIjpcIndcIn19XSxcIjItMC0wLTJcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNlXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibmVcIixcIm91dF9kaXJcIjpcIndcIn19XSxcIjMtMC0wLTJcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5lXCIsXCJvdXRfZGlyXCI6XCJzXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic1wiLFwib3V0X2RpclwiOlwibndcIn19XSxcIjAtMS0wLTJcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIndcIixcIm91dF9kaXJcIjpcIm5cIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwic1wifX1dLFwiMS0xLTAtMlwiOlt7XCJ2XCI6ZmFsc2UsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIndcIixcIm91dF9kaXJcIjpcIndcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwid1wifX1dLFwiMi0xLTAtMlwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic2VcIixcIm91dF9kaXJcIjpcIndcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJ3XCIsXCJvdXRfZGlyXCI6XCJuXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibmVcIixcIm91dF9kaXJcIjpcIndcIn19XSxcIjMtMS0wLTJcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIndcIixcIm91dF9kaXJcIjpcIm53XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibmVcIixcIm91dF9kaXJcIjpcInNcIn19XSxcIjAtMi0wLTJcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5lXCIsXCJvdXRfZGlyXCI6XCJzXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwid1wiLFwib3V0X2RpclwiOlwibmVcIn19XSxcIjEtMi0wLTJcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5lXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic1wiLFwib3V0X2RpclwiOlwid1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIndcIixcIm91dF9kaXJcIjpcIm5lXCJ9fV0sXCIyLTItMC0yXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzZVwiLFwib3V0X2RpclwiOlwid1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5lXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwid1wiLFwib3V0X2RpclwiOlwibmVcIn19XSxcIjMtMi0wLTJcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5lXCIsXCJvdXRfZGlyXCI6XCJzXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwid1wiLFwib3V0X2RpclwiOlwibmVcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzXCIsXCJvdXRfZGlyXCI6XCJud1wifX1dLFwiMC0zLTAtMlwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic3dcIixcIm91dF9kaXJcIjpcIm5cIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwic1wifX1dLFwiMS0zLTAtMlwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic3dcIixcIm91dF9kaXJcIjpcIndcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwid1wifX1dLFwiMi0zLTAtMlwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic2VcIixcIm91dF9kaXJcIjpcIndcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzd1wiLFwib3V0X2RpclwiOlwiblwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5lXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fV0sXCIzLTMtMC0yXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzd1wiLFwib3V0X2RpclwiOlwibndcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwic1wifX1dLFwiMC0wLTEtMlwiOntcInZcIjp0cnVlLFwibG9jXCI6XCJlXCJ9LFwiMS0wLTEtMlwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic1wiLFwib3V0X2RpclwiOlwid1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5lXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fV0sXCIyLTAtMS0yXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzZVwiLFwib3V0X2RpclwiOlwid1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5lXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fV0sXCIzLTAtMS0yXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwiZVwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNcIixcIm91dF9kaXJcIjpcIm53XCJ9fV0sXCIwLTEtMS0yXCI6e1widlwiOnRydWUsXCJsb2NcIjpcIm5cIn0sXCIxLTEtMS0yXCI6e1widlwiOnRydWUsXCJsb2NcIjpcIndcIn0sXCIyLTEtMS0yXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzZVwiLFwib3V0X2RpclwiOlwid1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5lXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fV0sXCIzLTEtMS0yXCI6e1widlwiOnRydWUsXCJsb2NcIjpcIm53XCJ9LFwiMC0yLTEtMlwiOntcInZcIjpmYWxzZSxcImxvY1wiOlwibmVcIn0sXCIxLTItMS0yXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwid1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNcIixcIm91dF9kaXJcIjpcIndcIn19XSxcIjItMi0xLTJcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNlXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibmVcIixcIm91dF9kaXJcIjpcIndcIn19XSxcIjMtMi0xLTJcIjpbe1widlwiOmZhbHNlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwibmVcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzXCIsXCJvdXRfZGlyXCI6XCJud1wifX1dLFwiMC0zLTEtMlwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic3dcIixcIm91dF9kaXJcIjpcImVcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwiZVwifX1dLFwiMS0zLTEtMlwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic3dcIixcIm91dF9kaXJcIjpcImVcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwid1wifX1dLFwiMi0zLTEtMlwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic2VcIixcIm91dF9kaXJcIjpcIndcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzd1wiLFwib3V0X2RpclwiOlwiZVwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5lXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fV0sXCIzLTMtMS0yXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzd1wiLFwib3V0X2RpclwiOlwiZVwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5lXCIsXCJvdXRfZGlyXCI6XCJlXCJ9fV0sXCIwLTAtMi0yXCI6e1widlwiOnRydWUsXCJsb2NcIjpcInNlXCJ9LFwiMS0wLTItMlwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic1wiLFwib3V0X2RpclwiOlwid1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5lXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fV0sXCIyLTAtMi0yXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzZVwiLFwib3V0X2RpclwiOlwid1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5lXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fV0sXCIzLTAtMi0yXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwic2VcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzXCIsXCJvdXRfZGlyXCI6XCJud1wifX1dLFwiMC0xLTItMlwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibmVcIixcIm91dF9kaXJcIjpcInNlXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwid1wiLFwib3V0X2RpclwiOlwiblwifX1dLFwiMS0xLTItMlwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibmVcIixcIm91dF9kaXJcIjpcIndcIn19LHtcInZcIjpmYWxzZSxcImxvY1wiOntcImluX2RpclwiOlwid1wiLFwib3V0X2RpclwiOlwid1wifX1dLFwiMi0xLTItMlwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic2VcIixcIm91dF9kaXJcIjpcIndcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwid1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIndcIixcIm91dF9kaXJcIjpcIm5cIn19XSxcIjMtMS0yLTJcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5lXCIsXCJvdXRfZGlyXCI6XCJzZVwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIndcIixcIm91dF9kaXJcIjpcIm53XCJ9fV0sXCIwLTItMi0yXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwic2VcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJ3XCIsXCJvdXRfZGlyXCI6XCJuZVwifX1dLFwiMS0yLTItMlwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibmVcIixcIm91dF9kaXJcIjpcIndcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwid1wiLFwib3V0X2RpclwiOlwibmVcIn19XSxcIjItMi0yLTJcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNlXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibmVcIixcIm91dF9kaXJcIjpcIndcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJ3XCIsXCJvdXRfZGlyXCI6XCJuZVwifX1dLFwiMy0yLTItMlwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibmVcIixcIm91dF9kaXJcIjpcInNlXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic1wiLFwib3V0X2RpclwiOlwibndcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJ3XCIsXCJvdXRfZGlyXCI6XCJuZVwifX1dLFwiMC0zLTItMlwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic3dcIixcIm91dF9kaXJcIjpcIm5cIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwic2VcIn19XSxcIjEtMy0yLTJcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInN3XCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibmVcIixcIm91dF9kaXJcIjpcIndcIn19XSxcIjItMy0yLTJcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNlXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic3dcIixcIm91dF9kaXJcIjpcIm5cIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwid1wifX1dLFwiMy0zLTItMlwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic3dcIixcIm91dF9kaXJcIjpcIm53XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibmVcIixcIm91dF9kaXJcIjpcInNlXCJ9fV0sXCIwLTAtMy0yXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJud1wiLFwib3V0X2RpclwiOlwiZVwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5lXCIsXCJvdXRfZGlyXCI6XCJzXCJ9fV0sXCIxLTAtMy0yXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcImVcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwid1wifX1dLFwiMi0wLTMtMlwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic2VcIixcIm91dF9kaXJcIjpcIndcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJud1wiLFwib3V0X2RpclwiOlwiZVwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5lXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fV0sXCIzLTAtMy0yXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJud1wiLFwib3V0X2RpclwiOlwiZVwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5lXCIsXCJvdXRfZGlyXCI6XCJzXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic1wiLFwib3V0X2RpclwiOlwibndcIn19XSxcIjAtMS0zLTJcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm53XCIsXCJvdXRfZGlyXCI6XCJzXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibmVcIixcIm91dF9kaXJcIjpcInNcIn19XSxcIjEtMS0zLTJcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm53XCIsXCJvdXRfZGlyXCI6XCJzXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibmVcIixcIm91dF9kaXJcIjpcIndcIn19XSxcIjItMS0zLTJcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNlXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcInNcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwid1wifX1dLFwiMy0xLTMtMlwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcInNcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwic1wifX1dLFwiMC0yLTMtMlwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcInNcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwic1wifX1dLFwiMS0yLTMtMlwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcInNcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwid1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNcIixcIm91dF9kaXJcIjpcIndcIn19XSxcIjItMi0zLTJcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNlXCIsXCJvdXRfZGlyXCI6XCJ3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcInNcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwid1wifX1dLFwiMy0yLTMtMlwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcInNcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwic1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNcIixcIm91dF9kaXJcIjpcIm53XCJ9fV0sXCIwLTMtMy0yXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzd1wiLFwib3V0X2RpclwiOlwiblwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm53XCIsXCJvdXRfZGlyXCI6XCJlXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibmVcIixcIm91dF9kaXJcIjpcInNcIn19XSxcIjEtMy0zLTJcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInN3XCIsXCJvdXRfZGlyXCI6XCJlXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcImVcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwid1wifX1dLFwiMi0zLTMtMlwiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic2VcIixcIm91dF9kaXJcIjpcIndcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzd1wiLFwib3V0X2RpclwiOlwiblwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm53XCIsXCJvdXRfZGlyXCI6XCJlXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibmVcIixcIm91dF9kaXJcIjpcIndcIn19XSxcIjMtMy0zLTJcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInN3XCIsXCJvdXRfZGlyXCI6XCJlXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcImVcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuZVwiLFwib3V0X2RpclwiOlwic1wifX1dLFwiMC0wLTAtM1wiOntcInZcIjp0cnVlLFwibG9jXCI6XCJzd1wifSxcIjEtMC0wLTNcIjp7XCJ2XCI6dHJ1ZSxcImxvY1wiOlwic3dcIn0sXCIyLTAtMC0zXCI6e1widlwiOnRydWUsXCJsb2NcIjpcInN3XCJ9LFwiMy0wLTAtM1wiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiZVwiLFwib3V0X2RpclwiOlwic3dcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzXCIsXCJvdXRfZGlyXCI6XCJud1wifX1dLFwiMC0xLTAtM1wiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiZVwiLFwib3V0X2RpclwiOlwic3dcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJ3XCIsXCJvdXRfZGlyXCI6XCJuXCJ9fV0sXCIxLTEtMC0zXCI6e1widlwiOnRydWUsXCJsb2NcIjpcInN3XCJ9LFwiMi0xLTAtM1wiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic2VcIixcIm91dF9kaXJcIjpcIm5cIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJ3XCIsXCJvdXRfZGlyXCI6XCJuXCJ9fV0sXCIzLTEtMC0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJlXCIsXCJvdXRfZGlyXCI6XCJzd1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIndcIixcIm91dF9kaXJcIjpcIm53XCJ9fV0sXCIwLTItMC0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJlXCIsXCJvdXRfZGlyXCI6XCJzd1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIndcIixcIm91dF9kaXJcIjpcIm5lXCJ9fV0sXCIxLTItMC0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzXCIsXCJvdXRfZGlyXCI6XCJzd1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIndcIixcIm91dF9kaXJcIjpcIm5lXCJ9fV0sXCIyLTItMC0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzZVwiLFwib3V0X2RpclwiOlwic3dcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJ3XCIsXCJvdXRfZGlyXCI6XCJuZVwifX1dLFwiMy0yLTAtM1wiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiZVwiLFwib3V0X2RpclwiOlwic3dcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJ3XCIsXCJvdXRfZGlyXCI6XCJuZVwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNcIixcIm91dF9kaXJcIjpcIm53XCJ9fV0sXCIwLTMtMC0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJlXCIsXCJvdXRfZGlyXCI6XCJzd1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInN3XCIsXCJvdXRfZGlyXCI6XCJuXCJ9fV0sXCIxLTMtMC0zXCI6e1widlwiOmZhbHNlLFwibG9jXCI6XCJzd1wifSxcIjItMy0wLTNcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNlXCIsXCJvdXRfZGlyXCI6XCJuXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic3dcIixcIm91dF9kaXJcIjpcIm5cIn19XSxcIjMtMy0wLTNcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcImVcIixcIm91dF9kaXJcIjpcInN3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic3dcIixcIm91dF9kaXJcIjpcIm53XCJ9fV0sXCIwLTAtMS0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJlXCIsXCJvdXRfZGlyXCI6XCJzd1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5cIixcIm91dF9kaXJcIjpcImVcIn19XSxcIjEtMC0xLTNcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNcIixcIm91dF9kaXJcIjpcInN3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiblwiLFwib3V0X2RpclwiOlwiZVwifX1dLFwiMi0wLTEtM1wiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic2VcIixcIm91dF9kaXJcIjpcInN3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiblwiLFwib3V0X2RpclwiOlwiZVwifX1dLFwiMy0wLTEtM1wiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiZVwiLFwib3V0X2RpclwiOlwic3dcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuXCIsXCJvdXRfZGlyXCI6XCJlXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic1wiLFwib3V0X2RpclwiOlwibndcIn19XSxcIjAtMS0xLTNcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcImVcIixcIm91dF9kaXJcIjpcInN3XCJ9fSx7XCJ2XCI6ZmFsc2UsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5cIixcIm91dF9kaXJcIjpcIm5cIn19XSxcIjEtMS0xLTNcIjp7XCJ2XCI6dHJ1ZSxcImxvY1wiOlwic3dcIn0sXCIyLTEtMS0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzZVwiLFwib3V0X2RpclwiOlwiblwifX0se1widlwiOmZhbHNlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuXCIsXCJvdXRfZGlyXCI6XCJuXCJ9fV0sXCIzLTEtMS0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJlXCIsXCJvdXRfZGlyXCI6XCJzd1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5cIixcIm91dF9kaXJcIjpcIm53XCJ9fV0sXCIwLTItMS0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJlXCIsXCJvdXRfZGlyXCI6XCJzd1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5cIixcIm91dF9kaXJcIjpcIm5lXCJ9fV0sXCIxLTItMS0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzXCIsXCJvdXRfZGlyXCI6XCJzd1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5cIixcIm91dF9kaXJcIjpcIm5lXCJ9fV0sXCIyLTItMS0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzZVwiLFwib3V0X2RpclwiOlwic3dcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuXCIsXCJvdXRfZGlyXCI6XCJuZVwifX1dLFwiMy0yLTEtM1wiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiZVwiLFwib3V0X2RpclwiOlwic3dcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuXCIsXCJvdXRfZGlyXCI6XCJuZVwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNcIixcIm91dF9kaXJcIjpcIm53XCJ9fV0sXCIwLTMtMS0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJlXCIsXCJvdXRfZGlyXCI6XCJzd1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInN3XCIsXCJvdXRfZGlyXCI6XCJlXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiblwiLFwib3V0X2RpclwiOlwiZVwifX1dLFwiMS0zLTEtM1wiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic3dcIixcIm91dF9kaXJcIjpcImVcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuXCIsXCJvdXRfZGlyXCI6XCJlXCJ9fV0sXCIyLTMtMS0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzZVwiLFwib3V0X2RpclwiOlwiblwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInN3XCIsXCJvdXRfZGlyXCI6XCJlXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiblwiLFwib3V0X2RpclwiOlwiZVwifX1dLFwiMy0zLTEtM1wiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiZVwiLFwib3V0X2RpclwiOlwic3dcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzd1wiLFwib3V0X2RpclwiOlwiZVwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5cIixcIm91dF9kaXJcIjpcImVcIn19XSxcIjAtMC0yLTNcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcImVcIixcIm91dF9kaXJcIjpcInN3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiblwiLFwib3V0X2RpclwiOlwic2VcIn19XSxcIjEtMC0yLTNcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNcIixcIm91dF9kaXJcIjpcInN3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiblwiLFwib3V0X2RpclwiOlwic2VcIn19XSxcIjItMC0yLTNcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNlXCIsXCJvdXRfZGlyXCI6XCJzd1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5cIixcIm91dF9kaXJcIjpcInNlXCJ9fV0sXCIzLTAtMi0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJlXCIsXCJvdXRfZGlyXCI6XCJzd1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNcIixcIm91dF9kaXJcIjpcIm53XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiblwiLFwib3V0X2RpclwiOlwic2VcIn19XSxcIjAtMS0yLTNcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcImVcIixcIm91dF9kaXJcIjpcInN3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwid1wiLFwib3V0X2RpclwiOlwiblwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5cIixcIm91dF9kaXJcIjpcInNlXCJ9fV0sXCIxLTEtMi0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJ3XCIsXCJvdXRfZGlyXCI6XCJzd1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5cIixcIm91dF9kaXJcIjpcInNlXCJ9fV0sXCIyLTEtMi0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzZVwiLFwib3V0X2RpclwiOlwiblwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIndcIixcIm91dF9kaXJcIjpcIm5cIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuXCIsXCJvdXRfZGlyXCI6XCJzZVwifX1dLFwiMy0xLTItM1wiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiZVwiLFwib3V0X2RpclwiOlwic3dcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJ3XCIsXCJvdXRfZGlyXCI6XCJud1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5cIixcIm91dF9kaXJcIjpcInNlXCJ9fV0sXCIwLTItMi0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJlXCIsXCJvdXRfZGlyXCI6XCJzd1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIndcIixcIm91dF9kaXJcIjpcIm5lXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiblwiLFwib3V0X2RpclwiOlwic2VcIn19XSxcIjEtMi0yLTNcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNcIixcIm91dF9kaXJcIjpcInN3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwid1wiLFwib3V0X2RpclwiOlwibmVcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuXCIsXCJvdXRfZGlyXCI6XCJzZVwifX1dLFwiMi0yLTItM1wiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic2VcIixcIm91dF9kaXJcIjpcInN3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwid1wiLFwib3V0X2RpclwiOlwibmVcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuXCIsXCJvdXRfZGlyXCI6XCJzZVwifX1dLFwiMy0yLTItM1wiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiZVwiLFwib3V0X2RpclwiOlwic3dcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzXCIsXCJvdXRfZGlyXCI6XCJud1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIndcIixcIm91dF9kaXJcIjpcIm5lXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiblwiLFwib3V0X2RpclwiOlwic2VcIn19XSxcIjAtMy0yLTNcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcImVcIixcIm91dF9kaXJcIjpcInN3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic3dcIixcIm91dF9kaXJcIjpcIm5cIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJuXCIsXCJvdXRfZGlyXCI6XCJzZVwifX1dLFwiMS0zLTItM1wiOlt7XCJ2XCI6ZmFsc2UsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInN3XCIsXCJvdXRfZGlyXCI6XCJzd1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm5cIixcIm91dF9kaXJcIjpcInNlXCJ9fV0sXCIyLTMtMi0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzZVwiLFwib3V0X2RpclwiOlwiblwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInN3XCIsXCJvdXRfZGlyXCI6XCJuXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiblwiLFwib3V0X2RpclwiOlwic2VcIn19XSxcIjMtMy0yLTNcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcImVcIixcIm91dF9kaXJcIjpcInN3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic3dcIixcIm91dF9kaXJcIjpcIm53XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiblwiLFwib3V0X2RpclwiOlwic2VcIn19XSxcIjAtMC0zLTNcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcImVcIixcIm91dF9kaXJcIjpcInN3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcImVcIn19XSxcIjEtMC0zLTNcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNcIixcIm91dF9kaXJcIjpcInN3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcImVcIn19XSxcIjItMC0zLTNcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNlXCIsXCJvdXRfZGlyXCI6XCJzd1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm53XCIsXCJvdXRfZGlyXCI6XCJlXCJ9fV0sXCIzLTAtMy0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJlXCIsXCJvdXRfZGlyXCI6XCJzd1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm53XCIsXCJvdXRfZGlyXCI6XCJlXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic1wiLFwib3V0X2RpclwiOlwibndcIn19XSxcIjAtMS0zLTNcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcImVcIixcIm91dF9kaXJcIjpcInN3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcIm5cIn19XSxcIjEtMS0zLTNcIjp7XCJ2XCI6dHJ1ZSxcImxvY1wiOlwic3dcIn0sXCIyLTEtMy0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzZVwiLFwib3V0X2RpclwiOlwiblwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm53XCIsXCJvdXRfZGlyXCI6XCJuXCJ9fV0sXCIzLTEtMy0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJlXCIsXCJvdXRfZGlyXCI6XCJzd1wifX0se1widlwiOmZhbHNlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJud1wiLFwib3V0X2RpclwiOlwibndcIn19XSxcIjAtMi0zLTNcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcImVcIixcIm91dF9kaXJcIjpcInN3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcIm5lXCJ9fV0sXCIxLTItMy0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJud1wiLFwib3V0X2RpclwiOlwibmVcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzXCIsXCJvdXRfZGlyXCI6XCJzd1wifX1dLFwiMi0yLTMtM1wiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic2VcIixcIm91dF9kaXJcIjpcInN3XCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcIm5lXCJ9fV0sXCIzLTItMy0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJlXCIsXCJvdXRfZGlyXCI6XCJzd1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm53XCIsXCJvdXRfZGlyXCI6XCJuZVwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNcIixcIm91dF9kaXJcIjpcIm53XCJ9fV0sXCIwLTMtMy0zXCI6W3tcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJlXCIsXCJvdXRfZGlyXCI6XCJzd1wifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInN3XCIsXCJvdXRfZGlyXCI6XCJuXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcImVcIn19XSxcIjEtMy0zLTNcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInN3XCIsXCJvdXRfZGlyXCI6XCJlXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwibndcIixcIm91dF9kaXJcIjpcImVcIn19XSxcIjItMy0zLTNcIjpbe1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcInNlXCIsXCJvdXRfZGlyXCI6XCJuXCJ9fSx7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwic3dcIixcIm91dF9kaXJcIjpcIm5cIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJud1wiLFwib3V0X2RpclwiOlwiZVwifX1dLFwiMy0zLTMtM1wiOlt7XCJ2XCI6dHJ1ZSxcImxvY1wiOntcImluX2RpclwiOlwiZVwiLFwib3V0X2RpclwiOlwic3dcIn19LHtcInZcIjp0cnVlLFwibG9jXCI6e1wiaW5fZGlyXCI6XCJzd1wiLFwib3V0X2RpclwiOlwiZVwifX0se1widlwiOnRydWUsXCJsb2NcIjp7XCJpbl9kaXJcIjpcIm53XCIsXCJvdXRfZGlyXCI6XCJlXCJ9fV19O1xyXG4iLCIvKipcclxuICogQSBwb2ludCBjYW4gcmVwcmVzZW50IGEgdmVydGV4IGluIGEgMmQgZW52aXJvbm1lbnQgb3IgYSB2ZWN0b3IuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBgeGAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIGB5YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludC5cclxuICovXHJcblBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gIHRoaXMueCA9IHg7XHJcbiAgdGhpcy55ID0geTtcclxufTtcclxuZXhwb3J0cy5Qb2ludCA9IFBvaW50O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYSBwb2ludC1saWtlIG9iamVjdCBpbnRvIGEgcG9pbnQuXHJcbiAqIEBwYXJhbSB7UG9pbnRMaWtlfSBwIC0gVGhlIHBvaW50LWxpa2Ugb2JqZWN0IHRvIGNvbnZlcnQuXHJcbiAqIEByZXR1cm4ge1BvaW50fSAtIFRoZSBuZXcgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBwb2ludC1saWtlXHJcbiAqICAgb2JqZWN0LlxyXG4gKi9cclxuUG9pbnQuZnJvbVBvaW50TGlrZSA9IGZ1bmN0aW9uKHApIHtcclxuICByZXR1cm4gbmV3IFBvaW50KHAueCwgcC55KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTdHJpbmcgbWV0aG9kIGZvciBwb2ludC1saWtlIG9iamVjdHMuXHJcbiAqIEBwYXJhbSB7UG9pbnRMaWtlfSBwIC0gVGhlIHBvaW50LWxpa2Ugb2JqZWN0IHRvIGNvbnZlcnQuXHJcbiAqIEByZXR1cm4ge1BvaW50fSAtIFRoZSBuZXcgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBwb2ludC1saWtlXHJcbiAqICAgb2JqZWN0LlxyXG4gKi9cclxuUG9pbnQudG9TdHJpbmcgPSBmdW5jdGlvbihwKSB7XHJcbiAgcmV0dXJuIFwieFwiICsgcC54ICsgXCJ5XCIgKyBwLnk7XHJcbn07XHJcblxyXG4vKipcclxuICogVGFrZXMgYSBwb2ludCBvciBzY2FsYXIgYW5kIGFkZHMgc2xvdHdpc2UgaW4gdGhlIGNhc2Ugb2YgYW5vdGhlclxyXG4gKiBwb2ludCwgb3IgdG8gZWFjaCBwYXJhbWV0ZXIgaW4gdGhlIGNhc2Ugb2YgYSBzY2FsYXIuXHJcbiAqIEBwYXJhbSB7KFBvaW50fG51bWJlcil9IC0gVGhlIFBvaW50LCBvciBzY2FsYXIsIHRvIGFkZCB0byB0aGlzXHJcbiAqICAgcG9pbnQuXHJcbiAqL1xyXG5Qb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ocCkge1xyXG4gIGlmICh0eXBlb2YgcCA9PSBcIm51bWJlclwiKVxyXG4gICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyBwLCB0aGlzLnkgKyBwKTtcclxuICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArIHAueCwgdGhpcy55ICsgcC55KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUYWtlcyBhIHBvaW50IG9yIHNjYWxhciBhbmQgc3VidHJhY3RzIHNsb3R3aXNlIGluIHRoZSBjYXNlIG9mXHJcbiAqIGFub3RoZXIgcG9pbnQgb3IgZnJvbSBlYWNoIHBhcmFtZXRlciBpbiB0aGUgY2FzZSBvZiBhIHNjYWxhci5cclxuICogQHBhcmFtIHsoUG9pbnR8bnVtYmVyKX0gLSBUaGUgUG9pbnQsIG9yIHNjYWxhciwgdG8gc3VidHJhY3QgZnJvbVxyXG4gKiAgIHRoaXMgcG9pbnQuXHJcbiAqL1xyXG5Qb2ludC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24ocCkge1xyXG4gIGlmICh0eXBlb2YgcCA9PSBcIm51bWJlclwiKVxyXG4gICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLSBwLCB0aGlzLnkgLSBwKTtcclxuICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAtIHAueCwgdGhpcy55IC0gcC55KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUYWtlcyBhIHNjYWxhciB2YWx1ZSBhbmQgbXVsdGlwbGllcyBlYWNoIHBhcmFtZXRlciBvZiB0aGUgcG9pbnRcclxuICogYnkgdGhlIHNjYWxhci5cclxuICogQHBhcmFtICB7bnVtYmVyfSBmIC0gVGhlIG51bWJlciB0byBtdWx0aXBsZSB0aGUgcGFyYW1ldGVycyBieS5cclxuICogQHJldHVybiB7UG9pbnR9IC0gQSBuZXcgcG9pbnQgd2l0aCB0aGUgY2FsY3VsYXRlZCBjb29yZGluYXRlcy5cclxuICovXHJcblBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbihmKSB7XHJcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKiBmLCB0aGlzLnkgKiBmKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUYWtlcyBhIHNjYWxhciB2YWx1ZSBhbmQgZGl2aWRlcyBlYWNoIHBhcmFtZXRlciBvZiB0aGUgcG9pbnRcclxuICogYnkgdGhlIHNjYWxhci5cclxuICogQHBhcmFtICB7bnVtYmVyfSBmIC0gVGhlIG51bWJlciB0byBkaXZpZGUgdGhlIHBhcmFtZXRlcnMgYnkuXHJcbiAqIEByZXR1cm4ge1BvaW50fSAtIEEgbmV3IHBvaW50IHdpdGggdGhlIGNhbGN1bGF0ZWQgY29vcmRpbmF0ZXMuXHJcbiAqL1xyXG5Qb2ludC5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24oZikge1xyXG4gIHJldHVybiBuZXcgUG9pbnQodGhpcy54IC8gZiwgdGhpcy55IC8gZik7XHJcbn07XHJcblxyXG4vKipcclxuICogVGFrZXMgYW5vdGhlciBwb2ludCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZVxyXG4gKiBwb2ludHMgYXJlIGVxdWFsLiBUd28gcG9pbnRzIGFyZSBlcXVhbCBpZiB0aGVpciBwYXJhbWV0ZXJzIGFyZVxyXG4gKiBlcXVhbC5cclxuICogQHBhcmFtICB7UG9pbnR9IHAgLSBUaGUgcG9pbnQgdG8gY2hlY2sgZXF1YWxpdHkgYWdhaW5zdC5cclxuICogQHJldHVybiB7Ym9vbGVhbn0gLSBXaGV0aGVyIG9yIG5vdCB0aGUgdHdvIHBvaW50cyBhcmUgZXF1YWwuXHJcbiAqL1xyXG5Qb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbihwKSB7XHJcbiAgcmV0dXJuICh0aGlzLnggPT0gcC54ICYmIHRoaXMueSA9PSBwLnkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRha2VzIGFub3RoZXIgcG9pbnQgYW5kIHJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGVcclxuICogcG9pbnRzIGFyZSBub3QgZXF1YWwuIFR3byBwb2ludHMgYXJlIGNvbnNpZGVyZWQgbm90IGVxdWFsIGlmIHRoZWlyXHJcbiAqIHBhcmFtZXRlcnMgYXJlIG5vdCBlcXVhbC5cclxuICogQHBhcmFtICB7UG9pbnR9IHAgLSBUaGUgcG9pbnQgdG8gY2hlY2sgZXF1YWxpdHkgYWdhaW5zdC5cclxuICogQHJldHVybiB7Ym9vbGVhbn0gLSBXaGV0aGVyIG9yIG5vdCB0aGUgdHdvIHBvaW50cyBhcmUgbm90IGVxdWFsLlxyXG4gKi9cclxuUG9pbnQucHJvdG90eXBlLm5lcSA9IGZ1bmN0aW9uKHApIHtcclxuICByZXR1cm4gKHRoaXMueCAhPSBwLnggfHwgdGhpcy55ICE9IHAueSk7XHJcbn07XHJcblxyXG4vLyBHaXZlbiBhbm90aGVyIHBvaW50LCByZXR1cm5zIHRoZSBkb3QgcHJvZHVjdC5cclxuUG9pbnQucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uKHApIHtcclxuICByZXR1cm4gKHRoaXMueCAqIHAueCArIHRoaXMueSAqIHAueSk7XHJcbn07XHJcblxyXG4vLyBHaXZlbiBhbm90aGVyIHBvaW50LCByZXR1cm5zIHRoZSAnY3Jvc3MgcHJvZHVjdCcsIG9yIGF0IGxlYXN0IHRoZSAyZFxyXG4vLyBlcXVpdmFsZW50LlxyXG5Qb2ludC5wcm90b3R5cGUuY3Jvc3MgPSBmdW5jdGlvbihwKSB7XHJcbiAgcmV0dXJuICh0aGlzLnggKiBwLnkgLSB0aGlzLnkgKiBwLngpO1xyXG59O1xyXG5cclxuLy8gR2l2ZW4gYW5vdGhlciBwb2ludCwgcmV0dXJucyB0aGUgZGlzdGFuY2UgdG8gdGhhdCBwb2ludC5cclxuUG9pbnQucHJvdG90eXBlLmRpc3QgPSBmdW5jdGlvbihwKSB7XHJcbiAgdmFyIGRpZmYgPSB0aGlzLnN1YihwKTtcclxuICByZXR1cm4gTWF0aC5zcXJ0KGRpZmYuZG90KGRpZmYpKTtcclxufTtcclxuXHJcbi8vIEdpdmVuIGFub3RoZXIgcG9pbnQsIHJldHVybnMgdGhlIHNxdWFyZWQgZGlzdGFuY2UgdG8gdGhhdCBwb2ludC5cclxuUG9pbnQucHJvdG90eXBlLmRpc3QyID0gZnVuY3Rpb24ocCkge1xyXG4gIHZhciBkaWZmID0gdGhpcy5zdWIocCk7XHJcbiAgcmV0dXJuIGRpZmYuZG90KGRpZmYpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcG9pbnQgaXMgKDAsIDApLlxyXG4gKiBAcmV0dXJuIHtib29sZWFufSAtIFdoZXRoZXIgb3Igbm90IHRoZSBwb2ludCBpcyAoMCwgMCkuXHJcbiAqL1xyXG5Qb2ludC5wcm90b3R5cGUuemVybyA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB0aGlzLnggPT0gMCAmJiB0aGlzLnkgPT0gMDtcclxufTtcclxuXHJcblBvaW50LnByb3RvdHlwZS5sZW4gPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gdGhpcy5kaXN0KG5ldyBQb2ludCgwLCAwKSk7XHJcbn07XHJcblxyXG5Qb2ludC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIG4gPSB0aGlzLmRpc3QobmV3IFBvaW50KDAsIDApKTtcclxuICBpZiAobiA+IDApIHJldHVybiB0aGlzLmRpdihuKTtcclxuICByZXR1cm4gbmV3IFBvaW50KDAsIDApO1xyXG59O1xyXG5cclxuUG9pbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuICd4JyArIHRoaXMueCArICd5JyArIHRoaXMueTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBjb3B5IG9mIHRoZSBwb2ludC5cclxuICogQHJldHVybiB7UG9pbnR9IC0gVGhlIG5ldyBwb2ludC5cclxuICovXHJcblBvaW50LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVkZ2VzIGFyZSB1c2VkIHRvIHJlcHJlc2VudCB0aGUgYm9yZGVyIGJldHdlZW4gdHdvIGFkamFjZW50XHJcbiAqIHBvbHlnb25zLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtQb2ludH0gcDEgLSBUaGUgZmlyc3QgcG9pbnQgb2YgdGhlIGVkZ2UuXHJcbiAqIEBwYXJhbSB7UG9pbnR9IHAyIC0gVGhlIHNlY29uZCBwb2ludCBvZiB0aGUgZWRnZS5cclxuICovXHJcbkVkZ2UgPSBmdW5jdGlvbihwMSwgcDIpIHtcclxuICB0aGlzLnAxID0gcDE7XHJcbiAgdGhpcy5wMiA9IHAyO1xyXG4gIHRoaXMuY2VudGVyID0gcDEuYWRkKHAyLnN1YihwMSkuZGl2KDIpKTtcclxuICB0aGlzLnBvaW50cyA9IFt0aGlzLnAxLCB0aGlzLmNlbnRlciwgdGhpcy5wMl07XHJcbn07XHJcbmV4cG9ydHMuRWRnZSA9IEVkZ2U7XHJcblxyXG5FZGdlLnByb3RvdHlwZS5fQ0NXID0gZnVuY3Rpb24ocDEsIHAyLCBwMykge1xyXG4gIGEgPSBwMS54OyBiID0gcDEueTtcclxuICBjID0gcDIueDsgZCA9IHAyLnk7XHJcbiAgZSA9IHAzLng7IGYgPSBwMy55O1xyXG4gIHJldHVybiAoZiAtIGIpICogKGMgLSBhKSA+IChkIC0gYikgKiAoZSAtIGEpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY3MjU3MTVcclxuICogQ2hlY2tzIHdoZXRoZXIgdGhpcyBlZGdlIGludGVyc2VjdHMgdGhlIHByb3ZpZGVkIGVkZ2UuXHJcbiAqIEBwYXJhbSB7RWRnZX0gZWRnZSAtIFRoZSBlZGdlIHRvIGNoZWNrIGludGVyc2VjdGlvbiBmb3IuXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IC0gV2hldGhlciBvciBub3QgdGhlIGVkZ2VzIGludGVyc2VjdC5cclxuICovXHJcbkVkZ2UucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbihlZGdlKSB7XHJcbiAgdmFyIHExID0gZWRnZS5wMSwgcTIgPSBlZGdlLnAyO1xyXG4gIGlmIChxMS5lcSh0aGlzLnAxKSB8fCBxMS5lcSh0aGlzLnAyKSB8fCBxMi5lcSh0aGlzLnAxKSB8fCBxMi5lcSh0aGlzLnAyKSkgcmV0dXJuIGZhbHNlO1xyXG4gIHJldHVybiAodGhpcy5fQ0NXKHRoaXMucDEsIHExLCBxMikgIT0gdGhpcy5fQ0NXKHRoaXMucDIsIHExLCBxMikpICYmICh0aGlzLl9DQ1codGhpcy5wMSwgdGhpcy5wMiwgcTEpICE9IHRoaXMuX0NDVyh0aGlzLnAxLCB0aGlzLnAyLCBxMikpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFBvbHlnb24gY2xhc3MuXHJcbiAqIENhbiBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGFycmF5IG9mIHBvaW50cy5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7QXJyYXkuPFBvaW50Pn0gW3BvaW50c10gLSBUaGUgcG9pbnRzIHRvIHVzZSB0byBpbml0aWFsaXplXHJcbiAqICAgdGhlIHBvbHkuXHJcbiAqL1xyXG5Qb2x5ID0gZnVuY3Rpb24ocG9pbnRzKSB7XHJcbiAgaWYgKHR5cGVvZiBwb2ludHMgPT0gJ3VuZGVmaW5lZCcpIHBvaW50cyA9IGZhbHNlO1xyXG4gIHRoaXMuaG9sZSA9IGZhbHNlO1xyXG4gIHRoaXMucG9pbnRzID0gbnVsbDtcclxuICB0aGlzLm51bXBvaW50cyA9IDA7XHJcbiAgaWYgKHBvaW50cykge1xyXG4gICAgdGhpcy5udW1wb2ludHMgPSBwb2ludHMubGVuZ3RoO1xyXG4gICAgdGhpcy5wb2ludHMgPSBwb2ludHMuc2xpY2UoKTtcclxuICB9XHJcbn07XHJcbmV4cG9ydHMuUG9seSA9IFBvbHk7XHJcblxyXG5Qb2x5LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obikge1xyXG4gIHRoaXMucG9pbnRzID0gbmV3IEFycmF5KG4pO1xyXG4gIHRoaXMubnVtcG9pbnRzID0gbjtcclxufTtcclxuXHJcblBvbHkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gIHRoaXMubnVtcG9pbnRzID0gdGhpcy5wb2ludHMubGVuZ3RoO1xyXG59O1xyXG5cclxuUG9seS5wcm90b3R5cGUudHJpYW5nbGUgPSBmdW5jdGlvbihwMSwgcDIsIHAzKSB7XHJcbiAgdGhpcy5pbml0KDMpO1xyXG4gIHRoaXMucG9pbnRzWzBdID0gcDE7XHJcbiAgdGhpcy5wb2ludHNbMV0gPSBwMjtcclxuICB0aGlzLnBvaW50c1syXSA9IHAzO1xyXG59O1xyXG5cclxuLy8gVGFrZXMgYW4gaW5kZXggYW5kIHJldHVybnMgdGhlIHBvaW50IGF0IHRoYXQgaW5kZXgsIG9yIG51bGwuXHJcblBvbHkucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24obikge1xyXG4gIGlmICh0aGlzLnBvaW50cyAmJiB0aGlzLm51bXBvaW50cyA+IG4pXHJcbiAgICByZXR1cm4gdGhpcy5wb2ludHNbbl07XHJcbiAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG4vLyBTZXQgYSBwb2ludCwgZmFpbHMgc2lsZW50bHkgb3RoZXJ3aXNlLiBUT0RPOiByZXBsYWNlIHdpdGggYnJhY2tldCBub3RhdGlvbi5cclxuUG9seS5wcm90b3R5cGUuc2V0UG9pbnQgPSBmdW5jdGlvbihpLCBwKSB7XHJcbiAgaWYgKHRoaXMucG9pbnRzICYmIHRoaXMucG9pbnRzLmxlbmd0aCA+IGkpIHtcclxuICAgIHRoaXMucG9pbnRzW2ldID0gcDtcclxuICB9XHJcbn07XHJcblxyXG4vLyBHaXZlbiBhbiBpbmRleCBpLCByZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBuZXh0IHBvaW50LlxyXG5Qb2x5LnByb3RvdHlwZS5nZXROZXh0SSA9IGZ1bmN0aW9uKGkpIHtcclxuICByZXR1cm4gKGkgKyAxKSAlIHRoaXMubnVtcG9pbnRzO1xyXG59O1xyXG5cclxuUG9seS5wcm90b3R5cGUuZ2V0UHJldkkgPSBmdW5jdGlvbihpKSB7XHJcbiAgaWYgKGkgPT0gMClcclxuICAgIHJldHVybiAodGhpcy5udW1wb2ludHMgLSAxKTtcclxuICByZXR1cm4gaSAtIDE7XHJcbn07XHJcblxyXG4vLyBSZXR1cm5zIHRoZSBzaWduZWQgYXJlYSBvZiBhIHBvbHlnb24sIGlmIHRoZSB2ZXJ0aWNlcyBhcmUgZ2l2ZW4gaW5cclxuLy8gQ0NXIG9yZGVyIHRoZW4gdGhlIGFyZWEgd2lsbCBiZSA+IDAsIDwgMCBvdGhlcndpc2UuXHJcblBvbHkucHJvdG90eXBlLmdldEFyZWEgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgYXJlYSA9IDA7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm51bXBvaW50czsgaSsrKSB7XHJcbiAgICB2YXIgaTIgPSB0aGlzLmdldE5leHRJKGkpO1xyXG4gICAgYXJlYSArPSB0aGlzLnBvaW50c1tpXS54ICogdGhpcy5wb2ludHNbaTJdLnkgLSB0aGlzLnBvaW50c1tpXS55ICogdGhpcy5wb2ludHNbaTJdLng7XHJcbiAgfVxyXG4gIHJldHVybiBhcmVhO1xyXG59O1xyXG5cclxuUG9seS5wcm90b3R5cGUuZ2V0T3JpZW50YXRpb24gPSBmdW5jdGlvbigpIHtcclxuICB2YXIgYXJlYSA9IHRoaXMuZ2V0QXJlYSgpO1xyXG4gIGlmIChhcmVhID4gMCkgcmV0dXJuIFwiQ0NXXCI7XHJcbiAgaWYgKGFyZWEgPCAwKSByZXR1cm4gXCJDV1wiO1xyXG4gIHJldHVybiAwO1xyXG59O1xyXG5cclxuUG9seS5wcm90b3R5cGUuc2V0T3JpZW50YXRpb24gPSBmdW5jdGlvbihvcmllbnRhdGlvbikge1xyXG4gIHZhciBjdXJyZW50X29yaWVudGF0aW9uID0gdGhpcy5nZXRPcmllbnRhdGlvbigpO1xyXG4gIGlmIChjdXJyZW50X29yaWVudGF0aW9uICYmIChjdXJyZW50X29yaWVudGF0aW9uICE9PSBvcmllbnRhdGlvbikpIHtcclxuICAgIHRoaXMuaW52ZXJ0KCk7XHJcbiAgfVxyXG59O1xyXG5cclxuUG9seS5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIG5ld3BvaW50cyA9IG5ldyBBcnJheSh0aGlzLm51bXBvaW50cyk7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm51bXBvaW50czsgaSsrKSB7XHJcbiAgICBuZXdwb2ludHNbaV0gPSB0aGlzLnBvaW50c1t0aGlzLm51bXBvaW50cyAtIGkgLSAxXTtcclxuICB9XHJcbiAgdGhpcy5wb2ludHMgPSBuZXdwb2ludHM7XHJcbn07XHJcblxyXG5Qb2x5LnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgeCA9IHRoaXMucG9pbnRzLm1hcChmdW5jdGlvbihwKSB7IHJldHVybiBwLnggfSk7XHJcbiAgdmFyIHkgPSB0aGlzLnBvaW50cy5tYXAoZnVuY3Rpb24ocCkgeyByZXR1cm4gcC55IH0pO1xyXG4gIHZhciBtaW5YID0gTWF0aC5taW4uYXBwbHkobnVsbCwgeCk7XHJcbiAgdmFyIG1heFggPSBNYXRoLm1heC5hcHBseShudWxsLCB4KTtcclxuICB2YXIgbWluWSA9IE1hdGgubWluLmFwcGx5KG51bGwsIHkpO1xyXG4gIHZhciBtYXhZID0gTWF0aC5tYXguYXBwbHkobnVsbCwgeSk7XHJcbiAgcmV0dXJuIG5ldyBQb2ludCgobWluWCArIG1heFgpLzIsIChtaW5ZICsgbWF4WSkvMik7XHJcbn07XHJcblxyXG4vLyBBZGFwdGVkIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTYyODMzNDlcclxuUG9seS5wcm90b3R5cGUuY2VudHJvaWQgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgeCA9IDAsXHJcbiAgICAgIHkgPSAwLFxyXG4gICAgICBpLFxyXG4gICAgICBqLFxyXG4gICAgICBmLFxyXG4gICAgICBwb2ludDEsXHJcbiAgICAgIHBvaW50MjtcclxuXHJcbiAgZm9yIChpID0gMCwgaiA9IHRoaXMucG9pbnRzLmxlbmd0aCAtIDE7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGogPSBpLCBpICs9IDEpIHtcclxuICAgIHBvaW50MSA9IHRoaXMucG9pbnRzW2ldO1xyXG4gICAgcG9pbnQyID0gdGhpcy5wb2ludHNbal07XHJcbiAgICBmID0gcG9pbnQxLnggKiBwb2ludDIueSAtIHBvaW50Mi54ICogcG9pbnQxLnk7XHJcbiAgICB4ICs9IChwb2ludDEueCArIHBvaW50Mi54KSAqIGY7XHJcbiAgICB5ICs9IChwb2ludDEueSArIHBvaW50Mi55KSAqIGY7XHJcbiAgfVxyXG5cclxuICBmID0gdGhpcy5nZXRBcmVhKCkgKiAzO1xyXG4gIHggPSBNYXRoLmFicyh4KTtcclxuICB5ID0gTWF0aC5hYnMoeSk7XHJcbiAgcmV0dXJuIG5ldyBQb2ludCh4IC8gZiwgeSAvIGYpO1xyXG59O1xyXG5cclxuUG9seS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgY2VudGVyID0gdGhpcy5jZW50cm9pZCgpO1xyXG4gIHJldHVybiBcIlwiICsgY2VudGVyLnggKyBcIiBcIiArIGNlbnRlci55O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gcG9pbnQgaXMgY29udGFpbmVkIHdpdGhpbiB0aGUgUG9seWdvbi5cclxuICogQWRhcHRlZCBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg3MjE0ODNcclxuICpcclxuICogQHBhcmFtIHtQb2ludH0gcCAtIFRoZSBwb2ludCB0byBjaGVjay5cclxuICogQHJldHVybiB7Ym9vbGVhbn0gLSBXaGV0aGVyIG9yIG5vdCB0aGUgcG9pbnQgaXMgY29udGFpbmVkIHdpdGhpblxyXG4gKiAgIHRoZSBwb2x5Z29uLlxyXG4gKi9cclxuUG9seS5wcm90b3R5cGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uKHApIHtcclxuICB2YXIgcmVzdWx0ID0gZmFsc2U7XHJcbiAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLm51bXBvaW50cyAtIDE7IGkgPCB0aGlzLm51bXBvaW50czsgaiA9IGkrKykge1xyXG4gICAgdmFyIHAxID0gdGhpcy5wb2ludHNbal0sIHAyID0gdGhpcy5wb2ludHNbaV07XHJcbiAgICBpZiAoKHAyLnkgPiBwLnkpICE9IChwMS55ID4gcC55KSAmJlxyXG4gICAgICAgIChwLnggPCAocDEueCAtIHAyLngpICogKHAueSAtIHAyLnkpIC8gKHAxLnkgLSBwMi55KSArIHAyLngpKSB7XHJcbiAgICAgIHJlc3VsdCA9ICFyZXN1bHQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xvbmUgdGhlIGdpdmVuIHBvbHlnb24gaW50byBhIG5ldyBwb2x5Z29uLlxyXG4gKiBAcmV0dXJuIHtQb2x5fSAtIEEgY2xvbmUgb2YgdGhlIHBvbHlnb24uXHJcbiAqL1xyXG5Qb2x5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiBuZXcgUG9seSh0aGlzLnBvaW50cy5zbGljZSgpLm1hcChmdW5jdGlvbihwb2ludCkge1xyXG4gICAgcmV0dXJuIHBvaW50LmNsb25lKCk7XHJcbiAgfSkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRyYW5zbGF0ZSBhIHBvbHlnb24gYWxvbmcgYSBnaXZlbiB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB7UG9pbnR9IHZlYyAtIFRoZSB2ZWN0b3IgYWxvbmcgd2hpY2ggdG8gdHJhbnNsYXRlIHRoZVxyXG4gKiAgIHBvbHlnb24uXHJcbiAqIEByZXR1cm4ge1BvbHl9IC0gVGhlIHRyYW5zbGF0ZWQgcG9seWdvbi5cclxuICovXHJcblBvbHkucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKHZlYykge1xyXG4gIHJldHVybiBuZXcgUG9seSh0aGlzLnBvaW50cy5tYXAoZnVuY3Rpb24ocG9pbnQpIHtcclxuICAgIHJldHVybiBwb2ludC5hZGQodmVjKTtcclxuICB9KSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBhcnJheSBvZiBlZGdlcyByZXByZXNlbnRpbmcgdGhlIHBvbHlnb24uXHJcbiAqIEByZXR1cm4ge0FycmF5LjxFZGdlPn0gLSBUaGUgZWRnZXMgb2YgdGhlIHBvbHlnb24uXHJcbiAqL1xyXG5Qb2x5LnByb3RvdHlwZS5lZGdlcyA9IGZ1bmN0aW9uKCkge1xyXG4gIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShcImNhY2hlZF9lZGdlc1wiKSkge1xyXG4gICAgdGhpcy5jYWNoZWRfZWRnZXMgPSB0aGlzLnBvaW50cy5tYXAoZnVuY3Rpb24ocG9pbnQsIGkpIHtcclxuICAgICAgcmV0dXJuIG5ldyBFZGdlKHBvaW50LCB0aGlzLnBvaW50c1t0aGlzLmdldE5leHRJKGkpXSk7XHJcbiAgICB9LCB0aGlzKTtcclxuICB9XHJcbiAgcmV0dXJuIHRoaXMuY2FjaGVkX2VkZ2VzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE5haXZlIGNoZWNrIGlmIG90aGVyIHBvbHkgaW50ZXJzZWN0cyB0aGlzIG9uZSwgYXNzdW1pbmcgYm90aCBjb252ZXguXHJcbiAqIEBwYXJhbSB7UG9seX0gcG9seVxyXG4gKiBAcmV0dXJuIHtib29sZWFufSAtIFdoZXRoZXIgdGhlIHBvbHlnb25zIGludGVyc2VjdC5cclxuICovXHJcblBvbHkucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbihwb2x5KSB7XHJcbiAgdmFyIGluc2lkZSA9IHBvbHkucG9pbnRzLnNvbWUoZnVuY3Rpb24ocCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29udGFpbnNQb2ludChwKTtcclxuICB9LCB0aGlzKTtcclxuICBpbnNpZGUgPSBpbnNpZGUgfHwgdGhpcy5wb2ludHMuc29tZShmdW5jdGlvbihwKSB7XHJcbiAgICByZXR1cm4gcG9seS5jb250YWluc1BvaW50KHApO1xyXG4gIH0pO1xyXG4gIGlmIChpbnNpZGUpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgb3duRWRnZXMgPSB0aGlzLmVkZ2VzKCk7XHJcbiAgICB2YXIgb3RoZXJFZGdlcyA9IHBvbHkuZWRnZXMoKTtcclxuICAgIHZhciBpbnRlcnNlY3QgPSBvd25FZGdlcy5zb21lKGZ1bmN0aW9uKG93bkVkZ2UpIHtcclxuICAgICAgcmV0dXJuIG90aGVyRWRnZXMuc29tZShmdW5jdGlvbihvdGhlckVkZ2UpIHtcclxuICAgICAgICByZXR1cm4gb3duRWRnZS5pbnRlcnNlY3RzKG90aGVyRWRnZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gaW50ZXJzZWN0O1xyXG4gIH1cclxufTtcclxuXHJcbnZhciB1dGlsID0ge307XHJcbmV4cG9ydHMudXRpbCA9IHV0aWw7XHJcblxyXG4vKipcclxuICogR2l2ZW4gYW4gYXJyYXkgb2YgcG9seWdvbnMsIHJldHVybnMgdGhlIG9uZSB0aGF0IGNvbnRhaW5zIHRoZSBwb2ludC5cclxuICogSWYgbm8gcG9seWdvbiBpcyBmb3VuZCwgbnVsbCBpcyByZXR1cm5lZC5cclxuICogQHBhcmFtIHtQb2ludH0gcCAtIFRoZSBwb2ludCB0byBmaW5kIHRoZSBwb2x5Z29uIGZvci5cclxuICogQHBhcmFtIHtBcnJheS48UG9seT59IHBvbHlzIC0gVGhlIHBvbHlnb25zIHRvIHNlYXJjaCBmb3IgdGhlIHBvaW50LlxyXG4gKiBAcmV0dXJuIHs/UG9seWdvbn0gLSBUaGUgcG9seWdvbiBjb250YWluaW5nIHRoZSBwb2ludC5cclxuICovXHJcbnV0aWwuZmluZFBvbHlGb3JQb2ludCA9IGZ1bmN0aW9uKHAsIHBvbHlzKSB7XHJcbiAgdmFyIGksIHBvbHk7XHJcbiAgZm9yIChpIGluIHBvbHlzKSB7XHJcbiAgICBwb2x5ID0gcG9seXNbaV07XHJcbiAgICBpZiAocG9seS5jb250YWluc1BvaW50KHApKSB7XHJcbiAgICAgIHJldHVybiBwb2x5O1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBIb2xkcyB0aGUgcHJvcGVydGllcyBvZiBhIGNvbGxpc2lvbiwgaWYgb25lIG9jY3VycmVkLlxyXG4gKiBAdHlwZWRlZiBDb2xsaXNpb25cclxuICogQHR5cGUge29iamVjdH1cclxuICogQHByb3BlcnR5IHtib29sZWFufSBjb2xsaWRlcyAtIFdoZXRoZXIgdGhlcmUgaXMgYSBjb2xsaXNpb24uXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaW5zaWRlIC0gV2hldGhlciBvbmUgb2JqZWN0IGlzIGluc2lkZSB0aGUgb3RoZXIuXHJcbiAqIEBwcm9wZXJ0eSB7P1BvaW50fSBwb2ludCAtIFRoZSBwb2ludCBvZiBjb2xsaXNpb24sIGlmIGNvbGxpc2lvblxyXG4gKiAgIG9jY3VycywgYW5kIGlmIGBpbnNpZGVgIGlzIGZhbHNlLlxyXG4gKiBAcHJvcGVydHkgez9Qb2ludH0gbm9ybWFsIC0gQSB1bml0IHZlY3RvciBub3JtYWwgdG8gdGhlIHBvaW50XHJcbiAqICAgb2YgY29sbGlzaW9uLCBpZiBpdCBvY2N1cnMgYW5kIGlmIGBpbnNpZGVgIGlzIGZhbHNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIElmIHRoZSByYXkgaW50ZXJzZWN0cyB0aGUgY2lyY2xlLCB0aGUgZGlzdGFuY2UgdG8gdGhlIGludGVyc2VjdGlvblxyXG4gKiBhbG9uZyB0aGUgcmF5IGlzIHJldHVybmVkLCBvdGhlcndpc2UgZmFsc2UgaXMgcmV0dXJuZWQuXHJcbiAqIEBwYXJhbSB7UG9pbnR9IHAgLSBUaGUgc3RhcnQgb2YgdGhlIHJheS5cclxuICogQHBhcmFtIHtQb2ludH0gcmF5IC0gVW5pdCB2ZWN0b3IgZXh0ZW5kaW5nIGZyb20gYHBgLlxyXG4gKiBAcGFyYW0ge1BvaW50fSBjIC0gVGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlIGZvciB0aGUgb2JqZWN0IGJlaW5nXHJcbiAqICAgY2hlY2tlZCBmb3IgaW50ZXJzZWN0aW9uLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlLlxyXG4gKiBAcmV0dXJuIHtDb2xsaXNpb259IC0gVGhlIGNvbGxpc2lvbiBpbmZvcm1hdGlvbi5cclxuICovXHJcbnV0aWwubGluZUNpcmNsZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKHAsIHJheSwgYywgcmFkaXVzKSB7XHJcbiAgdmFyIGNvbGxpc2lvbiA9IHtcclxuICAgIGNvbGxpZGVzOiBmYWxzZSxcclxuICAgIGluc2lkZTogZmFsc2UsXHJcbiAgICBwb2ludDogbnVsbCxcclxuICAgIG5vcm1hbDogbnVsbFxyXG4gIH07XHJcbiAgdmFyIHZwYyA9IGMuc3ViKHApO1xyXG5cclxuICBpZiAodnBjLmxlbigpIDw9IHJhZGl1cykge1xyXG4gICAgLy8gUG9pbnQgaXMgaW5zaWRlIG9ic3RhY2xlLlxyXG4gICAgY29sbGlzaW9uLmNvbGxpZGVzID0gdHJ1ZTtcclxuICAgIGNvbGxpc2lvbi5pbnNpZGUgPSAodnBjLmxlbigpICE9PSByYWRpdXMpO1xyXG4gIH0gZWxzZSBpZiAocmF5LmRvdCh2cGMpID49IDApIHtcclxuICAgIC8vIENpcmNsZSBpcyBhaGVhZCBvZiBwb2ludC5cclxuICAgIC8vIFByb2plY3Rpb24gb2YgY2VudGVyIHBvaW50IG9udG8gcmF5LlxyXG4gICAgdmFyIHBjID0gcC5hZGQocmF5Lm11bChyYXkuZG90KHZwYykpKTtcclxuICAgIC8vIExlbmd0aCBmcm9tIGMgdG8gaXRzIHByb2plY3Rpb24gb24gdGhlIHJheS5cclxuICAgIHZhciBsZW5fY19wYyA9IGMuc3ViKHBjKS5sZW4oKTtcclxuXHJcbiAgICBpZiAobGVuX2NfcGMgPD0gcmFkaXVzKSB7XHJcbiAgICAgIGNvbGxpc2lvbi5jb2xsaWRlcyA9IHRydWU7XHJcblxyXG4gICAgICAvLyBEaXN0YW5jZSBmcm9tIHByb2plY3RlZCBwb2ludCB0byBpbnRlcnNlY3Rpb24uXHJcbiAgICAgIHZhciBsZW5faW50ZXJzZWN0aW9uID0gTWF0aC5zcXJ0KGxlbl9jX3BjICogbGVuX2NfcGMgKyByYWRpdXMgKiByYWRpdXMpO1xyXG4gICAgICBjb2xsaXNpb24ucG9pbnQgPSBwYy5zdWIocmF5Lm11bChsZW5faW50ZXJzZWN0aW9uKSk7XHJcbiAgICAgIGNvbGxpc2lvbi5ub3JtYWwgPSBjb2xsaXNpb24ucG9pbnQuc3ViKGMpLm5vcm1hbGl6ZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gY29sbGlzaW9uO1xyXG59O1xyXG4iLCJ2YXIgcGFydGl0aW9uID0gcmVxdWlyZSgnLi9wYXJ0aXRpb24nKTtcclxudmFyIGdlbyA9IHJlcXVpcmUoJy4vZ2VvbWV0cnknKTtcclxudmFyIFBvaW50ID0gZ2VvLlBvaW50O1xyXG52YXIgUG9seSA9IGdlby5Qb2x5O1xyXG52YXIgRWRnZSA9IGdlby5FZGdlO1xyXG5cclxudmFyIE1hcFBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2UtbWFwJyk7XHJcbnZhciBQYXRoZmluZGVyID0gcmVxdWlyZSgnLi9wYXRoZmluZGVyJyk7XHJcblxyXG5yZXF1aXJlKCdtYXRoLXJvdW5kJyk7XHJcbnZhciBDbGlwcGVyTGliID0gcmVxdWlyZSgnanNjbGlwcGVyJyk7XHJcblxyXG4vKipcclxuICogQSBOYXZNZXNoIHJlcHJlc2VudHMgdGhlIHRyYXZlcnNhYmxlIGFyZWEgb2YgYSBtYXAgYW5kIGdpdmVzXHJcbiAqIHV0aWxpdGllcyBmb3IgcGF0aGZpbmRpbmcuXHJcbiAqIFVzYWdlOlxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIEFzc3VtaW5nIHRoZSAyZCBtYXAgdGlsZXMgYXJyYXkgaXMgYXZhaWxhYmxlOlxyXG4gKiB2YXIgbmF2bWVzaCA9IG5ldyBOYXZNZXNoKG1hcCk7XHJcbiAqIG5hdm1lc2guY2FsY3VsYXRlUGF0aChjdXJyZW50bG9jYXRpb24sIHRhcmdldExvY2F0aW9uLCBjYWxsYmFjayk7XHJcbiAqIGBgYFxyXG4gKiBAbW9kdWxlIE5hdk1lc2hcclxuICovICBcclxuLyoqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAYWxpYXMgbW9kdWxlOk5hdk1lc2hcclxuICogQHBhcmFtIHtNYXBUaWxlc30gbWFwIC0gVGhlIDJkIGFycmF5IGRlZmluaW5nIHRoZSBtYXAgdGlsZXMuXHJcbiAqIEBwYXJhbSB7TG9nZ2VyfSBbbG9nZ2VyXSAtIFRoZSBsb2dnZXIgdG8gdXNlLlxyXG4gKi9cclxudmFyIE5hdk1lc2ggPSBmdW5jdGlvbihtYXAsIGxvZ2dlcikge1xyXG4gIGlmICh0eXBlb2YgbG9nZ2VyID09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBsb2dnZXIgPSB7fTtcclxuICAgIGxvZ2dlci5sb2cgPSBmdW5jdGlvbigpIHt9O1xyXG4gIH1cclxuICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcclxuXHJcbiAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xyXG5cclxuICB0aGlzLnVwZGF0ZUZ1bmNzID0gW107XHJcblxyXG4gIHRoaXMuX3NldHVwV29ya2VyKCk7XHJcbiAgXHJcbiAgLy8gUGFyc2UgbWFwIHRpbGVzIGludG8gcG9seWdvbnMuXHJcbiAgdmFyIHBvbHlzID0gTWFwUGFyc2VyLnBhcnNlKG1hcCk7XHJcbiAgaWYgKCFwb2x5cykge1xyXG4gICAgdGhyb3cgXCJNYXAgcGFyc2luZyBmYWlsZWQhXCI7XHJcbiAgfVxyXG5cclxuICAvLyBUcmFjayBtYXAgc3RhdGUuXHJcbiAgdGhpcy5tYXAgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1hcCkpO1xyXG5cclxuICAvLyBJbml0aWFsaXplIG5hdm1lc2guXHJcbiAgdGhpcy5faW5pdChwb2x5cyk7XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gTmF2TWVzaDtcclxuXHJcbi8qKlxyXG4gKiBDYWxsYmFjayBmb3IgcGF0aCBjYWxjdWxhdGlvbiByZXF1ZXN0cy5cclxuICogQGNhbGxiYWNrIFBhdGhDYWxsYmFja1xyXG4gKiBAcGFyYW0gez9BcnJheS48UG9pbnRMaWtlPn0gLSBUaGUgY2FsY3VsYXRlZCBwYXRoIGJlZ2lubmluZyB3aXRoXHJcbiAqICAgdGhlIHN0YXJ0IHBvaW50LCBhbmQgZW5kaW5nIGF0IHRoZSB0YXJnZXQgcG9pbnQuIElmIG5vIHBhdGggaXNcclxuICogICBmb3VuZCB0aGVuIG51bGwgaXMgcGFzc2VkIHRvIHRoZSBjYWxsYmFjay5cclxuICovXHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlIGEgcGF0aCBmcm9tIHRoZSBzb3VyY2UgcG9pbnQgdG8gdGhlIHRhcmdldCBwb2ludCwgaW52b2tpbmdcclxuICogdGhlIGNhbGxiYWNrIHdpdGggdGhlIHBhdGggYWZ0ZXIgY2FsY3VsYXRpb24uXHJcbiAqIEBwYXJhbSB7UG9pbnRMaWtlfSBzb3VyY2UgLSBUaGUgc3RhcnQgbG9jYXRpb24gb2YgdGhlIHNlYXJjaC5cclxuICogQHBhcmFtIHtQb2ludExpa2V9IHRhcmdldCAtIFRoZSB0YXJnZXQgb2YgdGhlIHNlYXJjaC5cclxuICogQHBhcmFtIHtQYXRoQ2FsbGJhY2t9IGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWRcclxuICogICB3aGVuIHRoZSBwYXRoIGhhcyBiZWVuIGNhbGN1bGF0ZWQuXHJcbiAqL1xyXG5OYXZNZXNoLnByb3RvdHlwZS5jYWxjdWxhdGVQYXRoID0gZnVuY3Rpb24oc291cmNlLCB0YXJnZXQsIGNhbGxiYWNrKSB7XHJcbiAgdGhpcy5sb2dnZXIubG9nKFwibmF2bWVzaDpkZWJ1Z1wiLCBcIkNhbGN1bGF0aW5nIHBhdGguXCIpO1xyXG5cclxuICAvLyBVc2Ugd2ViIHdvcmtlciBpZiBwcmVzZW50LlxyXG4gIGlmICh0aGlzLndvcmtlciAmJiB0aGlzLndvcmtlckluaXRpYWxpemVkKSB7XHJcbiAgICB0aGlzLmxvZ2dlci5sb2coXCJuYXZtZXNoOmRlYnVnXCIsIFwiVXNpbmcgd29ya2VyIHRvIGNhbGN1bGF0ZSBwYXRoLlwiKTtcclxuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKFtcImFTdGFyXCIsIHNvdXJjZSwgdGFyZ2V0XSk7XHJcbiAgICAvLyBTZXQgY2FsbGJhY2sgc28gaXQgaXMgYWNjZXNzaWJsZSB3aGVuIHJlc3VsdHMgYXJlIHNlbnQgYmFjay5cclxuICAgIHRoaXMubGFzdENhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgfSBlbHNlIHtcclxuICAgIHNvdXJjZSA9IFBvaW50LmZyb21Qb2ludExpa2Uoc291cmNlKTtcclxuICAgIHRhcmdldCA9IFBvaW50LmZyb21Qb2ludExpa2UodGFyZ2V0KTtcclxuICAgIHBhdGggPSB0aGlzLnBhdGhmaW5kZXIuYVN0YXIoc291cmNlLCB0YXJnZXQpO1xyXG4gICAgY2FsbGJhY2socGF0aCk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIHdoZXRoZXIgb25lIHBvaW50IGlzIHZpc2libGUgZnJvbSBhbm90aGVyLCB3aXRob3V0IGJlaW5nXHJcbiAqIGJsb2NrZWQgYnkgb2JzdGFjbGVzLlxyXG4gKiBAcGFyYW0ge1BvaW50TGlrZX0gcDEgLSBUaGUgZmlyc3QgcG9pbnQuXHJcbiAqIEBwYXJhbSB7UG9pbnRMaWtlfSBwMiAtIFRoZSBzZWNvbmQgcG9pbnQuXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IC0gV2hldGhlciBgcDFgIGlzIHZpc2libGUgZnJvbSBgcDJgLlxyXG4gKi9cclxuTmF2TWVzaC5wcm90b3R5cGUuY2hlY2tWaXNpYmxlID0gZnVuY3Rpb24ocDEsIHAyKSB7XHJcbiAgdmFyIGVkZ2UgPSBuZXcgRWRnZShQb2ludC5mcm9tUG9pbnRMaWtlKHAxKSwgUG9pbnQuZnJvbVBvaW50TGlrZShwMikpO1xyXG4gIHZhciBibG9ja2VkID0gdGhpcy5vYnN0YWNsZV9lZGdlcy5zb21lKGZ1bmN0aW9uKGUpIHtyZXR1cm4gZS5pbnRlcnNlY3RzKGVkZ2UpO30pO1xyXG4gIHJldHVybiAhYmxvY2tlZDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbnN1cmUgdGhhdCBwYXNzZWQgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2hlbiB0aGUgbmF2bWVzaCBoYXMgYmVlblxyXG4gKiBmdWxseSBpbml0aWFsaXplZC5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBuYXZtZXNoIGlzXHJcbiAqICAgaW5pdGlhbGl6ZWQuXHJcbiAqL1xyXG5OYXZNZXNoLnByb3RvdHlwZS5vbkluaXQgPSBmdW5jdGlvbihmbikge1xyXG4gIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XHJcbiAgICBmbigpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLm9uSW5pdChmbik7XHJcbiAgICB9LmJpbmQodGhpcyksIDEwKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYgVGlsZVVwZGF0ZVxyXG4gKiBAdHlwZSB7b2JqZWN0fVxyXG4gKiBAcHJvcGVydHkge2ludGVnZXJ9IHggLSBUaGUgeCBpbmRleCBvZiB0aGUgdGlsZSB0byB1cGRhdGUgaW4gdGhlXHJcbiAqICAgb3JpZ2luYWwgbWFwIGFycmF5LlxyXG4gKiBAcHJvcGVydHkge2ludGVnZXJ9IHkgLSBUaGUgeSBpbmRleCBvZiB0aGUgdGlsZSB0byB1cGRhdGUgaW4gdGhlXHJcbiAqICAgb3JpZ2luYWwgbWFwIGFycmF5LlxyXG4gKiBAcHJvcGVydHkgeyhudW1iZXJ8c3RyaW5nKX0gdiAtIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSB0aWxlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBUYWtlcyBhbiBhcnJheSBvZiB0aWxlcyBhbmQgdXBkYXRlcyB0aGUgbmF2aWdhdGlvbiBtZXNoIHRvIHJlZmxlY3RcclxuICogdGhlIG5ld2x5IHRyYXZlcnNhYmxlIGFyZWEuIFRoaXMgc2hvdWxkIGJlIHNldCBhcyBhIGxpc3RlbmVyIHRvXHJcbiAqIGBtYXB1cGRhdGVgIHNvY2tldCBldmVudHMuXHJcbiAqIEBwYXJhbSB7QXJyYXkuPFRpbGVVcGRhdGU+fSAtIEluZm9ybWF0aW9uIG9uIHRoZSB0aWxlcyB1cGRhdGVzLlxyXG4gKi9cclxuTmF2TWVzaC5wcm90b3R5cGUubWFwVXBkYXRlID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gIC8vIENoZWNrIHRoZSBwYXNzZWQgdmFsdWVzLlxyXG4gIHZhciBlcnJvciA9IGZhbHNlO1xyXG4gIC8vIEhvbGQgdXBkYXRlZCB0aWxlIGxvY2F0aW9ucy5cclxuICB2YXIgdXBkYXRlcyA9IFtdO1xyXG4gIGRhdGEuZm9yRWFjaChmdW5jdGlvbih1cGRhdGUpIHtcclxuICAgIC8vIFVwZGF0ZSBpbnRlcm5hbCBtYXAgc3RhdGUuXHJcbiAgICB0aGlzLm1hcFt1cGRhdGUueF1bdXBkYXRlLnldID0gdXBkYXRlLnY7XHJcbiAgICBpZiAoZXJyb3IpIHJldHVybjtcclxuICAgIHZhciB0aWxlSWQgPSB1cGRhdGUudjtcclxuICAgIHZhciBsb2NJZCA9IFBvaW50LnRvU3RyaW5nKHVwZGF0ZSk7XHJcbiAgICB2YXIgcGFzc2FibGUgPSB0aGlzLl9pc1Bhc3NhYmxlKHRpbGVJZCk7XHJcbiAgICB2YXIgY3VycmVudExvY1N0YXRlID0gdGhpcy5vYnN0YWNsZV9zdGF0ZVtsb2NJZF07XHJcbiAgICAvLyBBbGwgZHluYW1pYyB0aWxlIGxvY2F0aW9ucyBzaG91bGQgYmUgZGVmaW5lZC5cclxuICAgIGlmICh0eXBlb2YgY3VycmVudExvY1N0YXRlID09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIGVycm9yID0gdHJ1ZTtcclxuICAgICAgdGhpcy5sb2dnZXIubG9nKFwibmF2bWVzaDplcnJvclwiLFxyXG4gICAgICAgIFwiRHluYW1pYyBvYnN0YWNsZSBmb3VuZCBidXQgbm90IGFscmVhZHkgaW5pdGlhbGl6ZWQuXCIpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAocGFzc2FibGUgPT0gY3VycmVudExvY1N0YXRlKSB7XHJcbiAgICAgICAgLy8gTm90aGluZyB0byBkbyBoZXJlLlxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLm9ic3RhY2xlX3N0YXRlW2xvY0lkXSA9IHBhc3NhYmxlO1xyXG4gICAgICAgIC8vIFRyYWNrIHdoZXRoZXIgdXBkYXRlIGlzIG1ha2luZyB0aGUgdGlsZXMgcGFzc2FibGUgb3JcclxuICAgICAgICAvLyBpbXBhc3NhYmxlLlxyXG4gICAgICAgIHVwZGF0ZS5wYXNzYWJsZSA9IHBhc3NhYmxlO1xyXG4gICAgICAgIHVwZGF0ZXMucHVzaCh1cGRhdGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgdGhpcyk7XHJcblxyXG4gIGlmIChlcnJvcikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBoYXZlIHVwZGF0ZXMgdG8gY2Fycnkgb3V0LlxyXG4gIGlmICh1cGRhdGVzLmxlbmd0aCA+IDApIHtcclxuICAgIC8vIFNlZSB3aGV0aGVyIHRoaXMgaXMgYW4gdXBkYXRlIGZyb20gcGFzc2FibGUgdG8gaW1wYXNzYWJsZVxyXG4gICAgLy8gb3IgdmljZS12ZXJzYS5cclxuICAgIHZhciBwYXNzYWJsZSA9IHVwZGF0ZXNbMF0ucGFzc2FibGU7XHJcblxyXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhleSBhbGwgaGF2ZSB0aGUgc2FtZSB1cGRhdGUgdHlwZS5cclxuICAgIHVwZGF0ZXMuZm9yRWFjaChmdW5jdGlvbih1cGRhdGUpIHtcclxuICAgICAgaWYgKHVwZGF0ZS5wYXNzYWJsZSAhPT0gcGFzc2FibGUpIHtcclxuICAgICAgICBlcnJvciA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0sIHRoaXMpO1xyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIm5hdm1lc2g6ZXJyb3JcIixcclxuICAgICAgICBcIk5vdCBhbGwgdXBkYXRlcyBvZiBzYW1lIHR5cGUuXCIpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBQYXNzYWJsZS9pbXBhc3NhYmxlLXNwZWNpZmljIHVwZGF0ZSBmdW5jdGlvbnMuXHJcbiAgICBpZiAocGFzc2FibGUpIHtcclxuICAgICAgdGhpcy5fcGFzc2FibGVVcGRhdGUodXBkYXRlcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9pbXBhc3NhYmxlVXBkYXRlKHVwZGF0ZXMpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdXAgdGhlIG5hdm1lc2ggdG8gbGlzdGVuIHRvIHRoZSByZWxldmFudCBzb2NrZXQuXHJcbiAqIEBwYXJhbSAge1NvY2tldH0gc29ja2V0IC0gVGhlIHNvY2tldCB0byBsaXN0ZW4gb24gZm9yIGBtYXB1cGRhdGVgXHJcbiAqICAgcGFja2V0cy5cclxuICovXHJcbk5hdk1lc2gucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uKHNvY2tldCkge1xyXG4gIHNvY2tldC5vbihcIm1hcHVwZGF0ZVwiLCB0aGlzLm1hcFVwZGF0ZS5iaW5kKHRoaXMpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBuYXZpZ2F0aW9uIG1lc2ggdXBkYXRlcy5cclxuICogQGNhbGxiYWNrIFVwZGF0ZUNhbGxiYWNrXHJcbiAqIEBwYXJhbSB7QXJyYXkuPFBvbHk+fSAtIFRoZSBwb2x5cyBkZWZpbmluZyB0aGUgY3VycmVudCBuYXZpZ2F0aW9uXHJcbiAqICAgbWVzaC5cclxuICogQHBhcmFtIHtBcnJheS48UG9seT59IC0gVGhlIHBvbHlzIHRoYXQgd2VyZSBhZGRlZCB0byB0aGUgbWVzaC5cclxuICogQHBhcmFtIHtBcnJheS48aW50ZWdlcj59IC0gVGhlIGluZGljZXMgb2YgdGhlIHBvbHlzIHRoYXQgd2VyZVxyXG4gKiAgIHJlbW92ZWQgZnJvbSB0aGUgbWVzaC5cclxuICovXHJcblxyXG4vKipcclxuICogUmVnaXN0ZXIgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgbmF2aWdhdGlvbiBtZXNoIHVwZGF0ZXMuXHJcbiAqIEBwYXJhbSB7VXBkYXRlQ2FsbGJhY2t9IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cclxuICovXHJcbk5hdk1lc2gucHJvdG90eXBlLm9uVXBkYXRlID0gZnVuY3Rpb24oZm4pIHtcclxuICB0aGlzLnVwZGF0ZUZ1bmNzLnB1c2goZm4pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldCBzcGVjaWZpYyB0aWxlIGlkZW50aWZpZXJzIGFzIGltcGFzc2FibGUgdG8gdGhlIGFnZW50LlxyXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBpZHMgLSBUaGUgdGlsZSBpZHMgdG8gc2V0IGFzIGltcGFzc2FibGUuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBvYnN0YWNsZSAtIFRoZSBpZGVudGlmaWVyIGZvciB0aGUgcG9seWdvbiBmb3IgdGhlXHJcbiAqICAgb2JzdGFjbGVzIChhbHJlYWR5IHBhc3NlZCB0byBhZGRPYnN0YWNsZVBvbHkpLlxyXG4gKi9cclxuTmF2TWVzaC5wcm90b3R5cGUuc2V0SW1wYXNzYWJsZSA9IGZ1bmN0aW9uKGlkcykge1xyXG4gIC8vIFJlbW92ZSBpZHMgYWxyZWFkeSBzZXQgYXMgaW1wYXNzYWJsZS5cclxuICBpZHMgPSBpZHMuZmlsdGVyKGZ1bmN0aW9uKGlkKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faXNQYXNzYWJsZShpZCk7XHJcbiAgfSwgdGhpcyk7XHJcbiAgdGhpcy5sb2dnZXIubG9nKFwibmF2bWVzaDpkZWJ1Z1wiLCBcIklkcyBwYXNzZWQ6XCIsIGlkcyk7XHJcblxyXG4gIHZhciB1cGRhdGVzID0gW107XHJcbiAgLy8gQ2hlY2sgaWYgYW55IG9mIHRoZSBkeW5hbWljIHRpbGVzIGhhdmUgdGhlIHZhbHVlcyBwYXNzZWQuXHJcbiAgdGhpcy5keW5hbWljX29ic3RhY2xlX2xvY2F0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGxvYykge1xyXG4gICAgdmFyIGlkeCA9IGlkcy5pbmRleE9mKHRoaXMubWFwW2xvYy54XVtsb2MueV0pO1xyXG4gICAgaWYgKGlkeCAhPT0gLTEpIHtcclxuICAgICAgdXBkYXRlcy5wdXNoKHtcclxuICAgICAgICB4OiBsb2MueCxcclxuICAgICAgICB5OiBsb2MueSxcclxuICAgICAgICB2OiBpZHNbaWR4XVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LCB0aGlzKTtcclxuXHJcbiAgLy8gQWRkIHRvIGxpc3Qgb2YgaW1wYXNzYWJsZSB0aWxlcy5cclxuICBpZHMuZm9yRWFjaChmdW5jdGlvbihpZCkge1xyXG4gICAgdGhpcy5pbXBhc3NhYmxlW2lkXSA9IHRydWU7XHJcbiAgfSwgdGhpcyk7XHJcblxyXG4gIGlmICh1cGRhdGVzLmxlbmd0aCA+IDApIHtcclxuICAgIHRoaXMubWFwVXBkYXRlKHVwZGF0ZXMpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgdGlsZSBpZGVudGlmaWVycyBmcm9tIHNldCBvZiBpbXBhc3NhYmxlIHRpbGUgdHlwZXMuXHJcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGlkcyAtIFRoZSB0aWxlIGlkcyB0byBzZXQgYXMgdHJhdmVyc2FibGUuXHJcbiAqL1xyXG5OYXZNZXNoLnByb3RvdHlwZS5yZW1vdmVJbXBhc3NhYmxlID0gZnVuY3Rpb24oaWRzKSB7XHJcbiAgLy8gUmVtb3ZlIGlkcyBub3Qgc2V0IGFzIGltcGFzc2FibGUuXHJcbiAgaWRzID0gaWRzLmZpbHRlcihmdW5jdGlvbihpZCkge1xyXG4gICAgcmV0dXJuICF0aGlzLl9pc1Bhc3NhYmxlKGlkKTtcclxuICB9LCB0aGlzKTtcclxuXHJcbiAgdmFyIHVwZGF0ZXMgPSBbXTtcclxuICAvLyBDaGVjayBpZiBhbnkgb2YgdGhlIGR5bmFtaWMgdGlsZXMgaGF2ZSB0aGUgdmFsdWVzIHBhc3NlZC5cclxuICB0aGlzLmR5bmFtaWNfb2JzdGFjbGVfbG9jYXRpb25zLmZvckVhY2goZnVuY3Rpb24obG9jKSB7XHJcbiAgICB2YXIgaWR4ID0gaWRzLmluZGV4T2YodGhpcy5tYXBbbG9jLnhdW2xvYy55XSk7XHJcbiAgICBpZiAoaWR4ICE9PSAtMSkge1xyXG4gICAgICB1cGRhdGVzLnB1c2goe1xyXG4gICAgICAgIHg6IGxvYy54LFxyXG4gICAgICAgIHk6IGxvYy55LFxyXG4gICAgICAgIHY6IGlkc1tpZHhdXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sIHRoaXMpO1xyXG5cclxuICAvLyBSZW1vdmUgZnJvbSBsaXN0IG9mIGltcGFzc2FibGUgdGlsZXMuXHJcbiAgaWRzLmZvckVhY2goZnVuY3Rpb24oaWQpIHtcclxuICAgIHRoaXMuaW1wYXNzYWJsZVtpZF0gPSBmYWxzZTtcclxuICB9LCB0aGlzKTtcclxuXHJcbiAgaWYgKHVwZGF0ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgdGhpcy5tYXBVcGRhdGUodXBkYXRlcyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgdGhlIG5hdmlnYXRpb24gbWVzaCB3aXRoIHRoZSBwb2x5Z29ucyBkZXNjcmliaW5nIHRoZVxyXG4gKiBtYXAgZWxlbWVudHMuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7UGFyc2VkTWFwfSAtIFRoZSBtYXAgaW5mb3JtYXRpb24gcGFyc2VkIGludG8gcG9seWdvbnMuXHJcbiAqL1xyXG5OYXZNZXNoLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKHBhcnNlZE1hcCkge1xyXG4gIC8vIFNhdmUgb3JpZ2luYWwgcGFyc2VkIG1hcCBwb2x5cy5cclxuICB0aGlzLnBhcnNlZE1hcCA9IHBhcnNlZE1hcDtcclxuXHJcbiAgLy8gU3RhdGljIG9iamVjdHMgcmVsYXRpdmUgdG8gdGhlIG5hdm1lc2guXHJcbiAgdmFyIG5hdmlnYXRpb25fc3RhdGljX29iamVjdHMgPSB7XHJcbiAgICB3YWxsczogcGFyc2VkTWFwLndhbGxzLFxyXG4gICAgb2JzdGFjbGVzOiBwYXJzZWRNYXAuc3RhdGljX29ic3RhY2xlc1xyXG4gIH07XHJcbiAgdmFyIG5hdmlnYXRpb25fZHluYW1pY19vYmplY3RzID0gcGFyc2VkTWFwLmR5bmFtaWNfb2JzdGFjbGVzO1xyXG5cclxuICAvLyBPZmZzZXQgcG9seXMgZnJvbSBzaWRlIHNvIHRoZXkgcmVwcmVzZW50IHRyYXZlcnNhYmxlIGFyZWEuXHJcbiAgdmFyIGFyZWFzID0gdGhpcy5fb2Zmc2V0UG9seXMobmF2aWdhdGlvbl9zdGF0aWNfb2JqZWN0cyk7XHJcblxyXG4gIHRoaXMucG9seXMgPSBhcmVhcy5tYXAoTmF2TWVzaC5fZ2VvbWV0cnkucGFydGl0aW9uQXJlYSk7XHJcbiAgdGhpcy5wb2x5cyA9IE5hdk1lc2guX3V0aWwuZmxhdHRlbih0aGlzLnBvbHlzKTtcclxuXHJcbiAgaWYgKCF0aGlzLndvcmtlckluaXRpYWxpemVkKSB7XHJcbiAgICB0aGlzLnBhdGhmaW5kZXIgPSBuZXcgUGF0aGZpbmRlcih0aGlzLnBvbHlzKTtcclxuICB9XHJcblxyXG4gIHRoaXMuX3NldHVwRHluYW1pY09ic3RhY2xlcyhuYXZpZ2F0aW9uX2R5bmFtaWNfb2JqZWN0cyk7XHJcblxyXG4gIFxyXG4gIC8vIEhvbGQgdGhlIGVkZ2VzIG9mIHN0YXRpYyBvYnN0YWNsZXMuXHJcbiAgdGhpcy5zdGF0aWNfb2JzdGFjbGVfZWRnZXMgPSBbXTtcclxuICBhcmVhcy5mb3JFYWNoKGZ1bmN0aW9uKGFyZWEpIHtcclxuICAgIHZhciBwb2x5cyA9IFthcmVhLnBvbHlnb25dLmNvbmNhdChhcmVhLmhvbGVzKTtcclxuICAgIHBvbHlzLmZvckVhY2goZnVuY3Rpb24ocG9seSkge1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHBvbHkubnVtcG9pbnRzIC0gMTsgaSA8IHBvbHkubnVtcG9pbnRzOyBqID0gaSsrKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0aWNfb2JzdGFjbGVfZWRnZXMucHVzaChuZXcgRWRnZShwb2x5LnBvaW50c1tqXSwgcG9seS5wb2ludHNbaV0pKTtcclxuICAgICAgfVxyXG4gICAgfSwgdGhpcyk7XHJcbiAgfSwgdGhpcyk7XHJcblxyXG4gIC8vIEhvbGRzIHRoZSBlZGdlcyBvZiBzdGF0aWMgYW5kIGR5bmFtaWMgb2JzdGFjbGVzLlxyXG4gIHRoaXMub2JzdGFjbGVfZWRnZXMgPSB0aGlzLnN0YXRpY19vYnN0YWNsZV9lZGdlcy5zbGljZSgpO1xyXG5cclxuICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdXAgbWVzaC1keW5hbWljIG9ic3RhY2xlcy5cclxuICogQHByaXZhdGVcclxuICovXHJcbk5hdk1lc2gucHJvdG90eXBlLl9zZXR1cER5bmFtaWNPYnN0YWNsZXMgPSBmdW5jdGlvbihvYnN0YWNsZXMpIHtcclxuICAvLyBIb2xkcyB0aWxlIGlkPC0+aW1wYXNzYWJsZSAoYm9vbGVhbikgYXNzb2NpYXRpb25zLlxyXG4gIHRoaXMuaW1wYXNzYWJsZSA9IHt9O1xyXG4gIC8vIFBvbHlnb25zIGRlZmluaW5nIG9ic3RhY2xlcy5cclxuICB0aGlzLm9ic3RhY2xlRGVmaW5pdGlvbnMgPSB7fTtcclxuICAvLyBSZWxhdGlvbiBiZXR3ZWVuIGlkcyBhbmQgb2JzdGFjbGVzLlxyXG4gIHRoaXMuaWRUb09ic3RhY2xlcyA9IHt9O1xyXG5cclxuICB2YXIgZ2VvID0gTmF2TWVzaC5fZ2VvbWV0cnk7XHJcblxyXG4gIC8vIEFkZCBwb2x5Z29ucyBkZXNjcmliaW5nIGR5bmFtaWMgb2JzdGFjbGVzLlxyXG4gIHRoaXMuX2FkZE9ic3RhY2xlUG9seShcImJvbWJcIiwgZ2VvLmdldEFwcHJveGltYXRlQ2lyY2xlKDE1KSk7XHJcbiAgdGhpcy5fYWRkT2JzdGFjbGVQb2x5KFwiYm9vc3RcIiwgZ2VvLmdldEFwcHJveGltYXRlQ2lyY2xlKDE1KSk7XHJcbiAgdGhpcy5fYWRkT2JzdGFjbGVQb2x5KFwicG9ydGFsXCIsIGdlby5nZXRBcHByb3hpbWF0ZUNpcmNsZSgxNSkpO1xyXG4gIHRoaXMuX2FkZE9ic3RhY2xlUG9seShcInNwaWtlXCIsIGdlby5nZXRBcHByb3hpbWF0ZUNpcmNsZSgxNCkpO1xyXG4gIHRoaXMuX2FkZE9ic3RhY2xlUG9seShcImdhdGVcIiwgZ2VvLmdldFNxdWFyZSgyMCkpO1xyXG4gIHRoaXMuX2FkZE9ic3RhY2xlUG9seShcInRpbGVcIiwgZ2VvLmdldFNxdWFyZSgyMCkpO1xyXG4gIHRoaXMuX2FkZE9ic3RhY2xlUG9seShcIndhbGxcIiwgZ2VvLmdldFNxdWFyZSgyMCkpO1xyXG4gIHRoaXMuX2FkZE9ic3RhY2xlUG9seShcInNld2FsbFwiLCBnZW8uZ2V0RGlhZ29uYWwoMjAsIFwic2VcIikpO1xyXG4gIHRoaXMuX2FkZE9ic3RhY2xlUG9seShcIm5ld2FsbFwiLCBnZW8uZ2V0RGlhZ29uYWwoMjAsIFwibmVcIikpO1xyXG4gIHRoaXMuX2FkZE9ic3RhY2xlUG9seShcInN3d2FsbFwiLCBnZW8uZ2V0RGlhZ29uYWwoMjAsIFwic3dcIikpO1xyXG4gIHRoaXMuX2FkZE9ic3RhY2xlUG9seShcIm53d2FsbFwiLCBnZW8uZ2V0RGlhZ29uYWwoMjAsIFwibndcIikpO1xyXG5cclxuICAvLyBBZGQgaWQ8LT50eXBlIGFzc29jaWF0aW9ucy5cclxuICB0aGlzLl9zZXRPYnN0YWNsZVR5cGUoWzEwLCAxMC4xXSwgXCJib21iXCIpO1xyXG4gIHRoaXMuX3NldE9ic3RhY2xlVHlwZShbNSwgNS4xLCAxNCwgMTQuMSwgMTUsIDE1LjFdLCBcImJvb3N0XCIpO1xyXG4gIHRoaXMuX3NldE9ic3RhY2xlVHlwZShbOSwgOS4xLCA5LjIsIDkuM10sIFwiZ2F0ZVwiKTtcclxuICB0aGlzLl9zZXRPYnN0YWNsZVR5cGUoWzFdLCBcIndhbGxcIik7XHJcbiAgdGhpcy5fc2V0T2JzdGFjbGVUeXBlKFsxLjFdLCBcInN3d2FsbFwiKTtcclxuICB0aGlzLl9zZXRPYnN0YWNsZVR5cGUoWzEuMl0sIFwibnd3YWxsXCIpO1xyXG4gIHRoaXMuX3NldE9ic3RhY2xlVHlwZShbMS4zXSwgXCJuZXdhbGxcIik7XHJcbiAgdGhpcy5fc2V0T2JzdGFjbGVUeXBlKFsxLjRdLCBcInNld2FsbFwiKTtcclxuICB0aGlzLl9zZXRPYnN0YWNsZVR5cGUoWzddLCBcInNwaWtlXCIpO1xyXG5cclxuICAvLyBTZXQgdXAgb2JzdGFjbGUgc3RhdGUgY29udGFpbmVyLiBIb2xkcyB3aGV0aGVyIHBvc2l0aW9uIGlzXHJcbiAgLy8gcGFzc2FibGUgb3Igbm90LiBSZWZlcmVuY2VkIHVzaW5nIGFycmF5IGxvY2F0aW9uLlxyXG4gIHRoaXMub2JzdGFjbGVfc3RhdGUgPSB7fTtcclxuXHJcbiAgLy8gTG9jYXRpb24gb2YgZHluYW1pYyBvYnN0YWNsZXMuXHJcbiAgdGhpcy5keW5hbWljX29ic3RhY2xlX2xvY2F0aW9ucyA9IFtdO1xyXG5cclxuICAvLyBFZGdlcyBvZiBvZmZzZXR0ZWQgb2JzdGFjbGVkLCBvcmdhbml6ZWQgYnkgaWQuXHJcbiAgdGhpcy5keW5hbWljX29ic3RhY2xlX3BvbHlzID0ge307XHJcblxyXG4gIC8vIENvbnRhaW5lciB0byBob2xkIGluaXRpYWwgb2JzdGFjbGUgc3RhdGVzLlxyXG4gIHZhciBpbml0aWFsX3N0YXRlcyA9IFtdO1xyXG4gIG9ic3RhY2xlcy5mb3JFYWNoKGZ1bmN0aW9uKG9ic3RhY2xlKSB7XHJcbiAgICB2YXIgaWQgPSBQb2ludC50b1N0cmluZyhvYnN0YWNsZSk7XHJcblxyXG4gICAgLy8gR2VuZXJhdGUgb2Zmc2V0IG9ic3RhY2xlLlxyXG4gICAgdmFyIG9icyA9IHRoaXMuX29mZnNldER5bmFtaWNPYnMoW3RoaXMuX2dldFRpbGVQb2x5KG9ic3RhY2xlKV0pO1xyXG4gICAgdmFyIGFyZWFzID0gTmF2TWVzaC5fZ2VvbWV0cnkuZ2V0QXJlYXMob2JzKTtcclxuICAgIGFyZWFzID0gYXJlYXMubWFwKGZ1bmN0aW9uKGFyZWEpIHtcclxuICAgICAgYXJlYS5ob2xlcy5wdXNoKGFyZWEucG9seWdvbik7XHJcbiAgICAgIHJldHVybiBhcmVhLmhvbGVzO1xyXG4gICAgfSk7XHJcbiAgICBhcmVhcyA9IE5hdk1lc2guX3V0aWwuZmxhdHRlbihhcmVhcyk7XHJcbiAgICAvLyBHZXQgZWRnZXMgb2Ygb2JzdGFjbGUuXHJcbiAgICB2YXIgZWRnZXMgPSBhcmVhcy5tYXAoZnVuY3Rpb24ocG9seSkge1xyXG4gICAgICByZXR1cm4gcG9seS5lZGdlcygpO1xyXG4gICAgfSk7XHJcbiAgICBlZGdlcyA9IE5hdk1lc2guX3V0aWwuZmxhdHRlbihlZGdlcyk7XHJcbiAgICB0aGlzLmR5bmFtaWNfb2JzdGFjbGVfcG9seXNbaWRdID0gZWRnZXM7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSBvYnN0YWNsZSBzdGF0ZXMgdG8gYWxsIGJlIHBhc3NhYmxlLlxyXG4gICAgdGhpcy5vYnN0YWNsZV9zdGF0ZVtpZF0gPSB0cnVlO1xyXG4gICAgdGhpcy5keW5hbWljX29ic3RhY2xlX2xvY2F0aW9ucy5wdXNoKFBvaW50LmZyb21Qb2ludExpa2Uob2JzdGFjbGUpKTtcclxuICAgIGluaXRpYWxfc3RhdGVzLnB1c2gob2JzdGFjbGUpO1xyXG4gIH0sIHRoaXMpO1xyXG5cclxuICAvLyBTZXQgdXAgYWxyZWFkeS1rbm93biBkeW5hbWljIGltcGFzc2FibGUgdmFsdWVzLlxyXG4gIHRoaXMuc2V0SW1wYXNzYWJsZShbMTAsIDUsIDkuMV0pO1xyXG4gIC8vIFdhbGxzIGFuZCBzcGlrZXMuXHJcbiAgdGhpcy5zZXRJbXBhc3NhYmxlKFsxLCAxLjEsIDEuMiwgMS4zLCAxLjQsIDddKTtcclxuXHJcbiAgLy8gU2V0IHVwIGNhbGxiYWNrIHRvIHJlZ2VuZXJhdGUgb2JzdGFjbGUgZWRnZXMgZm9yIHZpc2liaWxpdHkgY2hlY2tpbmcuXHJcbiAgdGhpcy5vblVwZGF0ZShmdW5jdGlvbihwb2x5cykge1xyXG4gICAgdmFyIG9ic3RhY2xlX2VkZ2VzID0gW107XHJcbiAgICBmb3IgKGlkIGluIHRoaXMub2JzdGFjbGVfc3RhdGUpIHtcclxuICAgICAgaWYgKCF0aGlzLm9ic3RhY2xlX3N0YXRlW2lkXSkge1xyXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KFxyXG4gICAgICAgICAgb2JzdGFjbGVfZWRnZXMsXHJcbiAgICAgICAgICB0aGlzLmR5bmFtaWNfb2JzdGFjbGVfcG9seXNbaWRdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5vYnN0YWNsZV9lZGdlcyA9IHRoaXMuc3RhdGljX29ic3RhY2xlX2VkZ2VzLmNvbmNhdChvYnN0YWNsZV9lZGdlcyk7XHJcbiAgfS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBtYXB1cGRhdGUgd2l0aCBhbHJlYWR5LXByZXNlbnQgZHluYW1pYyBvYnN0YWNsZXMuXHJcbiAgdGhpcy5tYXBVcGRhdGUoaW5pdGlhbF9zdGF0ZXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZCBwb2x5IGRlZmluaXRpb24gZm9yIG9ic3RhY2xlIHR5cGUuXHJcbiAqIGVkZ2VzIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjZW50ZXIgb2YgdGlsZS5cclxuICogQHByaXZhdGVcclxuICovXHJcbk5hdk1lc2gucHJvdG90eXBlLl9hZGRPYnN0YWNsZVBvbHkgPSBmdW5jdGlvbihuYW1lLCBwb2x5KSB7XHJcbiAgdGhpcy5vYnN0YWNsZURlZmluaXRpb25zW25hbWVdID0gcG9seTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXRyaWV2ZSB0aGUgcG9seWdvbiBmb3IgYSBnaXZlbiBvYnN0YWNsZSBpZC5cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IGlkIC0gVGhlIGlkIHRvIHJldHJpZXZlIHRoZSBvYnN0YWNsZSBwb2x5Z29uIGZvci5cclxuICogQHJldHVybiB7UG9seX0gLSBUaGUgcG9seWdvbiByZXByZXNlbnRpbmcgdGhlIG9ic3RhY2xlLlxyXG4gKi9cclxuTmF2TWVzaC5wcm90b3R5cGUuX2dldE9ic3RhY2xlUG9seSA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgdmFyIHBvbHkgPSB0aGlzLm9ic3RhY2xlRGVmaW5pdGlvbnNbdGhpcy5pZFRvT2JzdGFjbGVzW2lkXV1cclxuICBpZiAocG9seSkge1xyXG4gICAgcmV0dXJuIHBvbHkuY2xvbmUoKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5sb2dnZXIubG9nKFwibmF2bWVzaDpkZWJ1Z1wiLCBcIk5vIHBvbHkgZm91bmQgZm9yIGlkOlwiLCBpZCk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSB0aGUgbmF2aWdhdGlvbiBtZXNoIHRvIHRoZSBnaXZlbiBwb2x5cyBhbmQgY2FsbCB0aGUgdXBkYXRlXHJcbiAqIGZ1bmN0aW9ucy5cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtBcnJheS48UG9seT59IHBvbHlzIC0gVGhlIG5ldyBwb2x5cyBkZWZpbmluZyB0aGUgbmF2IG1lc2guXHJcbiAqIEBwYXJhbSB7QXJyYXkuPFBvbHk+fSBhZGRlZCAtIFRoZSBwb2x5cyB0aGF0IHdlcmUgYWRkZWQgdG8gdGhlIG1lc2guXHJcbiAqIEBwYXJhbSB7QXJyYXkuPGludGVnZXI+fSByZW1vdmVkIC0gVGhlIGluZGljZXMgb2YgdGhlIHBvbHlzIHRoYXQgd2VyZVxyXG4gKiAgIHJlbW92ZWQgZnJvbSB0aGUgbWVzaC5cclxuICovXHJcbk5hdk1lc2gucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbihwb2x5cywgYWRkZWQsIHJlbW92ZWQpIHtcclxuICB0aGlzLnBvbHlzID0gcG9seXM7XHJcbiAgdGhpcy51cGRhdGVGdW5jcy5mb3JFYWNoKGZ1bmN0aW9uKGZuKSB7XHJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICBmbih0aGlzLnBvbHlzLCBhZGRlZCwgcmVtb3ZlZCk7XHJcbiAgICB9LmJpbmQodGhpcyksIDApO1xyXG4gIH0sIHRoaXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgcmVsYXRpb25zaGlwIGJldHdlZW4gc3BlY2lmaWMgdGlsZSBpZGVudGlmaWVycyBhbmQgdGhlXHJcbiAqIHBvbHlnb25zIHJlcHJlc2VudGluZyB0aGUgc2hhcGUgb2YgdGhlIG9ic3RhY2xlIHRoZXkgY29ycmVzcG9uZFxyXG4gKiB0by5cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gaWRzIC0gVGhlIHRpbGUgaWRzIHRvIHNldCBhcyBpbXBhc3NhYmxlLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gb2JzdGFjbGUgLSBUaGUgaWRlbnRpZmllciBmb3IgdGhlIHBvbHlnb24gZm9yIHRoZVxyXG4gKiAgIG9ic3RhY2xlcyAoYWxyZWFkeSBwYXNzZWQgdG8gYWRkT2JzdGFjbGVQb2x5KS5cclxuICovXHJcbk5hdk1lc2gucHJvdG90eXBlLl9zZXRPYnN0YWNsZVR5cGUgPSBmdW5jdGlvbihpZHMsIHR5cGUpIHtcclxuICBpZHMuZm9yRWFjaChmdW5jdGlvbihpZCkge1xyXG4gICAgdGhpcy5pZFRvT2JzdGFjbGVzW2lkXSA9IHR5cGU7XHJcbiAgfSwgdGhpcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgd2hldGhlciB0aGUgcHJvdmlkZWQgaWQgY29ycmVzcG9uZHMgdG8gYSBwYXNzYWJsZSB0aWxlLlxyXG4gKiBAcmV0dXJuIHtib29sZWFufSAtIFdoZXRoZXIgdGhlIGlkIGlzIGZvciBhIHBhc3NhYmxlIHRpbGUuXHJcbiAqL1xyXG5OYXZNZXNoLnByb3RvdHlwZS5faXNQYXNzYWJsZSA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgLy8gQ2hlY2sgaWYgaW4gbGlzdCBvZiBpbXBhc3NhYmxlIHRpbGVzLlxyXG4gIHJldHVybiAhdGhpcy5pbXBhc3NhYmxlLmhhc093blByb3BlcnR5KGlkKSB8fCAhdGhpcy5pbXBhc3NhYmxlW2lkXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBwb2x5Z29uIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGRpbWVuc2lvbnMgYW5kIGxvY2F0aW9uIG9mIHRoZVxyXG4gKiBwcm92aWRlZCB0aWxlIHVwZGF0ZS5cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtUaWxlVXBkYXRlfSB0aWxlIC0gVGhlIHRpbGUgdXBkYXRlIGluZm9ybWF0aW9uLlxyXG4gKiBAcmV0dXJuIHtQb2x5fSAtIFRoZSBwb2x5Z29uIHJlcHJlc2VudGluZyB0aGUgdGlsZS5cclxuICovXHJcbk5hdk1lc2gucHJvdG90eXBlLl9nZXRUaWxlUG9seSA9IGZ1bmN0aW9uKHRpbGUpIHtcclxuICAvLyBHZXQgdGhlIGJhc2UgcG9seSBmcm9tIGEgbGlzdCBvZiBzdWNoIHRoaW5ncyBieSB0aWxlIGlkXHJcbiAgLy8gdGhlbiB0cmFuc2xhdGUgYWNjb3JkaW5nIHRvIHRoZSBhcnJheSBsb2NhdGlvbi5cclxuICB2YXIgaWQgPSB0aWxlLnY7XHJcbiAgdmFyIHAgPSB0aGlzLl9nZXRXb3JsZENvb3JkKHRpbGUpO1xyXG4gIHZhciBwb2x5ID0gdGhpcy5fZ2V0T2JzdGFjbGVQb2x5KGlkKS50cmFuc2xhdGUocCk7XHJcbiAgcmV0dXJuIHBvbHk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIHBvaW50IGluIHNwYWNlIG9yIGEgbG9jYXRpb24gaW4gYSAyZCBhcnJheS5cclxuICogQHR5cGVkZWYgUG9pbnRMaWtlXHJcbiAqIEB0eXBlIHtvYmplY3R9XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IC0gVGhlIGB4YCBjb29yZGluYXRlIGZvciB0aGUgcG9pbnQsIG9yIHJvd1xyXG4gKiAgIGZvciB0aGUgYXJyYXkgbG9jYXRpb24uXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IC0gVGhlIGB5YCBjb29yZGluYXRlIGZvciB0aGUgcG9pbnQuIG9yIGNvbHVtblxyXG4gKiAgIGZvciB0aGUgYXJyYXkgbG9jYXRpb24uXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGFuIGFycmF5IGxvY2F0aW9uLCByZXR1cm4gdGhlIHdvcmxkIGNvb3JkaW5hdGUgcmVwcmVzZW50aW5nXHJcbiAqIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIHRpbGUgYXQgdGhhdCBhcnJheSBsb2NhdGlvbi5cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtQb2ludExpa2V9IGFycmF5TG9jIC0gVGhlIGxvY2F0aW9uIGluIHRoZSBtYXAgZm9yIHRoZSBwb2ludC5cclxuICogQHJldHVybSB7UG9pbnR9IC0gVGhlIGNvb3JkaW5hdGVzIGZvciB0aGUgY2VudGVyIG9mIHRoZSBsb2NhdGlvbi5cclxuICovXHJcbk5hdk1lc2gucHJvdG90eXBlLl9nZXRXb3JsZENvb3JkID0gZnVuY3Rpb24oYXJyYXlMb2MpIHtcclxuICB2YXIgVElMRV9XSURUSCA9IDQwO1xyXG4gIHJldHVybiBuZXcgUG9pbnQoXHJcbiAgICBhcnJheUxvYy54ICogVElMRV9XSURUSCArIChUSUxFX1dJRFRIIC8gMiksXHJcbiAgICBhcnJheUxvYy55ICogVElMRV9XSURUSCArIChUSUxFX1dJRFRIIC8gMilcclxuICApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhcnJ5IG91dCB0aGUgbmF2bWVzaCB1cGRhdGUgZm9yIGltcGFzc2FibGUgZHluYW1pYyBvYnN0YWNsZXMgdGhhdFxyXG4gKiBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBuYXZtZXNoLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0FycmF5LjxUaWxlVXBkYXRlPn0gdXBkYXRlcyAtIFRoZSB0aWxlIHVwZGF0ZSBpbmZvcm1hdGlvbi5cclxuICovXHJcbk5hdk1lc2gucHJvdG90eXBlLl9wYXNzYWJsZVVwZGF0ZSA9IGZ1bmN0aW9uKHVwZGF0ZXMpIHtcclxuICB2YXIgc2NhbGUgPSAxMDA7XHJcbiAgLy8gQXNzdW1lIGVhY2ggb2YgdGhlIHRpbGVzIGlzIG5vdyBhIHNxdWFyZSBvZiBvcGVuIHNwYWNlLlxyXG4gIHZhciBwYXNzYWJsZVRpbGVzID0gdXBkYXRlcy5tYXAoZnVuY3Rpb24odXBkYXRlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZ2V0VGlsZVBvbHkoe1xyXG4gICAgICB4OiB1cGRhdGUueCxcclxuICAgICAgeTogdXBkYXRlLnksXHJcbiAgICAgIHY6IDFcclxuICAgIH0pO1xyXG4gIH0sIHRoaXMpO1xyXG5cclxuICAvLyBPZmZzZXQgYW5kIG1lcmdlIG5ld2x5IHBhc3NhYmxlIHRpbGVzLCBhc3N1bWluZyBubyB0aWxlIGFsb25nXHJcbiAgLy8gd2l0aCBpdHMgb2Zmc2V0IHdvdWxkIGhhdmUgYmVlbiBsYXJnZXIgdGhhbiBhIHNpbmdsZSB0aWxlLlxyXG4gIC8vIFNldCBvZmZzZXQgc2xpZ2h0bHkgbGFyZ2VyIHRoYXQgbm9ybWFsIHNvIHRoYXQgd2UgY2F0Y2ggYWxsXHJcbiAgLy8gcmVsZXZhbnQgcG9seWdvbnMgdGhhdCBuZWVkIHRvIGJlIHVwZGF0ZWQgaW4gdGhlIG5hdm1lc2guXHJcbiAgdmFyIHBhc3NhYmxlQXJlYSA9IHRoaXMuX29mZnNldER5bmFtaWNPYnMocGFzc2FibGVUaWxlcywgMjApO1xyXG5cclxuICB2YXIgY3ByID0gTmF2TWVzaC5fZ2VvbWV0cnkuY3ByO1xyXG5cclxuICAvLyBHZXQgaW1wYXNzYWJsZSB0aWxlcyBib3JkZXJpbmcgdGhlIG5vdy1wYXNzYWJsZSBhcmVhIGFuZCBvZmZzZXQgdGhlbS5cclxuICB2YXIgYm9yZGVyaW5nVGlsZXMgPSB0aGlzLl9nZXRCb3JkZXJlZFRpbGVzKHVwZGF0ZXMpO1xyXG4gIHZhciBib3JkZXJpbmdQb2x5cyA9IGJvcmRlcmluZ1RpbGVzLm1hcCh0aGlzLl9nZXRUaWxlUG9seSwgdGhpcyk7XHJcbiAgdmFyIHN1cnJvdW5kaW5nQXJlYSA9IHRoaXMuX29mZnNldER5bmFtaWNPYnMoYm9yZGVyaW5nUG9seXMpO1xyXG5cclxuICAvLyBHZXQgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBvcGVuIGFyZWEgYW5kIHRoZSBzdXJyb3VuZGluZyBvYnN0YWNsZXMuXHJcbiAgY3ByLkNsZWFyKCk7XHJcbiAgdmFyIGFjdHVhbFBhc3NhYmxlQXJlYSA9IG5ldyBDbGlwcGVyTGliLlBhdGhzKCk7XHJcbiAgY3ByLkFkZFBhdGhzKHBhc3NhYmxlQXJlYSwgQ2xpcHBlckxpYi5Qb2x5VHlwZS5wdFN1YmplY3QsIHRydWUpO1xyXG4gIGNwci5BZGRQYXRocyhzdXJyb3VuZGluZ0FyZWEsIENsaXBwZXJMaWIuUG9seVR5cGUucHRDbGlwLCB0cnVlKTtcclxuICBjcHIuRXhlY3V0ZShDbGlwcGVyTGliLkNsaXBUeXBlLmN0RGlmZmVyZW5jZSxcclxuICAgIGFjdHVhbFBhc3NhYmxlQXJlYSxcclxuICAgIENsaXBwZXJMaWIuUG9seUZpbGxUeXBlLnBmdE5vblplcm8sXHJcbiAgICBDbGlwcGVyTGliLlBvbHlGaWxsVHlwZS5wZnROb25aZXJvXHJcbiAgKTtcclxuXHJcbiAgdmFyIHBhc3NhYmxlQXJlYXMgPSBOYXZNZXNoLl9nZW9tZXRyeS5nZXRBcmVhcyhhY3R1YWxQYXNzYWJsZUFyZWEsIHNjYWxlKTtcclxuXHJcbiAgdmFyIHBhc3NhYmxlUGFydGl0aW9uID0gTmF2TWVzaC5fZ2VvbWV0cnkucGFydGl0aW9uQXJlYXMocGFzc2FibGVBcmVhcyk7XHJcblxyXG4gIC8vIEdldCBtZXNoIHBvbHlzIGludGVyc2VjdGVkIGJ5IG9mZnNldHRlZCBwYXNzYWJsZSBhcmVhLlxyXG4gIHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLl9nZXRJbnRlcnNlY3RlZFBvbHlzKHBhc3NhYmxlUGFydGl0aW9uKTtcclxuICB2YXIgaW50ZXJzZWN0ZWRNZXNoUG9seXMgPSBpbnRlcnNlY3Rpb24ucG9seXM7XHJcblxyXG4gIC8vIENyZWF0ZSBvdXRsaW5lIHdpdGggbWF0Y2hlZCBtZXNoIHBvbHlzLlxyXG4gIGludGVyc2VjdGVkTWVzaFBvbHlzID0gaW50ZXJzZWN0ZWRNZXNoUG9seXMubWFwKE5hdk1lc2guX2dlb21ldHJ5LmNvbnZlcnRQb2x5VG9DbGlwcGVyKTtcclxuICBDbGlwcGVyTGliLkpTLlNjYWxlVXBQYXRocyhpbnRlcnNlY3RlZE1lc2hQb2x5cywgc2NhbGUpO1xyXG5cclxuICAvLyBNZXJnZSBpbnRlcnNlY3RlZCBtZXNoIHBvbHlzIGFuZCB3aXRoIG5ld2x5IHBhc3NhYmxlIGFyZWEuXHJcbiAgY3ByLkNsZWFyKCk7XHJcbiAgY3ByLkFkZFBhdGhzKGludGVyc2VjdGVkTWVzaFBvbHlzLCBDbGlwcGVyTGliLlBvbHlUeXBlLnB0U3ViamVjdCwgdHJ1ZSk7XHJcbiAgY3ByLkFkZFBhdGhzKGFjdHVhbFBhc3NhYmxlQXJlYSwgQ2xpcHBlckxpYi5Qb2x5VHlwZS5wdFN1YmplY3QsIHRydWUpO1xyXG4gIHZhciBuZXdNZXNoQXJlYSA9IG5ldyBDbGlwcGVyTGliLlBhdGhzKCk7XHJcbiAgY3ByLkV4ZWN1dGUoXHJcbiAgICBDbGlwcGVyTGliLkNsaXBUeXBlLmN0VW5pb24sXHJcbiAgICBuZXdNZXNoQXJlYSxcclxuICAgIENsaXBwZXJMaWIuUG9seUZpbGxUeXBlLnBmdE5vblplcm8sXHJcbiAgICBudWxsKTtcclxuXHJcbiAgLy8gUGFydGl0aW9uIHRoZSB1bmlvbmVkIG1lc2ggcG9seXMgYW5kIG5ldyBwYXNzYWJsZSBhcmVhIGFuZCBhZGRcclxuICAvLyB0byB0aGUgZXhpc3RpbmcgbWVzaCBwb2x5cy5cclxuICB2YXIgbWVzaEFyZWFzID0gTmF2TWVzaC5fZ2VvbWV0cnkuZ2V0QXJlYXMobmV3TWVzaEFyZWEsIHNjYWxlKTtcclxuICB2YXIgbmV3UG9seXMgPSBOYXZNZXNoLl9nZW9tZXRyeS5wYXJ0aXRpb25BcmVhcyhtZXNoQXJlYXMpO1xyXG4gIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMucG9seXMsIG5ld1BvbHlzKTtcclxuXHJcbiAgdGhpcy5fdXBkYXRlKHRoaXMucG9seXMsIG5ld1BvbHlzLCBpbnRlcnNlY3Rpb24uaW5kaWNlcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2Fycnkgb3V0IHRoZSBuYXZtZXNoIHVwZGF0ZSBmb3IgaW1wYXNzYWJsZSBkeW5hbWljIG9ic3RhY2xlcyB0aGF0XHJcbiAqIGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgbmF2bWVzaC5cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtBcnJheS48VGlsZVVwZGF0ZT59IHVwZGF0ZXMgLSBUaGUgdGlsZSB1cGRhdGUgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5OYXZNZXNoLnByb3RvdHlwZS5faW1wYXNzYWJsZVVwZGF0ZSA9IGZ1bmN0aW9uKHVwZGF0ZXMpIHtcclxuICB2YXIgc2NhbGUgPSAxMDA7XHJcbiAgLy8gR2V0IHBvbHlnb25zIGRlZmluaW5nIHRoZXNlIG9ic3RhY2xlcy5cclxuICB2YXIgb2JzdGFjbGVQb2x5cyA9IHVwZGF0ZXMubWFwKGZ1bmN0aW9uKHVwZGF0ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2dldFRpbGVQb2x5KHVwZGF0ZSk7XHJcbiAgfSwgdGhpcyk7XHJcblxyXG4gIC8vIE9mZnNldCB0aGUgb2JzdGFjbGUgcG9seWdvbnMuXHJcbiAgdmFyIG9mZnNldHRlZE9ic3RhY2xlcyA9IHRoaXMuX29mZnNldER5bmFtaWNPYnMob2JzdGFjbGVQb2x5cyk7XHJcbiAgdmFyIG9ic3RhY2xlQXJlYXMgPSBOYXZNZXNoLl9nZW9tZXRyeS5nZXRBcmVhcyhvZmZzZXR0ZWRPYnN0YWNsZXMpO1xyXG5cclxuICAvLyBHZXQgY29udmV4IHBhcnRpdGlvbiBvZiBuZXcgb2JzdGFjbGUgYXJlYXMgZm9yIGZpbmRpbmdcclxuICAvLyBpbnRlcnNlY3Rpb25zLlxyXG4gIHZhciBvYnN0YWNsZVBhcnRpdGlvbiA9IE5hdk1lc2guX2dlb21ldHJ5LnBhcnRpdGlvbkFyZWFzKG9ic3RhY2xlQXJlYXMpO1xyXG5cclxuICAvLyBHZXQgbWVzaCBwb2x5cyBpbnRlcnNlY3RlZCBieSBvZmZzZXR0ZWQgb2JzdGFjbGVzLlxyXG4gIHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLl9nZXRJbnRlcnNlY3RlZFBvbHlzKG9ic3RhY2xlUGFydGl0aW9uKTtcclxuICB2YXIgaW50ZXJzZWN0ZWRNZXNoUG9seXMgPSBpbnRlcnNlY3Rpb24ucG9seXM7XHJcblxyXG4gIC8vIENyZWF0ZSBvdXRsaW5lIHdpdGggbWF0Y2hlZCBtZXNoIHBvbHlzLlxyXG4gIGludGVyc2VjdGVkTWVzaFBvbHlzID0gaW50ZXJzZWN0ZWRNZXNoUG9seXMubWFwKE5hdk1lc2guX2dlb21ldHJ5LmNvbnZlcnRQb2x5VG9DbGlwcGVyKTtcclxuICBDbGlwcGVyTGliLkpTLlNjYWxlVXBQYXRocyhpbnRlcnNlY3RlZE1lc2hQb2x5cywgc2NhbGUpO1xyXG4gIHZhciBjcHIgPSBOYXZNZXNoLl9nZW9tZXRyeS5jcHI7XHJcblxyXG4gIC8vIE1lcmdlIG1hdGNoZWQgcG9seXNcclxuICBjcHIuQ2xlYXIoKTtcclxuICBjcHIuQWRkUGF0aHMoaW50ZXJzZWN0ZWRNZXNoUG9seXMsIENsaXBwZXJMaWIuUG9seVR5cGUucHRTdWJqZWN0LCB0cnVlKTtcclxuICB2YXIgbWVyZ2VkTWVzaFBvbHlzID0gbmV3IENsaXBwZXJMaWIuUGF0aHMoKTtcclxuICBjcHIuRXhlY3V0ZShcclxuICAgIENsaXBwZXJMaWIuQ2xpcFR5cGUuY3RVbmlvbixcclxuICAgIG1lcmdlZE1lc2hQb2x5cyxcclxuICAgIENsaXBwZXJMaWIuUG9seUZpbGxUeXBlLnBmdE5vblplcm8sXHJcbiAgICBudWxsKTtcclxuXHJcbiAgLy8gVGFrZSBkaWZmZXJlbmNlIG9mIG1lc2ggcG9seXMgYW5kIG9ic3RhY2xlIHBvbHlzLlxyXG4gIHZhciBwYXRocyA9IG5ldyBDbGlwcGVyTGliLlBhdGhzKCk7XHJcbiAgY3ByLkNsZWFyKCk7XHJcbiAgY3ByLkFkZFBhdGhzKG1lcmdlZE1lc2hQb2x5cywgQ2xpcHBlckxpYi5Qb2x5VHlwZS5wdFN1YmplY3QsIHRydWUpO1xyXG4gIGNwci5BZGRQYXRocyhvZmZzZXR0ZWRPYnN0YWNsZXMsIENsaXBwZXJMaWIuUG9seVR5cGUucHRDbGlwLCB0cnVlKTtcclxuXHJcbiAgY3ByLkV4ZWN1dGUoQ2xpcHBlckxpYi5DbGlwVHlwZS5jdERpZmZlcmVuY2UsXHJcbiAgICBwYXRocyxcclxuICAgIENsaXBwZXJMaWIuUG9seUZpbGxUeXBlLnBmdE5vblplcm8sXHJcbiAgICBDbGlwcGVyTGliLlBvbHlGaWxsVHlwZS5wZnROb25aZXJvXHJcbiAgKTtcclxuXHJcbiAgdmFyIGFyZWFzID0gTmF2TWVzaC5fZ2VvbWV0cnkuZ2V0QXJlYXMocGF0aHMsIHNjYWxlKTtcclxuICAvLyBNYWtlIHBvbHlzIGZyb20gbmV3IHNwYWNlLlxyXG4gIHZhciBwb2x5cyA9IE5hdk1lc2guX2dlb21ldHJ5LnBhcnRpdGlvbkFyZWFzKGFyZWFzKTtcclxuXHJcbiAgLy8gQWRkIHRvIGV4aXN0aW5nIHBvbHlnb25zLlxyXG4gIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMucG9seXMsIHBvbHlzKTtcclxuXHJcbiAgdGhpcy5fdXBkYXRlKHRoaXMucG9seXMsIHBvbHlzLCBpbnRlcnNlY3Rpb24uaW5kaWNlcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogT2Zmc2V0dGluZyBmdW5jdGlvbiBmb3IgZHluYW1pYyBvYnN0YWNsZXMuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7QXJyYXkuPFBvbHk+fSBvYnN0YWNsZXNcclxuICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXQ9MTZdXHJcbiAqIEByZXR1cm4ge0FycmF5LjxQb2x5Pn1cclxuICovXHJcbk5hdk1lc2gucHJvdG90eXBlLl9vZmZzZXREeW5hbWljT2JzID0gZnVuY3Rpb24ob2JzdGFjbGVzLCBvZmZzZXQpIHtcclxuICBpZiAodHlwZW9mIG9mZnNldCA9PSAndW5kZWZpbmVkJykgb2Zmc2V0ID0gMTY7XHJcbiAgdmFyIHNjYWxlID0gMTAwO1xyXG4gIG9ic3RhY2xlcyA9IG9ic3RhY2xlcy5tYXAoTmF2TWVzaC5fZ2VvbWV0cnkuY29udmVydFBvbHlUb0NsaXBwZXIpO1xyXG4gIENsaXBwZXJMaWIuSlMuU2NhbGVVcFBhdGhzKG9ic3RhY2xlcywgc2NhbGUpO1xyXG5cclxuICB2YXIgY3ByID0gTmF2TWVzaC5fZ2VvbWV0cnkuY3ByO1xyXG4gIHZhciBjbyA9IE5hdk1lc2guX2dlb21ldHJ5LmNvO1xyXG5cclxuICAvLyBNZXJnZSBvYnN0YWNsZXMgdG9nZXRoZXIsIHNvIG9ic3RhY2xlcyB0aGF0IHNoYXJlIGEgY29tbW9uIGVkZ2VcclxuICAvLyB3aWxsIGJlIGV4cGFuZGVkIHByb3Blcmx5LlxyXG4gIGNwci5DbGVhcigpO1xyXG4gIGNwci5BZGRQYXRocyhvYnN0YWNsZXMsIENsaXBwZXJMaWIuUG9seVR5cGUucHRTdWJqZWN0LCB0cnVlKTtcclxuICB2YXIgbWVyZ2VkX29ic3RhY2xlcyA9IG5ldyBDbGlwcGVyTGliLlBhdGhzKCk7XHJcbiAgY3ByLkV4ZWN1dGUoXHJcbiAgICBDbGlwcGVyTGliLkNsaXBUeXBlLmN0VW5pb24sXHJcbiAgICBtZXJnZWRfb2JzdGFjbGVzLFxyXG4gICAgQ2xpcHBlckxpYi5Qb2x5RmlsbFR5cGUucGZ0Tm9uWmVybyxcclxuICAgIG51bGwpO1xyXG5cclxuICAvLyBPZmZzZXQgb2JzdGFjbGVzLlxyXG4gIHZhciBvZmZzZXR0ZWRfcGF0aHMgPSBuZXcgQ2xpcHBlckxpYi5QYXRocygpO1xyXG5cclxuICBtZXJnZWRfb2JzdGFjbGVzLmZvckVhY2goZnVuY3Rpb24ob2JzdGFjbGUpIHtcclxuICAgIHZhciBvZmZzZXR0ZWRfb2JzdGFjbGUgPSBuZXcgQ2xpcHBlckxpYi5QYXRocygpO1xyXG4gICAgY28uQ2xlYXIoKTtcclxuICAgIGNvLkFkZFBhdGgob2JzdGFjbGUsIENsaXBwZXJMaWIuSm9pblR5cGUuanRNaXRlciwgQ2xpcHBlckxpYi5FbmRUeXBlLmV0Q2xvc2VkUG9seWdvbik7XHJcbiAgICBjby5FeGVjdXRlKG9mZnNldHRlZF9vYnN0YWNsZSwgb2Zmc2V0ICogc2NhbGUpO1xyXG4gICAgb2Zmc2V0dGVkX3BhdGhzLnB1c2gob2Zmc2V0dGVkX29ic3RhY2xlWzBdKTtcclxuICB9KTtcclxuXHJcbiAgLy8gTWVyZ2UgYW55IG5ld2x5LW92ZXJsYXBwaW5nIG9ic3RhY2xlcy5cclxuICBjcHIuQ2xlYXIoKTtcclxuICBjcHIuQWRkUGF0aHMob2Zmc2V0dGVkX3BhdGhzLCBDbGlwcGVyTGliLlBvbHlUeXBlLnB0U3ViamVjdCwgdHJ1ZSk7XHJcbiAgbWVyZ2VkX29ic3RhY2xlcyA9IG5ldyBDbGlwcGVyTGliLlBhdGhzKCk7XHJcbiAgY3ByLkV4ZWN1dGUoXHJcbiAgICBDbGlwcGVyTGliLkNsaXBUeXBlLmN0VW5pb24sXHJcbiAgICBtZXJnZWRfb2JzdGFjbGVzLFxyXG4gICAgQ2xpcHBlckxpYi5Qb2x5RmlsbFR5cGUucGZ0Tm9uWmVybyxcclxuICAgIG51bGwpO1xyXG4gIHJldHVybiBtZXJnZWRfb2JzdGFjbGVzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBhbmQgcmVtb3ZlIHRoZSBtZXNoIHBvbHlnb25zIGltcGFjdGVkIGJ5IHRoZSBhZGRpdGlvbiBvZiBuZXdcclxuICogb2JzdGFjbGVzLiBUaGUgcHJvdmlkZWQgb2JzdGFjbGVzIHNob3VsZCBhbHJlYWR5IGJlIG9mZnNldHRlZC5cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtBcnJheS48UG9seT59IG9ic3RhY2xlcyAtIFRoZSBvZmZzZXR0ZWQgb2JzdGFjbGVzIHRvIGdldFxyXG4gKiAgIHRoZSBpbnRlcnNlY3Rpb24gb2YuIE11c3QgYmUgY29udmV4LlxyXG4gKiBAcmV0dXJuIHtBcnJheS48UG9seT59IC0gVGhlIGFmZmVjdGVkIHBvbHlzLlxyXG4gKi9cclxuTmF2TWVzaC5wcm90b3R5cGUuX2dldEludGVyc2VjdGVkUG9seXMgPSBmdW5jdGlvbihvYnN0YWNsZXMpIHtcclxuICB2YXIgaW50ZXJzZWN0ZWRJbmRpY2VzID0gTmF2TWVzaC5fZ2VvbWV0cnkuZ2V0SW50ZXJzZWN0aW9ucyhvYnN0YWNsZXMsIHRoaXMucG9seXMpO1xyXG4gIHJldHVybiB7XHJcbiAgICBpbmRpY2VzOiBpbnRlcnNlY3RlZEluZGljZXMsXHJcbiAgICBwb2x5czogTmF2TWVzaC5fdXRpbC5zcGxpY2UodGhpcy5wb2x5cywgaW50ZXJzZWN0ZWRJbmRpY2VzKVxyXG4gIH07XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBpbXBhc3NhYmxlIHRpbGVzIGJvcmRlcmluZyB1cGRhdGVkIHBhc3NhYmxlIHRpbGVzLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0FycmF5LjxUaWxlVXBkYXRlPn0gdGlsZXMgLSBUaGUgdXBkYXRlZCBwYXNzYWJsZSB0aWxlcy5cclxuICogQHJldHVybiB7QXJyYXkuPEFycmF5TG9jPn0gLSBUaGUgbmV3IGFycmF5IGxvY2F0aW9ucy5cclxuICovXHJcbk5hdk1lc2gucHJvdG90eXBlLl9nZXRCb3JkZXJlZFRpbGVzID0gZnVuY3Rpb24odGlsZXMpIHtcclxuICAvLyBUcmFjayBsb2NhdGlvbnMgYWxyZWFkeSBiZWluZyB1cGRhdGVkIG9yIGFkZGVkLlxyXG4gIHZhciBsb2NhdGlvbnMgPSB7fTtcclxuICB0aWxlcy5mb3JFYWNoKGZ1bmN0aW9uKHRpbGUpIHtcclxuICAgIGxvY2F0aW9uc1tQb2ludC50b1N0cmluZyh0aWxlKV0gPSB0cnVlO1xyXG4gIH0pO1xyXG5cclxuICB2YXIgbWFwID0gdGhpcy5tYXA7XHJcbiAgdmFyIHhVcHBlckJvdW5kID0gbWFwLmxlbmd0aDtcclxuICB2YXIgeVVwcGVyQm91bmQgPSBtYXBbMF0ubGVuZ3RoO1xyXG4gIC8vIEdldCB0aGUgbG9jYXRpb25zIGFkamFjZW50IHRvIGEgZ2l2ZW4gdGlsZSBpbiB0aGUgbWFwLlxyXG4gIHZhciBnZXRBZGphY2VudCA9IGZ1bmN0aW9uKHRpbGUpIHtcclxuICAgIHZhciB4ID0gdGlsZS54O1xyXG4gICAgdmFyIHkgPSB0aWxlLnk7XHJcbiAgICB2YXIgeFVwID0geCArIDEgPCB4VXBwZXJCb3VuZDtcclxuICAgIHZhciB4RG93biA9IHggPj0gMDtcclxuICAgIHZhciB5VXAgPSB5ICsgMSA8IHlVcHBlckJvdW5kO1xyXG4gICAgdmFyIHlEb3duID0geSA+PSAwO1xyXG5cclxuICAgIHZhciBhZGphY2VudHMgPSBbXTtcclxuICAgIGlmICh4VXApIHtcclxuICAgICAgYWRqYWNlbnRzLnB1c2goe3g6IHggKyAxLCB5OiB5fSk7XHJcbiAgICAgIGlmICh5VXApIHtcclxuICAgICAgICBhZGphY2VudHMucHVzaCh7eDogeCArIDEsIHk6IHkgKyAxfSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHlEb3duKSB7XHJcbiAgICAgICAgYWRqYWNlbnRzLnB1c2goe3g6IHggKyAxLCB5OiB5IC0gMX0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoeERvd24pIHtcclxuICAgICAgYWRqYWNlbnRzLnB1c2goe3g6IHggLSAxLCB5OiB5fSk7XHJcbiAgICAgIGlmICh5VXApIHtcclxuICAgICAgICBhZGphY2VudHMucHVzaCh7eDogeCAtIDEsIHk6IHkgKyAxfSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHlEb3duKSB7XHJcbiAgICAgICAgYWRqYWNlbnRzLnB1c2goe3g6IHggLSAxLCB5OiB5IC0gMX0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoeVVwKSB7XHJcbiAgICAgIGFkamFjZW50cy5wdXNoKHt4OiB4LCB5OiB5ICsgMX0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHlEb3duKSB7XHJcbiAgICAgIGFkamFjZW50cy5wdXNoKHt4OiB4LCB5OiB5IC0gMX0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFkamFjZW50cztcclxuICB9O1xyXG5cclxuICAvLyBTdG9yZSBhZGphY2VudCBpbXBhc3NhYmxlIHRpbGVzLlxyXG4gIHZhciBhZGphY2VudF90aWxlcyA9IFtdO1xyXG4gIHRpbGVzLmZvckVhY2goZnVuY3Rpb24odGlsZSkge1xyXG4gICAgdmFyIGFkamFjZW50cyA9IGdldEFkamFjZW50KHRpbGUpO1xyXG4gICAgYWRqYWNlbnRzLmZvckVhY2goZnVuY3Rpb24oYWRqYWNlbnQpIHtcclxuICAgICAgdmFyIGlkID0gUG9pbnQudG9TdHJpbmcoYWRqYWNlbnQpO1xyXG4gICAgICBpZiAoIWxvY2F0aW9uc1tpZF0pIHtcclxuICAgICAgICAvLyBSZWNvcmQgYXMgaGF2aW5nIGJlZW4gc2Vlbi5cclxuICAgICAgICBsb2NhdGlvbnNbaWRdID0gdHJ1ZTtcclxuICAgICAgICB2YXIgdmFsID0gdGhpcy5tYXBbYWRqYWNlbnQueF1bYWRqYWNlbnQueV07XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc1Bhc3NhYmxlKHZhbCkpIHtcclxuICAgICAgICAgIGFkamFjZW50LnYgPSB2YWw7XHJcbiAgICAgICAgICBhZGphY2VudF90aWxlcy5wdXNoKGFkamFjZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sIHRoaXMpO1xyXG4gIH0sIHRoaXMpO1xyXG4gIHJldHVybiBhZGphY2VudF90aWxlcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSBvdXRsaW5lIG9mIGEgc2hhcGUgYWxvbmcgd2l0aCBpdHMgaG9sZXMuXHJcbiAqIEB0eXBlZGVmIE1hcEFyZWFcclxuICogQHR5cGUge29iamVjdH1cclxuICogQHByb3BlcnR5IHtQb2x5fSBwb2x5Z29uIC0gVGhlIHBvbHlnb24gZGVmaW5pbmcgdGhlIGV4dGVyaW9yIG9mXHJcbiAqICAgdGhlIHNoYXBlLlxyXG4gKiBAcHJvcGVydHkge0FycmF5LjxQb2x5Pn0gaG9sZXMgLSBUaGUgaG9sZXMgb2YgdGhlIHNoYXBlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBPZmZzZXQgdGhlIHBvbHlnb25zIHN1Y2ggdGhhdCB0aGVyZSBpcyBhIGBvZmZzZXRgIHVuaXQgYnVmZmVyXHJcbiAqIGJldHdlZW4gdGhlIHNpZGVzIG9mIHRoZSBvdXRsaW5lIGFuZCBhcm91bmQgdGhlIG9ic3RhY2xlcy4gVGhpc1xyXG4gKiBidWZmZXIgbWFrZXMgaXQgc28gdGhhdCB0aGUgbWVzaCB0cnVseSByZXByZXNlbnRzIHRoZSBtb3ZhYmxlIGFyZWFcclxuICogaW4gdGhlIG1hcC4gQXNzdW1lcyB2ZXJ0aWNlcyBkZWZpbmluZyBpbnRlcmlvciBzaGFwZXMgKGxpa2UgdGhlXHJcbiAqIG1haW4gb3V0bGluZSBvZiBhbiBlbmNsb3NlZCBtYXApIGFyZSBnaXZlbiBpbiBDQ1cgb3JkZXIgYW5kXHJcbiAqIG9ic3RhY2xlcyBhcmUgZ2l2ZW4gaW4gQ1cgb3JkZXIuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7QXJyYXkuPFBvbHk+fSBwb2x5cyAtIFRoZSBwb2x5Z29ucyB0byBvZmZzZXQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0PTE2XSAtIFRoZSBhbW91bnQgdG8gb2Zmc2V0IHRoZSBwb2x5Z29uc1xyXG4gKiAgIGZyb20gdGhlIG1vdmFibGUgYXJlYXMuXHJcbiAqIEByZXR1cm4ge0FycmF5LjxNYXBBcmVhPn0gLSBUaGUgc2hhcGVzIGRlZmluaW5nIHRoZSBwb2x5Z29ucyBhZnRlclxyXG4gKiAgIG9mZnNldHRpbmcgYW5kIG1lcmdpbmcuXHJcbiAqL1xyXG5OYXZNZXNoLnByb3RvdHlwZS5fb2Zmc2V0UG9seXMgPSBmdW5jdGlvbihzdGF0aWNfb2JqZWN0cywgb2Zmc2V0KSB7XHJcbiAgLy8gfj0gYmFsbCByYWRpdXMgLyAyXHJcbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT0gJ3VuZGVmaW5lZCcpIG9mZnNldCA9IDE2O1xyXG5cclxuICAvLyBTZXBhcmF0ZSBpbnRlcmlvciBhbmQgZXh0ZXJpb3Igd2FsbHMuIFRoZSBDQ1cgc2hhcGVzIGNvcnJlc3BvbmRcclxuICAvLyB0byB0aGUgaW50ZXJpb3Igd2FsbCBvdXRsaW5lcyBvZiBvdXQgbWFwLCB0aGUgQ1cgc2hhcGVzIGFyZSB3YWxsc1xyXG4gIC8vIHRoYXQgd2VyZSB0cmFjZWQgb24gdGhlaXIgb3V0c2lkZS5cclxuICB2YXIgaW50ZXJpb3Jfd2FsbHMgPSBbXTtcclxuICB2YXIgZXh0ZXJpb3Jfd2FsbHMgPSBzdGF0aWNfb2JqZWN0cy53YWxscy5maWx0ZXIoZnVuY3Rpb24ocG9seSwgaW5kZXgpIHtcclxuICAgIGlmIChwb2x5LmdldE9yaWVudGF0aW9uKCkgPT0gXCJDQ1dcIikge1xyXG4gICAgICBpbnRlcmlvcl93YWxscy5wdXNoKHBvbHkpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9KTtcclxuXHJcbiAgdmFyIHNjYWxlID0gMTAwO1xyXG4gIFxyXG4gIC8vIE9mZnNldCB0aGUgaW50ZXJpb3Igd2FsbHMuXHJcbiAgaW50ZXJpb3Jfd2FsbHMgPSBpbnRlcmlvcl93YWxscy5tYXAoTmF2TWVzaC5fZ2VvbWV0cnkuY29udmVydFBvbHlUb0NsaXBwZXIpO1xyXG4gIENsaXBwZXJMaWIuSlMuU2NhbGVVcFBhdGhzKGludGVyaW9yX3dhbGxzLCBzY2FsZSk7XHJcbiAgXHJcbiAgdmFyIG9mZnNldHRlZF9pbnRlcmlvcl93YWxscyA9IFtdO1xyXG4gIGludGVyaW9yX3dhbGxzLmZvckVhY2goZnVuY3Rpb24od2FsbCkge1xyXG4gICAgdmFyIG9mZnNldHRlZF9wYXRocyA9IE5hdk1lc2guX2dlb21ldHJ5Lm9mZnNldEludGVyaW9yKHdhbGwsIG9mZnNldCk7XHJcbiAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShvZmZzZXR0ZWRfaW50ZXJpb3Jfd2FsbHMsIG9mZnNldHRlZF9wYXRocyk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIFJldmVyc2UgcGF0aHMgc2luY2UgZnJvbSBoZXJlIG9uIHdlJ3JlIGdvaW5nIHRvIHRyZWF0IHRoZVxyXG4gIC8vIG91dGxpbmVzIGFzIHRoZSBleHRlcmlvciBvZiBhIHNoYXBlLlxyXG4gIG9mZnNldHRlZF9pbnRlcmlvcl93YWxscy5mb3JFYWNoKGZ1bmN0aW9uKHBhdGgpIHtcclxuICAgIHBhdGgucmV2ZXJzZSgpO1xyXG4gIH0pO1xyXG4gIFxyXG4gIGV4dGVyaW9yX3dhbGxzID0gZXh0ZXJpb3Jfd2FsbHMubWFwKE5hdk1lc2guX2dlb21ldHJ5LmNvbnZlcnRQb2x5VG9DbGlwcGVyKTtcclxuXHJcbiAgQ2xpcHBlckxpYi5KUy5TY2FsZVVwUGF0aHMoZXh0ZXJpb3Jfd2FsbHMsIHNjYWxlKTtcclxuXHJcbiAgLy92YXIgY3ByID0gbmV3IENsaXBwZXJMaWIuQ2xpcHBlcigpO1xyXG4gIHZhciBjcHIgPSBOYXZNZXNoLl9nZW9tZXRyeS5jcHI7XHJcbiAgdmFyIGNvID0gTmF2TWVzaC5fZ2VvbWV0cnkuY287XHJcbiAgXHJcbiAgdmFyIHdhbGxfZmlsbFR5cGUgPSBDbGlwcGVyTGliLlBvbHlGaWxsVHlwZS5wZnRFdmVuT2RkO1xyXG4gIHZhciBvYnN0YWNsZV9maWxsVHlwZSA9IENsaXBwZXJMaWIuUG9seUZpbGxUeXBlLnBmdE5vblplcm87XHJcbiAgXHJcbiAgLy8gT2Zmc2V0IGV4dGVyaW9yIHdhbGxzLlxyXG4gIHZhciBvZmZzZXR0ZWRfZXh0ZXJpb3Jfd2FsbHMgPSBbXTtcclxuXHJcbiAgZXh0ZXJpb3Jfd2FsbHMuZm9yRWFjaChmdW5jdGlvbih3YWxsKSB7XHJcbiAgICB2YXIgb2Zmc2V0dGVkX2V4dGVyaW9yX3dhbGwgPSBuZXcgQ2xpcHBlckxpYi5QYXRocygpO1xyXG4gICAgY28uQ2xlYXIoKTtcclxuICAgIGNvLkFkZFBhdGgod2FsbCwgQ2xpcHBlckxpYi5Kb2luVHlwZS5qdFNxdWFyZSwgQ2xpcHBlckxpYi5FbmRUeXBlLmV0Q2xvc2VkUG9seWdvbik7XHJcbiAgICBjby5FeGVjdXRlKG9mZnNldHRlZF9leHRlcmlvcl93YWxsLCBvZmZzZXQgKiBzY2FsZSk7XHJcbiAgICBvZmZzZXR0ZWRfZXh0ZXJpb3Jfd2FsbHMucHVzaChvZmZzZXR0ZWRfZXh0ZXJpb3Jfd2FsbFswXSk7XHJcbiAgfSk7XHJcbiAgXHJcbiAgLy8gT2Zmc2V0IG9ic3RhY2xlcy5cclxuICAvLyBPYnN0YWNsZXMgYXJlIG9mZnNldHRlZCB1c2luZyBtaXRlciBqb2luIHR5cGUgdG8gYXZvaWRcclxuICAvLyB1bm5lY2Vzc2FyeSBzbWFsbCBlZGdlcy5cclxuICB2YXIgb2Zmc2V0dGVkX29ic3RhY2xlcyA9IG5ldyBDbGlwcGVyTGliLlBhdGhzKCk7XHJcblxyXG4gIHZhciBvYnN0YWNsZXMgPSBzdGF0aWNfb2JqZWN0cy5vYnN0YWNsZXMubWFwKE5hdk1lc2guX2dlb21ldHJ5LmNvbnZlcnRQb2x5VG9DbGlwcGVyKTtcclxuICBDbGlwcGVyTGliLkpTLlNjYWxlVXBQYXRocyhvYnN0YWNsZXMsIHNjYWxlKTtcclxuICBjby5DbGVhcigpO1xyXG4gIGNvLkFkZFBhdGhzKG9ic3RhY2xlcywgQ2xpcHBlckxpYi5Kb2luVHlwZS5qdE1pdGVyLCBDbGlwcGVyTGliLkVuZFR5cGUuZXRDbG9zZWRQb2x5Z29uKTtcclxuICBjby5FeGVjdXRlKG9mZnNldHRlZF9vYnN0YWNsZXMsIG9mZnNldCAqIHNjYWxlKTtcclxuXHJcbiAgLy8gVGFrZSBkaWZmZXJlbmNlIG9mIHBvbHlnb25zIGRlZmluaW5nIGludGVyaW9yIHdhbGwgYW5kIHBvbHlnb25zXHJcbiAgLy8gZGVmaW5pbmcgZXh0ZXJpb3Igd2FsbHMsIGxpbWl0aW5nIHRvIGV4dGVyaW9yIHdhbGwgcG9seWdvbnMgd2hvc2VcclxuICAvLyBhcmVhIGlzIGxlc3MgdGhhbiB0aGUgaW50ZXJpb3Igd2FsbCBwb2x5Z29ucyBzbyB0aGUgZGlmZmVyZW5jZVxyXG4gIC8vIG9wZXJhdGlvbiBkb2Vzbid0IHJlbW92ZSBwb3RlbnRpYWxseSB0cmF2ZXJzYWJsZSBhcmVhcy5cclxuICB2YXIgbWVyZ2VkX3BhdGhzID0gW107XHJcbiAgb2Zmc2V0dGVkX2ludGVyaW9yX3dhbGxzLmZvckVhY2goZnVuY3Rpb24od2FsbCkge1xyXG4gICAgdmFyIGFyZWEgPSBDbGlwcGVyTGliLkpTLkFyZWFPZlBvbHlnb24od2FsbCwgc2NhbGUpO1xyXG4gICAgdmFyIHNtYWxsZXJfZXh0ZXJpb3Jfd2FsbHMgPSBvZmZzZXR0ZWRfZXh0ZXJpb3Jfd2FsbHMuZmlsdGVyKGZ1bmN0aW9uKGV4dF93YWxsKSB7XHJcbiAgICAgIHJldHVybiBDbGlwcGVyTGliLkpTLkFyZWFPZlBvbHlnb24oZXh0X3dhbGwsIHNjYWxlKSA8IGFyZWE7XHJcbiAgICB9KTtcclxuICAgIHZhciBwYXRocyA9IG5ldyBDbGlwcGVyTGliLlBhdGhzKCk7XHJcbiAgICBjcHIuQ2xlYXIoKTtcclxuICAgIGNwci5BZGRQYXRoKHdhbGwsIENsaXBwZXJMaWIuUG9seVR5cGUucHRTdWJqZWN0LCB0cnVlKTtcclxuICAgIGNwci5BZGRQYXRocyhzbWFsbGVyX2V4dGVyaW9yX3dhbGxzLCBDbGlwcGVyTGliLlBvbHlUeXBlLnB0Q2xpcCwgdHJ1ZSk7XHJcbiAgICAvLyBPYnN0YWNsZXMgYXJlIHNtYWxsIGluZGl2aWR1YWwgc29saWQgb2JqZWN0cyB0aGF0IGFyZW4ndCBhdFxyXG4gICAgLy8gcmlzayBvZiBlbmNsb3NpbmcgYW4gaW50ZXJpb3IgYXJlYS5cclxuICAgIGNwci5BZGRQYXRocyhvZmZzZXR0ZWRfb2JzdGFjbGVzLCBDbGlwcGVyTGliLlBvbHlUeXBlLnB0Q2xpcCwgdHJ1ZSk7XHJcbiAgICBjcHIuRXhlY3V0ZShDbGlwcGVyTGliLkNsaXBUeXBlLmN0RGlmZmVyZW5jZSxcclxuICAgICAgcGF0aHMsXHJcbiAgICAgIENsaXBwZXJMaWIuUG9seUZpbGxUeXBlLnBmdE5vblplcm8sXHJcbiAgICAgIENsaXBwZXJMaWIuUG9seUZpbGxUeXBlLnBmdE5vblplcm9cclxuICAgICk7XHJcbiAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShtZXJnZWRfcGF0aHMsIHBhdGhzKTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIE5hdk1lc2guX2dlb21ldHJ5LmdldEFyZWFzKG1lcmdlZF9wYXRocywgc2NhbGUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldHMgdXAgY2FsbGJhY2tzIG9uIHRoZSB3ZWIgd29ya2VyIHByb21pc2Ugb2JqZWN0IHRvIGluaXRpYWxpemVcclxuICogdGhlIHdlYiB3b3JrZXIgaW50ZXJmYWNlIG9uY2UgbG9hZGVkLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuTmF2TWVzaC5wcm90b3R5cGUuX3NldHVwV29ya2VyID0gZnVuY3Rpb24oKSB7XHJcbiAgLy8gSW5pdGlhbCBzdGF0ZS5cclxuICB0aGlzLndvcmtlciA9IG5ldyBXb3JrZXIod2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoWycoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSBcXCdcIitvK1wiXFwnXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAoZ2xvYmFsKXtcXG4hZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9dCgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSx0KTtlbHNle3ZhciBlO1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/ZT13aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9lPWdsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmKGU9c2VsZiksZS5Qcmlvcml0eVF1ZXVlPXQoKX19KGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uIHQoZSxpLHIpe2Z1bmN0aW9uIG8obixzKXtpZighaVtuXSl7aWYoIWVbbl0pe3ZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIXMmJnUpcmV0dXJuIHUobiwhMCk7aWYoYSlyZXR1cm4gYShuLCEwKTt2YXIgaD1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgXFwnXCIrbitcIlxcJ1wiKTt0aHJvdyBoLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsaH12YXIgcD1pW25dPXtleHBvcnRzOnt9fTtlW25dWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHQpe3ZhciBpPWVbbl1bMV1bdF07cmV0dXJuIG8oaT9pOnQpfSxwLHAuZXhwb3J0cyx0LGUsaSxyKX1yZXR1cm4gaVtuXS5leHBvcnRzfWZvcih2YXIgYT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLG49MDtuPHIubGVuZ3RoO24rKylvKHJbbl0pO3JldHVybiBvfSh7MTpbZnVuY3Rpb24odCxlKXt2YXIgaSxyLG8sYSxuLHM9e30uaGFzT3duUHJvcGVydHksdT1mdW5jdGlvbih0LGUpe2Z1bmN0aW9uIGkoKXt0aGlzLmNvbnN0cnVjdG9yPXR9Zm9yKHZhciByIGluIGUpcy5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiBpLnByb3RvdHlwZT1lLnByb3RvdHlwZSx0LnByb3RvdHlwZT1uZXcgaSx0Ll9fc3VwZXJfXz1lLnByb3RvdHlwZSx0fTtpPXQoXCIuL1ByaW9yaXR5UXVldWUvQWJzdHJhY3RQcmlvcml0eVF1ZXVlXCIpLHI9dChcIi4vUHJpb3JpdHlRdWV1ZS9BcnJheVN0cmF0ZWd5XCIpLGE9dChcIi4vUHJpb3JpdHlRdWV1ZS9CaW5hcnlIZWFwU3RyYXRlZ3lcIiksbz10KFwiLi9Qcmlvcml0eVF1ZXVlL0JIZWFwU3RyYXRlZ3lcIiksbj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe3R8fCh0PXt9KSx0LnN0cmF0ZWd5fHwodC5zdHJhdGVneT1hKSx0LmNvbXBhcmF0b3J8fCh0LmNvbXBhcmF0b3I9ZnVuY3Rpb24odCxlKXtyZXR1cm4odHx8MCktKGV8fDApfSksZS5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLHQpfXJldHVybiB1KGUsdCksZX0oaSksbi5BcnJheVN0cmF0ZWd5PXIsbi5CaW5hcnlIZWFwU3RyYXRlZ3k9YSxuLkJIZWFwU3RyYXRlZ3k9byxlLmV4cG9ydHM9bn0se1wiLi9Qcmlvcml0eVF1ZXVlL0Fic3RyYWN0UHJpb3JpdHlRdWV1ZVwiOjIsXCIuL1ByaW9yaXR5UXVldWUvQXJyYXlTdHJhdGVneVwiOjMsXCIuL1ByaW9yaXR5UXVldWUvQkhlYXBTdHJhdGVneVwiOjQsXCIuL1ByaW9yaXR5UXVldWUvQmluYXJ5SGVhcFN0cmF0ZWd5XCI6NX1dLDI6W2Z1bmN0aW9uKHQsZSl7dmFyIGk7ZS5leHBvcnRzPWk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKG51bGw9PShudWxsIT10P3Quc3RyYXRlZ3k6dm9pZCAwKSl0aHJvd1wiTXVzdCBwYXNzIG9wdGlvbnMuc3RyYXRlZ3ksIGEgc3RyYXRlZ3lcIjtpZihudWxsPT0obnVsbCE9dD90LmNvbXBhcmF0b3I6dm9pZCAwKSl0aHJvd1wiTXVzdCBwYXNzIG9wdGlvbnMuY29tcGFyYXRvciwgYSBjb21wYXJhdG9yXCI7dGhpcy5wcml2PW5ldyB0LnN0cmF0ZWd5KHQpLHRoaXMubGVuZ3RoPTB9cmV0dXJuIHQucHJvdG90eXBlLnF1ZXVlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmxlbmd0aCsrLHZvaWQgdGhpcy5wcml2LnF1ZXVlKHQpfSx0LnByb3RvdHlwZS5kZXF1ZXVlPWZ1bmN0aW9uKCl7aWYoIXRoaXMubGVuZ3RoKXRocm93XCJFbXB0eSBxdWV1ZVwiO3JldHVybiB0aGlzLmxlbmd0aC0tLHRoaXMucHJpdi5kZXF1ZXVlKCl9LHQucHJvdG90eXBlLnBlZWs9ZnVuY3Rpb24oKXtpZighdGhpcy5sZW5ndGgpdGhyb3dcIkVtcHR5IHF1ZXVlXCI7cmV0dXJuIHRoaXMucHJpdi5wZWVrKCl9LHR9KCl9LHt9XSwzOltmdW5jdGlvbih0LGUpe3ZhciBpLHI7cj1mdW5jdGlvbih0LGUsaSl7dmFyIHIsbyxhO2ZvcihvPTAscj10Lmxlbmd0aDtyPm87KWE9bytyPj4+MSxpKHRbYV0sZSk+PTA/bz1hKzE6cj1hO3JldHVybiBvfSxlLmV4cG9ydHM9aT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dmFyIGU7dGhpcy5vcHRpb25zPXQsdGhpcy5jb21wYXJhdG9yPXRoaXMub3B0aW9ucy5jb21wYXJhdG9yLHRoaXMuZGF0YT0obnVsbCE9KGU9dGhpcy5vcHRpb25zLmluaXRpYWxWYWx1ZXMpP2Uuc2xpY2UoMCk6dm9pZCAwKXx8W10sdGhpcy5kYXRhLnNvcnQodGhpcy5jb21wYXJhdG9yKS5yZXZlcnNlKCl9cmV0dXJuIHQucHJvdG90eXBlLnF1ZXVlPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBlPXIodGhpcy5kYXRhLHQsdGhpcy5jb21wYXJhdG9yKSx2b2lkIHRoaXMuZGF0YS5zcGxpY2UoZSwwLHQpfSx0LnByb3RvdHlwZS5kZXF1ZXVlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YS5wb3AoKX0sdC5wcm90b3R5cGUucGVlaz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGFbdGhpcy5kYXRhLmxlbmd0aC0xXX0sdH0oKX0se31dLDQ6W2Z1bmN0aW9uKHQsZSl7dmFyIGk7ZS5leHBvcnRzPWk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3ZhciBlLGkscixvLGEsbixzLHUsaDtmb3IodGhpcy5jb21wYXJhdG9yPShudWxsIT10P3QuY29tcGFyYXRvcjp2b2lkIDApfHxmdW5jdGlvbih0LGUpe3JldHVybiB0LWV9LHRoaXMucGFnZVNpemU9KG51bGwhPXQ/dC5wYWdlU2l6ZTp2b2lkIDApfHw1MTIsdGhpcy5sZW5ndGg9MCxyPTA7MTw8cjx0aGlzLnBhZ2VTaXplOylyKz0xO2lmKDE8PHIhPT10aGlzLnBhZ2VTaXplKXRocm93XCJwYWdlU2l6ZSBtdXN0IGJlIGEgcG93ZXIgb2YgdHdvXCI7Zm9yKHRoaXMuX3NoaWZ0PXIsdGhpcy5fZW1wdHlNZW1vcnlQYWdlVGVtcGxhdGU9ZT1bXSxpPWE9MCx1PXRoaXMucGFnZVNpemU7dT49MD91PmE6YT51O2k9dT49MD8rK2E6LS1hKWUucHVzaChudWxsKTtpZih0aGlzLl9tZW1vcnk9W10sdGhpcy5fbWFzaz10aGlzLnBhZ2VTaXplLTEsdC5pbml0aWFsVmFsdWVzKWZvcihoPXQuaW5pdGlhbFZhbHVlcyxuPTAscz1oLmxlbmd0aDtzPm47bisrKW89aFtuXSx0aGlzLnF1ZXVlKG8pfXJldHVybiB0LnByb3RvdHlwZS5xdWV1ZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5sZW5ndGgrPTEsdGhpcy5fd3JpdGUodGhpcy5sZW5ndGgsdCksdm9pZCB0aGlzLl9idWJibGVVcCh0aGlzLmxlbmd0aCx0KX0sdC5wcm90b3R5cGUuZGVxdWV1ZT1mdW5jdGlvbigpe3ZhciB0LGU7cmV0dXJuIHQ9dGhpcy5fcmVhZCgxKSxlPXRoaXMuX3JlYWQodGhpcy5sZW5ndGgpLHRoaXMubGVuZ3RoLT0xLHRoaXMubGVuZ3RoPjAmJih0aGlzLl93cml0ZSgxLGUpLHRoaXMuX2J1YmJsZURvd24oMSxlKSksdH0sdC5wcm90b3R5cGUucGVlaz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZWFkKDEpfSx0LnByb3RvdHlwZS5fd3JpdGU9ZnVuY3Rpb24odCxlKXt2YXIgaTtmb3IoaT10Pj50aGlzLl9zaGlmdDtpPj10aGlzLl9tZW1vcnkubGVuZ3RoOyl0aGlzLl9tZW1vcnkucHVzaCh0aGlzLl9lbXB0eU1lbW9yeVBhZ2VUZW1wbGF0ZS5zbGljZSgwKSk7cmV0dXJuIHRoaXMuX21lbW9yeVtpXVt0JnRoaXMuX21hc2tdPWV9LHQucHJvdG90eXBlLl9yZWFkPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9tZW1vcnlbdD4+dGhpcy5fc2hpZnRdW3QmdGhpcy5fbWFza119LHQucHJvdG90eXBlLl9idWJibGVVcD1mdW5jdGlvbih0LGUpe3ZhciBpLHIsbyxhO2ZvcihpPXRoaXMuY29tcGFyYXRvcjt0PjEmJihyPXQmdGhpcy5fbWFzayx0PHRoaXMucGFnZVNpemV8fHI+Mz9vPXQmfnRoaXMuX21hc2t8cj4+MToyPnI/KG89dC10aGlzLnBhZ2VTaXplPj50aGlzLl9zaGlmdCxvKz1vJn4odGhpcy5fbWFzaz4+MSksb3w9dGhpcy5wYWdlU2l6ZT4+MSk6bz10LTIsYT10aGlzLl9yZWFkKG8pLCEoaShhLGUpPDApKTspdGhpcy5fd3JpdGUobyxlKSx0aGlzLl93cml0ZSh0LGEpLHQ9bztyZXR1cm4gdm9pZCAwfSx0LnByb3RvdHlwZS5fYnViYmxlRG93bj1mdW5jdGlvbih0LGUpe3ZhciBpLHIsbyxhLG47Zm9yKG49dGhpcy5jb21wYXJhdG9yO3Q8dGhpcy5sZW5ndGg7KWlmKHQ+dGhpcy5fbWFzayYmISh0JnRoaXMuX21hc2stMSk/aT1yPXQrMjp0JnRoaXMucGFnZVNpemU+PjE/KGk9KHQmfnRoaXMuX21hc2spPj4xLGl8PXQmdGhpcy5fbWFzaz4+MSxpPWkrMTw8dGhpcy5fc2hpZnQscj1pKzEpOihpPXQrKHQmdGhpcy5fbWFzaykscj1pKzEpLGkhPT1yJiZyPD10aGlzLmxlbmd0aClpZihvPXRoaXMuX3JlYWQoaSksYT10aGlzLl9yZWFkKHIpLG4obyxlKTwwJiZuKG8sYSk8PTApdGhpcy5fd3JpdGUoaSxlKSx0aGlzLl93cml0ZSh0LG8pLHQ9aTtlbHNle2lmKCEobihhLGUpPDApKWJyZWFrO3RoaXMuX3dyaXRlKHIsZSksdGhpcy5fd3JpdGUodCxhKSx0PXJ9ZWxzZXtpZighKGk8PXRoaXMubGVuZ3RoKSlicmVhaztpZihvPXRoaXMuX3JlYWQoaSksIShuKG8sZSk8MCkpYnJlYWs7dGhpcy5fd3JpdGUoaSxlKSx0aGlzLl93cml0ZSh0LG8pLHQ9aX1yZXR1cm4gdm9pZCAwfSx0fSgpfSx7fV0sNTpbZnVuY3Rpb24odCxlKXt2YXIgaTtlLmV4cG9ydHM9aT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dmFyIGU7dGhpcy5jb21wYXJhdG9yPShudWxsIT10P3QuY29tcGFyYXRvcjp2b2lkIDApfHxmdW5jdGlvbih0LGUpe3JldHVybiB0LWV9LHRoaXMubGVuZ3RoPTAsdGhpcy5kYXRhPShudWxsIT0oZT10LmluaXRpYWxWYWx1ZXMpP2Uuc2xpY2UoMCk6dm9pZCAwKXx8W10sdGhpcy5faGVhcGlmeSgpfXJldHVybiB0LnByb3RvdHlwZS5faGVhcGlmeT1mdW5jdGlvbigpe3ZhciB0LGUsaTtpZih0aGlzLmRhdGEubGVuZ3RoPjApZm9yKHQ9ZT0xLGk9dGhpcy5kYXRhLmxlbmd0aDtpPj0xP2k+ZTplPmk7dD1pPj0xPysrZTotLWUpdGhpcy5fYnViYmxlVXAodCk7cmV0dXJuIHZvaWQgMH0sdC5wcm90b3R5cGUucXVldWU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGF0YS5wdXNoKHQpLHZvaWQgdGhpcy5fYnViYmxlVXAodGhpcy5kYXRhLmxlbmd0aC0xKX0sdC5wcm90b3R5cGUuZGVxdWV1ZT1mdW5jdGlvbigpe3ZhciB0LGU7cmV0dXJuIGU9dGhpcy5kYXRhWzBdLHQ9dGhpcy5kYXRhLnBvcCgpLHRoaXMuZGF0YS5sZW5ndGg+MCYmKHRoaXMuZGF0YVswXT10LHRoaXMuX2J1YmJsZURvd24oMCkpLGV9LHQucHJvdG90eXBlLnBlZWs9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhWzBdfSx0LnByb3RvdHlwZS5fYnViYmxlVXA9ZnVuY3Rpb24odCl7Zm9yKHZhciBlLGk7dD4wJiYoZT10LTE+Pj4xLHRoaXMuY29tcGFyYXRvcih0aGlzLmRhdGFbdF0sdGhpcy5kYXRhW2VdKTwwKTspaT10aGlzLmRhdGFbZV0sdGhpcy5kYXRhW2VdPXRoaXMuZGF0YVt0XSx0aGlzLmRhdGFbdF09aSx0PWU7cmV0dXJuIHZvaWQgMH0sdC5wcm90b3R5cGUuX2J1YmJsZURvd249ZnVuY3Rpb24odCl7dmFyIGUsaSxyLG8sYTtmb3IoZT10aGlzLmRhdGEubGVuZ3RoLTE7Oyl7aWYoaT0odDw8MSkrMSxvPWkrMSxyPXQsZT49aSYmdGhpcy5jb21wYXJhdG9yKHRoaXMuZGF0YVtpXSx0aGlzLmRhdGFbcl0pPDAmJihyPWkpLGU+PW8mJnRoaXMuY29tcGFyYXRvcih0aGlzLmRhdGFbb10sdGhpcy5kYXRhW3JdKTwwJiYocj1vKSxyPT09dClicmVhazthPXRoaXMuZGF0YVtyXSx0aGlzLmRhdGFbcl09dGhpcy5kYXRhW3RdLHRoaXMuZGF0YVt0XT1hLHQ9cn1yZXR1cm4gdm9pZCAwfSx0fSgpfSx7fV19LHt9LFsxXSkoMSl9KTtcXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxcbn0se31dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbnZhciBQYXRoZmluZGVyID0gcmVxdWlyZShcXCcuL3BhdGhmaW5kZXJcXCcpO1xcclxcbnZhciBnZW8gPSByZXF1aXJlKFxcJy4vZ2VvbWV0cnlcXCcpO1xcclxcblxcclxcbi8qKlxcclxcbiAqIFBhdGhmaW5kaW5nIHdlYiB3b3JrZXIgaW1wbGVtZW50YXRpb24uXFxyXFxuICogQGlnbm9yZVxcclxcbiAqL1xcclxcbnZhciBQb2ludCA9IGdlby5Qb2ludDtcXHJcXG52YXIgUG9seSA9IGdlby5Qb2x5O1xcclxcblxcclxcbi8qKlxcclxcbiAqIE9iamVjdCB3aXRoIHV0aWxpdHkgbWV0aG9kcyBmb3IgY29udmVydGluZyBvYmplY3RzIGZyb20gc2VyaWFsaXplZFxcclxcbiAqIG1lc3NhZ2UgZm9ybSBpbnRvIHRoZSByZXF1aXJlZCBvYmplY3RzLlxcclxcbiAqIEBwcml2YXRlXFxyXFxuICovXFxyXFxudmFyIENvbnZlcnQgPSB7fTtcXHJcXG5cXHJcXG4vKipcXHJcXG4gKiBUaGUgZm9ybWF0IG9mIGEgUG9pbnQgYXMgc2VyaWFsaXplZCBieSB0aGUgV2ViIFdvcmtlciBtZXNzYWdlLVxcclxcbiAqIHBhc3NpbmcgaW50ZXJmYWNlLlxcclxcbiAqIEBwcml2YXRlXFxyXFxuICogQHR5cGVkZWYge29iamVjdH0gUG9pbnRPYmpcXHJcXG4gKiBAcHJvcGVydHkge251bWJlcn0geFxcclxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5XFxyXFxuICovXFxyXFxuXFxyXFxuLyoqXFxyXFxuICogQ29udmVydCBzZXJpYWxpemVkIFBvaW50IG9iamVjdCBiYWNrIHRvIFBvaW50LlxcclxcbiAqIEBwcml2YXRlXFxyXFxuICogQHBhcmFtIHtQb2ludE9ian0gb2JqIC0gVGhlIHNlcmlhbGl6ZWQgUG9pbnQgb2JqZWN0LlxcclxcbiAqL1xcclxcbkNvbnZlcnQudG9Qb2ludCA9IGZ1bmN0aW9uKG9iaikge1xcclxcbiAgcmV0dXJuIG5ldyBQb2ludChvYmoueCwgb2JqLnkpO1xcclxcbn07XFxyXFxuXFxyXFxuLyoqXFxyXFxuICogVGhlIGZvcm1hdCBvZiBhIFBvbHkgYXMgc2VyaWFsaXplZCBieSB0aGUgV2ViIFdvcmtlciBtZXNzYWdlLVxcclxcbiAqIHBhc3NpbmcgaW50ZXJmYWNlLlxcclxcbiAqIEBwcml2YXRlXFxyXFxuICogQHR5cGVkZWYge29iamVjdH0gUG9seU9ialxcclxcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPFBvaW50T2JqPn0gcG9pbnRzIC0gVGhlIGFycmF5IG9mIHNlcmlhbGl6ZWRcXHJcXG4gKiAgIFBvaW50cy5cXHJcXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGhvbGUgLSBXaGV0aGVyIG9yIG5vdCB0aGUgcG9seWdvbiBpcyBhIGhvbGUuXFxyXFxuICogQHByb3BlcnR5IHtpbnRlZ2VyfSBudW1wb2ludHMgLSBUaGUgbnVtYmVyIG9mIHBvaW50cyBpbiB0aGUgUG9seS5cXHJcXG4gKi9cXHJcXG5cXHJcXG4gLyoqXFxyXFxuICAqIENvbnZlcnQgc2VyaWFsaXplZCBQb2x5IG9iamVjdCBiYWNrIHRvIFBvbHkuXFxyXFxuICAqIEBwcml2YXRlXFxyXFxuICAqIEBwYXJhbSB7UG9seU9ian0gb2JqIC0gVGhlIHNlcmlhbGl6ZWQgUG9seSBvYmplY3QuXFxyXFxuICAqL1xcclxcbkNvbnZlcnQudG9Qb2x5ID0gZnVuY3Rpb24ob2JqKSB7XFxyXFxuICB2YXIgcG9seSA9IG5ldyBQb2x5KCk7XFxyXFxuICBwb2x5LnBvaW50cyA9IG9iai5wb2ludHMubWFwKENvbnZlcnQudG9Qb2ludCk7XFxyXFxuICBwb2x5LmhvbGUgPSBvYmouaG9sZTtcXHJcXG4gIHBvbHkudXBkYXRlKCk7XFxyXFxuICByZXR1cm4gcG9seTtcXHJcXG59O1xcclxcblxcclxcbnZhciBMb2dnZXIgPSB7fTtcXHJcXG5cXHJcXG4vKipcXHJcXG4gKiBTZW5kcyBtZXNzYWdlIHRvIHBhcmVudCB0byBiZSBsb2dnZWQgdG8gY29uc29sZS4gVGFrZXMgc2FtZVxcclxcbiAqIGFyZ3VtZW50cyBhcyBCcmFnaSBsb2dnZXIuXFxyXFxuICogQHByaXZhdGVcXHJcXG4gKiBAcGFyYW0ge3N0cmluZ30gZ3JvdXAgLSBUaGUgZ3JvdXAgdG8gYXNzb2NpYXRlIHRoZSBtZXNzYWdlIHdpdGguXFxyXFxuICogQHBhcmFtIHsuLi4qfSAtIGFyYml0cmFyeSBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIGJhY2sgdG8gdGhlIHBhcmVudFxcclxcbiAqICAgbG9nZ2luZyBmdW5jdGlvbi5cXHJcXG4gKi9cXHJcXG5Mb2dnZXIubG9nID0gZnVuY3Rpb24oZ3JvdXApIHtcXHJcXG4gIHZhciBtZXNzYWdlID0gW1wibG9nXCJdO1xcclxcbiAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobWVzc2FnZSwgYXJndW1lbnRzKTtcXHJcXG4gIHBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xcclxcbn07XFxyXFxuXFxyXFxudmFyIFV0aWwgPSB7fTtcXHJcXG5cXHJcXG5VdGlsLnNwbGljZSA9IGZ1bmN0aW9uKGFyeSwgaW5kaWNlcykge1xcclxcbiAgaW5kaWNlcyA9IGluZGljZXMuc29ydChVdGlsLl9udW1iZXJDb21wYXJlKS5yZXZlcnNlKCk7XFxyXFxuICB2YXIgcmVtb3ZlZCA9IFtdO1xcclxcbiAgaW5kaWNlcy5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcXHJcXG4gICAgcmVtb3ZlZC5wdXNoKGFyeS5zcGxpY2UoaSwgMSlbMF0pO1xcclxcbiAgfSk7XFxyXFxuICByZXR1cm4gcmVtb3ZlZDtcXHJcXG59O1xcclxcblxcclxcblV0aWwuX251bWJlckNvbXBhcmUgPSBmdW5jdGlvbihhLCBiKSB7XFxyXFxuICBpZiAoYSA8IGIpIHtcXHJcXG4gICAgcmV0dXJuIC0xO1xcclxcbiAgfSBlbHNlIGlmIChhID4gYikge1xcclxcbiAgICByZXR1cm4gMTtcXHJcXG4gIH0gZWxzZSB7XFxyXFxuICAgIHJldHVybiAwO1xcclxcbiAgfVxcclxcbn07XFxyXFxuXFxyXFxuLyoqXFxyXFxuICogU2V0IHVwIHZhcmlvdXMgYWN0aW9ucyB0byB0YWtlIG9uIGNvbW11bmljYXRpb24uXFxyXFxuICogQHByaXZhdGVcXHJcXG4gKiBAcGFyYW0ge0FycmF5fSBlIC0gQW4gYXJyYXkgd2l0aCB0aGUgZmlyc3QgZWxlbWVudCBiZWluZyBhIHN0cmluZ1xcclxcbiAqICAgaWRlbnRpZmllciBmb3IgdGhlIG1lc3NhZ2UgdHlwZSwgYW5kIHN1YnNlcXVlbnQgZWxlbWVudHMgYmVpbmdcXHJcXG4gKiAgIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gdGhlIHJlbGV2YW50IGZ1bmN0aW9uLiBNZXNzYWdlIHR5cGVzOlxcclxcbiAqICAgKiBwb2x5cyAtIHNldHMgdGhlIHBvbHlnb25zIHRvIHVzZSBmb3IgbmF2aWdhdGlvblxcclxcbiAqICAgICAgIC0ge0FycmF5LjxQb2x5Pn0gYXJyYXkgb2YgcG9seWdvbnMgZGVmaW5pbmcgdGhlIG1hcFxcclxcbiAqICAgKiBhU3RhciAtIGNvbXB1dGVzIEEqIG9uIGFib3ZlLXNldCBpdGVtc1xcclxcbiAqICAgICAgIC0ge1BvaW50fSBzdGFydCBsb2NhdGlvbiB0byB1c2UgZm9yIHNlYXJjaFxcclxcbiAqICAgICAgIC0ge1BvaW50fSBlbmQgbG9jYXRpb24gdG8gdXNlIGZvciBzZWFyY2hcXHJcXG4gKiAgICogaXNJbml0aWFsaXplZCAtIGNoZWNrIGlmIHRoZSB3b3JrZXIgaXMgaW5pdGlhbGl6ZWQuXFxyXFxuICovXFxyXFxub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xcclxcbiAgdmFyIGRhdGEgPSBlLmRhdGE7XFxyXFxuICB2YXIgbmFtZSA9IGRhdGFbMF07XFxyXFxuICBMb2dnZXIubG9nKFwid29ya2VyOmRlYnVnXCIsIFwiTWVzc2FnZSByZWNlaXZlZCBieSB3b3JrZXI6XCIsIGRhdGEpO1xcclxcbiAgaWYgKG5hbWUgPT0gXCJwb2x5c1wiKSB7XFxyXFxuICAgIC8vIFBvbHlnb25zIGRlZmluaW5nIG1hcC5cXHJcXG4gICAgc2VsZi5wb2x5cyA9IGRhdGFbMV0ubWFwKENvbnZlcnQudG9Qb2x5KTtcXHJcXG5cXHJcXG4gICAgLy8gSW5pdGlhbGl6ZSBwYXRoZmluZGVyIG1vZHVsZS5cXHJcXG4gICAgc2VsZi5wYXRoZmluZGVyID0gbmV3IFBhdGhmaW5kZXIoc2VsZi5wb2x5cyk7XFxyXFxuICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJwb2x5VXBkYXRlXCIpIHtcXHJcXG4gICAgLy8gVXBkYXRlIHRvIG5hdm1lc2guXFxyXFxuICAgIHZhciBuZXdQb2x5cyA9IGRhdGFbMV0ubWFwKENvbnZlcnQudG9Qb2x5KTtcXHJcXG4gICAgdmFyIHJlbW92ZWRQb2x5cyA9IGRhdGFbMl07XFxyXFxuXFxyXFxuICAgIFV0aWwuc3BsaWNlKHNlbGYucG9seXMsIHJlbW92ZWRQb2x5cyk7XFxyXFxuICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHNlbGYucG9seXMsIG5ld1BvbHlzKTtcXHJcXG5cXHJcXG4gICAgLy8gUmUtaW5pdGlhbGl6ZSBwYXRoZmluZGVyLlxcclxcbiAgICBzZWxmLnBhdGhmaW5kZXIgPSBuZXcgUGF0aGZpbmRlcihzZWxmLnBvbHlzKTtcXHJcXG4gIH0gZWxzZSBpZiAobmFtZSA9PSBcImFTdGFyXCIpIHtcXHJcXG4gICAgdmFyIHNvdXJjZSA9IENvbnZlcnQudG9Qb2ludChkYXRhWzFdKTtcXHJcXG4gICAgdmFyIHRhcmdldCA9IENvbnZlcnQudG9Qb2ludChkYXRhWzJdKTtcXHJcXG5cXHJcXG4gICAgdmFyIHBhdGggPSBzZWxmLnBhdGhmaW5kZXIuYVN0YXIoc291cmNlLCB0YXJnZXQpO1xcclxcbiAgICBwb3N0TWVzc2FnZShbXCJyZXN1bHRcIiwgcGF0aF0pO1xcclxcbiAgfSBlbHNlIGlmIChuYW1lID09IFwiaXNJbml0aWFsaXplZFwiKSB7XFxyXFxuICAgIHBvc3RNZXNzYWdlKFtcImluaXRpYWxpemVkXCJdKTtcXHJcXG4gIH1cXHJcXG59O1xcclxcblxcclxcbkxvZ2dlci5sb2coXCJ3b3JrZXJcIiwgXCJXb3JrZXIgbG9hZGVkLlwiKTtcXHJcXG4vLyBTZW50IGNvbmZpcm1hdGlvbiB0aGF0IHdvcmtlciBpcyBpbml0aWFsaXplZC5cXHJcXG5wb3N0TWVzc2FnZShbXCJpbml0aWFsaXplZFwiXSk7XFxyXFxuXFxufSx7XCIuL2dlb21ldHJ5XCI6MyxcIi4vcGF0aGZpbmRlclwiOjR9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKipcXHJcXG4gKiBBIHBvaW50IGNhbiByZXByZXNlbnQgYSB2ZXJ0ZXggaW4gYSAyZCBlbnZpcm9ubWVudCBvciBhIHZlY3Rvci5cXHJcXG4gKiBAY29uc3RydWN0b3JcXHJcXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBgeGAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXFxyXFxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgYHlgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxcclxcbiAqL1xcclxcblBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xcclxcbiAgdGhpcy54ID0geDtcXHJcXG4gIHRoaXMueSA9IHk7XFxyXFxufTtcXHJcXG5leHBvcnRzLlBvaW50ID0gUG9pbnQ7XFxyXFxuXFxyXFxuLyoqXFxyXFxuICogQ29udmVydCBhIHBvaW50LWxpa2Ugb2JqZWN0IGludG8gYSBwb2ludC5cXHJcXG4gKiBAcGFyYW0ge1BvaW50TGlrZX0gcCAtIFRoZSBwb2ludC1saWtlIG9iamVjdCB0byBjb252ZXJ0LlxcclxcbiAqIEByZXR1cm4ge1BvaW50fSAtIFRoZSBuZXcgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBwb2ludC1saWtlXFxyXFxuICogICBvYmplY3QuXFxyXFxuICovXFxyXFxuUG9pbnQuZnJvbVBvaW50TGlrZSA9IGZ1bmN0aW9uKHApIHtcXHJcXG4gIHJldHVybiBuZXcgUG9pbnQocC54LCBwLnkpO1xcclxcbn07XFxyXFxuXFxyXFxuLyoqXFxyXFxuICogU3RyaW5nIG1ldGhvZCBmb3IgcG9pbnQtbGlrZSBvYmplY3RzLlxcclxcbiAqIEBwYXJhbSB7UG9pbnRMaWtlfSBwIC0gVGhlIHBvaW50LWxpa2Ugb2JqZWN0IHRvIGNvbnZlcnQuXFxyXFxuICogQHJldHVybiB7UG9pbnR9IC0gVGhlIG5ldyBwb2ludCByZXByZXNlbnRpbmcgdGhlIHBvaW50LWxpa2VcXHJcXG4gKiAgIG9iamVjdC5cXHJcXG4gKi9cXHJcXG5Qb2ludC50b1N0cmluZyA9IGZ1bmN0aW9uKHApIHtcXHJcXG4gIHJldHVybiBcInhcIiArIHAueCArIFwieVwiICsgcC55O1xcclxcbn07XFxyXFxuXFxyXFxuLyoqXFxyXFxuICogVGFrZXMgYSBwb2ludCBvciBzY2FsYXIgYW5kIGFkZHMgc2xvdHdpc2UgaW4gdGhlIGNhc2Ugb2YgYW5vdGhlclxcclxcbiAqIHBvaW50LCBvciB0byBlYWNoIHBhcmFtZXRlciBpbiB0aGUgY2FzZSBvZiBhIHNjYWxhci5cXHJcXG4gKiBAcGFyYW0geyhQb2ludHxudW1iZXIpfSAtIFRoZSBQb2ludCwgb3Igc2NhbGFyLCB0byBhZGQgdG8gdGhpc1xcclxcbiAqICAgcG9pbnQuXFxyXFxuICovXFxyXFxuUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHApIHtcXHJcXG4gIGlmICh0eXBlb2YgcCA9PSBcIm51bWJlclwiKVxcclxcbiAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArIHAsIHRoaXMueSArIHApO1xcclxcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyBwLngsIHRoaXMueSArIHAueSk7XFxyXFxufTtcXHJcXG5cXHJcXG4vKipcXHJcXG4gKiBUYWtlcyBhIHBvaW50IG9yIHNjYWxhciBhbmQgc3VidHJhY3RzIHNsb3R3aXNlIGluIHRoZSBjYXNlIG9mXFxyXFxuICogYW5vdGhlciBwb2ludCBvciBmcm9tIGVhY2ggcGFyYW1ldGVyIGluIHRoZSBjYXNlIG9mIGEgc2NhbGFyLlxcclxcbiAqIEBwYXJhbSB7KFBvaW50fG51bWJlcil9IC0gVGhlIFBvaW50LCBvciBzY2FsYXIsIHRvIHN1YnRyYWN0IGZyb21cXHJcXG4gKiAgIHRoaXMgcG9pbnQuXFxyXFxuICovXFxyXFxuUG9pbnQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKHApIHtcXHJcXG4gIGlmICh0eXBlb2YgcCA9PSBcIm51bWJlclwiKVxcclxcbiAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAtIHAsIHRoaXMueSAtIHApO1xcclxcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLSBwLngsIHRoaXMueSAtIHAueSk7XFxyXFxufTtcXHJcXG5cXHJcXG4vKipcXHJcXG4gKiBUYWtlcyBhIHNjYWxhciB2YWx1ZSBhbmQgbXVsdGlwbGllcyBlYWNoIHBhcmFtZXRlciBvZiB0aGUgcG9pbnRcXHJcXG4gKiBieSB0aGUgc2NhbGFyLlxcclxcbiAqIEBwYXJhbSAge251bWJlcn0gZiAtIFRoZSBudW1iZXIgdG8gbXVsdGlwbGUgdGhlIHBhcmFtZXRlcnMgYnkuXFxyXFxuICogQHJldHVybiB7UG9pbnR9IC0gQSBuZXcgcG9pbnQgd2l0aCB0aGUgY2FsY3VsYXRlZCBjb29yZGluYXRlcy5cXHJcXG4gKi9cXHJcXG5Qb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24oZikge1xcclxcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKiBmLCB0aGlzLnkgKiBmKTtcXHJcXG59O1xcclxcblxcclxcbi8qKlxcclxcbiAqIFRha2VzIGEgc2NhbGFyIHZhbHVlIGFuZCBkaXZpZGVzIGVhY2ggcGFyYW1ldGVyIG9mIHRoZSBwb2ludFxcclxcbiAqIGJ5IHRoZSBzY2FsYXIuXFxyXFxuICogQHBhcmFtICB7bnVtYmVyfSBmIC0gVGhlIG51bWJlciB0byBkaXZpZGUgdGhlIHBhcmFtZXRlcnMgYnkuXFxyXFxuICogQHJldHVybiB7UG9pbnR9IC0gQSBuZXcgcG9pbnQgd2l0aCB0aGUgY2FsY3VsYXRlZCBjb29yZGluYXRlcy5cXHJcXG4gKi9cXHJcXG5Qb2ludC5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24oZikge1xcclxcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLyBmLCB0aGlzLnkgLyBmKTtcXHJcXG59O1xcclxcblxcclxcbi8qKlxcclxcbiAqIFRha2VzIGFub3RoZXIgcG9pbnQgYW5kIHJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGVcXHJcXG4gKiBwb2ludHMgYXJlIGVxdWFsLiBUd28gcG9pbnRzIGFyZSBlcXVhbCBpZiB0aGVpciBwYXJhbWV0ZXJzIGFyZVxcclxcbiAqIGVxdWFsLlxcclxcbiAqIEBwYXJhbSAge1BvaW50fSBwIC0gVGhlIHBvaW50IHRvIGNoZWNrIGVxdWFsaXR5IGFnYWluc3QuXFxyXFxuICogQHJldHVybiB7Ym9vbGVhbn0gLSBXaGV0aGVyIG9yIG5vdCB0aGUgdHdvIHBvaW50cyBhcmUgZXF1YWwuXFxyXFxuICovXFxyXFxuUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24ocCkge1xcclxcbiAgcmV0dXJuICh0aGlzLnggPT0gcC54ICYmIHRoaXMueSA9PSBwLnkpO1xcclxcbn07XFxyXFxuXFxyXFxuLyoqXFxyXFxuICogVGFrZXMgYW5vdGhlciBwb2ludCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZVxcclxcbiAqIHBvaW50cyBhcmUgbm90IGVxdWFsLiBUd28gcG9pbnRzIGFyZSBjb25zaWRlcmVkIG5vdCBlcXVhbCBpZiB0aGVpclxcclxcbiAqIHBhcmFtZXRlcnMgYXJlIG5vdCBlcXVhbC5cXHJcXG4gKiBAcGFyYW0gIHtQb2ludH0gcCAtIFRoZSBwb2ludCB0byBjaGVjayBlcXVhbGl0eSBhZ2FpbnN0LlxcclxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IC0gV2hldGhlciBvciBub3QgdGhlIHR3byBwb2ludHMgYXJlIG5vdCBlcXVhbC5cXHJcXG4gKi9cXHJcXG5Qb2ludC5wcm90b3R5cGUubmVxID0gZnVuY3Rpb24ocCkge1xcclxcbiAgcmV0dXJuICh0aGlzLnggIT0gcC54IHx8IHRoaXMueSAhPSBwLnkpO1xcclxcbn07XFxyXFxuXFxyXFxuLy8gR2l2ZW4gYW5vdGhlciBwb2ludCwgcmV0dXJucyB0aGUgZG90IHByb2R1Y3QuXFxyXFxuUG9pbnQucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uKHApIHtcXHJcXG4gIHJldHVybiAodGhpcy54ICogcC54ICsgdGhpcy55ICogcC55KTtcXHJcXG59O1xcclxcblxcclxcbi8vIEdpdmVuIGFub3RoZXIgcG9pbnQsIHJldHVybnMgdGhlIFxcJ2Nyb3NzIHByb2R1Y3RcXCcsIG9yIGF0IGxlYXN0IHRoZSAyZFxcclxcbi8vIGVxdWl2YWxlbnQuXFxyXFxuUG9pbnQucHJvdG90eXBlLmNyb3NzID0gZnVuY3Rpb24ocCkge1xcclxcbiAgcmV0dXJuICh0aGlzLnggKiBwLnkgLSB0aGlzLnkgKiBwLngpO1xcclxcbn07XFxyXFxuXFxyXFxuLy8gR2l2ZW4gYW5vdGhlciBwb2ludCwgcmV0dXJucyB0aGUgZGlzdGFuY2UgdG8gdGhhdCBwb2ludC5cXHJcXG5Qb2ludC5wcm90b3R5cGUuZGlzdCA9IGZ1bmN0aW9uKHApIHtcXHJcXG4gIHZhciBkaWZmID0gdGhpcy5zdWIocCk7XFxyXFxuICByZXR1cm4gTWF0aC5zcXJ0KGRpZmYuZG90KGRpZmYpKTtcXHJcXG59O1xcclxcblxcclxcbi8vIEdpdmVuIGFub3RoZXIgcG9pbnQsIHJldHVybnMgdGhlIHNxdWFyZWQgZGlzdGFuY2UgdG8gdGhhdCBwb2ludC5cXHJcXG5Qb2ludC5wcm90b3R5cGUuZGlzdDIgPSBmdW5jdGlvbihwKSB7XFxyXFxuICB2YXIgZGlmZiA9IHRoaXMuc3ViKHApO1xcclxcbiAgcmV0dXJuIGRpZmYuZG90KGRpZmYpO1xcclxcbn07XFxyXFxuXFxyXFxuLyoqXFxyXFxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludCBpcyAoMCwgMCkuXFxyXFxuICogQHJldHVybiB7Ym9vbGVhbn0gLSBXaGV0aGVyIG9yIG5vdCB0aGUgcG9pbnQgaXMgKDAsIDApLlxcclxcbiAqL1xcclxcblBvaW50LnByb3RvdHlwZS56ZXJvID0gZnVuY3Rpb24oKSB7XFxyXFxuICByZXR1cm4gdGhpcy54ID09IDAgJiYgdGhpcy55ID09IDA7XFxyXFxufTtcXHJcXG5cXHJcXG5Qb2ludC5wcm90b3R5cGUubGVuID0gZnVuY3Rpb24oKSB7XFxyXFxuICByZXR1cm4gdGhpcy5kaXN0KG5ldyBQb2ludCgwLCAwKSk7XFxyXFxufTtcXHJcXG5cXHJcXG5Qb2ludC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24oKSB7XFxyXFxuICB2YXIgbiA9IHRoaXMuZGlzdChuZXcgUG9pbnQoMCwgMCkpO1xcclxcbiAgaWYgKG4gPiAwKSByZXR1cm4gdGhpcy5kaXYobik7XFxyXFxuICByZXR1cm4gbmV3IFBvaW50KDAsIDApO1xcclxcbn07XFxyXFxuXFxyXFxuUG9pbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XFxyXFxuICByZXR1cm4gXFwneFxcJyArIHRoaXMueCArIFxcJ3lcXCcgKyB0aGlzLnk7XFxyXFxufTtcXHJcXG5cXHJcXG4vKipcXHJcXG4gKiBSZXR1cm4gYSBjb3B5IG9mIHRoZSBwb2ludC5cXHJcXG4gKiBAcmV0dXJuIHtQb2ludH0gLSBUaGUgbmV3IHBvaW50LlxcclxcbiAqL1xcclxcblBvaW50LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xcclxcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XFxyXFxufTtcXHJcXG5cXHJcXG4vKipcXHJcXG4gKiBFZGdlcyBhcmUgdXNlZCB0byByZXByZXNlbnQgdGhlIGJvcmRlciBiZXR3ZWVuIHR3byBhZGphY2VudFxcclxcbiAqIHBvbHlnb25zLlxcclxcbiAqIEBjb25zdHJ1Y3RvclxcclxcbiAqIEBwYXJhbSB7UG9pbnR9IHAxIC0gVGhlIGZpcnN0IHBvaW50IG9mIHRoZSBlZGdlLlxcclxcbiAqIEBwYXJhbSB7UG9pbnR9IHAyIC0gVGhlIHNlY29uZCBwb2ludCBvZiB0aGUgZWRnZS5cXHJcXG4gKi9cXHJcXG5FZGdlID0gZnVuY3Rpb24ocDEsIHAyKSB7XFxyXFxuICB0aGlzLnAxID0gcDE7XFxyXFxuICB0aGlzLnAyID0gcDI7XFxyXFxuICB0aGlzLmNlbnRlciA9IHAxLmFkZChwMi5zdWIocDEpLmRpdigyKSk7XFxyXFxuICB0aGlzLnBvaW50cyA9IFt0aGlzLnAxLCB0aGlzLmNlbnRlciwgdGhpcy5wMl07XFxyXFxufTtcXHJcXG5leHBvcnRzLkVkZ2UgPSBFZGdlO1xcclxcblxcclxcbkVkZ2UucHJvdG90eXBlLl9DQ1cgPSBmdW5jdGlvbihwMSwgcDIsIHAzKSB7XFxyXFxuICBhID0gcDEueDsgYiA9IHAxLnk7XFxyXFxuICBjID0gcDIueDsgZCA9IHAyLnk7XFxyXFxuICBlID0gcDMueDsgZiA9IHAzLnk7XFxyXFxuICByZXR1cm4gKGYgLSBiKSAqIChjIC0gYSkgPiAoZCAtIGIpICogKGUgLSBhKTtcXHJcXG59O1xcclxcblxcclxcbi8qKlxcclxcbiAqIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY3MjU3MTVcXHJcXG4gKiBDaGVja3Mgd2hldGhlciB0aGlzIGVkZ2UgaW50ZXJzZWN0cyB0aGUgcHJvdmlkZWQgZWRnZS5cXHJcXG4gKiBAcGFyYW0ge0VkZ2V9IGVkZ2UgLSBUaGUgZWRnZSB0byBjaGVjayBpbnRlcnNlY3Rpb24gZm9yLlxcclxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IC0gV2hldGhlciBvciBub3QgdGhlIGVkZ2VzIGludGVyc2VjdC5cXHJcXG4gKi9cXHJcXG5FZGdlLnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24oZWRnZSkge1xcclxcbiAgdmFyIHExID0gZWRnZS5wMSwgcTIgPSBlZGdlLnAyO1xcclxcbiAgaWYgKHExLmVxKHRoaXMucDEpIHx8IHExLmVxKHRoaXMucDIpIHx8IHEyLmVxKHRoaXMucDEpIHx8IHEyLmVxKHRoaXMucDIpKSByZXR1cm4gZmFsc2U7XFxyXFxuICByZXR1cm4gKHRoaXMuX0NDVyh0aGlzLnAxLCBxMSwgcTIpICE9IHRoaXMuX0NDVyh0aGlzLnAyLCBxMSwgcTIpKSAmJiAodGhpcy5fQ0NXKHRoaXMucDEsIHRoaXMucDIsIHExKSAhPSB0aGlzLl9DQ1codGhpcy5wMSwgdGhpcy5wMiwgcTIpKTtcXHJcXG59O1xcclxcblxcclxcbi8qKlxcclxcbiAqIFBvbHlnb24gY2xhc3MuXFxyXFxuICogQ2FuIGJlIGluaXRpYWxpemVkIHdpdGggYW4gYXJyYXkgb2YgcG9pbnRzLlxcclxcbiAqIEBjb25zdHJ1Y3RvclxcclxcbiAqIEBwYXJhbSB7QXJyYXkuPFBvaW50Pn0gW3BvaW50c10gLSBUaGUgcG9pbnRzIHRvIHVzZSB0byBpbml0aWFsaXplXFxyXFxuICogICB0aGUgcG9seS5cXHJcXG4gKi9cXHJcXG5Qb2x5ID0gZnVuY3Rpb24ocG9pbnRzKSB7XFxyXFxuICBpZiAodHlwZW9mIHBvaW50cyA9PSBcXCd1bmRlZmluZWRcXCcpIHBvaW50cyA9IGZhbHNlO1xcclxcbiAgdGhpcy5ob2xlID0gZmFsc2U7XFxyXFxuICB0aGlzLnBvaW50cyA9IG51bGw7XFxyXFxuICB0aGlzLm51bXBvaW50cyA9IDA7XFxyXFxuICBpZiAocG9pbnRzKSB7XFxyXFxuICAgIHRoaXMubnVtcG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcXHJcXG4gICAgdGhpcy5wb2ludHMgPSBwb2ludHMuc2xpY2UoKTtcXHJcXG4gIH1cXHJcXG59O1xcclxcbmV4cG9ydHMuUG9seSA9IFBvbHk7XFxyXFxuXFxyXFxuUG9seS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKG4pIHtcXHJcXG4gIHRoaXMucG9pbnRzID0gbmV3IEFycmF5KG4pO1xcclxcbiAgdGhpcy5udW1wb2ludHMgPSBuO1xcclxcbn07XFxyXFxuXFxyXFxuUG9seS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XFxyXFxuICB0aGlzLm51bXBvaW50cyA9IHRoaXMucG9pbnRzLmxlbmd0aDtcXHJcXG59O1xcclxcblxcclxcblBvbHkucHJvdG90eXBlLnRyaWFuZ2xlID0gZnVuY3Rpb24ocDEsIHAyLCBwMykge1xcclxcbiAgdGhpcy5pbml0KDMpO1xcclxcbiAgdGhpcy5wb2ludHNbMF0gPSBwMTtcXHJcXG4gIHRoaXMucG9pbnRzWzFdID0gcDI7XFxyXFxuICB0aGlzLnBvaW50c1syXSA9IHAzO1xcclxcbn07XFxyXFxuXFxyXFxuLy8gVGFrZXMgYW4gaW5kZXggYW5kIHJldHVybnMgdGhlIHBvaW50IGF0IHRoYXQgaW5kZXgsIG9yIG51bGwuXFxyXFxuUG9seS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbihuKSB7XFxyXFxuICBpZiAodGhpcy5wb2ludHMgJiYgdGhpcy5udW1wb2ludHMgPiBuKVxcclxcbiAgICByZXR1cm4gdGhpcy5wb2ludHNbbl07XFxyXFxuICByZXR1cm4gbnVsbDtcXHJcXG59O1xcclxcblxcclxcbi8vIFNldCBhIHBvaW50LCBmYWlscyBzaWxlbnRseSBvdGhlcndpc2UuIFRPRE86IHJlcGxhY2Ugd2l0aCBicmFja2V0IG5vdGF0aW9uLlxcclxcblBvbHkucHJvdG90eXBlLnNldFBvaW50ID0gZnVuY3Rpb24oaSwgcCkge1xcclxcbiAgaWYgKHRoaXMucG9pbnRzICYmIHRoaXMucG9pbnRzLmxlbmd0aCA+IGkpIHtcXHJcXG4gICAgdGhpcy5wb2ludHNbaV0gPSBwO1xcclxcbiAgfVxcclxcbn07XFxyXFxuXFxyXFxuLy8gR2l2ZW4gYW4gaW5kZXggaSwgcmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBwb2ludC5cXHJcXG5Qb2x5LnByb3RvdHlwZS5nZXROZXh0SSA9IGZ1bmN0aW9uKGkpIHtcXHJcXG4gIHJldHVybiAoaSArIDEpICUgdGhpcy5udW1wb2ludHM7XFxyXFxufTtcXHJcXG5cXHJcXG5Qb2x5LnByb3RvdHlwZS5nZXRQcmV2SSA9IGZ1bmN0aW9uKGkpIHtcXHJcXG4gIGlmIChpID09IDApXFxyXFxuICAgIHJldHVybiAodGhpcy5udW1wb2ludHMgLSAxKTtcXHJcXG4gIHJldHVybiBpIC0gMTtcXHJcXG59O1xcclxcblxcclxcbi8vIFJldHVybnMgdGhlIHNpZ25lZCBhcmVhIG9mIGEgcG9seWdvbiwgaWYgdGhlIHZlcnRpY2VzIGFyZSBnaXZlbiBpblxcclxcbi8vIENDVyBvcmRlciB0aGVuIHRoZSBhcmVhIHdpbGwgYmUgPiAwLCA8IDAgb3RoZXJ3aXNlLlxcclxcblBvbHkucHJvdG90eXBlLmdldEFyZWEgPSBmdW5jdGlvbigpIHtcXHJcXG4gIHZhciBhcmVhID0gMDtcXHJcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5udW1wb2ludHM7IGkrKykge1xcclxcbiAgICB2YXIgaTIgPSB0aGlzLmdldE5leHRJKGkpO1xcclxcbiAgICBhcmVhICs9IHRoaXMucG9pbnRzW2ldLnggKiB0aGlzLnBvaW50c1tpMl0ueSAtIHRoaXMucG9pbnRzW2ldLnkgKiB0aGlzLnBvaW50c1tpMl0ueDtcXHJcXG4gIH1cXHJcXG4gIHJldHVybiBhcmVhO1xcclxcbn07XFxyXFxuXFxyXFxuUG9seS5wcm90b3R5cGUuZ2V0T3JpZW50YXRpb24gPSBmdW5jdGlvbigpIHtcXHJcXG4gIHZhciBhcmVhID0gdGhpcy5nZXRBcmVhKCk7XFxyXFxuICBpZiAoYXJlYSA+IDApIHJldHVybiBcIkNDV1wiO1xcclxcbiAgaWYgKGFyZWEgPCAwKSByZXR1cm4gXCJDV1wiO1xcclxcbiAgcmV0dXJuIDA7XFxyXFxufTtcXHJcXG5cXHJcXG5Qb2x5LnByb3RvdHlwZS5zZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uKG9yaWVudGF0aW9uKSB7XFxyXFxuICB2YXIgY3VycmVudF9vcmllbnRhdGlvbiA9IHRoaXMuZ2V0T3JpZW50YXRpb24oKTtcXHJcXG4gIGlmIChjdXJyZW50X29yaWVudGF0aW9uICYmIChjdXJyZW50X29yaWVudGF0aW9uICE9PSBvcmllbnRhdGlvbikpIHtcXHJcXG4gICAgdGhpcy5pbnZlcnQoKTtcXHJcXG4gIH1cXHJcXG59O1xcclxcblxcclxcblBvbHkucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uKCkge1xcclxcbiAgdmFyIG5ld3BvaW50cyA9IG5ldyBBcnJheSh0aGlzLm51bXBvaW50cyk7XFxyXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubnVtcG9pbnRzOyBpKyspIHtcXHJcXG4gICAgbmV3cG9pbnRzW2ldID0gdGhpcy5wb2ludHNbdGhpcy5udW1wb2ludHMgLSBpIC0gMV07XFxyXFxuICB9XFxyXFxuICB0aGlzLnBvaW50cyA9IG5ld3BvaW50cztcXHJcXG59O1xcclxcblxcclxcblBvbHkucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uKCkge1xcclxcbiAgdmFyIHggPSB0aGlzLnBvaW50cy5tYXAoZnVuY3Rpb24ocCkgeyByZXR1cm4gcC54IH0pO1xcclxcbiAgdmFyIHkgPSB0aGlzLnBvaW50cy5tYXAoZnVuY3Rpb24ocCkgeyByZXR1cm4gcC55IH0pO1xcclxcbiAgdmFyIG1pblggPSBNYXRoLm1pbi5hcHBseShudWxsLCB4KTtcXHJcXG4gIHZhciBtYXhYID0gTWF0aC5tYXguYXBwbHkobnVsbCwgeCk7XFxyXFxuICB2YXIgbWluWSA9IE1hdGgubWluLmFwcGx5KG51bGwsIHkpO1xcclxcbiAgdmFyIG1heFkgPSBNYXRoLm1heC5hcHBseShudWxsLCB5KTtcXHJcXG4gIHJldHVybiBuZXcgUG9pbnQoKG1pblggKyBtYXhYKS8yLCAobWluWSArIG1heFkpLzIpO1xcclxcbn07XFxyXFxuXFxyXFxuLy8gQWRhcHRlZCBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2MjgzMzQ5XFxyXFxuUG9seS5wcm90b3R5cGUuY2VudHJvaWQgPSBmdW5jdGlvbigpIHtcXHJcXG4gIHZhciB4ID0gMCxcXHJcXG4gICAgICB5ID0gMCxcXHJcXG4gICAgICBpLFxcclxcbiAgICAgIGosXFxyXFxuICAgICAgZixcXHJcXG4gICAgICBwb2ludDEsXFxyXFxuICAgICAgcG9pbnQyO1xcclxcblxcclxcbiAgZm9yIChpID0gMCwgaiA9IHRoaXMucG9pbnRzLmxlbmd0aCAtIDE7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGogPSBpLCBpICs9IDEpIHtcXHJcXG4gICAgcG9pbnQxID0gdGhpcy5wb2ludHNbaV07XFxyXFxuICAgIHBvaW50MiA9IHRoaXMucG9pbnRzW2pdO1xcclxcbiAgICBmID0gcG9pbnQxLnggKiBwb2ludDIueSAtIHBvaW50Mi54ICogcG9pbnQxLnk7XFxyXFxuICAgIHggKz0gKHBvaW50MS54ICsgcG9pbnQyLngpICogZjtcXHJcXG4gICAgeSArPSAocG9pbnQxLnkgKyBwb2ludDIueSkgKiBmO1xcclxcbiAgfVxcclxcblxcclxcbiAgZiA9IHRoaXMuZ2V0QXJlYSgpICogMztcXHJcXG4gIHggPSBNYXRoLmFicyh4KTtcXHJcXG4gIHkgPSBNYXRoLmFicyh5KTtcXHJcXG4gIHJldHVybiBuZXcgUG9pbnQoeCAvIGYsIHkgLyBmKTtcXHJcXG59O1xcclxcblxcclxcblBvbHkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XFxyXFxuICB2YXIgY2VudGVyID0gdGhpcy5jZW50cm9pZCgpO1xcclxcbiAgcmV0dXJuIFwiXCIgKyBjZW50ZXIueCArIFwiIFwiICsgY2VudGVyLnk7XFxyXFxufTtcXHJcXG5cXHJcXG4vKipcXHJcXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHBvaW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIFBvbHlnb24uXFxyXFxuICogQWRhcHRlZCBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg3MjE0ODNcXHJcXG4gKlxcclxcbiAqIEBwYXJhbSB7UG9pbnR9IHAgLSBUaGUgcG9pbnQgdG8gY2hlY2suXFxyXFxuICogQHJldHVybiB7Ym9vbGVhbn0gLSBXaGV0aGVyIG9yIG5vdCB0aGUgcG9pbnQgaXMgY29udGFpbmVkIHdpdGhpblxcclxcbiAqICAgdGhlIHBvbHlnb24uXFxyXFxuICovXFxyXFxuUG9seS5wcm90b3R5cGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uKHApIHtcXHJcXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcXHJcXG4gIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5udW1wb2ludHMgLSAxOyBpIDwgdGhpcy5udW1wb2ludHM7IGogPSBpKyspIHtcXHJcXG4gICAgdmFyIHAxID0gdGhpcy5wb2ludHNbal0sIHAyID0gdGhpcy5wb2ludHNbaV07XFxyXFxuICAgIGlmICgocDIueSA+IHAueSkgIT0gKHAxLnkgPiBwLnkpICYmXFxyXFxuICAgICAgICAocC54IDwgKHAxLnggLSBwMi54KSAqIChwLnkgLSBwMi55KSAvIChwMS55IC0gcDIueSkgKyBwMi54KSkge1xcclxcbiAgICAgIHJlc3VsdCA9ICFyZXN1bHQ7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIHJldHVybiByZXN1bHQ7XFxyXFxufTtcXHJcXG5cXHJcXG4vKipcXHJcXG4gKiBDbG9uZSB0aGUgZ2l2ZW4gcG9seWdvbiBpbnRvIGEgbmV3IHBvbHlnb24uXFxyXFxuICogQHJldHVybiB7UG9seX0gLSBBIGNsb25lIG9mIHRoZSBwb2x5Z29uLlxcclxcbiAqL1xcclxcblBvbHkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XFxyXFxuICByZXR1cm4gbmV3IFBvbHkodGhpcy5wb2ludHMuc2xpY2UoKS5tYXAoZnVuY3Rpb24ocG9pbnQpIHtcXHJcXG4gICAgcmV0dXJuIHBvaW50LmNsb25lKCk7XFxyXFxuICB9KSk7XFxyXFxufTtcXHJcXG5cXHJcXG4vKipcXHJcXG4gKiBUcmFuc2xhdGUgYSBwb2x5Z29uIGFsb25nIGEgZ2l2ZW4gdmVjdG9yLlxcclxcbiAqIEBwYXJhbSB7UG9pbnR9IHZlYyAtIFRoZSB2ZWN0b3IgYWxvbmcgd2hpY2ggdG8gdHJhbnNsYXRlIHRoZVxcclxcbiAqICAgcG9seWdvbi5cXHJcXG4gKiBAcmV0dXJuIHtQb2x5fSAtIFRoZSB0cmFuc2xhdGVkIHBvbHlnb24uXFxyXFxuICovXFxyXFxuUG9seS5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24odmVjKSB7XFxyXFxuICByZXR1cm4gbmV3IFBvbHkodGhpcy5wb2ludHMubWFwKGZ1bmN0aW9uKHBvaW50KSB7XFxyXFxuICAgIHJldHVybiBwb2ludC5hZGQodmVjKTtcXHJcXG4gIH0pKTtcXHJcXG59O1xcclxcblxcclxcbi8qKlxcclxcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgZWRnZXMgcmVwcmVzZW50aW5nIHRoZSBwb2x5Z29uLlxcclxcbiAqIEByZXR1cm4ge0FycmF5LjxFZGdlPn0gLSBUaGUgZWRnZXMgb2YgdGhlIHBvbHlnb24uXFxyXFxuICovXFxyXFxuUG9seS5wcm90b3R5cGUuZWRnZXMgPSBmdW5jdGlvbigpIHtcXHJcXG4gIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShcImNhY2hlZF9lZGdlc1wiKSkge1xcclxcbiAgICB0aGlzLmNhY2hlZF9lZGdlcyA9IHRoaXMucG9pbnRzLm1hcChmdW5jdGlvbihwb2ludCwgaSkge1xcclxcbiAgICAgIHJldHVybiBuZXcgRWRnZShwb2ludCwgdGhpcy5wb2ludHNbdGhpcy5nZXROZXh0SShpKV0pO1xcclxcbiAgICB9LCB0aGlzKTtcXHJcXG4gIH1cXHJcXG4gIHJldHVybiB0aGlzLmNhY2hlZF9lZGdlcztcXHJcXG59O1xcclxcblxcclxcbi8qKlxcclxcbiAqIE5haXZlIGNoZWNrIGlmIG90aGVyIHBvbHkgaW50ZXJzZWN0cyB0aGlzIG9uZSwgYXNzdW1pbmcgYm90aCBjb252ZXguXFxyXFxuICogQHBhcmFtIHtQb2x5fSBwb2x5XFxyXFxuICogQHJldHVybiB7Ym9vbGVhbn0gLSBXaGV0aGVyIHRoZSBwb2x5Z29ucyBpbnRlcnNlY3QuXFxyXFxuICovXFxyXFxuUG9seS5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKHBvbHkpIHtcXHJcXG4gIHZhciBpbnNpZGUgPSBwb2x5LnBvaW50cy5zb21lKGZ1bmN0aW9uKHApIHtcXHJcXG4gICAgcmV0dXJuIHRoaXMuY29udGFpbnNQb2ludChwKTtcXHJcXG4gIH0sIHRoaXMpO1xcclxcbiAgaW5zaWRlID0gaW5zaWRlIHx8IHRoaXMucG9pbnRzLnNvbWUoZnVuY3Rpb24ocCkge1xcclxcbiAgICByZXR1cm4gcG9seS5jb250YWluc1BvaW50KHApO1xcclxcbiAgfSk7XFxyXFxuICBpZiAoaW5zaWRlKSB7XFxyXFxuICAgIHJldHVybiB0cnVlO1xcclxcbiAgfSBlbHNlIHtcXHJcXG4gICAgdmFyIG93bkVkZ2VzID0gdGhpcy5lZGdlcygpO1xcclxcbiAgICB2YXIgb3RoZXJFZGdlcyA9IHBvbHkuZWRnZXMoKTtcXHJcXG4gICAgdmFyIGludGVyc2VjdCA9IG93bkVkZ2VzLnNvbWUoZnVuY3Rpb24ob3duRWRnZSkge1xcclxcbiAgICAgIHJldHVybiBvdGhlckVkZ2VzLnNvbWUoZnVuY3Rpb24ob3RoZXJFZGdlKSB7XFxyXFxuICAgICAgICByZXR1cm4gb3duRWRnZS5pbnRlcnNlY3RzKG90aGVyRWRnZSk7XFxyXFxuICAgICAgfSk7XFxyXFxuICAgIH0pO1xcclxcbiAgICByZXR1cm4gaW50ZXJzZWN0O1xcclxcbiAgfVxcclxcbn07XFxyXFxuXFxyXFxudmFyIHV0aWwgPSB7fTtcXHJcXG5leHBvcnRzLnV0aWwgPSB1dGlsO1xcclxcblxcclxcbi8qKlxcclxcbiAqIEdpdmVuIGFuIGFycmF5IG9mIHBvbHlnb25zLCByZXR1cm5zIHRoZSBvbmUgdGhhdCBjb250YWlucyB0aGUgcG9pbnQuXFxyXFxuICogSWYgbm8gcG9seWdvbiBpcyBmb3VuZCwgbnVsbCBpcyByZXR1cm5lZC5cXHJcXG4gKiBAcGFyYW0ge1BvaW50fSBwIC0gVGhlIHBvaW50IHRvIGZpbmQgdGhlIHBvbHlnb24gZm9yLlxcclxcbiAqIEBwYXJhbSB7QXJyYXkuPFBvbHk+fSBwb2x5cyAtIFRoZSBwb2x5Z29ucyB0byBzZWFyY2ggZm9yIHRoZSBwb2ludC5cXHJcXG4gKiBAcmV0dXJuIHs/UG9seWdvbn0gLSBUaGUgcG9seWdvbiBjb250YWluaW5nIHRoZSBwb2ludC5cXHJcXG4gKi9cXHJcXG51dGlsLmZpbmRQb2x5Rm9yUG9pbnQgPSBmdW5jdGlvbihwLCBwb2x5cykge1xcclxcbiAgdmFyIGksIHBvbHk7XFxyXFxuICBmb3IgKGkgaW4gcG9seXMpIHtcXHJcXG4gICAgcG9seSA9IHBvbHlzW2ldO1xcclxcbiAgICBpZiAocG9seS5jb250YWluc1BvaW50KHApKSB7XFxyXFxuICAgICAgcmV0dXJuIHBvbHk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIHJldHVybiBudWxsO1xcclxcbn07XFxyXFxuXFxyXFxuLyoqXFxyXFxuICogSG9sZHMgdGhlIHByb3BlcnRpZXMgb2YgYSBjb2xsaXNpb24sIGlmIG9uZSBvY2N1cnJlZC5cXHJcXG4gKiBAdHlwZWRlZiBDb2xsaXNpb25cXHJcXG4gKiBAdHlwZSB7b2JqZWN0fVxcclxcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29sbGlkZXMgLSBXaGV0aGVyIHRoZXJlIGlzIGEgY29sbGlzaW9uLlxcclxcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaW5zaWRlIC0gV2hldGhlciBvbmUgb2JqZWN0IGlzIGluc2lkZSB0aGUgb3RoZXIuXFxyXFxuICogQHByb3BlcnR5IHs/UG9pbnR9IHBvaW50IC0gVGhlIHBvaW50IG9mIGNvbGxpc2lvbiwgaWYgY29sbGlzaW9uXFxyXFxuICogICBvY2N1cnMsIGFuZCBpZiBgaW5zaWRlYCBpcyBmYWxzZS5cXHJcXG4gKiBAcHJvcGVydHkgez9Qb2ludH0gbm9ybWFsIC0gQSB1bml0IHZlY3RvciBub3JtYWwgdG8gdGhlIHBvaW50XFxyXFxuICogICBvZiBjb2xsaXNpb24sIGlmIGl0IG9jY3VycyBhbmQgaWYgYGluc2lkZWAgaXMgZmFsc2UuXFxyXFxuICovXFxyXFxuLyoqXFxyXFxuICogSWYgdGhlIHJheSBpbnRlcnNlY3RzIHRoZSBjaXJjbGUsIHRoZSBkaXN0YW5jZSB0byB0aGUgaW50ZXJzZWN0aW9uXFxyXFxuICogYWxvbmcgdGhlIHJheSBpcyByZXR1cm5lZCwgb3RoZXJ3aXNlIGZhbHNlIGlzIHJldHVybmVkLlxcclxcbiAqIEBwYXJhbSB7UG9pbnR9IHAgLSBUaGUgc3RhcnQgb2YgdGhlIHJheS5cXHJcXG4gKiBAcGFyYW0ge1BvaW50fSByYXkgLSBVbml0IHZlY3RvciBleHRlbmRpbmcgZnJvbSBgcGAuXFxyXFxuICogQHBhcmFtIHtQb2ludH0gYyAtIFRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSBmb3IgdGhlIG9iamVjdCBiZWluZ1xcclxcbiAqICAgY2hlY2tlZCBmb3IgaW50ZXJzZWN0aW9uLlxcclxcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUuXFxyXFxuICogQHJldHVybiB7Q29sbGlzaW9ufSAtIFRoZSBjb2xsaXNpb24gaW5mb3JtYXRpb24uXFxyXFxuICovXFxyXFxudXRpbC5saW5lQ2lyY2xlSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24ocCwgcmF5LCBjLCByYWRpdXMpIHtcXHJcXG4gIHZhciBjb2xsaXNpb24gPSB7XFxyXFxuICAgIGNvbGxpZGVzOiBmYWxzZSxcXHJcXG4gICAgaW5zaWRlOiBmYWxzZSxcXHJcXG4gICAgcG9pbnQ6IG51bGwsXFxyXFxuICAgIG5vcm1hbDogbnVsbFxcclxcbiAgfTtcXHJcXG4gIHZhciB2cGMgPSBjLnN1YihwKTtcXHJcXG5cXHJcXG4gIGlmICh2cGMubGVuKCkgPD0gcmFkaXVzKSB7XFxyXFxuICAgIC8vIFBvaW50IGlzIGluc2lkZSBvYnN0YWNsZS5cXHJcXG4gICAgY29sbGlzaW9uLmNvbGxpZGVzID0gdHJ1ZTtcXHJcXG4gICAgY29sbGlzaW9uLmluc2lkZSA9ICh2cGMubGVuKCkgIT09IHJhZGl1cyk7XFxyXFxuICB9IGVsc2UgaWYgKHJheS5kb3QodnBjKSA+PSAwKSB7XFxyXFxuICAgIC8vIENpcmNsZSBpcyBhaGVhZCBvZiBwb2ludC5cXHJcXG4gICAgLy8gUHJvamVjdGlvbiBvZiBjZW50ZXIgcG9pbnQgb250byByYXkuXFxyXFxuICAgIHZhciBwYyA9IHAuYWRkKHJheS5tdWwocmF5LmRvdCh2cGMpKSk7XFxyXFxuICAgIC8vIExlbmd0aCBmcm9tIGMgdG8gaXRzIHByb2plY3Rpb24gb24gdGhlIHJheS5cXHJcXG4gICAgdmFyIGxlbl9jX3BjID0gYy5zdWIocGMpLmxlbigpO1xcclxcblxcclxcbiAgICBpZiAobGVuX2NfcGMgPD0gcmFkaXVzKSB7XFxyXFxuICAgICAgY29sbGlzaW9uLmNvbGxpZGVzID0gdHJ1ZTtcXHJcXG5cXHJcXG4gICAgICAvLyBEaXN0YW5jZSBmcm9tIHByb2plY3RlZCBwb2ludCB0byBpbnRlcnNlY3Rpb24uXFxyXFxuICAgICAgdmFyIGxlbl9pbnRlcnNlY3Rpb24gPSBNYXRoLnNxcnQobGVuX2NfcGMgKiBsZW5fY19wYyArIHJhZGl1cyAqIHJhZGl1cyk7XFxyXFxuICAgICAgY29sbGlzaW9uLnBvaW50ID0gcGMuc3ViKHJheS5tdWwobGVuX2ludGVyc2VjdGlvbikpO1xcclxcbiAgICAgIGNvbGxpc2lvbi5ub3JtYWwgPSBjb2xsaXNpb24ucG9pbnQuc3ViKGMpLm5vcm1hbGl6ZSgpO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICByZXR1cm4gY29sbGlzaW9uO1xcclxcbn07XFxyXFxuXFxufSx7fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxudmFyIGdlbyA9IHJlcXVpcmUoXFwnLi9nZW9tZXRyeVxcJyk7XFxyXFxudmFyIGZpbmRQb2x5Rm9yUG9pbnQgPSBnZW8udXRpbC5maW5kUG9seUZvclBvaW50O1xcclxcbnZhciBQcmlvcml0eVF1ZXVlID0gcmVxdWlyZShcXCdwcmlvcml0eS1xdWV1ZVxcJyk7XFxyXFxuXFxyXFxuLyoqXFxyXFxuICogUGF0aGZpbmRlciBpbXBsZW1lbnRzIHBhdGhmaW5kaW5nIG9uIGEgbmF2aWdhdGlvbiBtZXNoLlxcclxcbiAqIEBjb25zdHJ1Y3RvclxcclxcbiAqIEBwYXJhbSB7QXJyYXkuPFBvbHk+fSBwb2x5cyAtIFRoZSBwb2x5Z29ucyBkZWZpbmluZyB0aGUgbmF2aWdhdGlvbiBtZXNoLlxcclxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXQ9dHJ1ZV0gLSBXaGV0aGVyIG9yIG5vdCB0byBpbml0aWFsaXplIHRoZSBwYXRoZmluZGVyLlxcclxcbiAqL1xcclxcbnZhciBQYXRoZmluZGVyID0gZnVuY3Rpb24ocG9seXMsIGluaXQpIHtcXHJcXG4gIGlmICh0eXBlb2YgaW5pdCA9PSBcInVuZGVmaW5lZFwiKSBpbml0ID0gdHJ1ZTtcXHJcXG4gIHRoaXMucG9seXMgPSBwb2x5cztcXHJcXG4gIGlmIChpbml0KSB7XFxyXFxuICAgIHRoaXMuaW5pdCgpO1xcclxcbiAgfVxcclxcbn07XFxyXFxubW9kdWxlLmV4cG9ydHMgPSBQYXRoZmluZGVyO1xcclxcblxcclxcblBhdGhmaW5kZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcXHJcXG4gIHRoaXMuZ3JpZCA9IHRoaXMuZ2VuZXJhdGVBZGphY2VuY3lHcmlkKHRoaXMucG9seXMpO1xcclxcbn07XFxyXFxuXFxyXFxuLyoqXFxyXFxuICogQ29tcHV0ZXMgcGF0aCBmcm9tIHNvdXJjZSB0byB0YXJnZXQsIHVzaW5nIHNpZGVzIGFuZCBjZW50ZXJzIG9mIHRoZSBlZGdlc1xcclxcbiAqIGJldHdlZW4gYWRqYWNlbnQgcG9seWdvbnMuIHNvdXJjZSBhbmQgdGFyZ2V0IGFyZSBQb2ludHMgYW5kIHBvbHlzIHNob3VsZFxcclxcbiAqIGJlIHRoZSBmaW5hbCBwYXJ0aXRpb25lZCBtYXAuXFxyXFxuICogQHBhcmFtIHtQb2ludH0gc291cmNlIC0gVGhlIHN0YXJ0IGxvY2F0aW9uIGZvciB0aGUgc2VhcmNoLlxcclxcbiAqIEBwYXJhbSB7UG9pbnR9IHRhcmdldCAtIFRoZSB0YXJnZXQgbG9jYXRpb24gZm9yIHRoZSBzZWFyY2guXFxyXFxuICogQHJldHVybiB7P0FycmF5LjxQb2ludD59IC0gQSBzZXJpZXMgb2YgcG9pbnRzIHJlcHJlc2VudGluZyB0aGUgcGF0aCBmcm9tXFxyXFxuICogICB0aGUgc291cmNlIHRvIHRoZSB0YXJnZXQuIElmIGEgcGF0aCBpcyBub3QgZm91bmQsIGBudWxsYCBpcyByZXR1cm5lZC5cXHJcXG4gKi9cXHJcXG5QYXRoZmluZGVyLnByb3RvdHlwZS5hU3RhciA9IGZ1bmN0aW9uKHNvdXJjZSwgdGFyZ2V0KSB7XFxyXFxuICAvLyBDb21wYXJlcyB0aGUgdmFsdWUgb2YgdHdvIG5vZGVzLlxcclxcbiAgZnVuY3Rpb24gbm9kZVZhbHVlKG5vZGUxLCBub2RlMikge1xcclxcbiAgICByZXR1cm4gKG5vZGUxLmRpc3QgKyBoZXVyaXN0aWMobm9kZTEucG9pbnQpKSAtIChub2RlMi5kaXN0ICsgaGV1cmlzdGljKG5vZGUyLnBvaW50KSk7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAvLyBEaXN0YW5jZSBiZXR3ZWVuIHBvbHlnb25zLlxcclxcbiAgZnVuY3Rpb24gZXVjbGlkZWFuRGlzdGFuY2UocDEsIHAyKSB7XFxyXFxuICAgIHJldHVybiBwMS5kaXN0KHAyKTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC8vIERpc3RhbmNlIGJldHdlZW4gcG9seWdvbnMuIHRvZG86IHVwZGF0ZVxcclxcbiAgZnVuY3Rpb24gbWFuaGF0dGFuRGlzdGFuY2UoZWx0MSwgZWx0Mikge1xcclxcbiAgICByZXR1cm4gKGVsdDEuciAtIGVsdDIucikgKyAoZWx0MS5jIC0gZWx0Mi5jKTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC8vIFRha2VzIFBvaW50IGFuZCByZXR1cm5zIHZhbHVlLlxcclxcbiAgZnVuY3Rpb24gaGV1cmlzdGljKHApIHtcXHJcXG4gICAgcmV0dXJuIGV1Y2xpZGVhbkRpc3RhbmNlKHAsIHRhcmdldCk7XFxyXFxuICB9XFxyXFxuXFxyXFxuICB2YXIgc291cmNlUG9seSA9IGZpbmRQb2x5Rm9yUG9pbnQoc291cmNlLCB0aGlzLnBvbHlzKTtcXHJcXG5cXHJcXG4gIC8vIFdlXFwncmUgb3V0c2lkZSBvZiB0aGUgbWVzaCBzb21laG93LiBUcnkgYSBmZXcgbmVhcmJ5IHBvaW50cy5cXHJcXG4gIGlmICghc291cmNlUG9seSkge1xcclxcbiAgICB2YXIgb2Zmc2V0U291cmNlID0gW25ldyBQb2ludCg1LCAwKSwgbmV3IFBvaW50KC01LCAwKSwgbmV3IFBvaW50KDAsIC01KSwgbmV3IFBvaW50KDAsIDUpXTtcXHJcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvZmZzZXRTb3VyY2UubGVuZ3RoOyBpKyspIHtcXHJcXG4gICAgICAvLyBNYWtlIG5ldyBwb2ludC5cXHJcXG4gICAgICB2YXIgcG9pbnQgPSBzb3VyY2UuYWRkKG9mZnNldFNvdXJjZVtpXSk7XFxyXFxuICAgICAgc291cmNlUG9seSA9IGZpbmRQb2x5Rm9yUG9pbnQocG9pbnQsIHRoaXMucG9seXMpO1xcclxcbiAgICAgIGlmIChzb3VyY2VQb2x5KSB7XFxyXFxuICAgICAgICBzb3VyY2UgPSBwb2ludDtcXHJcXG4gICAgICAgIGJyZWFrO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICBpZiAoIXNvdXJjZVBvbHkpIHtcXHJcXG4gICAgICByZXR1cm4gbnVsbDtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgdmFyIHRhcmdldFBvbHkgPSBmaW5kUG9seUZvclBvaW50KHRhcmdldCwgdGhpcy5wb2x5cyk7XFxyXFxuXFxyXFxuICAvLyBIYW5kbGUgdHJpdmlhbCBjYXNlLlxcclxcbiAgaWYgKHNvdXJjZVBvbHkgPT0gdGFyZ2V0UG9seSkge1xcclxcbiAgICByZXR1cm4gW3NvdXJjZSwgdGFyZ2V0XTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC8vIFdhcm5pbmcsIG1heSBoYXZlIGNvbXBhdGliaWxpdHkgaXNzdWVzLlxcclxcbiAgdmFyIGRpc2NvdmVyZWRQb2x5cyA9IG5ldyBXZWFrU2V0KCk7XFxyXFxuICB2YXIgZGlzY292ZXJlZFBvaW50cyA9IG5ldyBXZWFrU2V0KCk7XFxyXFxuICB2YXIgcHEgPSBuZXcgUHJpb3JpdHlRdWV1ZSh7IGNvbXBhcmF0b3I6IG5vZGVWYWx1ZSB9KTtcXHJcXG4gIHZhciBmb3VuZCA9IG51bGw7XFxyXFxuICAvLyBJbml0aWFsaXplIHdpdGggc3RhcnQgbG9jYXRpb24uXFxyXFxuICBwcS5xdWV1ZSh7ZGlzdDogMCwgcG9seTogc291cmNlUG9seSwgcG9pbnQ6IHNvdXJjZSwgcGFyZW50OiBudWxsfSk7XFxyXFxuICB3aGlsZSAocHEubGVuZ3RoID4gMCkge1xcclxcbiAgICB2YXIgbm9kZSA9IHBxLmRlcXVldWUoKTtcXHJcXG4gICAgaWYgKG5vZGUucG9seSA9PSB0YXJnZXRQb2x5KSB7XFxyXFxuICAgICAgZm91bmQgPSBub2RlO1xcclxcbiAgICAgIGJyZWFrO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIGRpc2NvdmVyZWRQb2x5cy5hZGQobm9kZS5wb2x5KTtcXHJcXG4gICAgICBkaXNjb3ZlcmVkUG9pbnRzLmFkZChub2RlLnBvaW50KTtcXHJcXG4gICAgfVxcclxcbiAgICAvLyBUaGlzIG1heSBiZSB1bmRlZmluZWQgaWYgdGhlcmUgd2FzIG5vIHBvbHlnb24gZm91bmQuXFxyXFxuICAgIHZhciBuZWlnaGJvcnMgPSB0aGlzLmdyaWQuZ2V0KG5vZGUucG9seSk7XFxyXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSsrKSB7XFxyXFxuICAgICAgdmFyIGVsdCA9IG5laWdoYm9yc1tpXTtcXHJcXG4gICAgICB2YXIgbmVpZ2hib3JGb3VuZCA9IGRpc2NvdmVyZWRQb2x5cy5oYXMoZWx0LnBvbHkpO1xcclxcblxcclxcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWx0LmVkZ2UucG9pbnRzLmxlbmd0aDsgaisrKSB7XFxyXFxuICAgICAgICB2YXIgcCA9IGVsdC5lZGdlLnBvaW50c1tqXTtcXHJcXG4gICAgICAgIGlmICghbmVpZ2hib3JGb3VuZCB8fCAhZGlzY292ZXJlZFBvaW50cy5oYXMocCkpXFxyXFxuICAgICAgICAgIHBxLnF1ZXVlKHtkaXN0OiBub2RlLmRpc3QgKyBldWNsaWRlYW5EaXN0YW5jZShwLCBub2RlLnBvaW50KSwgcG9seTogZWx0LnBvbHksIHBvaW50OiBwLCBwYXJlbnQ6IG5vZGV9KTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG5cXHJcXG4gIGlmIChmb3VuZCkge1xcclxcbiAgICB2YXIgcGF0aCA9IFtdO1xcclxcbiAgICB2YXIgY3VycmVudCA9IGZvdW5kO1xcclxcbiAgICB3aGlsZSAoY3VycmVudC5wYXJlbnQpIHtcXHJcXG4gICAgICBwYXRoLnVuc2hpZnQoY3VycmVudC5wb2ludCk7XFxyXFxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xcclxcbiAgICB9XFxyXFxuICAgIHBhdGgudW5zaGlmdChjdXJyZW50LnBvaW50KTtcXHJcXG4gICAgLy8gQWRkIGVuZCBwb2ludCB0byBwYXRoLlxcclxcbiAgICBwYXRoLnB1c2godGFyZ2V0KTtcXHJcXG4gICAgcmV0dXJuIHBhdGg7XFxyXFxuICB9IGVsc2Uge1xcclxcbiAgICByZXR1cm4gbnVsbDtcXHJcXG4gIH1cXHJcXG59O1xcclxcblxcclxcbi8qKlxcclxcbiAqIEhvbGRzIHRoZSBcIm5laWdoYm9yXCIgcmVsYXRpb25zaGlwIG9mIFBvbHkgb2JqZWN0cyBpbiB0aGUgcGFydGl0aW9uXFxyXFxuICogdXNpbmcgdGhlIFBvbHlcXCdzIHRoZW1zZWx2ZXMgYXMga2V5cywgYW5kIGFuIGFycmF5IG9mIFBvbHlcXCdzIGFzXFxyXFxuICogdmFsdWVzLCB3aGVyZSB0aGUgUG9seXMgaW4gdGhlIGFycmF5IGFyZSBuZWlnaGJvcnMgb2YgdGhlIFBvbHlcXHJcXG4gKiB0aGF0IHdhcyB0aGUga2V5LlxcclxcbiAqIEB0eXBlZGVmIEFkamFjZW5jeUdyaWRcXHJcXG4gKiBAdHlwZSB7T2JqZWN0LjxQb2x5LCBBcnJheTxQb2x5Pj59XFxyXFxuICovXFxyXFxuXFxyXFxuLyoqXFxyXFxuICogR2l2ZW4gYW4gYXJyYXkgb2YgUG9seSBvYmplY3RzLCBmaW5kIGFsbCBuZWlnaGJvcmluZyBwb2x5Z29ucyBmb3JcXHJcXG4gKiBlYWNoIHBvbHlnb24uXFxyXFxuICogQHByaXZhdGVcXHJcXG4gKiBAcGFyYW0ge0FycmF5LjxQb2x5Pn0gcG9seXMgLSBUaGUgYXJyYXkgb2YgcG9seXMgdG8gZmluZCBuZWlnaGJvcnNcXHJcXG4gKiAgIGFtb25nLlxcclxcbiAqIEByZXR1cm4ge0FkamFjZW5jeUdyaWR9IC0gVGhlIFwibmVpZ2hib3JcIiByZWxhdGlvbnNoaXBzLlxcclxcbiAqL1xcclxcblBhdGhmaW5kZXIucHJvdG90eXBlLmdlbmVyYXRlQWRqYWNlbmN5R3JpZCA9IGZ1bmN0aW9uKHBvbHlzKSB7XFxyXFxuICB2YXIgbmVpZ2hib3JzID0gbmV3IFdlYWtNYXAoKTtcXHJcXG4gIHBvbHlzLmZvckVhY2goZnVuY3Rpb24ocG9seSwgcG9seUksIHBvbHlzKSB7XFxyXFxuICAgIGlmIChuZWlnaGJvcnMuaGFzKHBvbHkpKSB7XFxyXFxuICAgICAgLy8gTWF4aW11bSBudW1iZXIgb2YgbmVpZ2hib3JzIGFscmVhZHkgZm91bmQuXFxyXFxuICAgICAgaWYgKG5laWdoYm9ycy5nZXQocG9seSkubGVuZ3RoID09IHBvbHkubnVtcG9pbnRzKSB7XFxyXFxuICAgICAgICByZXR1cm47XFxyXFxuICAgICAgfVxcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIC8vIEluaXRpYWxpemUgYXJyYXkuXFxyXFxuICAgICAgbmVpZ2hib3JzLnNldChwb2x5LCBuZXcgQXJyYXkoKSk7XFxyXFxuICAgIH1cXHJcXG4gICAgLy8gT2YgcmVtYWluaW5nIHBvbHlnb25zLCBmaW5kIHNvbWUgdGhhdCBhcmUgYWRqYWNlbnQuXFxyXFxuICAgIHBvbHkucG9pbnRzLmZvckVhY2goZnVuY3Rpb24ocDEsIGksIHBvaW50cykge1xcclxcbiAgICAgIC8vIE5leHQgcG9pbnQuXFxyXFxuICAgICAgdmFyIHAyID0gcG9pbnRzW3BvbHkuZ2V0TmV4dEkoaSldO1xcclxcbiAgICAgIGZvciAodmFyIHBvbHlKID0gcG9seUkgKyAxOyBwb2x5SiA8IHBvbHlzLmxlbmd0aDsgcG9seUorKykge1xcclxcbiAgICAgICAgdmFyIHBvbHkyID0gcG9seXNbcG9seUpdO1xcclxcbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIHBvaW50cyB1bnRpbCBtYXRjaCBpcyBmb3VuZC5cXHJcXG4gICAgICAgIHBvbHkyLnBvaW50cy5zb21lKGZ1bmN0aW9uKHExLCBqLCBwb2ludHMyKSB7XFxyXFxuICAgICAgICAgIHZhciBxMiA9IHBvaW50czJbcG9seTIuZ2V0TmV4dEkoaildO1xcclxcbiAgICAgICAgICB2YXIgbWF0Y2ggPSBwMS5lcShxMikgJiYgcDIuZXEocTEpO1xcclxcbiAgICAgICAgICBpZiAobWF0Y2gpIHtcXHJcXG4gICAgICAgICAgICB2YXIgZWRnZSA9IG5ldyBFZGdlKHAxLCBwMik7XFxyXFxuICAgICAgICAgICAgbmVpZ2hib3JzLmdldChwb2x5KS5wdXNoKHsgcG9seTogcG9seTIsIGVkZ2U6IGVkZ2UgfSk7XFxyXFxuICAgICAgICAgICAgaWYgKCFuZWlnaGJvcnMuaGFzKHBvbHkyKSkge1xcclxcbiAgICAgICAgICAgICAgbmVpZ2hib3JzLnNldChwb2x5MiwgbmV3IEFycmF5KCkpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBuZWlnaGJvcnMuZ2V0KHBvbHkyKS5wdXNoKHsgcG9seTogcG9seSwgZWRnZTogZWRnZSB9KTtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XFxyXFxuICAgICAgICB9KTtcXHJcXG4gICAgICAgIGlmIChuZWlnaGJvcnMuZ2V0KHBvbHkpLmxlbmd0aCA9PSBwb2x5Lm51bXBvaW50cykgYnJlYWs7XFxyXFxuICAgICAgfVxcclxcbiAgICB9KTtcXHJcXG4gIH0pO1xcclxcbiAgcmV0dXJuIG5laWdoYm9ycztcXHJcXG59O1xcclxcblxcbn0se1wiLi9nZW9tZXRyeVwiOjMsXCJwcmlvcml0eS1xdWV1ZVwiOjF9XX0se30sWzJdKSddLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KSkpO1xyXG4gIHRoaXMud29ya2VyLm9ubWVzc2FnZSA9IHRoaXMuX2dldFdvcmtlckludGVyZmFjZSgpO1xyXG4gIC8vIENoZWNrIGlmIHdvcmtlciBpcyBhbHJlYWR5IGluaXRpYWxpemVkLlxyXG4gIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKFtcImlzSW5pdGlhbGl6ZWRcIl0pO1xyXG4gIHRoaXMud29ya2VySW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuXHJcbiAgLy8gU2V0IHVwIGNhbGxiYWNrIHRvIHVwZGF0ZSB3b3JrZXIgb24gbmF2bWVzaCB1cGRhdGUuXHJcbiAgdGhpcy5vblVwZGF0ZShmdW5jdGlvbihkaXNyZWdhcmQsIG5ld1BvbHlzLCByZW1vdmVkSW5kaWNlcykge1xyXG4gICAgaWYgKHRoaXMud29ya2VyICYmIHRoaXMud29ya2VySW5pdGlhbGl6ZWQpIHtcclxuICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UoW1wicG9seVVwZGF0ZVwiLCBuZXdQb2x5cywgcmVtb3ZlZEluZGljZXNdKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIm5hdm1lc2g6ZGVidWdcIiwgXCJXb3JrZXIgbm90IGxvYWRlZCB5ZXQuXCIpO1xyXG4gICAgfVxyXG4gIH0uYmluZCh0aGlzKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogSGFuZGxlciBmb3IgbG9nIG1lc3NhZ2VzIHNlbnQgYnkgd29ya2VyLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0FycmF5Ljwoc3RyaW5nfG9iamVjdCk+fSBtZXNzYWdlIC0gQXJyYXkgb2YgYXJndW1lbnRzIHRvXHJcbiAqICAgcGFzcyB0byBgTG9nZ2VyLmxvZ2AuIFRoZSBmaXJzdCBlbGVtZW50IHNob3VsZCBiZSB0aGUgZ3JvdXAgdG9cclxuICogICBhc3NvY2lhdGUgdGhlIG1lc3NhZ2Ugd2l0aC5cclxuICovXHJcbk5hdk1lc2gucHJvdG90eXBlLl93b3JrZXJMb2dnZXIgPSBmdW5jdGlvbihtZXNzYWdlKSB7XHJcbiAgdGhpcy5sb2dnZXIubG9nLmFwcGx5KG51bGwsIG1lc3NhZ2UpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIHRoZSBgb25tZXNzYWdlYCBjYWxsYmFjayBmb3JcclxuICogdGhlIHdlYiB3b3JrZXIuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSAtIFRoZSBgb25tZXNzYWdlYCBoYW5kbGVyIGZvciB0aGUgd2ViIHdvcmtlci5cclxuICovXHJcbk5hdk1lc2gucHJvdG90eXBlLl9nZXRXb3JrZXJJbnRlcmZhY2UgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gZnVuY3Rpb24obWVzc2FnZSkge1xyXG4gICAgdmFyIGRhdGEgPSBtZXNzYWdlLmRhdGE7XHJcbiAgICB2YXIgbmFtZSA9IGRhdGFbMF07XHJcblxyXG4gICAgLy8gT3V0cHV0IGRlYnVnIG1lc3NhZ2UgZm9yIGFsbCBtZXNzYWdlcyByZWNlaXZlZCBleGNlcHQgXCJsb2dcIlxyXG4gICAgLy8gbWVzc2FnZXMuXHJcbiAgICBpZiAobmFtZSAhPT0gXCJsb2dcIilcclxuICAgICAgdGhpcy5sb2dnZXIubG9nKFwibmF2bWVzaDpkZWJ1Z1wiLCBcIk1lc3NhZ2UgcmVjZWl2ZWQgZnJvbSB3b3JrZXI6XCIsIGRhdGEpO1xyXG5cclxuICAgIGlmIChuYW1lID09IFwibG9nXCIpIHtcclxuICAgICAgdGhpcy5fd29ya2VyTG9nZ2VyKGRhdGEuc2xpY2UoMSkpO1xyXG4gICAgfSBlbHNlIGlmIChuYW1lID09IFwicmVzdWx0XCIpIHtcclxuICAgICAgdmFyIHBhdGggPSBkYXRhWzFdO1xyXG4gICAgICB0aGlzLmxhc3RDYWxsYmFjayhwYXRoKTtcclxuICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImluaXRpYWxpemVkXCIpIHtcclxuICAgICAgdGhpcy53b3JrZXJJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgIC8vIFNlbmQgcGFyc2VkIG1hcCBwb2x5Z29ucyB0byB3b3JrZXIgd2hlbiBhdmFpbGFibGUuXHJcbiAgICAgIHRoaXMub25Jbml0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKFtcInBvbHlzXCIsIHRoaXMucG9seXNdKTtcclxuICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuICB9LmJpbmQodGhpcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogTWFrZSB1dGlsaXRpZXMgaW4gcG9seXBhcnRpdGlvbiBhdmFpbGFibGUgd2l0aG91dCByZXF1aXJpbmdcclxuICogdGhhdCBpdCBiZSBpbmNsdWRlZCBpbiBleHRlcm5hbCBzY3JpcHRzLlxyXG4gKi9cclxuTmF2TWVzaC5wb2x5ID0gZ2VvO1xyXG5cclxuLyoqXHJcbiAqIEhvbGQgbWV0aG9kcyB1c2VkIGZvciBnZW5lcmF0aW5nIHRoZSBuYXZpZ2F0aW9uIG1lc2guXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5OYXZNZXNoLl9nZW9tZXRyeSA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemVkIENsaXBwZXIgZm9yIG9wZXJhdGlvbnMuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEB0eXBlIHtDbGlwcGVyTGliLkNsaXBwZXJ9XHJcbiAqL1xyXG5OYXZNZXNoLl9nZW9tZXRyeS5jcHIgPSBuZXcgQ2xpcHBlckxpYi5DbGlwcGVyKCk7XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZWQgQ2xpcHBlck9mZnNldCBmb3Igb3BlcmF0aW9ucy5cclxuICogQHByaXZhdGVcclxuICogQHR5cGUge0NsaXBwZXJMaWIuQ2xpcHBlck9mZnNldH1cclxuICovXHJcbk5hdk1lc2guX2dlb21ldHJ5LmNvID0gbmV3IENsaXBwZXJMaWIuQ2xpcHBlck9mZnNldCgpO1xyXG5cclxuLy8gRGVmYXVsdHMuXHJcbk5hdk1lc2guX2dlb21ldHJ5LmNvLk1pdGVyTGltaXQgPSAyO1xyXG5OYXZNZXNoLl9nZW9tZXRyeS5zY2FsZSA9IDEwMDtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBwb2x5Z29uYWwgYXBwcm94aW1hdGlvbiBvZiBhIGNpcmNsZSBvZiBhIGdpdmVuIHJhZGl1c1xyXG4gKiBjZW50ZXJlZCBhdCB0aGUgcHJvdmlkZWQgcG9pbnQuIFZlcnRpY2VzIG9mIHBvbHlnb24gYXJlIGluIENXXHJcbiAqIG9yZGVyLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gVGhlIHJhZGl1cyBmb3IgdGhlIHBvbHlnb24uXHJcbiAqIEBwYXJhbSB7UG9pbnR9IFtwb2ludF0gLSBUaGUgcG9pbnQgYXQgd2hpY2ggdG8gY2VudGVyIHRoZSBwb2x5Z29uLlxyXG4gKiAgIElmIGEgcG9pbnQgaXMgbm90IHByb3ZpZGVkIHRoZW4gdGhlIHBvbHlnb24gaXMgY2VudGVyZWQgYXQgdGhlXHJcbiAqICAgb3JpZ2luLlxyXG4gKiBAcmV0dXJuIHtQb2x5fSAtIFRoZSBhcHByb3hpbWF0ZWQgY2lyY2xlLlxyXG4gKi9cclxuTmF2TWVzaC5fZ2VvbWV0cnkuZ2V0QXBwcm94aW1hdGVDaXJjbGUgPSBmdW5jdGlvbihyYWRpdXMsIHBvaW50KSB7XHJcbiAgdmFyIHgsIHk7XHJcbiAgaWYgKHBvaW50KSB7XHJcbiAgICB4ID0gcG9pbnQueDtcclxuICAgIHkgPSBwb2ludC55O1xyXG4gIH0gZWxzZSB7XHJcbiAgICB4ID0gMDtcclxuICAgIHkgPSAwO1xyXG4gIH1cclxuICB2YXIgb2Zmc2V0ID0gcmFkaXVzICogTWF0aC50YW4oTWF0aC5QSSAvIDgpO1xyXG4gIG9mZnNldCA9IE1hdGgucm91bmQxMChvZmZzZXQsIC0xKTtcclxuICB2YXIgcG9seSA9IG5ldyBQb2x5KFtcclxuICAgIG5ldyBQb2ludCh4IC0gcmFkaXVzLCB5IC0gb2Zmc2V0KSxcclxuICAgIG5ldyBQb2ludCh4IC0gcmFkaXVzLCB5ICsgb2Zmc2V0KSxcclxuICAgIG5ldyBQb2ludCh4IC0gb2Zmc2V0LCB5ICsgcmFkaXVzKSxcclxuICAgIG5ldyBQb2ludCh4ICsgb2Zmc2V0LCB5ICsgcmFkaXVzKSxcclxuICAgIG5ldyBQb2ludCh4ICsgcmFkaXVzLCB5ICsgb2Zmc2V0KSxcclxuICAgIG5ldyBQb2ludCh4ICsgcmFkaXVzLCB5IC0gb2Zmc2V0KSxcclxuICAgIG5ldyBQb2ludCh4ICsgb2Zmc2V0LCB5IC0gcmFkaXVzKSxcclxuICAgIG5ldyBQb2ludCh4IC0gb2Zmc2V0LCB5IC0gcmFkaXVzKVxyXG4gIF0pO1xyXG4gIHJldHVybiBwb2x5O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzcXVhcmUgd2l0aCBzaWRlIGxlbmd0aCBnaXZlbiBieSBkb3VibGUgdGhlIHByb3ZpZGVkXHJcbiAqIHJhZGl1cywgY2VudGVyZWQgYXQgdGhlIG9yaWdpbi4gVmVydGljZXMgb2YgcG9seWdvbiBhcmUgaW4gQ1dcclxuICogb3JkZXIuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBUaGUgbGVuZ3RoIG9mIGhhbGYgb2Ygb25lIHNpZGUuXHJcbiAqIEByZXR1cm4ge1BvbHl9IC0gVGhlIGNvbnN0cnVjdGVkIHNxdWFyZS5cclxuICovXHJcbk5hdk1lc2guX2dlb21ldHJ5LmdldFNxdWFyZSA9IGZ1bmN0aW9uKHJhZGl1cykge1xyXG4gIHZhciBwb2x5ID0gbmV3IFBvbHkoW1xyXG4gICAgbmV3IFBvaW50KC1yYWRpdXMsIHJhZGl1cyksXHJcbiAgICBuZXcgUG9pbnQocmFkaXVzLCByYWRpdXMpLFxyXG4gICAgbmV3IFBvaW50KHJhZGl1cywgLXJhZGl1cyksXHJcbiAgICBuZXcgUG9pbnQoLXJhZGl1cywgLXJhZGl1cylcclxuICBdKTtcclxuICByZXR1cm4gcG9seTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHVwcGVyIG9yIGxvd2VyIGRpYWdvbmFsIG9mIGEgc3F1YXJlIG9mIHRoZSBnaXZlblxyXG4gKiByYWRpdXMuIFxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gVGhlIGxlbmd0aCBvZiBoYWxmIG9mIG9uZSBzaWRlIG9mIHRoZVxyXG4gKiAgIHNxdWFyZSB0byBnZXQgdGhlIGRpYWdvbmFsIG9mLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY29ybmVyIC0gT25lIG9mIG5lLCBzZSwgbncsIHN3IGluZGljYXRpbmcgd2hpY2hcclxuICogICBjb3JuZXIgc2hvdWxkIGJlIGZpbGxlZC5cclxuICogQHJldHVybiB7UG9seX0gLSBUaGUgZGlhZ29uYWwgc2hhcGUuXHJcbiAqL1xyXG5OYXZNZXNoLl9nZW9tZXRyeS5nZXREaWFnb25hbCA9IGZ1bmN0aW9uKHJhZGl1cywgY29ybmVyKSB7XHJcbiAgdmFyIHR5cGVzID0ge1xyXG4gICAgXCJuZVwiOiBbW3JhZGl1cywgLXJhZGl1c10sIFtyYWRpdXMsIHJhZGl1c10sIFstcmFkaXVzLCAtcmFkaXVzXV0sXHJcbiAgICBcInNlXCI6IFtbcmFkaXVzLCByYWRpdXNdLCBbLXJhZGl1cywgcmFkaXVzXSwgW3JhZGl1cywgLXJhZGl1c11dLFxyXG4gICAgXCJzd1wiOiBbWy1yYWRpdXMsIHJhZGl1c10sIFstcmFkaXVzLCAtcmFkaXVzXSwgW3JhZGl1cywgcmFkaXVzXV0sXHJcbiAgICBcIm53XCI6IFtbLXJhZGl1cywgLXJhZGl1c10sIFtyYWRpdXMsIC1yYWRpdXNdLCBbLXJhZGl1cywgcmFkaXVzXV1cclxuICB9O1xyXG4gIHZhciBwb2ludHMgPSB0eXBlc1tjb3JuZXJdLm1hcChmdW5jdGlvbihtdWwpIHtcclxuICAgIHJldHVybiBuZXcgUG9pbnQobXVsWzBdLCBtdWxbMV0pO1xyXG4gIH0pO1xyXG4gIHJldHVybiBuZXcgUG9seShwb2ludHMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdpdmVuIHR3byBzZXRzIG9mIHBvbHlnb25zLCByZXR1cm4gaW5kaWNlcyBvZiB0aGUgb25lcyBpbiB0aGUgYmx1ZVxyXG4gKiBzZXQgdGhhdCBhcmUgaW50ZXJzZWN0ZWQgYnkgb25lcyBpbiByZWQuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7QXJyYXkuPFBvbHk+fSByZWRcclxuICogQHBhcmFtIHtBcnJheS48UG9seT59IGJsdWVcclxuICogQHJldHVybiB7QXJyYXkuPGludGVnZXI+fSAtIFRoZSBpbmRpY2VzIG9mIHRoZSBpbnRlcnNlY3RlZCBibHVlXHJcbiAqICAgcG9seXMuXHJcbiAqL1xyXG5OYXZNZXNoLl9nZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24ocmVkLCBibHVlKSB7XHJcbiAgdmFyIGluZGljZXMgPSBbXTtcclxuICAvLyBOYWl2ZSBzb2x1dGlvbi5cclxuICBibHVlLmZvckVhY2goZnVuY3Rpb24ocG9seSwgaSkge1xyXG4gICAgdmFyIGludGVyc2VjdHMgPSByZWQuc29tZShmdW5jdGlvbihwb2x5Yikge1xyXG4gICAgICByZXR1cm4gcG9seS5pbnRlcnNlY3RzKHBvbHliKTtcclxuICAgIH0pO1xyXG4gICAgaWYgKGludGVyc2VjdHMpIHtcclxuICAgICAgaW5kaWNlcy5wdXNoKGkpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiBpbmRpY2VzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFuIEFyZWEgaXMgYW4gb2JqZWN0IHRoYXQgaG9sZHMgYSBwb2x5Z29uIHJlcHJlc2VudGluZyBhIHNwYWNlXHJcbiAqIGFsb25nIHdpdGggaXRzIGhvbGVzLiBBbiBBcmVhIGNhbiByZXByZXNlbnQsIGZvciBleGFtcGxlLCBhXHJcbiAqIHRyYXZlcnNhYmxlIHJlZ2lvbiwgaWYgd2UgY29uc2lkZXIgdGhlIG5vbi1ob2xlIGFyZWEgb2YgdGhlXHJcbiAqIHBvbHlnb24gYXMgYmVpbmcgdHJhdmVyc2FibGUsIG9yIHRoZSBvcHBvc2l0ZSwgaWYgd2UgY29uc2lkZXJcclxuICogdGhlIG5vbi1ob2xlIGFyZWEgYXMgYmVpbmcgc29saWQsIGJsb2NraW5nIG1vdmVtZW50LlxyXG4gKiBAdHlwZWRlZiBBcmVhXHJcbiAqIEB0eXBlIHtvYmplY3R9XHJcbiAqIEBwcm9wZXJ0eSB7UG9seX0gcG9seWdvbiAtIFRoZSBwb2x5Z29uIGRlZmluaW5nIHRoZSBvdXRzaWRlIG9mIHRoZVxyXG4gKiAgIGFyZWEuXHJcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPFBvbHk+fSBob2xlcyAtIFRoZSBob2xlcyBpbiB0aGUgcG9seWdvbiBmb3IgdGhpc1xyXG4gKiAgIGFyZWEuXHJcbiAqL1xyXG4vKipcclxuICogR2l2ZW4gYSBQb2x5VHJlZSwgcmV0dXJuIGFuIGFycmF5IG9mIGFyZWFzIGFzc3VtaW5nIGV2ZW4tb2RkIGZpbGxcclxuICogb3JkZXJpbmcuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Q2xpcHBlckxpYi5QYXRoc30gcGF0aHMgLSBUaGUgcGF0aHMgb3V0cHV0IGZyb20gc29tZVxyXG4gKiAgIG9wZXJhdGlvbi4gUGF0aHMgc2hvdWxkIGJlIG5vbi1vdmVybGFwcGluZywgaS5lLiB0aGUgZWRnZXMgb2ZcclxuICogICByZXByZXNlbnRlZCBwb2x5Z29ucyBzaG91bGQgbm90IGJlIG92ZXJsYXBwaW5nLCBidXQgcG9seWdvbnNcclxuICogICBtYXkgYmUgZnVsbHkgY29udGFpbmVkIGluIG9uZSBhbm90aGVyLiBQYXRocyBzaG91bGQgYWxyZWFkeVxyXG4gKiAgIGJlIHNjYWxlZCB1cC5cclxuICogQHBhcmFtIHtpbnRlZ2VyfSBbc2NhbGU9MTAwXSAtIFRoZSBzY2FsZSB0byB1c2Ugd2hlbiBicmluZ2luZyB0aGVcclxuICogICBDbGlwcGVyIHBhdGhzIGRvd24gdG8gc2l6ZS5cclxuICogQHJldHVybiB7QXJyYXkuPEFyZWE+fSAtIFRoZSBhcmVhcyByZXByZXNlbnRlZCBieSB0aGUgcG9seXRyZWUuXHJcbiAqL1xyXG5OYXZNZXNoLl9nZW9tZXRyeS5nZXRBcmVhcyA9IGZ1bmN0aW9uKHBhdGhzLCBzY2FsZSkge1xyXG4gIGlmICh0eXBlb2Ygc2NhbGUgPT0gJ3VuZGVmaW5lZCcpIHNjYWxlID0gTmF2TWVzaC5fZ2VvbWV0cnkuc2NhbGU7XHJcbiAgLy8gV2UgYXJlIHJlYWxseSBvbmx5IGNvbmNlcm5lZCB3aXRoIGdldHRpbmcgdGhlIHBhdGhzIGludG8gYVxyXG4gIC8vIHBvbHl0cmVlIHN0cnVjdHVyZS5cclxuICB2YXIgY3ByID0gTmF2TWVzaC5fZ2VvbWV0cnkuY3ByO1xyXG4gIGNwci5DbGVhcigpO1xyXG4gIGNwci5BZGRQYXRocyhwYXRocywgQ2xpcHBlckxpYi5Qb2x5VHlwZS5wdFN1YmplY3QsIHRydWUpO1xyXG4gIHZhciB1bmlvbmVkX3NoYXBlc19wb2x5dHJlZSA9IG5ldyBDbGlwcGVyTGliLlBvbHlUcmVlKCk7XHJcbiAgY3ByLkV4ZWN1dGUoXHJcbiAgICBDbGlwcGVyTGliLkNsaXBUeXBlLmN0VW5pb24sXHJcbiAgICB1bmlvbmVkX3NoYXBlc19wb2x5dHJlZSxcclxuICAgIENsaXBwZXJMaWIuUG9seUZpbGxUeXBlLnBmdEV2ZW5PZGQsXHJcbiAgICBudWxsKTtcclxuXHJcbiAgdmFyIGFyZWFzID0gW107XHJcblxyXG4gIHZhciBvdXRlcl9wb2x5Z29ucyA9IHVuaW9uZWRfc2hhcGVzX3BvbHl0cmVlLkNoaWxkcygpO1xyXG5cclxuICAvLyBPcmdhbml6ZSBzaGFwZXMgaW50byB0aGVpciBvdXRlciBwb2x5Z29ucyBhbmQgaG9sZXMsIGFzc3VtaW5nXHJcbiAgLy8gdGhhdCB0aGUgZmlyc3QgbGF5ZXIgb2YgcG9seWdvbnMgaW4gdGhlIHBvbHl0cmVlIHJlcHJlc2VudCB0aGVcclxuICAvLyBvdXRzaWRlIGVkZ2Ugb2YgdGhlIGRlc2lyZWQgYXJlYXMuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRlcl9wb2x5Z29ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIG91dGVyX3BvbHlnb24gPSBvdXRlcl9wb2x5Z29uc1tpXTtcclxuICAgIHZhciBjb250b3VyID0gb3V0ZXJfcG9seWdvbi5Db250b3VyKCk7XHJcbiAgICBDbGlwcGVyTGliLkpTLlNjYWxlRG93blBhdGgoY29udG91ciwgc2NhbGUpO1xyXG4gICAgdmFyIGFyZWEgPSB7XHJcbiAgICAgIHBvbHlnb246IGNvbnRvdXIsXHJcbiAgICAgIGhvbGVzOiBbXVxyXG4gICAgfTtcclxuXHJcbiAgICBvdXRlcl9wb2x5Z29uLkNoaWxkcygpLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcclxuICAgICAgdmFyIGNvbnRvdXIgPSBjaGlsZC5Db250b3VyKCk7XHJcbiAgICAgIENsaXBwZXJMaWIuSlMuU2NhbGVEb3duUGF0aChjaGlsZC5Db250b3VyKCksIHNjYWxlKTtcclxuICAgICAgLy8gQWRkIGFzIGEgaG9sZS5cclxuICAgICAgYXJlYS5ob2xlcy5wdXNoKGNvbnRvdXIpO1xyXG5cclxuICAgICAgLy8gQWRkIGNoaWxkcmVuIGFzIGFkZGl0aW9uYWwgb3V0ZXIgcG9seWdvbnMgdG8gYmUgZXhwYW5kZWQuXHJcbiAgICAgIGNoaWxkLkNoaWxkcygpLmZvckVhY2goZnVuY3Rpb24oY2hpbGRfb3V0ZXIpIHtcclxuICAgICAgICBvdXRlcl9wb2x5Z29ucy5wdXNoKGNoaWxkX291dGVyKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIGFyZWFzLnB1c2goYXJlYSk7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIENvbnZlcnQgQ2xpcHBlciBQYXRocyB0byBQb2x5cy5cclxuICBhcmVhcy5mb3JFYWNoKGZ1bmN0aW9uKGFyZWEpIHtcclxuICAgIGFyZWEucG9seWdvbiA9IE5hdk1lc2guX2dlb21ldHJ5LmNvbnZlcnRDbGlwcGVyVG9Qb2x5KGFyZWEucG9seWdvbik7XHJcbiAgICBhcmVhLmhvbGVzID0gYXJlYS5ob2xlcy5tYXAoTmF2TWVzaC5fZ2VvbWV0cnkuY29udmVydENsaXBwZXJUb1BvbHkpO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gYXJlYXM7XHJcbn07XHJcblxyXG4vKipcclxuICogT2Zmc2V0IGEgcG9seWdvbiBpbndhcmRzIChhcyBvcHBvc2VkIHRvIGRlZmxhdGluZyBpdCkuIFRoZSBwb2x5Z29uXHJcbiAqIHZlcnRpY2VzIHNob3VsZCBiZSBpbiBDQ1cgb3JkZXIgYW5kIHRoZSBwb2x5Z29uIHNob3VsZCBhbHJlYWR5IGJlXHJcbiAqIHNjYWxlZC5cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtDTFNoYXBlfSBzaGFwZSAtIFRoZSBzaGFwZSB0byBpbmZsYXRlIGlud2FyZHMuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgYW1vdW50IHRvIG9mZnNldCB0aGUgc2hhcGUuXHJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3NjYWxlPTEwMF0gLSBUaGUgc2NhbGUgZm9yIHRoZSBvcGVyYXRpb24uXHJcbiAqIEByZXR1cm4ge0NsaXBwZXJMaWIuUGF0aHN9IC0gVGhlIHJlc3VsdGluZyBzaGFwZSBmcm9tIG9mZnNldHRpbmcuXHJcbiAqICAgSWYgdGhlIHByb2Nlc3Mgb2Ygb2Zmc2V0dGluZyByZXN1bHRlZCBpbiB0aGUgaW50ZXJpb3Igc2hhcGVcclxuICogICBjbG9zaW5nIGNvbXBsZXRlbHksIHRoZW4gYW4gZW1wdHkgYXJyYXkgd2lsbCBiZSByZXR1cm5lZC4gVGhlXHJcbiAqICAgcmV0dXJuZWQgc2hhcGUgd2lsbCBzdGlsbCBiZSBzY2FsZWQgdXAsIGZvciB1c2UgaW4gb3RoZXJcclxuICogICBvcGVyYXRpb25zLlxyXG4gKi9cclxuTmF2TWVzaC5fZ2VvbWV0cnkub2Zmc2V0SW50ZXJpb3IgPSBmdW5jdGlvbihzaGFwZSwgb2Zmc2V0LCBzY2FsZSkge1xyXG4gIGlmICh0eXBlb2Ygc2NhbGUgPT0gJ3VuZGVmaW5lZCcpIHNjYWxlID0gTmF2TWVzaC5fZ2VvbWV0cnkuc2NhbGU7XHJcblxyXG4gIHZhciBjcHIgPSBOYXZNZXNoLl9nZW9tZXRyeS5jcHI7XHJcbiAgdmFyIGNvID0gTmF2TWVzaC5fZ2VvbWV0cnkuY287XHJcblxyXG4gIC8vIEZpcnN0LCBjcmVhdGUgYSBzaGFwZSB3aXRoIHRoZSBvdXRsaW5lIGFzIHRoZSBpbnRlcmlvci5cclxuICB2YXIgYm91bmRpbmdTaGFwZSA9IE5hdk1lc2guX2dlb21ldHJ5LmdldEJvdW5kaW5nU2hhcGVGb3JQYXRocyhbc2hhcGVdKTtcclxuXHJcbiAgY3ByLkNsZWFyKCk7XHJcbiAgY3ByLkFkZFBhdGgoYm91bmRpbmdTaGFwZSwgQ2xpcHBlckxpYi5Qb2x5VHlwZS5wdFN1YmplY3QsIHRydWUpO1xyXG4gIGNwci5BZGRQYXRoKHNoYXBlLCBDbGlwcGVyTGliLlBvbHlUeXBlLnB0Q2xpcCwgdHJ1ZSk7XHJcblxyXG4gIHZhciBzb2x1dGlvbl9wYXRocyA9IG5ldyBDbGlwcGVyTGliLlBhdGhzKCk7XHJcbiAgY3ByLkV4ZWN1dGUoQ2xpcHBlckxpYi5DbGlwVHlwZS5jdERpZmZlcmVuY2UsXHJcbiAgICBzb2x1dGlvbl9wYXRocyxcclxuICAgIENsaXBwZXJMaWIuUG9seUZpbGxUeXBlLnBmdE5vblplcm8sXHJcbiAgICBDbGlwcGVyTGliLlBvbHlGaWxsVHlwZS5wZnROb25aZXJvKTtcclxuXHJcbiAgLy8gT25jZSB3ZSBoYXZlIHRoZSBzaGFwZSBhcyBjcmVhdGVkIGFib3ZlLCBpbmZsYXRlIGl0LiBUaGlzIGdpdmVzXHJcbiAgLy8gYmV0dGVyIHJlc3VsdHMgdGhhbiB0cmVhdGluZyB0aGUgb3V0bGluZSBhcyB0aGUgZXh0ZXJpb3Igb2YgYVxyXG4gIC8vIHNoYXBlIGFuZCBkZWZsYXRpbmcgaXQuXHJcbiAgdmFyIG9mZnNldHRlZF9wYXRocyA9IG5ldyBDbGlwcGVyTGliLlBhdGhzKCk7XHJcblxyXG4gIGNvLkNsZWFyKCk7XHJcbiAgY28uQWRkUGF0aHMoc29sdXRpb25fcGF0aHMsIENsaXBwZXJMaWIuSm9pblR5cGUuanRTcXVhcmUsIENsaXBwZXJMaWIuRW5kVHlwZS5ldENsb3NlZFBvbHlnb24pO1xyXG4gIGNvLkV4ZWN1dGUob2Zmc2V0dGVkX3BhdGhzLCBvZmZzZXQgKiBzY2FsZSk7XHJcblxyXG4gIC8vIElmIHRoaXMgaXMgbm90IHRydWUgdGhlbiB0aGUgb2Zmc2V0dGluZyBwcm9jZXNzIHNocmFuayB0aGVcclxuICAvLyBvdXRsaW5lIGludG8gbm9uLWV4aXN0ZW5jZSBhbmQgb25seSB0aGUgYm91bmRpbmcgc2hhcGUgaXNcclxuICAvLyBsZWZ0LlxyXG4gIC8vID49IDIgaW4gY2FzZSB0aGUgb2Zmc2V0dGluZyBwcm9jZXNzIGlzb2xhdGVzIHBvcnRpb25zIG9mIHRoZVxyXG4gIC8vIG91dGxpbmUgKHNlZTogR2FtZVBhZCkuXHJcbiAgaWYgKG9mZnNldHRlZF9wYXRocy5sZW5ndGggPj0gMikge1xyXG4gICAgLy8gR2V0IG9ubHkgdGhlIHBhdGhzIGRlZmluaW5nIHRoZSBvdXRsaW5lcyB3ZSB3ZXJlIGludGVyZXN0ZWRcclxuICAgIC8vIGluLCBkaXNjYXJkaW5nIHRoZSBleHRlcmlvciBib3VuZGluZyBzaGFwZS5cclxuICAgIG9mZnNldHRlZF9wYXRocy5zaGlmdCgpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBvZmZzZXR0ZWRfcGF0aHMgPSBuZXcgQ2xpcHBlckxpYi5QYXRocygpO1xyXG4gIH1cclxuICByZXR1cm4gb2Zmc2V0dGVkX3BhdGhzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE9mZnNldCBhIHBvbHlnb24uIFRoZSBwb2x5Z29uIHZlcnRpY2VzIHNob3VsZCBiZSBpbiBDVyBvcmRlciBhbmRcclxuICogdGhlIHBvbHlnb24gc2hvdWxkIGFscmVhZHkgYmUgc2NhbGVkIHVwLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0NMU2hhcGV9IHNoYXBlIC0gVGhlIHNoYXBlIHRvIGluZmxhdGUgb3V0d2FyZHMuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgYW1vdW50IHRvIG9mZnNldCB0aGUgc2hhcGUuXHJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3NjYWxlPTEwMF0gLSBUaGUgc2NhbGUgZm9yIHRoZSBvcGVyYXRpb24uXHJcbiAqIEByZXR1cm4ge0NsaXBwZXJMaWIuUGF0aHN9IC0gVGhlIHJlc3VsdGluZyBzaGFwZSBmcm9tIG9mZnNldHRpbmcuXHJcbiAqICAgSWYgdGhlIHByb2Nlc3Mgb2Ygb2Zmc2V0dGluZyByZXN1bHRlZCBpbiB0aGUgaW50ZXJpb3Igc2hhcGVcclxuICogICBjbG9zaW5nIGNvbXBsZXRlbHksIHRoZW4gYW4gZW1wdHkgYXJyYXkgd2lsbCBiZSByZXR1cm5lZC4gVGhlXHJcbiAqICAgcmV0dXJuZWQgc2hhcGUgd2lsbCBzdGlsbCBiZSBzY2FsZWQgdXAsIGZvciB1c2UgaW4gb3RoZXJcclxuICogICBvcGVyYXRpb25zLlxyXG4gKi9cclxuTmF2TWVzaC5fZ2VvbWV0cnkub2Zmc2V0RXh0ZXJpb3IgPSBmdW5jdGlvbihzaGFwZSwgb2Zmc2V0LCBzY2FsZSkge1xyXG4gIC8vIFRPRE9cclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBhIGNvbnZleCBwYXJ0aXRpb24gb2YgdGhlIHByb3ZpZGVkIHBvbHlnb24sIGV4Y2x1ZGluZ1xyXG4gKiBhcmVhcyBnaXZlbiBieSB0aGUgaG9sZXMuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7UG9seX0gb3V0bGluZSAtIFRoZSBwb2x5Z29uIG91dGxpbmUgb2YgdGhlIGFyZWEgdG9cclxuICogICBwYXJ0aXRpb24uXHJcbiAqIEBwYXJhbSB7QXJyYXkuPFBvbHk+fSBob2xlcyAtIEhvbGVzIGluIHRoZSBwb2x5Z29uLlxyXG4gKiBAcmV0dXJuIHtBcnJheS48UG9seT59IC0gUG9seWdvbnMgcmVwcmVzZW50aW5nIHRoZSBwYXJ0aXRpb25lZFxyXG4gKiAgIHNwYWNlLlxyXG4gKi9cclxuTmF2TWVzaC5fZ2VvbWV0cnkuY29udmV4UGFydGl0aW9uID0gZnVuY3Rpb24ob3V0bGluZSwgaG9sZXMpIHtcclxuICAvLyBFbnN1cmUgcHJvcGVyIHZlcnRleCBvcmRlciBmb3IgaG9sZXMgYW5kIG91dGxpbmUuXHJcbiAgb3V0bGluZS5zZXRPcmllbnRhdGlvbihcIkNDV1wiKTtcclxuICBob2xlcy5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcclxuICAgIGUuc2V0T3JpZW50YXRpb24oXCJDV1wiKTtcclxuICAgIGUuaG9sZSA9IHRydWU7XHJcbiAgfSk7XHJcbiAgXHJcbiAgcmV0dXJuIHBhcnRpdGlvbihvdXRsaW5lLCBob2xlcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogUGFydGl0aW9uIHRoZSBwcm92aWRlZCBhcmVhLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0FyZWF9IGFyZWEgLSBUaGUgQXJlYSB0byBwYXJ0aXRpb24uXHJcbiAqIEByZXR1cm4ge0FycmF5LjxQb2x5Pn0gLSBQb2x5Z29ucyByZXByZXNlbnRpbmcgdGhlIHBhcnRpdGlvbmVkXHJcbiAqICAgc3BhY2UuXHJcbiAqL1xyXG5OYXZNZXNoLl9nZW9tZXRyeS5wYXJ0aXRpb25BcmVhID0gZnVuY3Rpb24oYXJlYSkge1xyXG4gIHJldHVybiBOYXZNZXNoLl9nZW9tZXRyeS5jb252ZXhQYXJ0aXRpb24oYXJlYS5wb2x5Z29uLCBhcmVhLmhvbGVzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQYXJ0aXRpb24gdGhlIHByb3ZpZGVkIGFyZWFzLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0FycmF5LjxBcmVhPn0gYXJlYXMgLSBUaGUgYXJlYXMgdG8gcGFydGl0aW9uLlxyXG4gKiBAcmV0dXJuIHtBcnJheS48UG9seT59IC0gUG9seWdvbnMgcmVwcmVzZW50aW5nIHRoZSBwYXJ0aXRpb25lZFxyXG4gKiAgIHNwYWNlLlxyXG4gKi9cclxuTmF2TWVzaC5fZ2VvbWV0cnkucGFydGl0aW9uQXJlYXMgPSBmdW5jdGlvbihhcmVhcykge1xyXG4gIHZhciBwb2x5cyA9IGFyZWFzLm1hcChOYXZNZXNoLl9nZW9tZXRyeS5wYXJ0aXRpb25BcmVhKTtcclxuICByZXR1cm4gTmF2TWVzaC5fdXRpbC5mbGF0dGVuKHBvbHlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIHBvaW50IGluIENsaXBwZXJMaWIgaXMganVzdCBhbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzXHJcbiAqIFggYW5kIFkgY29ycmVzcG9uZGluZyB0byBhIHBvaW50LlxyXG4gKiBAdHlwZWRlZiBDTFBvaW50XHJcbiAqIEB0eXBlIHtvYmplY3R9XHJcbiAqIEBwcm9wZXJ0eSB7aW50ZWdlcn0gWCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxyXG4gKiBAcHJvcGVydHkge2ludGVnZXJ9IFkgLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBwb2ludC5cclxuICovXHJcbi8qKlxyXG4gKiBBIHNoYXBlIGluIENsaXBwZXJMaWIgaXMgc2ltcGx5IGFuIGFycmF5IG9mIENMUG9pbnRzLlxyXG4gKiBAdHlwZWRlZiBDTFNoYXBlXHJcbiAqIEB0eXBlIHtBcnJheS48Q0xQb2ludD59XHJcbiAqL1xyXG4vKipcclxuICogVGFrZXMgYSBQb2x5IGFuZCBjb252ZXJ0cyBpdCBpbnRvIGEgQ2xpcHBlckxpYiBwb2x5Z29uLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge1BvbHl9IHBvbHkgLSBUaGUgUG9seSB0byBjb252ZXJ0LlxyXG4gKiBAcmV0dXJuIHtDTFNoYXBlfSAtIFRoZSBjb252ZXJ0ZWQgcG9seWdvbi5cclxuICovXHJcbk5hdk1lc2guX2dlb21ldHJ5LmNvbnZlcnRQb2x5VG9DbGlwcGVyID0gZnVuY3Rpb24ocG9seSkge1xyXG4gIHJldHVybiBwb2x5LnBvaW50cy5tYXAoZnVuY3Rpb24ocCkge1xyXG4gICAgcmV0dXJuIHtYOnAueCwgWTpwLnl9O1xyXG4gIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYSBDbGlwcGVyTGliIHNoYXBlIGludG8gYSBQb2x5LlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0NMU2hhcGV9IGNsaXAgLSBUaGUgc2hhcGUgdG8gY29udmVydC5cclxuICogQHJldHVybiB7UG9seX0gLSBUaGUgY29udmVydGVkIHNoYXBlLlxyXG4gKi9cclxuTmF2TWVzaC5fZ2VvbWV0cnkuY29udmVydENsaXBwZXJUb1BvbHkgPSBmdW5jdGlvbihjbGlwKSB7XHJcbiAgdmFyIHBvaW50cyA9IGNsaXAubWFwKGZ1bmN0aW9uKHApIHtcclxuICAgIHJldHVybiBuZXcgUG9pbnQocC5YLCBwLlkpO1xyXG4gIH0pO1xyXG4gIHJldHVybiBuZXcgUG9seShwb2ludHMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIGEgYm91bmRpbmcgc2hhcGUgZm9yIHBhdGhzIHdpdGggYSBnaXZlbiBidWZmZXIuIElmIHVzaW5nXHJcbiAqIGZvciBhbiBvZmZzZXR0aW5nIG9wZXJhdGlvbiwgdGhlIHJldHVybmVkIENMU2hhcGUgZG9lcyBOT1QgbmVlZCB0b1xyXG4gKiBiZSBzY2FsZWQgdXAuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7QXJyYXkuPENMU2hhcGU+fSBwYXRocyAtIFRoZSBwYXRocyB0byBnZXQgYSBib3VuZGluZyBzaGFwZSBmb3IuXHJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW2J1ZmZlcj01XSAtIEhvdyBtYW55IHVuaXRzIHRvIHBhZCB0aGUgYm91bmRpbmdcclxuICogICByZWN0YW5nbGUuXHJcbiAqIEByZXR1cm4ge0NMU2hhcGV9IC0gQSBib3VuZGluZyByZWN0YW5nbGUgZm9yIHRoZSBwYXRocy5cclxuICovXHJcbk5hdk1lc2guX2dlb21ldHJ5LmdldEJvdW5kaW5nU2hhcGVGb3JQYXRocyA9IGZ1bmN0aW9uKHBhdGhzLCBidWZmZXIpIHtcclxuICBpZiAodHlwZW9mIGJ1ZmZlciA9PSBcInVuZGVmaW5lZFwiKSBidWZmZXIgPSA1O1xyXG4gIHZhciBib3VuZHMgPSBDbGlwcGVyTGliLkNsaXBwZXIuR2V0Qm91bmRzKHBhdGhzKTtcclxuICBib3VuZHMubGVmdCAtPSBidWZmZXI7XHJcbiAgYm91bmRzLnRvcCAtPSBidWZmZXI7XHJcbiAgYm91bmRzLnJpZ2h0ICs9IGJ1ZmZlcjtcclxuICBib3VuZHMuYm90dG9tICs9IGJ1ZmZlcjtcclxuICB2YXIgc2hhcGUgPSBbXTtcclxuICBzaGFwZS5wdXNoKHtYOiBib3VuZHMucmlnaHQsIFk6IGJvdW5kcy5ib3R0b219KTtcclxuICBzaGFwZS5wdXNoKHtYOiBib3VuZHMubGVmdCwgWTogYm91bmRzLmJvdHRvbX0pO1xyXG4gIHNoYXBlLnB1c2goe1g6IGJvdW5kcy5sZWZ0LCBZOiBib3VuZHMudG9wfSk7XHJcbiAgc2hhcGUucHVzaCh7WDogYm91bmRzLnJpZ2h0LCBZOiBib3VuZHMudG9wfSk7XHJcbiAgcmV0dXJuIHNoYXBlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEhvbGRzIHV0aWxpdHkgbWV0aG9kcyBuZWVkZWQgYnkgdGhlIG5hdm1lc2guXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5OYXZNZXNoLl91dGlsID0ge307XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBhbmQgcmV0dXJucyB0aGUgaXRlbXMgYXQgdGhlIGluZGljZXMgaWRlbnRpZmllZCBpblxyXG4gKiBgaW5kaWNlc2AuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeSAtIFRoZSBhcnJheSB0byByZW1vdmUgaXRlbXMgZnJvbS5cclxuICogQHBhcmFtIHtBcnJheS48aW50ZWdlcj59IGluZGljZXMgLSBUaGUgaW5kaWNlcyBmcm9tIHdoaWNoIHRvXHJcbiAqICAgcmVtb3ZlIHRoZSBpdGVtcyBmcm9tIGluIGFyeS4gSW5kaWNlcyBzaG91bGQgYmUgdW5pcXVlIGFuZFxyXG4gKiAgIGVhY2ggc2hvdWxkIGJlIGxlc3MgdGhhbiB0aGUgbGVuZ3RoIG9mIGBhcnlgIGl0c2VsZi5cclxuICogQHJldHVybiB7QXJyYXl9IC0gVGhlIGl0ZW1zIHJlbW92ZWQgZnJvbSBhcnkuXHJcbiAqL1xyXG5OYXZNZXNoLl91dGlsLnNwbGljZSA9IGZ1bmN0aW9uKGFyeSwgaW5kaWNlcykge1xyXG4gIGluZGljZXMgPSBpbmRpY2VzLnNvcnQoTmF2TWVzaC5fdXRpbC5fbnVtYmVyQ29tcGFyZSkucmV2ZXJzZSgpO1xyXG4gIHZhciByZW1vdmVkID0gW107XHJcbiAgaW5kaWNlcy5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcclxuICAgIHJlbW92ZWQucHVzaChhcnkuc3BsaWNlKGksIDEpWzBdKTtcclxuICB9KTtcclxuICByZXR1cm4gcmVtb3ZlZDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wYXJpc29uIGZ1bmN0aW9uIGZvciBudW1iZXJzLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuTmF2TWVzaC5fdXRpbC5fbnVtYmVyQ29tcGFyZSA9IGZ1bmN0aW9uKGEsIGIpIHtcclxuICBpZiAoYSA8IGIpIHtcclxuICAgIHJldHVybiAtMTtcclxuICB9IGVsc2UgaWYgKGEgPiBiKSB7XHJcbiAgICByZXR1cm4gMTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRha2UgYW4gYXJyYXkgb2YgYXJyYXlzIGFuZCBmbGF0dGVuIGl0LlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0gIHtBcnJheS48QXJyYXkuPCo+Pn0gYXJ5IC0gVGhlIGFycmF5IHRvIGZsYXR0ZW4uXHJcbiAqIEByZXR1cm4ge0FycmF5LjwqPn0gLSBUaGUgZmxhdHRlbmVkIGFycmF5LlxyXG4gKi9cclxuTmF2TWVzaC5fdXRpbC5mbGF0dGVuID0gZnVuY3Rpb24oYXJ5KSB7XHJcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFyeSk7XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqIEBtb2R1bGUgTWFwUGFyc2VyXHJcbiAqL1xyXG5cclxudmFyIEFjdGlvblZhbHVlcyA9IHJlcXVpcmUoJy4vYWN0aW9uLXZhbHVlcycpO1xyXG52YXIgZ2VvID0gcmVxdWlyZSgnLi9nZW9tZXRyeScpO1xyXG52YXIgUG9pbnQgPSBnZW8uUG9pbnQ7XHJcbnZhciBQb2x5ID0gZ2VvLlBvbHk7XHJcblxyXG4vKipcclxuICogQ29udGFpbnMgdXRpbGl0aWVzIGZvciBnZW5lcmF0aW5nIHVzYWJsZSBtYXAgcmVwcmVzZW50YXRpb25zIGZyb21cclxuICogbWFwIHRpbGVzLlxyXG4gKi9cclxudmFyIE1hcFBhcnNlciA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEFuIG9iamVjdCB3aXRoIHggYW5kIHkgcHJvcGVydGllcyB0aGF0IHJlcHJlc2VudHMgYSBjb29yZGluYXRlIHBhaXIuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEB0eXBlZGVmIE1QUG9pbnRcclxuICogQHR5cGUge29iamVjdH1cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBsb2NhdGlvbi5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBsb2NhdGlvbi5cclxuICovXHJcblxyXG4vKipcclxuICogQSBTaGFwZSBpcyBhbiBhcnJheSBvZiBwb2ludHMsIHdoZXJlIHBvaW50cyBhcmUgb2JqZWN0cyB3aXRoIHggYW5kIHkgcHJvcGVydGllcyB3aGljaCByZXByZXNlbnQgY29vcmRpbmF0ZXMgb24gdGhlIG1hcC5cclxuICogQHByaXZhdGVcclxuICogQHR5cGVkZWYgTVBTaGFwZVxyXG4gKiBAdHlwZSB7QXJyYXkuPE1QUG9pbnQ+fVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBbiBvYmplY3Qgd2l0aCByIGFuZCBjIHByb3BlcnRpZXMgdGhhdCByZXByZXNlbnRzIGEgcm93L2NvbHVtblxyXG4gKiBsb2NhdGlvbiBpbiBhIDJkIGFycmF5LlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAdHlwZWRlZiBBcnJheUxvY1xyXG4gKiBAdHlwZSB7b2JqZWN0fVxyXG4gKiBAcHJvcGVydHkge2ludGVnZXJ9IHIgLSBUaGUgcm93IG51bWJlciBvZiB0aGUgYXJyYXkgbG9jYXRpb24uXHJcbiAqIEBwcm9wZXJ0eSB7aW50ZWdlcn0gYyAtIFRoZSBjb2x1bW4gbnVtYmVyIG9mIHRoZSBhcnJheSBsb2NhdGlvbi5cclxuICovXHJcblxyXG4vKipcclxuICogVGhlIDJkIHRpbGUgZ3JpZCBmcm9tIGB0YWdwcm8ubWFwYCwgb3IgYSBzaW1pbGFyIDJkIGdyaWQgcmVzdWx0aW5nXHJcbiAqIGZyb20gYW4gb3BlcmF0aW9uIG9uIHRoZSBvcmlnaW5hbC5cclxuICogQHR5cGVkZWYgTWFwVGlsZXNcclxuICogQHR5cGUge0FycmF5LjxBcnJheS48bnVtYmVyPj59XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEEgQ2VsbCBpcyBqdXN0IGFuIGFycmF5IHRoYXQgaG9sZHMgdGhlIHZhbHVlcyBvZiB0aGUgZm91ciBhZGphY2VudFxyXG4gKiBjZWxscyBpbiBhIDJkIGFycmF5LCByZWNvcmRlZCBpbiBDQ1cgb3JkZXIgc3RhcnRpbmcgZnJvbSB0aGUgdXBwZXItXHJcbiAqIGxlZnQgcXVhZHJhbnQuIEZvciBleGFtcGxlLCBnaXZlbiBhIDJkIGFycmF5OlxyXG4gKiBbWzEsIDAsIDFdLFxyXG4gKiAgWzEsIDAsIDBdLFxyXG4gKiAgWzEsIDEsIDFdXVxyXG4gKiB3ZSB3b3VsZCBnZW5lcmF0ZSB0aGUgcmVwcmVzZW50YXRpb24gdXNpbmcgdGhlIGNlbGxzOlxyXG4gKiBbMSwgMCwgIFswLCAxLCAgWzEsIDAsICBbMCwgMCAgXHJcbiAqICAxLCAwXSAgIDAsIDBdICAgMSwgMV0gICAxLCAxXS5cclxuICogVGhlc2UgY29ycmVzcG9uZCB0byB0aGUgcGFydHMgb2YgYSB0aWxlIHRoYXQgd291bGQgYmUgY292ZXJlZCBpZlxyXG4gKiBwbGFjZWQgYXQgdGhlIGludGVyc2VjdGlvbiBvZiA0IHRpbGVzLiBUaGUgdmFsdWUgMCByZXByZXNlbnRzIGFcclxuICogYmxhbmsgbG9jYXRpb24sIDEgaW5kaWNhdGVzIHRoYXQgdGhlIHF1YWRyYW50IGlzIGNvdmVyZWQuXHJcbiAqIFRvIHJlcHJlc2VudCBob3cgc3VjaCB0aWxlcyB3b3VsZCBiZSBjb3ZlcmVkIGluIHRoZSBjYXNlIG9mIGRpYWdvbmFsXHJcbiAqIHRpbGVzLCB3ZSB1c2UgMiB0byBpbmRpY2F0ZSB0aGF0IHRoZSBsb3dlciBkaWFnb25hbCBvZiBhIHF1YWRyYW50IGlzXHJcbiAqIGZpbGxlZCwgYW5kIDMgdG8gaW5kaWNhdGUgdGhhdCB0aGUgdXBwZXIgZGlhZ29uYWwgb2YgYSBxdWFkcmFudCBpc1xyXG4gKiBmaWxsZWQuIFRoZSB0aWxlcyBhdmFpbGFibGUgZm9yY2UgdGhlIGRpYWdvbmFscyBvZiBlYWNoIHF1YWRyYW50IHRvXHJcbiAqIHBvaW50IHRvIHRoZSBjZW50ZXIsIHNvIHRoaXMgaXMgc3VmZmljaWVudCBmb3IgZGVzY3JpYmluZyBhbGxcclxuICogcG9zc2libGUgb3ZlcmxhcHBpbmdzLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAdHlwZWRlZiBDZWxsXHJcbiAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cclxuICovXHJcblxyXG4vKipcclxuICogQ2FsbGJhY2sgdGhhdCByZWNlaXZlcyBlYWNoIG9mIHRoZSBlbGVtZW50cyBpbiB0aGUgMmQgbWFwIGZ1bmN0aW9uLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY2FsbGJhY2sgbWFwQ2FsbGJhY2tcclxuICogQHBhcmFtIHsqfSAtIFRoZSBlbGVtZW50IGZyb20gdGhlIDJkIGFycmF5LlxyXG4gKiBAcmV0dXJuIHsqfSAtIFRoZSB0cmFuc2Zvcm1lZCBlbGVtZW50LlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBcHBsaWVzIGBmbmAgdG8gZXZlcnkgaW5kaXZpZHVhbCBlbGVtZW50IG9mIHRoZSAyZCBhcnJheSBgYXJyYC5cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPCo+Pn0gYXJyIC0gVGhlIDJkIGFycmF5IHRvIHVzZS5cclxuICogQHBhcmFtIHttYXBDYWxsYmFja30gZm4gLSBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBlbGVtZW50LlxyXG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPCo+Pn0gLSBUaGUgMmQgYXJyYXkgYWZ0ZXIgdGhlIGZ1bmN0aW9uXHJcbiAqICAgaGFzIGJlZW4gYXBwbGllZCB0byBlYWNoIGVsZW1lbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXAyZChhcnIsIGZuKSB7XHJcbiAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24ocm93KSB7XHJcbiAgICByZXR1cm4gcm93Lm1hcChmbik7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIDEgaWYgYSB0aWxlIHZhbHVlIGlzIG9uZSB0aGF0IHdlIHdhbnQgdG8gY29uc2lkZXIgYXNcclxuICogYSB3YWxsICh3ZSBjb25zaWRlciBlbXB0eSBzcGFjZSB0byBiZSBhIHdhbGwpLCBvciB0aGUgdGlsZSB2YWx1ZVxyXG4gKiBpdHNlbGYgZm9yIGRpYWdvbmFsIHdhbGxzLiAwIGlzIHJldHVybmVkIG90aGVyd2lzZS5cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IGVsdCAtIFRoZSB0aWxlIHZhbHVlIGF0IGEgcm93L2NvbHVtbiBsb2NhdGlvblxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIG51bWJlciB0byBpbnNlcnQgaW4gcGxhY2Ugb2YgdGhlIHRpbGUgdmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0JhZENlbGwoZWx0KSB7XHJcbiAgdmFyIGJhZF9jZWxscyA9IFsxLCAxLjEsIDEuMiwgMS4zLCAxLjRdO1xyXG4gIGlmKGJhZF9jZWxscy5pbmRleE9mKGVsdCkgIT09IC0xKSB7XHJcbiAgICAvLyBFbnN1cmUgZW1wdHkgc3BhY2VzIGdldCBtYXBwZWQgdG8gZnVsbCB0aWxlcyBzbyBvdXRzaWRlIG9mXHJcbiAgICAvLyBtYXAgaXNuJ3QgdHJhY2VkLlxyXG4gICAgaWYgKGVsdCA9PSAwKSB7XHJcbiAgICAgIHJldHVybiAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGVsdDtcclxuICAgIH1cclxuICAgIHJldHVybiBlbHQ7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBwcm92aWRlZCBhcnJheSBpbnRvIGl0cyBlcXVpdmFsZW50IHJlcHJlc2VudGF0aW9uXHJcbiAqIHVzaW5nIGNlbGxzLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge01hcFRpbGVzfSBhcnIgLSBcclxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPENlbGw+Pn0gLSBUaGUgY29udmVydGVkIGFycmF5LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVDb250b3VyR3JpZChhcnIpIHtcclxuICAvLyBHZW5lcmF0ZSBncmlkIGZvciBob2xkaW5nIHZhbHVlcy5cclxuICB2YXIgY29udG91cl9ncmlkID0gbmV3IEFycmF5KGFyci5sZW5ndGggLSAxKTtcclxuICBmb3IgKHZhciBuID0gMDsgbiA8IGNvbnRvdXJfZ3JpZC5sZW5ndGg7IG4rKykge1xyXG4gICAgY29udG91cl9ncmlkW25dID0gbmV3IEFycmF5KGFyclswXS5sZW5ndGggLSAxKTtcclxuICB9XHJcbiAgdmFyIGNvcm5lcnMgPSBbMS4xLCAxLjIsIDEuMywgMS40XTtcclxuICAvLyBTcGVjaWZpZXMgdGhlIHJlc3VsdGluZyB2YWx1ZXMgZm9yIHRoZSBhYm92ZSBjb3JuZXIgdmFsdWVzLiBUaGUgaW5kZXhcclxuICAvLyBvZiB0aGUgb2JqZWN0cyBpbiB0aGlzIGFycmF5IGNvcnJlc3BvbmRzIHRvIHRoZSBwcm9wZXIgdmFsdWVzIGZvciB0aGVcclxuICAvLyBxdWFkcmFudCBvZiB0aGUgc2FtZSBpbmRleC5cclxuICB2YXIgY29ybmVyX3ZhbHVlcyA9IFtcclxuICAgIHsxLjE6IDMsIDEuMjogMCwgMS4zOiAyLCAxLjQ6IDF9LFxyXG4gICAgezEuMTogMCwgMS4yOiAzLCAxLjM6IDEsIDEuNDogMn0sXHJcbiAgICB7MS4xOiAzLCAxLjI6IDEsIDEuMzogMiwgMS40OiAwfSxcclxuICAgIHsxLjE6IDEsIDEuMjogMywgMS4zOiAwLCAxLjQ6IDJ9XHJcbiAgXTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IChhcnIubGVuZ3RoIC0gMSk7IGkrKykge1xyXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAoYXJyWzBdLmxlbmd0aCAtIDEpOyBqKyspIHtcclxuICAgICAgdmFyIGNlbGwgPSBbYXJyW2ldW2pdLCBhcnJbaV1baisxXSwgYXJyW2krMV1baisxXSwgYXJyW2krMV1bal1dO1xyXG4gICAgICAvLyBDb252ZXJ0IGNvcm5lciB0aWxlcyB0byBhcHByb3ByaWF0ZSByZXByZXNlbnRhdGlvbi5cclxuICAgICAgY2VsbC5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaSwgY2VsbCkge1xyXG4gICAgICAgIGlmIChjb3JuZXJzLmluZGV4T2YodmFsKSAhPT0gLTEpIHtcclxuICAgICAgICAgIGNlbGxbaV0gPSBjb3JuZXJfdmFsdWVzW2ldW3ZhbF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnRvdXJfZ3JpZFtpXVtqXSA9IGNlbGw7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBjb250b3VyX2dyaWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgdGVzdGluZyBlcXVhbGl0eSBvZiBpdGVtcy5cclxuICogQHByaXZhdGVcclxuICogQGNhbGxiYWNrIGNvbXBhcmlzb25DYWxsYmFja1xyXG4gKiBAcGFyYW0geyp9IC0gVGhlIGZpcnN0IGl0ZW0uXHJcbiAqIEBwYXJhbSB7Kn0gLSBUaGUgc2Vjb25kIGl0ZW0uXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IC0gV2hldGhlciBvciBub3QgdGhlIGl0ZW1zIGFyZSBlcXVhbC5cclxuICovXHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbG9jYXRpb24gb2Ygb2JqIGluIGFyciB3aXRoIGVxdWFsaXR5IGRldGVybWluZWQgYnkgY21wLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0FycmF5LjwqPn0gYXJyIC0gVGhlIGFycmF5IHRvIGJlIHNlYXJjaGVkLlxyXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRoZSBpdGVtIHRvIGZpbmQgYSBtYXRjaCBmb3IuXHJcbiAqIEBwYXJhbSB7Y29tcGFyaXNvbkNhbGxiYWNrfSBjbXAgLSBUaGUgY2FsbGJhY2sgdGhhdCBkZWZpbmVzXHJcbiAqICAgd2hldGhlciBgb2JqYCBtYXRjaGVzLlxyXG4gKiBAcmV0dXJuIHtpbnRlZ2VyfSAtIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCB0byBtYXRjaCBgb2JqYCxcclxuICogICBvciAtMSBpZiBubyBzdWNoIGVsZW1lbnQgd2FzIGxvY2F0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBmaW5kKGFyciwgb2JqLCBjbXApIHtcclxuICBpZiAodHlwZW9mIGNtcCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmIChjbXAoYXJyW2ldLCBvYmopKSB7XHJcbiAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb21wYXJlIHR3byBvYmplY3RzIGRlZmluaW5nIHJvdy9jb2wgbG9jYXRpb25zIGluIGFuIGFycmF5XHJcbiAqIGFuZCByZXR1cm4gdHJ1ZSBpZiB0aGV5IHJlcHJlc2VudCB0aGUgc2FtZSByb3cvY29sIGxvY2F0aW9uLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0FycmF5TG9jfSBlbHQxXHJcbiAqIEBwYXJhbSB7QXJyYXlMb2N9IGVsdDJcclxuICogQHJldHVybiB7Ym9vbGVhbn0gLSBXaGV0aGVyIG9yIG5vdCB0aGVzZSB0d28gYXJyYXkgbG9jYXRpb25zXHJcbiAqICAgcmVwcmVzZW50IHRoZSBzYW1lIHJvdy9jb2x1bW4uXHJcbiAqL1xyXG5mdW5jdGlvbiBlbHRDb21wYXJlKGVsdDEsIGVsdDIpIHtcclxuICByZXR1cm4gKGVsdDEuYyA9PSBlbHQyLmMgJiYgZWx0MS5yID09IGVsdDIucik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUYWtlcyBpbiB0aGUgdmVydGV4L2FjdGlvbiBpbmZvcm1hdGlvbiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBhcnJheXMsXHJcbiAqIHdoZXJlIGVhY2ggYXJyYXkgY29ycmVzcG9uZHMgdG8gYSBzaGFwZSBhbmQgZWFjaCBlbGVtZW50IG9mIHRoZSBhcnJheSBpc1xyXG4gKiBhIHZlcnRleCB3aGljaCBpcyBjb25uZWN0ZWQgdG8gaXQncyBwcmV2aW91cyBhbmQgbmV4dCBuZWlnaGJvciAoY2lyY3VsYXIpLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge30gYWN0aW9uSW5mb1xyXG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXk8QXJyYXlMb2M+Pn0gLSBBcnJheSBvZiB2ZXJ0ZXggbG9jYXRpb25zIGluIFxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVTaGFwZXMoYWN0aW9uSW5mbykge1xyXG4gIC8vIFRvdGFsIG51bWJlciBvZiBjZWxscy5cclxuICB2YXIgdG90YWwgPSBhY3Rpb25JbmZvLmxlbmd0aCAqIGFjdGlvbkluZm9bMF0ubGVuZ3RoO1xyXG4gIHZhciBkaXJlY3Rpb25zID0ge1xyXG4gICAgXCJuXCI6IFstMSwgMF0sXHJcbiAgICBcImVcIjogWzAsIDFdLFxyXG4gICAgXCJzXCI6IFsxLCAwXSxcclxuICAgIFwid1wiOiBbMCwgLTFdLFxyXG4gICAgXCJuZVwiOiBbLTEsIDFdLFxyXG4gICAgXCJzZVwiOiBbMSwgMV0sXHJcbiAgICBcInN3XCI6IFsxLCAtMV0sXHJcbiAgICBcIm53XCI6IFstMSwgLTFdXHJcbiAgfTtcclxuICAvLyBUYWtlcyB0aGUgY3VycmVudCBsb2NhdGlvbiBhbmQgZGlyZWN0aW9uIGF0IHRoaXMgcG9pbnQgYW5kXHJcbiAgLy8gcmV0dXJucyB0aGUgbmV4dCBsb2NhdGlvbiB0byBjaGVjay4gUmV0dXJucyBudWxsIGlmIHRoaXMgY2VsbCBpc1xyXG4gIC8vIG5vdCBwYXJ0IG9mIGEgc2hhcGUuXHJcbiAgZnVuY3Rpb24gbmV4dE5laWdoYm9yKGVsdCwgZGlyKSB7XHJcbiAgICB2YXIgZHJvdyA9IDAsIGRjb2wgPSAwO1xyXG4gICAgaWYgKGRpciA9PSBcIm5vbmVcIikge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBvZmZzZXQgPSBkaXJlY3Rpb25zW2Rpcl07XHJcbiAgICAgIHJldHVybiB7cjogZWx0LnIgKyBvZmZzZXRbMF0sIGM6IGVsdC5jICsgb2Zmc2V0WzFdfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEdldCB0aGUgbmV4dCBjZWxsLCBmcm9tIGxlZnQgdG8gcmlnaHQsIHRvcCB0byBib3R0b20uIFJldHVybnMgbnVsbFxyXG4gIC8vIGlmIGxhc3QgZWxlbWVudCBpbiBhcnJheSByZWFjaGVkLlxyXG4gIGZ1bmN0aW9uIG5leHRDZWxsKGVsdCkge1xyXG4gICAgaWYgKGVsdC5jICsgMSA8IGFjdGlvbkluZm9bZWx0LnJdLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4ge3I6IGVsdC5yLCBjOiBlbHQuYyArIDF9O1xyXG4gICAgfSBlbHNlIGlmIChlbHQuciArIDEgPCBhY3Rpb25JbmZvLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4ge3I6IGVsdC5yICsgMSwgYzogMH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIEdldCBpZGVudGlmaWVyIGZvciBnaXZlbiBub2RlIGFuZCBkaXJlY3Rpb25cclxuICBmdW5jdGlvbiBnZXRJZGVudGlmaWVyKG5vZGUsIGRpcikge1xyXG4gICAgcmV0dXJuIFwiclwiICsgbm9kZS5yICsgXCJjXCIgKyBub2RlLmMgKyBcImRcIiArIGRpcjtcclxuICB9XHJcbiAgXHJcbiAgdmFyIGRpc2NvdmVyZWQgPSBbXTtcclxuICB2YXIgbm9kZSA9IHtyOiAwLCBjOiAwfTtcclxuICB2YXIgc2hhcGVzID0gW107XHJcbiAgdmFyIGN1cnJlbnRfc2hhcGUgPSBbXTtcclxuICB2YXIgc2hhcGVfbm9kZV9zdGFydCA9IG51bGw7XHJcbiAgdmFyIGxhc3RfYWN0aW9uID0gbnVsbDtcclxuICAvLyBPYmplY3QgdG8gdHJhY2sgbG9jYXRpb24gKyBhY3Rpb25zIHRoYXQgaGF2ZSBiZWVuIHRha2VuLlxyXG4gIHZhciB0YWtlbl9hY3Rpb25zID0ge307XHJcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xyXG5cclxuICAvLyBJdGVyYXRlIHVudGlsIGFsbCBub2RlcyBoYXZlIGJlZW4gdmlzaXRlZC5cclxuICB3aGlsZSAoZGlzY292ZXJlZC5sZW5ndGggIT09IHRvdGFsKSB7XHJcbiAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgLy8gUmVhY2hlZCBlbmQuXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgaWYgKGl0ZXJhdGlvbnMgPiB0b3RhbCAqIDQpIHtcclxuICAgICAgLy8gU2FuaXR5IGNoZWNrIG9uIG51bWJlciBvZiBpdGVyYXRpb25zLiBNYXhpbXVtIG51bWJlciBvZlxyXG4gICAgICAvLyB0aW1lcyBhIHNpbmdsZSB0aWxlIHdvdWxkIGJlIHZpc2l0ZWQgaXMgNCBmb3IgYSBmYW4tbGlrZVxyXG4gICAgICAvLyBwYXR0ZXJuIG9mIHRyaWFuZ2xlIHdhbGwgdGlsZXMuXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaXRlcmF0aW9ucysrO1xyXG4gICAgfVxyXG4gICAgLy8gSXQncyBva2F5IHRvIGJlIGluIGEgZGlzY292ZXJlZCBub2RlIGlmIHNoYXBlcyBhcmUgYWRqYWNlbnQsXHJcbiAgICAvLyB3ZSBqdXN0IHdhbnQgdG8ga2VlcCB0cmFjayBvZiB0aGUgb25lcyB3ZSd2ZSBzZWVuLlxyXG4gICAgaWYgKGZpbmQoZGlzY292ZXJlZCwgbm9kZSwgZWx0Q29tcGFyZSkgPT0gLTEpIHtcclxuICAgICAgZGlzY292ZXJlZC5wdXNoKG5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBhY3Rpb24gPSBhY3Rpb25JbmZvW25vZGUucl1bbm9kZS5jXTtcclxuICAgIHZhciBkaXI7XHJcbiAgICAvLyBJZiBhY3Rpb24gaGFzIG11bHRpcGxlIHBvc3NpYmlsaXRpZXMuXHJcbiAgICBpZiAoYWN0aW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgLy8gUGFydCBvZiBhIHNoYXBlLCBmaW5kIHRoZSBpbmZvIHdpdGggdGhhdCBwcmV2aW91cyBhY3Rpb24gYXNcclxuICAgICAgLy8gaW5fZGlyLlxyXG4gICAgICBpZiAobGFzdF9hY3Rpb24gIT09IFwibm9uZVwiKSB7XHJcbiAgICAgICAgdmFyIGFjdGlvbl9mb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0aW9uLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB2YXIgdGhpc19hY3Rpb24gPSBhY3Rpb25baV07XHJcbiAgICAgICAgICBpZiAodGhpc19hY3Rpb25bXCJsb2NcIl1bXCJpbl9kaXJcIl0gPT0gbGFzdF9hY3Rpb24pIHtcclxuICAgICAgICAgICAgYWN0aW9uID0gdGhpc19hY3Rpb247XHJcbiAgICAgICAgICAgIGRpciA9IHRoaXNfYWN0aW9uW1wibG9jXCJdW1wib3V0X2RpclwiXTtcclxuICAgICAgICAgICAgYWN0aW9uX2ZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWFjdGlvbl9mb3VuZCkge1xyXG4gICAgICAgICAgdGhyb3cgXCJFcnJvciFcIjtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgYWN0aW9uIHRoYXQgaGFzIG5vdCBiZWVuIHRha2VuIHByZXZpb3VzbHkuXHJcbiAgICAgICAgdmFyIGFjdGlvbl9mb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0aW9uLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB2YXIgdGhpc19hY3Rpb24gPSBhY3Rpb25baV07XHJcbiAgICAgICAgICBpZiAoIXRha2VuX2FjdGlvbnNbZ2V0SWRlbnRpZmllcihub2RlLCB0aGlzX2FjdGlvbltcImxvY1wiXVtcIm91dF9kaXJcIl0pXSkge1xyXG4gICAgICAgICAgICBhY3Rpb24gPSB0aGlzX2FjdGlvblxyXG4gICAgICAgICAgICBkaXIgPSB0aGlzX2FjdGlvbltcImxvY1wiXVtcIm91dF9kaXJcIl07XHJcbiAgICAgICAgICAgIGFjdGlvbl9mb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFjdGlvbl9mb3VuZCkge1xyXG4gICAgICAgICAgdGhyb3cgXCJFcnJvciFcIjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7IC8vIEFjdGlvbiBvbmx5IGhhcyBzaW5nbGUgcG9zc2liaWxpdHkuXHJcbiAgICAgIGRpciA9IGFjdGlvbi5sb2M7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2V0IG5vZGUvYWN0aW9uIGFzIGhhdmluZyBiZWVuIHZpc2l0ZWQuXHJcbiAgICB0YWtlbl9hY3Rpb25zW2dldElkZW50aWZpZXIobm9kZSwgZGlyKV0gPSB0cnVlO1xyXG5cclxuICAgIGxhc3RfYWN0aW9uID0gZGlyO1xyXG4gICAgdmFyIG5leHQgPSBuZXh0TmVpZ2hib3Iobm9kZSwgZGlyKTtcclxuICAgIGlmIChuZXh0KSB7IC8vIFBhcnQgb2YgYSBzaGFwZS5cclxuICAgICAgLy8gU2F2ZSBsb2NhdGlvbiBmb3IgcmVzdGFydGluZyBhZnRlciB0aGlzIHNoYXBlIGhhcyBiZWVuIGRlZmluZWQuXHJcbiAgICAgIHZhciBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICBpZiAoY3VycmVudF9zaGFwZS5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgIGZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICBzaGFwZV9ub2RlX3N0YXJ0ID0gbm9kZTtcclxuICAgICAgICBzaGFwZV9ub2RlX3N0YXJ0X2FjdGlvbiA9IGxhc3RfYWN0aW9uO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBDdXJyZW50IG5vZGUgYW5kIGRpcmVjdGlvbiBpcyBzYW1lIGFzIGF0IHN0YXJ0IG9mIHNoYXBlLFxyXG4gICAgICAvLyBzaGFwZSBoYXMgYmVlbiBleHBsb3JlZC5cclxuICAgICAgaWYgKCFmaXJzdCAmJiBlbHRDb21wYXJlKG5vZGUsIHNoYXBlX25vZGVfc3RhcnQpICYmIGxhc3RfYWN0aW9uID09IHNoYXBlX25vZGVfc3RhcnRfYWN0aW9uKSB7XHJcbiAgICAgICAgc2hhcGVzLnB1c2goY3VycmVudF9zaGFwZSk7XHJcbiAgICAgICAgY3VycmVudF9zaGFwZSA9IFtdO1xyXG4gICAgICAgIC8vIEdldCB0aGUgbmV4dCB1bmRpc2NvdmVyZWQgbm9kZS5cclxuICAgICAgICBub2RlID0gbmV4dENlbGwoc2hhcGVfbm9kZV9zdGFydCk7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUgJiYgKGZpbmQoZGlzY292ZXJlZCwgbm9kZSwgZWx0Q29tcGFyZSkgIT09IC0xKSkge1xyXG4gICAgICAgICAgbm9kZSA9IG5leHRDZWxsKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzaGFwZV9ub2RlX3N0YXJ0ID0gbnVsbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoYWN0aW9uLnYgfHwgZmlyc3QpIHtcclxuICAgICAgICAgIGN1cnJlbnRfc2hhcGUucHVzaChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZSA9IG5leHQ7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7IC8vIE5vdCBwYXJ0IG9mIGEgc2hhcGUuXHJcbiAgICAgIG5vZGUgPSBuZXh0Q2VsbChub2RlKTtcclxuICAgICAgLy8gR2V0IHRoZSBuZXh0IHVuZGlzY292ZXJlZCBub2RlLlxyXG4gICAgICB3aGlsZSAobm9kZSAmJiAoZmluZChkaXNjb3ZlcmVkLCBub2RlLCBlbHRDb21wYXJlKSAhPT0gLTEpKSB7XHJcbiAgICAgICAgbm9kZSA9IG5leHRDZWxsKG5vZGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSAvLyBlbmQgd2hpbGVcclxuXHJcbiAgaWYgKGRpc2NvdmVyZWQubGVuZ3RoID09IHRvdGFsKSB7XHJcbiAgICByZXR1cm4gc2hhcGVzO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8vIFJldHVybiB3aGV0aGVyIHRoZXJlIHNob3VsZCBiZSBhIHZlcnRleCBhdCB0aGUgZ2l2ZW4gbG9jYXRpb24gYW5kXHJcbi8vIHdoaWNoIGxvY2F0aW9uIHRvIGdvIG5leHQsIGlmIGFueS5cclxuLy8gVmFsdWUgcmV0dXJuZWQgaXMgYW4gb2JqZWN0IHdpdGggcHJvcGVydGllcyAndicgYW5kICdsb2MnLiAndicgaXMgYSBib29sZWFuXHJcbi8vIGluZGljYXRpbmcgd2hldGhlciB0aGVyZSBpcyBhIHZlcnRleCwgYW5kICdsb2MnIGdpdmVzIHRoZSBuZXh0IGxvY2F0aW9uIHRvIG1vdmUsIGlmIGFueS5cclxuLy8gbG9jIGlzIGEgc3RyaW5nLCBvZiBub25lLCBkb3duLCBsZWZ0LCByaWdodCwgdXAsIGRvd24gY29ycmVzcG9uZGluZyB0b1xyXG4vLyB0cmFjaW5nIG91dCBhIHNoYXBlIGNsb2Nrd2lzZSAob3IgdGhlIGludGVyaW9yIG9mIGEgc2hhcGUgQ0NXKSwgb3IgYSBmdW5jdGlvblxyXG4vLyB0aGF0IHRha2VzIGEgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGRpcmVjdGlvbiB0YWtlbiB0byBnZXQgdG8gdGhlIGN1cnJlbnRcclxuLy8gY2VsbC5cclxuLy8gVGhlcmUgd2lsbCBuZXZlciBiZSBhIHZlcnRleCB3aXRob3V0IGEgbmV4dCBkaXJlY3Rpb24uXHJcbmZ1bmN0aW9uIGdldEFjdGlvbihjZWxsKSB7XHJcbiAgdmFyIHN0ciA9IGNlbGxbMF0gKyBcIi1cIiArIGNlbGxbMV0gKyBcIi1cIiArIGNlbGxbMl0gKyBcIi1cIiArIGNlbGxbM107XHJcbiAgcmV0dXJuIEFjdGlvblZhbHVlc1tzdHJdO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydCBhbiBhcnJheSBsb2NhdGlvbiB0byBhIHBvaW50IHJlcHJlc2VudGluZyB0aGUgdG9wLWxlZnRcclxuICogY29ybmVyIG9mIHRoZSB0aWxlIGluIGdsb2JhbCBjb29yZGluYXRlcy5cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtBcnJheUxvY30gbG9jYXRpb24gLSBUaGUgYXJyYXkgbG9jYXRpb24gdG8gZ2V0IHRoZVxyXG4gKiAgIGNvb3JkaW5hdGVzIGZvci5cclxuICogQHJldHVybiB7TVBQb2ludH0gLSBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHRpbGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDb29yZGluYXRlcyhsb2NhdGlvbikge1xyXG4gIHZhciB0aWxlX3dpZHRoID0gNDA7XHJcbiAgdmFyIHggPSBsb2NhdGlvbi5yICogdGlsZV93aWR0aDtcclxuICB2YXIgeSA9IGxvY2F0aW9uLmMgKiB0aWxlX3dpZHRoO1xyXG4gIHJldHVybiB7eDogeCwgeTogeX07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUYWtlcyBpbiBhbiBhcnJheSBvZiBzaGFwZXMgYW5kIGNvbnZlcnRzIGZyb20gY29udG91ciBncmlkIGxheW91dFxyXG4gKiB0byBhY3R1YWwgY29vcmRpbmF0ZXMuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxBcnJheUxvYz4+fSBzaGFwZXMgLSBvdXRwdXQgZnJvbSBnZW5lcmF0ZVNoYXBlc1xyXG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fT4+fVxyXG4gKi9cclxuZnVuY3Rpb24gY29udmVydFNoYXBlc1RvQ29vcmRzKHNoYXBlcykge1xyXG4gIHZhciB0aWxlX3dpZHRoID0gNDA7XHJcblxyXG4gIHZhciBuZXdfc2hhcGVzID0gbWFwMmQoc2hhcGVzLCBmdW5jdGlvbihsb2MpIHtcclxuICAgIC8vIEl0IHdvdWxkIGJlIGxvYy5yICsgMSBhbmQgbG9jLmMgKyAxIGJ1dCB0aGF0IGhhcyBiZWVuIHJlbW92ZWRcclxuICAgIC8vIHRvIGFjY291bnQgZm9yIHRoZSBvbmUtdGlsZSB3aWR0aCBvZiBwYWRkaW5nIGFkZGVkIGluIGRvUGFyc2UuXHJcbiAgICB2YXIgcm93ID0gbG9jLnIgKiB0aWxlX3dpZHRoO1xyXG4gICAgdmFyIGNvbCA9IGxvYy5jICogdGlsZV93aWR0aDtcclxuICAgIHJldHVybiB7eDogcm93LCB5OiBjb2x9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIG5ld19zaGFwZXM7XHJcbn1cclxuXHJcbi8vIEdpdmVuIGFuIHggYW5kIHkgdmFsdWUsIHJldHVybiBhIHBvbHlnb24gKG9jdGFnb24pIHRoYXQgYXBwcm94aW1hdGVzXHJcbi8vIGEgc3Bpa2UgYXQgdGhlIHRpbGUgZ2l2ZW4gYnkgdGhhdCB4LCB5IGxvY2F0aW9uLiBQb2ludHMgaW4gQ1cgb3JkZXIuXHJcbmZ1bmN0aW9uIGdldFNwaWtlU2hhcGUoY29vcmQpIHtcclxuICB2YXIgeCA9IGNvb3JkLnggKyAyMCwgeSA9IGNvb3JkLnkgKyAyMDtcclxuICB2YXIgc3Bpa2VfcmFkaXVzID0gMTQ7XHJcbiAgLy8gYWxtb3N0ID0gc3Bpa2VfcmFkaXVzICogdGFuKHBpLzgpIGZvciB0aGUgdmVydGljZXMgb2YgYSByZWd1bGFyIG9jdGFnb24uXHJcbiAgdmFyIHBvaW50X29mZnNldCA9IDUuODtcclxuICByZXR1cm4gW1xyXG4gICAge3g6IHggLSBzcGlrZV9yYWRpdXMsIHk6IHkgLSBwb2ludF9vZmZzZXR9LFxyXG4gICAge3g6IHggLSBzcGlrZV9yYWRpdXMsIHk6IHkgKyBwb2ludF9vZmZzZXR9LFxyXG4gICAge3g6IHggLSBwb2ludF9vZmZzZXQsIHk6IHkgKyBzcGlrZV9yYWRpdXN9LFxyXG4gICAge3g6IHggKyBwb2ludF9vZmZzZXQsIHk6IHkgKyBzcGlrZV9yYWRpdXN9LFxyXG4gICAge3g6IHggKyBzcGlrZV9yYWRpdXMsIHk6IHkgKyBwb2ludF9vZmZzZXR9LFxyXG4gICAge3g6IHggKyBzcGlrZV9yYWRpdXMsIHk6IHkgLSBwb2ludF9vZmZzZXR9LFxyXG4gICAge3g6IHggKyBwb2ludF9vZmZzZXQsIHk6IHkgLSBzcGlrZV9yYWRpdXN9LFxyXG4gICAge3g6IHggLSBwb2ludF9vZmZzZXQsIHk6IHkgLSBzcGlrZV9yYWRpdXN9XHJcbiAgXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGFycmF5IGxvY2F0aW9ucyBvZiB0aGUgc3Bpa2VzIGNvbnRhaW5lZFxyXG4gKiBpbiB0aGUgbWFwIHRpbGVzLCByZXBsYWNpbmcgdGhvc2UgYXJyYXkgbG9jYXRpb25zIGluIHRoZSBvcmlnaW5hbFxyXG4gKiBtYXAgdGlsZXMgd2l0aCAyLCB3aGljaCBjb3JyZXNwb25kcyB0byBhIGZsb29yIHRpbGUuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7TWFwVGlsZXN9IHRpbGVzIC0gVGhlIG1hcCB0aWxlcy5cclxuICogQHJldHVybiB7QXJyYXkuPEFycmF5TG9jPn0gLSBUaGUgYXJyYXkgb2YgbG9jYXRpb25zIHRoYXQgaGVsZFxyXG4gKiAgIHNwaWtlIHRpbGVzLlxyXG4gKi9cclxuTWFwUGFyc2VyLmV4dHJhY3RTcGlrZXMgPSBmdW5jdGlvbih0aWxlcykge1xyXG4gIHZhciBzcGlrZV9sb2NhdGlvbnMgPSBbXTtcclxuICB0aWxlcy5mb3JFYWNoKGZ1bmN0aW9uKHJvdywgcm93X24pIHtcclxuICAgIHJvdy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGxfdmFsdWUsIGluZGV4LCByb3cpIHtcclxuICAgICAgaWYgKGNlbGxfdmFsdWUgPT0gNykge1xyXG4gICAgICAgIHNwaWtlX2xvY2F0aW9ucy5wdXNoKHtyOiByb3dfbiwgYzogaW5kZXh9KTtcclxuICAgICAgICByb3dbaW5kZXhdID0gMjtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHNwaWtlX2xvY2F0aW9ucztcclxufTtcclxuXHJcbnZhciBPYnN0YWNsZSA9IGZ1bmN0aW9uKHR5cGUsIGlkcykge1xyXG4gIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgdGhpcy52YWxzID0gW107XHJcbiAgdGhpcy5pbmZvID0ge307XHJcbiAgaWRzLmZvckVhY2goZnVuY3Rpb24oaWQpIHtcclxuICAgIGlmICh0eXBlb2YgaWQgPT0gXCJudW1iZXJcIikge1xyXG4gICAgICB0aGlzLnZhbHMucHVzaChpZCk7XHJcbiAgICAgIHRoaXMuaW5mb1tpZF0gPSB0aGlzLnR5cGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnZhbHMucHVzaChpZC5udW0pO1xyXG4gICAgICB0aGlzLmluZm9baWRdID0gaWQubmFtZTtcclxuICAgIH1cclxuICB9LCB0aGlzKTtcclxufTtcclxuXHJcbk9ic3RhY2xlLnByb3RvdHlwZS5kZXNjcmliZXMgPSBmdW5jdGlvbih2YWwpIHtcclxuICBpZih0aGlzLnZhbHMuaW5kZXhPZihNYXRoLmZsb29yKCt2YWwpKSAhPT0gLTEpIHtcclxuICAgIHJldHVybiAodGhpcy5pbmZvWyt2YWxdIHx8IHRoaXMuaW5mb1tNYXRoLmZsb29yKCt2YWwpXSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn07XHJcblxyXG52YXIgT2JzdGFjbGVzID0gW1xyXG4gIG5ldyBPYnN0YWNsZShcImJvbWJcIiwgWzEwLCAxMC4xXSksXHJcbiAgbmV3IE9ic3RhY2xlKFwiYm9vc3RcIixcclxuICAgIFs1LCA1LjEsIHtudW06IDE0LCBuYW1lOiBcInJlZGJvb3N0XCJ9LCB7bnVtOiAxNSwgbmFtZTogXCJibHVlYm9vc3RcIn1dKSxcclxuICBuZXcgT2JzdGFjbGUoXCJnYXRlXCIsXHJcbiAgICBbOSwge251bTogOS4xLCBuYW1lOiBcImdyZWVuZ2F0ZVwifSwge251bTogOS4yLCBuYW1lOiBcInJlZGdhdGVcIn0sXHJcbiAgICB7bnVtOiA5LjMsIG5hbWU6IFwiYmx1ZWdhdGVcIn1dKVxyXG5dO1xyXG5cclxuTWFwUGFyc2VyLmV4dHJhY3REeW5hbWljT2JzdGFjbGVzID0gZnVuY3Rpb24odGlsZXMpIHtcclxuICB2YXIgZHluYW1pY19vYnN0YWNsZXMgPSBbXTtcclxuICB0aWxlcy5mb3JFYWNoKGZ1bmN0aW9uKHJvdywgeCkge1xyXG4gICAgcm93LmZvckVhY2goZnVuY3Rpb24odGlsZSwgeSkge1xyXG4gICAgICBPYnN0YWNsZXMuc29tZShmdW5jdGlvbihvYnN0YWNsZV90eXBlKSB7XHJcbiAgICAgICAgdmFyIGR5bmFtaWNfb2JzdGFjbGUgPSBvYnN0YWNsZV90eXBlLmRlc2NyaWJlcyh0aWxlKVxyXG4gICAgICAgIGlmIChkeW5hbWljX29ic3RhY2xlKSB7XHJcbiAgICAgICAgICBkeW5hbWljX29ic3RhY2xlcy5wdXNoKHtcclxuICAgICAgICAgICAgdHlwZTogZHluYW1pY19vYnN0YWNsZSxcclxuICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgeTogeSxcclxuICAgICAgICAgICAgdjogdGlsZVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICB0aWxlc1t4XVt5XSA9IDA7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuICByZXR1cm4gZHluYW1pY19vYnN0YWNsZXM7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhlIHJldHVybmVkIHZhbHVlIGZyb20gdGhlIG1hcCBwYXJzaW5nIGZ1bmN0aW9uLlxyXG4gKiBAdHlwZWRlZiBQYXJzZWRNYXBcclxuICogQHR5cGUge29iamVjdH1cclxuICogQHByb3BlcnR5IHtBcnJheS48TVBTaGFwZT59IHdhbGxzIC0gVGhlIHBhcnNlZCB3YWxscy5cclxuICogQHByb3BlcnR5IHtBcnJheS48TVBTaGFwZT59IG9ic3RhY2xlcyAtIFRoZSBwYXJzZWQgb2JzdGFjbGVzLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgMmQgYXJyYXkgZGVmaW5pbmcgYSBUYWdQcm8gbWFwIGludG8gc2hhcGVzLlxyXG4gKiBAcGFyYW0ge01hcFRpbGVzfSB0aWxlcyAtIFRoZSB0aWxlcyBhcyByZXRyaWV2ZWQgZnJvbSBgdGFncHJvLm1hcGAuXHJcbiAqIEByZXR1cm4gez9QYXJzZWRNYXB9IC0gVGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIHRoZSBtYXAgaW50b1xyXG4gKiAgIHBvbHlnb25zLCBvciBudWxsIGlmIHRoZXJlIHdhcyBhbiBpc3N1ZSBwYXJzaW5nIHRoZSBtYXAuXHJcbiAqL1xyXG5NYXBQYXJzZXIucGFyc2UgPSBmdW5jdGlvbih0aWxlcykge1xyXG4gIC8vIE1ha2UgY29weSBvZiB0aWxlcyB0byBwcmVzZXJ2ZSBvcmlnaW5hbCBhcnJheVxyXG4gIHRpbGVzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aWxlcykpO1xyXG5cclxuICAvLyBSZXR1cm5zIGEgbGlzdCBvZiB0aGUgc3Bpa2UgbG9jYXRpb25zIGFuZCByZW1vdmVzIHRoZW0gZnJvbVxyXG4gIC8vIHRoZSB0aWxlcy5cclxuICB2YXIgc3Bpa2VfbG9jYXRpb25zID0gTWFwUGFyc2VyLmV4dHJhY3RTcGlrZXModGlsZXMpO1xyXG5cclxuICB2YXIgZHluYW1pY19vYnN0YWNsZXMgPSBNYXBQYXJzZXIuZXh0cmFjdER5bmFtaWNPYnN0YWNsZXModGlsZXMpO1xyXG5cclxuICAvLyBQYWQgdGlsZXMgd2l0aCBhIHJpbmcgb2Ygd2FsbCB0aWxlcywgdG8gZW5zdXJlIHRoZSBtYXAgaXNcclxuICAvLyBjbG9zZWQuXHJcbiAgdmFyIGVtcHR5X3JvdyA9IFtdO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGlsZXNbMF0ubGVuZ3RoICsgMjsgaSsrKSB7XHJcbiAgICBlbXB0eV9yb3cucHVzaCgxKTtcclxuICB9XHJcbiAgdGlsZXMuZm9yRWFjaChmdW5jdGlvbihyb3cpIHtcclxuICAgIHJvdy51bnNoaWZ0KDEpO1xyXG4gICAgcm93LnB1c2goMSk7XHJcbiAgfSk7XHJcbiAgdGlsZXMudW5zaGlmdChlbXB0eV9yb3cpO1xyXG4gIHRpbGVzLnB1c2goZW1wdHlfcm93LnNsaWNlKCkpO1xyXG5cclxuICAvLyBBY3R1YWxseSBkb2luZyB0aGUgY29udmVyc2lvbi5cclxuICAvLyBHZXQgcmlkIG9mIHRpbGUgdmFsdWVzIGV4Y2VwdCB0aG9zZSBmb3IgdGhlIHdhbGxzLlxyXG4gIHZhciB0aHJlc2hvbGRfdGlsZXMgPSBtYXAyZCh0aWxlcywgaXNCYWRDZWxsKTtcclxuXHJcbiAgLy8gR2VuZXJhdGUgY29udG91ciBncmlkLCBlc3NlbnRpYWxseSBhIGdyaWQgd2hvc2UgY2VsbHMgYXJlIGF0IHRoZVxyXG4gIC8vIGludGVyc2VjdGlvbiBvZiBldmVyeSBzZXQgb2YgNCBjZWxscyBpbiB0aGUgb3JpZ2luYWwgbWFwLlxyXG4gIHZhciBjb250b3VyX2dyaWRfMiA9IGdlbmVyYXRlQ29udG91ckdyaWQodGhyZXNob2xkX3RpbGVzKTtcclxuXHJcbiAgLy8gR2V0IHRpbGUgdmVydGV4IGFuZCBhY3Rpb25zIGZvciBlYWNoIGNlbGwgaW4gY29udG91ciBncmlkLlxyXG4gIHZhciB0aWxlX2FjdGlvbnMgPSBtYXAyZChjb250b3VyX2dyaWRfMiwgZ2V0QWN0aW9uKTtcclxuXHJcbiAgdmFyIGdlbmVyYXRlZF9zaGFwZXMgPSBnZW5lcmF0ZVNoYXBlcyh0aWxlX2FjdGlvbnMpO1xyXG4gIGlmICghZ2VuZXJhdGVkX3NoYXBlcykge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICB2YXIgYWN0dWFsX3NoYXBlcyA9IGdlbmVyYXRlZF9zaGFwZXMuZmlsdGVyKGZ1bmN0aW9uKGVsdCkge1xyXG4gICAgcmV0dXJuIGVsdC5sZW5ndGggPiAwO1xyXG4gIH0pO1xyXG5cclxuICB2YXIgY29udmVydGVkX3NoYXBlcyA9IGNvbnZlcnRTaGFwZXNUb0Nvb3JkcyhhY3R1YWxfc2hhcGVzKTtcclxuXHJcbiAgLy8gR2V0IHNwaWtlLWFwcHJveGltYXRpbmcgc2hhcGVzIGFuZCBhZGQgdG8gbGlzdC5cclxuICB2YXIgc3RhdGljX29ic3RhY2xlcyA9IHNwaWtlX2xvY2F0aW9ucy5tYXAoZnVuY3Rpb24oc3Bpa2UpIHtcclxuICAgIHJldHVybiBnZXRTcGlrZVNoYXBlKGdldENvb3JkaW5hdGVzKHNwaWtlKSk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICB3YWxsczogdGhpcy5jb252ZXJ0U2hhcGVzVG9Qb2x5cyhjb252ZXJ0ZWRfc2hhcGVzKSxcclxuICAgIHN0YXRpY19vYnN0YWNsZXM6IHRoaXMuY29udmVydFNoYXBlc1RvUG9seXMoc3RhdGljX29ic3RhY2xlcyksXHJcbiAgICBkeW5hbWljX29ic3RhY2xlczogZHluYW1pY19vYnN0YWNsZXNcclxuICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgc2hhcGVzIGludG8gcG9seXMuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7QXJyYXkuPFNoYXBlPn0gc2hhcGVzIC0gVGhlIHNoYXBlcyB0byBiZSBjb252ZXJ0ZWQuXHJcbiAqIEByZXR1cm4ge0FycmF5LjxQb2x5Pn0gLSBUaGUgY29udmVydGVkIHNoYXBlcy5cclxuICovXHJcbk1hcFBhcnNlci5jb252ZXJ0U2hhcGVzVG9Qb2x5cyA9IGZ1bmN0aW9uKHNoYXBlcykge1xyXG4gIHZhciBwb2x5cyA9IHNoYXBlcy5tYXAoZnVuY3Rpb24oc2hhcGUpIHtcclxuICAgIHJldHVybiBNYXBQYXJzZXIuY29udmVydFNoYXBlVG9Qb2x5KHNoYXBlKTtcclxuICB9KTtcclxuICByZXR1cm4gcG9seXM7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYSBzaGFwZSBpbnRvIGEgUG9seS5cclxuICogQHBhcmFtIHtNUFNoYXBlfSBzaGFwZSAtIFRoZSBzaGFwZSB0byBjb252ZXJ0LlxyXG4gKiBAcmV0dXJuIHtQb2x5fSAtIFRoZSBjb252ZXJ0ZWQgc2hhcGUuXHJcbiAqL1xyXG5NYXBQYXJzZXIuY29udmVydFNoYXBlVG9Qb2x5ID0gZnVuY3Rpb24oc2hhcGUpIHtcclxuICB2YXIgcG9seSA9IG5ldyBQb2x5KCk7XHJcbiAgcG9seS5pbml0KHNoYXBlLmxlbmd0aCk7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFwZS5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KHNoYXBlW2ldLngsIHNoYXBlW2ldLnkpO1xyXG4gICAgcG9seS5zZXRQb2ludChpLCBwb2ludCk7XHJcbiAgfVxyXG4gIHJldHVybiBwb2x5O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNYXBQYXJzZXI7XHJcbiIsIi8qKlxyXG4gKiBIb2xkcyBjbGFzc2VzIGZvciBwb2ludHMsIHBvbHlnb25zLCBhbmQgdXRpbGl0aWVzIGZvciBvcGVyYXRpbmcgb25cclxuICogdGhlbS5cclxuICogQWRhcHRlZC9jb3BpZWQgZnJvbSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHlwYXJ0aXRpb24vXHJcbiAqIEBtb2R1bGUgUG9seVBhcnRpdGlvblxyXG4gKi9cclxudmFyIHBvbHkydHJpID0gcmVxdWlyZSgncG9seTJ0cmknKTtcclxudmFyIGdlbyA9IHJlcXVpcmUoJy4vZ2VvbWV0cnknKTtcclxuXHJcbnZhciBQb2ludCA9IGdlby5Qb2ludDtcclxudmFyIEVkZ2UgPSBnZW8uRWRnZTtcclxudmFyIFBvbHkgPSBnZW8uUG9seTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgUG9pbnQgY2xhc3MgdXNlZCBieSBwb2x5MnRyaS5cclxuICogQHByaXZhdGVcclxuICogQHR5cGVkZWYgUDJUUG9pbnRcclxuICovXHJcblxyXG4vKipcclxuICogQSBwb2x5Z29uIGZvciB1c2Ugd2l0aCBwb2x5MnRyaS5cclxuICogQHByaXZhdGVcclxuICogQHR5cGVkZWYgUDJUUG9seVxyXG4gKiBAdHlwZSB7QXJyYXkuPFAyVFBvaW50Pn1cclxuICovXHJcblxyXG4vKipcclxuICogQ29udmVydCBhIHBvbHlnb24gaW50byBmb3JtYXQgcmVxdWlyZWQgYnkgcG9seTJ0cmkuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7UG9seX0gcG9seSAtIFRoZSBwb2x5Z29uIHRvIGNvbnZlcnQuXHJcbiAqIEByZXR1cm4ge1AyVFBvbHl9IC0gVGhlIGNvbnZlcnRlZCBwb2x5Z29uLlxyXG4gKi9cclxuZnVuY3Rpb24gY29udmVydFBvbHlUb1AyVFBvbHkocG9seSkge1xyXG4gIHJldHVybiBwb2x5LnBvaW50cy5tYXAoZnVuY3Rpb24ocCkge1xyXG4gICAgcmV0dXJuIG5ldyBwb2x5MnRyaS5Qb2ludChwLngsIHAueSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgcG9seWdvbi90cmlhbmdsZSByZXR1cm5lZCBmcm9tIHBvbHkydHJpIGJhY2sgaW50byBhXHJcbiAqIHBvbHlnb24uXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7UDJUUG9seX0gcDJ0cG9seSAtIFRoZSBwb2x5Z29uIHRvIGNvbnZlcnQuXHJcbiAqIEByZXR1cm4ge1BvbHl9IC0gVGhlIGNvbnZlcnRlZCBwb2x5Z29uLlxyXG4gKi9cclxuZnVuY3Rpb24gY29udmVydFAyVFBvbHlUb1BvbHkocDJ0cG9seSkge1xyXG4gIHZhciBwb2ludHMgPSBwMnRwb2x5LmdldFBvaW50cygpLm1hcChmdW5jdGlvbihwKSB7XHJcbiAgICByZXR1cm4gbmV3IFBvaW50KHAueCwgcC55KTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIG5ldyBQb2x5KHBvaW50cyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzQ29udmV4KHAxLCBwMiwgcDMpIHtcclxuICB2YXIgdG1wID0gKHAzLnkgLSBwMS55KSAqIChwMi54IC0gcDEueCkgLSAocDMueCAtIHAxLngpICogKHAyLnkgLSBwMS55KTtcclxuICByZXR1cm4gKHRtcCA+IDApO1xyXG59XHJcblxyXG4vKipcclxuICogVGFrZXMgYW4gYXJyYXkgb2YgcG9seWdvbnMgdGhhdCBvdmVybGFwIHRoZW1zZWx2ZXMgYW5kIG90aGVyc1xyXG4gKiBhdCBkaXNjcmV0ZSBjb3JuZXIgcG9pbnRzIGFuZCBzZXBhcmF0ZSB0aG9zZSBvdmVybGFwcGluZyBjb3JuZXJzXHJcbiAqIHNsaWdodGx5IHNvIHRoZSBwb2x5Z29ucyBhcmUgc3VpdGFibGUgZm9yIHRyaWFuZ3VsYXRpb24gYnlcclxuICogcG9seTJ0cmkuanMuIFRoaXMgY2hhbmdlcyB0aGUgUG9seSBvYmplY3RzIGluIHRoZSBhcnJheS5cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtBcnJheS48UG9seT59IHBvbHlzIC0gVGhlIHBvbHlnb25zIHRvIHNlcGFyYXRlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29mZnNldD0xXSAtIFRoZSBudW1iZXIgb2YgdW5pdHMgdGhlIHZlcnRpY2VzXHJcbiAqICAgc2hvdWxkIGJlIG1vdmVkIGF3YXkgZnJvbSBlYWNoIG90aGVyLlxyXG4gKi9cclxuZnVuY3Rpb24gc2VwYXJhdGVQb2x5cyhwb2x5cywgb2Zmc2V0KSB7XHJcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDE7XHJcbiAgdmFyIGRpc2NvdmVyZWQgPSB7fTtcclxuICB2YXIgZHVwZXMgPSB7fTtcclxuICAvLyBPZmZzZXQgdG8gdXNlIGluIGNhbGN1bGF0aW9uLlxyXG4gIC8vIEZpbmQgZHVwbGljYXRlcy5cclxuICBmb3IgKHZhciBzMSA9IDA7IHMxIDwgcG9seXMubGVuZ3RoOyBzMSsrKSB7XHJcbiAgICB2YXIgcG9seSA9IHBvbHlzW3MxXTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seS5udW1wb2ludHM7IGkrKykge1xyXG4gICAgICB2YXIgcG9pbnQgPSBwb2x5LnBvaW50c1tpXS50b1N0cmluZygpO1xyXG4gICAgICBpZiAoIWRpc2NvdmVyZWQuaGFzT3duUHJvcGVydHkocG9pbnQpKSB7XHJcbiAgICAgICAgZGlzY292ZXJlZFtwb2ludF0gPSB0cnVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGR1cGVzW3BvaW50XSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEdldCBkdXBsaWNhdGUgcG9pbnRzLlxyXG4gIHZhciBkdXBlX3BvaW50cyA9IFtdO1xyXG4gIHZhciBkdXBlO1xyXG4gIGZvciAodmFyIHMxID0gMDsgczEgPCBwb2x5cy5sZW5ndGg7IHMxKyspIHtcclxuICAgIHZhciBwb2x5ID0gcG9seXNbczFdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Lm51bXBvaW50czsgaSsrKSB7XHJcbiAgICAgIHZhciBwb2ludCA9IHBvbHkucG9pbnRzW2ldO1xyXG4gICAgICBpZiAoZHVwZXMuaGFzT3duUHJvcGVydHkocG9pbnQudG9TdHJpbmcoKSkpIHtcclxuICAgICAgICBkdXBlID0gW3BvaW50LCBpLCBwb2x5XTtcclxuICAgICAgICBkdXBlX3BvaW50cy5wdXNoKGR1cGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTb3J0IGVsZW1lbnRzIGluIGRlc2NlbmRpbmcgb3JkZXIgYmFzZWQgb24gdGhlaXIgaW5kaWNlcyB0b1xyXG4gIC8vIHByZXZlbnQgZnV0dXJlIGluZGljZXMgZnJvbSBiZWNvbWluZyBpbnZhbGlkIHdoZW4gY2hhbmdlcyBhcmUgbWFkZS5cclxuICBkdXBlX3BvaW50cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgIHJldHVybiBiWzFdIC0gYVsxXVxyXG4gIH0pO1xyXG4gIC8vIEVkaXQgZHVwbGljYXRlcy5cclxuICB2YXIgcHJldiwgbmV4dCwgcG9pbnQsIGluZGV4LCBwMSwgcDI7XHJcbiAgZHVwZV9wb2ludHMuZm9yRWFjaChmdW5jdGlvbihlLCBpLCBhcnkpIHtcclxuICAgIHBvaW50ID0gZVswXSwgaW5kZXggPSBlWzFdLCBwb2x5ID0gZVsyXTtcclxuICAgIHByZXYgPSBwb2x5LnBvaW50c1twb2x5LmdldFByZXZJKGluZGV4KV07XHJcbiAgICBuZXh0ID0gcG9seS5wb2ludHNbcG9seS5nZXROZXh0SShpbmRleCldO1xyXG4gICAgcDEgPSBwb2ludC5hZGQocHJldi5zdWIocG9pbnQpLm5vcm1hbGl6ZSgpLm11bChvZmZzZXQpKTtcclxuICAgIHAyID0gcG9pbnQuYWRkKG5leHQuc3ViKHBvaW50KS5ub3JtYWxpemUoKS5tdWwob2Zmc2V0KSk7XHJcbiAgICAvLyBJbnNlcnQgbmV3IHBvaW50cy5cclxuICAgIHBvbHkucG9pbnRzLnNwbGljZShpbmRleCwgMSwgcDEsIHAyKTtcclxuICAgIHBvbHkudXBkYXRlKCk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJ0aXRpb24gYSBwb2x5Z29uIHdpdGggKG9wdGlvbmFsKSBob2xlcyBpbnRvIGEgc2V0IG9mIGNvbnZleFxyXG4gKiBwb2x5Z29ucy4gVGhlIHZlcnRpY2VzIG9mIHRoZSBwb2x5Z29uIG11c3QgYmUgZ2l2ZW4gaW4gQ1cgb3JkZXIsXHJcbiAqIGFuZCB0aGUgdmVydGljZXMgb2YgdGhlIGhvbGVzIG11c3QgYmUgaW4gQ0NXIG9yZGVyLiBVc2VzIHBvbHkydHJpXHJcbiAqIGZvciB0aGUgaW5pdGlhbCB0cmlhbmd1bGF0aW9uIGFuZCBIZXJ0ZWwtTWVobGhvcm4gdG8gY29tYmluZSB0aGVtXHJcbiAqIGludG8gY29udmV4IHBvbHlnb25zLlxyXG4gKiBAcGFyYW0ge1BvbHl9IHBvbHkgLSBUaGUgcG9seWdvbiB0byB1c2UgYXMgdGhlIG91dGxpbmUuXHJcbiAqIEBwYXJhbSB7QXJyYXkuPFBvbHk+fSBbaG9sZXNdIC0gQW4gYXJyYXkgb2YgaG9sZXMgcHJlc2VudCBpbiB0aGVcclxuICogICBwb2x5Z29uLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gW21pbkFyZWE9NV0gLSBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBmaWx0ZXJzXHJcbiAqICAgb3V0IHBvbHlnb25zIGluIHRoZSBwYXJ0aXRpb24gc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuXHJcbiAqIEByZXR1cm4ge0FycmF5LjxQb2x5Pn0gLSBUaGUgc2V0IG9mIHBvbHlnb25zIGRlZmluaW5nIHRoZVxyXG4gKiAgIHBhcnRpdGlvbiBvZiB0aGUgcHJvdmlkZWQgcG9seWdvbi5cclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocG9seSwgaG9sZXMsIG1pbkFyZWEpIHtcclxuICBpZiAodHlwZW9mIGhvbGVzID09ICd1bmRlZmluZWQnKSBob2xlcyA9IGZhbHNlO1xyXG4gIGlmICh0eXBlb2YgbWluQXJlYSA9PSAndW5kZWZpbmVkJykgbWluQXJlYSA9IDU7XHJcblxyXG4gIHZhciBpMTEsIGkxMiwgaTEzLCBpMjEsIGkyMiwgaTIzO1xyXG4gIHZhciBwYXJ0cyA9IG5ldyBBcnJheSgpO1xyXG5cclxuICAvLyBDaGVjayBpZiBwb2x5IGlzIGFscmVhZHkgY29udmV4IG9ubHkgaWYgdGhlcmUgYXJlIG5vIGhvbGVzLlxyXG4gIGlmICghaG9sZXMgfHwgaG9sZXMubGVuZ3RoID09IDApIHtcclxuICAgIHZhciByZWZsZXggPSBmYWxzZTtcclxuICAgIC8vIENoZWNrIGlmIGFscmVhZHkgY29udmV4LlxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Lm51bXBvaW50czsgaSsrKSB7XHJcbiAgICAgIHZhciBwcmV2ID0gcG9seS5nZXRQcmV2SShpKTtcclxuICAgICAgdmFyIG5leHQgPSBwb2x5LmdldE5leHRJKGkpO1xyXG4gICAgICBpZiAoIWlzQ29udmV4KHBvbHkuZ2V0UG9pbnQocHJldiksIHBvbHkuZ2V0UG9pbnQoaSksIHBvbHkuZ2V0UG9pbnQobmV4dCkpKSB7XHJcbiAgICAgICAgcmVmbGV4ID0gdHJ1ZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFyZWZsZXgpIHtcclxuICAgICAgcGFydHMucHVzaChwb2x5KTtcclxuICAgICAgcmV0dXJuIHBhcnRzO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gU2VwYXJhdGUgcG9seXMgdG8gcmVtb3ZlIGNvbGxpbmVhciBwb2ludHMuXHJcbiAgc2VwYXJhdGVQb2x5cyhob2xlcy5jb25jYXQocG9seSkpO1xyXG5cclxuICAvLyBDb252ZXJ0IHBvbHlnb24gaW50byBmb3JtYXQgcmVxdWlyZWQgYnkgcG9seTJ0cmkuXHJcbiAgdmFyIGNvbnRvdXIgPSBjb252ZXJ0UG9seVRvUDJUUG9seShwb2x5KTtcclxuXHJcbiAgaWYgKGhvbGVzKSB7XHJcbiAgICAvLyBDb252ZXJ0IGhvbGVzIGludG8gZm9ybWF0IHJlcXVpcmVkIGJ5IHBvbHkydHJpLlxyXG4gICAgaG9sZXMgPSBob2xlcy5tYXAoY29udmVydFBvbHlUb1AyVFBvbHkpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHN3Y3R4ID0gbmV3IHBvbHkydHJpLlN3ZWVwQ29udGV4dChjb250b3VyKTtcclxuICBpZiAoaG9sZXMpIHtcclxuICAgIHN3Y3R4LmFkZEhvbGVzKGhvbGVzKTtcclxuICB9XHJcbiAgdmFyIHRyaWFuZ2xlcyA9IHN3Y3R4LnRyaWFuZ3VsYXRlKCkuZ2V0VHJpYW5nbGVzKCk7XHJcbiAgXHJcbiAgLy8gQ29udmVydCBwb2x5MnRyaSB0cmlhbmdsZXMgYmFjayBpbnRvIHBvbHlnb25zIGFuZCBmaWx0ZXIgb3V0IHRoZVxyXG4gIC8vIG9uZXMgdG9vIHNtYWxsIHRvIGJlIHJlbGV2YW50LlxyXG4gIHRyaWFuZ2xlcyA9IHRyaWFuZ2xlcy5tYXAoY29udmVydFAyVFBvbHlUb1BvbHkpLmZpbHRlcihmdW5jdGlvbihwb2x5KSB7XHJcbiAgICByZXR1cm4gcG9seS5nZXRBcmVhKCkgPj0gbWluQXJlYTtcclxuICB9KTtcclxuXHJcbiAgZm9yICh2YXIgczEgPSAwOyBzMSA8IHRyaWFuZ2xlcy5sZW5ndGg7IHMxKyspIHtcclxuICAgIHZhciBwb2x5MSA9IHRyaWFuZ2xlc1tzMV07XHJcbiAgICB2YXIgczJfaW5kZXggPSBudWxsO1xyXG4gICAgZm9yIChpMTEgPSAwOyBpMTEgPCBwb2x5MS5udW1wb2ludHM7IGkxMSsrKSB7XHJcbiAgICAgIHZhciBkMSA9IHBvbHkxLmdldFBvaW50KGkxMSk7XHJcbiAgICAgIGkxMiA9IHBvbHkxLmdldE5leHRJKGkxMSk7XHJcbiAgICAgIHZhciBkMiA9IHBvbHkxLmdldFBvaW50KGkxMik7XHJcblxyXG4gICAgICB2YXIgaXNkaWFnb25hbCA9IGZhbHNlO1xyXG4gICAgICBmb3IgKHZhciBzMiA9IHMxOyBzMiA8IHRyaWFuZ2xlcy5sZW5ndGg7IHMyKyspIHtcclxuICAgICAgICBpZiAoczEgPT0gczIpIGNvbnRpbnVlO1xyXG4gICAgICAgIHZhciBwb2x5MiA9IHRyaWFuZ2xlc1tzMl07XHJcbiAgICAgICAgZm9yIChpMjEgPSAwOyBpMjEgPCBwb2x5Mi5udW1wb2ludHM7IGkyMSsrKSB7XHJcbiAgICAgICAgICBpZiAoZDIubmVxKHBvbHkyLmdldFBvaW50KGkyMSkpKSBjb250aW51ZTtcclxuICAgICAgICAgIGkyMiA9IHBvbHkyLmdldE5leHRJKGkyMSk7XHJcbiAgICAgICAgICBpZiAoZDEubmVxKHBvbHkyLmdldFBvaW50KGkyMikpKSBjb250aW51ZTtcclxuICAgICAgICAgIGlzZGlhZ29uYWwgPSB0cnVlO1xyXG4gICAgICAgICAgb2JqZWN0XzJfaW5kZXggPSBzMjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNkaWFnb25hbCkgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghaXNkaWFnb25hbCkgY29udGludWU7XHJcbiAgICAgIHZhciBwMSwgcDIsIHAzO1xyXG4gICAgICBwMiA9IHBvbHkxLmdldFBvaW50KGkxMSk7XHJcbiAgICAgIGkxMyA9IHBvbHkxLmdldFByZXZJKGkxMSk7XHJcbiAgICAgIHAxID0gcG9seTEuZ2V0UG9pbnQoaTEzKTtcclxuICAgICAgaTIzID0gcG9seTIuZ2V0TmV4dEkoaTIyKTtcclxuICAgICAgcDMgPSBwb2x5Mi5nZXRQb2ludChpMjMpO1xyXG5cclxuICAgICAgaWYgKCFpc0NvbnZleChwMSwgcDIsIHAzKSkgY29udGludWU7XHJcblxyXG4gICAgICBwMiA9IHBvbHkxLmdldFBvaW50KGkxMik7XHJcbiAgICAgIGkxMyA9IHBvbHkxLmdldE5leHRJKGkxMik7XHJcbiAgICAgIHAzID0gcG9seTEuZ2V0UG9pbnQoaTEzKTtcclxuICAgICAgaTIzID0gcG9seTIuZ2V0UHJldkkoaTIxKTtcclxuICAgICAgcDEgPSBwb2x5Mi5nZXRQb2ludChpMjMpO1xyXG5cclxuICAgICAgaWYgKCFpc0NvbnZleChwMSwgcDIsIHAzKSkgY29udGludWU7XHJcblxyXG4gICAgICB2YXIgbmV3cG9seSA9IG5ldyBQb2x5KCk7XHJcbiAgICAgIG5ld3BvbHkuaW5pdChwb2x5MS5udW1wb2ludHMgKyBwb2x5Mi5udW1wb2ludHMgLSAyKTtcclxuICAgICAgdmFyIGsgPSAwO1xyXG4gICAgICBmb3IgKHZhciBqID0gaTEyOyBqICE9IGkxMTsgaiA9IHBvbHkxLmdldE5leHRJKGopKSB7XHJcbiAgICAgICAgbmV3cG9seS5zZXRQb2ludChrLCBwb2x5MS5nZXRQb2ludChqKSk7XHJcbiAgICAgICAgaysrO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAodmFyIGogPSBpMjI7IGogIT0gaTIxOyBqID0gcG9seTIuZ2V0TmV4dEkoaikpIHtcclxuICAgICAgICBuZXdwb2x5LnNldFBvaW50KGssIHBvbHkyLmdldFBvaW50KGopKTtcclxuICAgICAgICBrKys7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzMSA+IG9iamVjdF8yX2luZGV4KSB7XHJcbiAgICAgICAgdHJpYW5nbGVzW3MxXSA9IG5ld3BvbHk7XHJcbiAgICAgICAgcG9seTEgPSB0cmlhbmdsZXNbczFdO1xyXG4gICAgICAgIHRyaWFuZ2xlcy5zcGxpY2Uob2JqZWN0XzJfaW5kZXgsIDEpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRyaWFuZ2xlcy5zcGxpY2Uob2JqZWN0XzJfaW5kZXgsIDEpO1xyXG4gICAgICAgIHRyaWFuZ2xlc1tzMV0gPSBuZXdwb2x5O1xyXG4gICAgICAgIHBvbHkxID0gdHJpYW5nbGVzW3MxXTtcclxuICAgICAgfVxyXG4gICAgICBpMTEgPSAtMTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRyaWFuZ2xlcztcclxufTtcclxuIiwidmFyIGdlbyA9IHJlcXVpcmUoJy4vZ2VvbWV0cnknKTtcclxudmFyIGZpbmRQb2x5Rm9yUG9pbnQgPSBnZW8udXRpbC5maW5kUG9seUZvclBvaW50O1xyXG52YXIgUHJpb3JpdHlRdWV1ZSA9IHJlcXVpcmUoJ3ByaW9yaXR5LXF1ZXVlJyk7XHJcblxyXG4vKipcclxuICogUGF0aGZpbmRlciBpbXBsZW1lbnRzIHBhdGhmaW5kaW5nIG9uIGEgbmF2aWdhdGlvbiBtZXNoLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtBcnJheS48UG9seT59IHBvbHlzIC0gVGhlIHBvbHlnb25zIGRlZmluaW5nIHRoZSBuYXZpZ2F0aW9uIG1lc2guXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXQ9dHJ1ZV0gLSBXaGV0aGVyIG9yIG5vdCB0byBpbml0aWFsaXplIHRoZSBwYXRoZmluZGVyLlxyXG4gKi9cclxudmFyIFBhdGhmaW5kZXIgPSBmdW5jdGlvbihwb2x5cywgaW5pdCkge1xyXG4gIGlmICh0eXBlb2YgaW5pdCA9PSBcInVuZGVmaW5lZFwiKSBpbml0ID0gdHJ1ZTtcclxuICB0aGlzLnBvbHlzID0gcG9seXM7XHJcbiAgaWYgKGluaXQpIHtcclxuICAgIHRoaXMuaW5pdCgpO1xyXG4gIH1cclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBQYXRoZmluZGVyO1xyXG5cclxuUGF0aGZpbmRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xyXG4gIHRoaXMuZ3JpZCA9IHRoaXMuZ2VuZXJhdGVBZGphY2VuY3lHcmlkKHRoaXMucG9seXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIHBhdGggZnJvbSBzb3VyY2UgdG8gdGFyZ2V0LCB1c2luZyBzaWRlcyBhbmQgY2VudGVycyBvZiB0aGUgZWRnZXNcclxuICogYmV0d2VlbiBhZGphY2VudCBwb2x5Z29ucy4gc291cmNlIGFuZCB0YXJnZXQgYXJlIFBvaW50cyBhbmQgcG9seXMgc2hvdWxkXHJcbiAqIGJlIHRoZSBmaW5hbCBwYXJ0aXRpb25lZCBtYXAuXHJcbiAqIEBwYXJhbSB7UG9pbnR9IHNvdXJjZSAtIFRoZSBzdGFydCBsb2NhdGlvbiBmb3IgdGhlIHNlYXJjaC5cclxuICogQHBhcmFtIHtQb2ludH0gdGFyZ2V0IC0gVGhlIHRhcmdldCBsb2NhdGlvbiBmb3IgdGhlIHNlYXJjaC5cclxuICogQHJldHVybiB7P0FycmF5LjxQb2ludD59IC0gQSBzZXJpZXMgb2YgcG9pbnRzIHJlcHJlc2VudGluZyB0aGUgcGF0aCBmcm9tXHJcbiAqICAgdGhlIHNvdXJjZSB0byB0aGUgdGFyZ2V0LiBJZiBhIHBhdGggaXMgbm90IGZvdW5kLCBgbnVsbGAgaXMgcmV0dXJuZWQuXHJcbiAqL1xyXG5QYXRoZmluZGVyLnByb3RvdHlwZS5hU3RhciA9IGZ1bmN0aW9uKHNvdXJjZSwgdGFyZ2V0KSB7XHJcbiAgLy8gQ29tcGFyZXMgdGhlIHZhbHVlIG9mIHR3byBub2Rlcy5cclxuICBmdW5jdGlvbiBub2RlVmFsdWUobm9kZTEsIG5vZGUyKSB7XHJcbiAgICByZXR1cm4gKG5vZGUxLmRpc3QgKyBoZXVyaXN0aWMobm9kZTEucG9pbnQpKSAtIChub2RlMi5kaXN0ICsgaGV1cmlzdGljKG5vZGUyLnBvaW50KSk7XHJcbiAgfVxyXG5cclxuICAvLyBEaXN0YW5jZSBiZXR3ZWVuIHBvbHlnb25zLlxyXG4gIGZ1bmN0aW9uIGV1Y2xpZGVhbkRpc3RhbmNlKHAxLCBwMikge1xyXG4gICAgcmV0dXJuIHAxLmRpc3QocDIpO1xyXG4gIH1cclxuXHJcbiAgLy8gRGlzdGFuY2UgYmV0d2VlbiBwb2x5Z29ucy4gdG9kbzogdXBkYXRlXHJcbiAgZnVuY3Rpb24gbWFuaGF0dGFuRGlzdGFuY2UoZWx0MSwgZWx0Mikge1xyXG4gICAgcmV0dXJuIChlbHQxLnIgLSBlbHQyLnIpICsgKGVsdDEuYyAtIGVsdDIuYyk7XHJcbiAgfVxyXG5cclxuICAvLyBUYWtlcyBQb2ludCBhbmQgcmV0dXJucyB2YWx1ZS5cclxuICBmdW5jdGlvbiBoZXVyaXN0aWMocCkge1xyXG4gICAgcmV0dXJuIGV1Y2xpZGVhbkRpc3RhbmNlKHAsIHRhcmdldCk7XHJcbiAgfVxyXG5cclxuICB2YXIgc291cmNlUG9seSA9IGZpbmRQb2x5Rm9yUG9pbnQoc291cmNlLCB0aGlzLnBvbHlzKTtcclxuXHJcbiAgLy8gV2UncmUgb3V0c2lkZSBvZiB0aGUgbWVzaCBzb21laG93LiBUcnkgYSBmZXcgbmVhcmJ5IHBvaW50cy5cclxuICBpZiAoIXNvdXJjZVBvbHkpIHtcclxuICAgIHZhciBvZmZzZXRTb3VyY2UgPSBbbmV3IFBvaW50KDUsIDApLCBuZXcgUG9pbnQoLTUsIDApLCBuZXcgUG9pbnQoMCwgLTUpLCBuZXcgUG9pbnQoMCwgNSldO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvZmZzZXRTb3VyY2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgLy8gTWFrZSBuZXcgcG9pbnQuXHJcbiAgICAgIHZhciBwb2ludCA9IHNvdXJjZS5hZGQob2Zmc2V0U291cmNlW2ldKTtcclxuICAgICAgc291cmNlUG9seSA9IGZpbmRQb2x5Rm9yUG9pbnQocG9pbnQsIHRoaXMucG9seXMpO1xyXG4gICAgICBpZiAoc291cmNlUG9seSkge1xyXG4gICAgICAgIHNvdXJjZSA9IHBvaW50O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIXNvdXJjZVBvbHkpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHZhciB0YXJnZXRQb2x5ID0gZmluZFBvbHlGb3JQb2ludCh0YXJnZXQsIHRoaXMucG9seXMpO1xyXG5cclxuICAvLyBIYW5kbGUgdHJpdmlhbCBjYXNlLlxyXG4gIGlmIChzb3VyY2VQb2x5ID09IHRhcmdldFBvbHkpIHtcclxuICAgIHJldHVybiBbc291cmNlLCB0YXJnZXRdO1xyXG4gIH1cclxuXHJcbiAgLy8gV2FybmluZywgbWF5IGhhdmUgY29tcGF0aWJpbGl0eSBpc3N1ZXMuXHJcbiAgdmFyIGRpc2NvdmVyZWRQb2x5cyA9IG5ldyBXZWFrU2V0KCk7XHJcbiAgdmFyIGRpc2NvdmVyZWRQb2ludHMgPSBuZXcgV2Vha1NldCgpO1xyXG4gIHZhciBwcSA9IG5ldyBQcmlvcml0eVF1ZXVlKHsgY29tcGFyYXRvcjogbm9kZVZhbHVlIH0pO1xyXG4gIHZhciBmb3VuZCA9IG51bGw7XHJcbiAgLy8gSW5pdGlhbGl6ZSB3aXRoIHN0YXJ0IGxvY2F0aW9uLlxyXG4gIHBxLnF1ZXVlKHtkaXN0OiAwLCBwb2x5OiBzb3VyY2VQb2x5LCBwb2ludDogc291cmNlLCBwYXJlbnQ6IG51bGx9KTtcclxuICB3aGlsZSAocHEubGVuZ3RoID4gMCkge1xyXG4gICAgdmFyIG5vZGUgPSBwcS5kZXF1ZXVlKCk7XHJcbiAgICBpZiAobm9kZS5wb2x5ID09IHRhcmdldFBvbHkpIHtcclxuICAgICAgZm91bmQgPSBub2RlO1xyXG4gICAgICBicmVhaztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRpc2NvdmVyZWRQb2x5cy5hZGQobm9kZS5wb2x5KTtcclxuICAgICAgZGlzY292ZXJlZFBvaW50cy5hZGQobm9kZS5wb2ludCk7XHJcbiAgICB9XHJcbiAgICAvLyBUaGlzIG1heSBiZSB1bmRlZmluZWQgaWYgdGhlcmUgd2FzIG5vIHBvbHlnb24gZm91bmQuXHJcbiAgICB2YXIgbmVpZ2hib3JzID0gdGhpcy5ncmlkLmdldChub2RlLnBvbHkpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGVsdCA9IG5laWdoYm9yc1tpXTtcclxuICAgICAgdmFyIG5laWdoYm9yRm91bmQgPSBkaXNjb3ZlcmVkUG9seXMuaGFzKGVsdC5wb2x5KTtcclxuXHJcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWx0LmVkZ2UucG9pbnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgdmFyIHAgPSBlbHQuZWRnZS5wb2ludHNbal07XHJcbiAgICAgICAgaWYgKCFuZWlnaGJvckZvdW5kIHx8ICFkaXNjb3ZlcmVkUG9pbnRzLmhhcyhwKSlcclxuICAgICAgICAgIHBxLnF1ZXVlKHtkaXN0OiBub2RlLmRpc3QgKyBldWNsaWRlYW5EaXN0YW5jZShwLCBub2RlLnBvaW50KSwgcG9seTogZWx0LnBvbHksIHBvaW50OiBwLCBwYXJlbnQ6IG5vZGV9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGZvdW5kKSB7XHJcbiAgICB2YXIgcGF0aCA9IFtdO1xyXG4gICAgdmFyIGN1cnJlbnQgPSBmb3VuZDtcclxuICAgIHdoaWxlIChjdXJyZW50LnBhcmVudCkge1xyXG4gICAgICBwYXRoLnVuc2hpZnQoY3VycmVudC5wb2ludCk7XHJcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcclxuICAgIH1cclxuICAgIHBhdGgudW5zaGlmdChjdXJyZW50LnBvaW50KTtcclxuICAgIC8vIEFkZCBlbmQgcG9pbnQgdG8gcGF0aC5cclxuICAgIHBhdGgucHVzaCh0YXJnZXQpO1xyXG4gICAgcmV0dXJuIHBhdGg7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBIb2xkcyB0aGUgXCJuZWlnaGJvclwiIHJlbGF0aW9uc2hpcCBvZiBQb2x5IG9iamVjdHMgaW4gdGhlIHBhcnRpdGlvblxyXG4gKiB1c2luZyB0aGUgUG9seSdzIHRoZW1zZWx2ZXMgYXMga2V5cywgYW5kIGFuIGFycmF5IG9mIFBvbHkncyBhc1xyXG4gKiB2YWx1ZXMsIHdoZXJlIHRoZSBQb2x5cyBpbiB0aGUgYXJyYXkgYXJlIG5laWdoYm9ycyBvZiB0aGUgUG9seVxyXG4gKiB0aGF0IHdhcyB0aGUga2V5LlxyXG4gKiBAdHlwZWRlZiBBZGphY2VuY3lHcmlkXHJcbiAqIEB0eXBlIHtPYmplY3QuPFBvbHksIEFycmF5PFBvbHk+Pn1cclxuICovXHJcblxyXG4vKipcclxuICogR2l2ZW4gYW4gYXJyYXkgb2YgUG9seSBvYmplY3RzLCBmaW5kIGFsbCBuZWlnaGJvcmluZyBwb2x5Z29ucyBmb3JcclxuICogZWFjaCBwb2x5Z29uLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0FycmF5LjxQb2x5Pn0gcG9seXMgLSBUaGUgYXJyYXkgb2YgcG9seXMgdG8gZmluZCBuZWlnaGJvcnNcclxuICogICBhbW9uZy5cclxuICogQHJldHVybiB7QWRqYWNlbmN5R3JpZH0gLSBUaGUgXCJuZWlnaGJvclwiIHJlbGF0aW9uc2hpcHMuXHJcbiAqL1xyXG5QYXRoZmluZGVyLnByb3RvdHlwZS5nZW5lcmF0ZUFkamFjZW5jeUdyaWQgPSBmdW5jdGlvbihwb2x5cykge1xyXG4gIHZhciBuZWlnaGJvcnMgPSBuZXcgV2Vha01hcCgpO1xyXG4gIHBvbHlzLmZvckVhY2goZnVuY3Rpb24ocG9seSwgcG9seUksIHBvbHlzKSB7XHJcbiAgICBpZiAobmVpZ2hib3JzLmhhcyhwb2x5KSkge1xyXG4gICAgICAvLyBNYXhpbXVtIG51bWJlciBvZiBuZWlnaGJvcnMgYWxyZWFkeSBmb3VuZC5cclxuICAgICAgaWYgKG5laWdoYm9ycy5nZXQocG9seSkubGVuZ3RoID09IHBvbHkubnVtcG9pbnRzKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBJbml0aWFsaXplIGFycmF5LlxyXG4gICAgICBuZWlnaGJvcnMuc2V0KHBvbHksIG5ldyBBcnJheSgpKTtcclxuICAgIH1cclxuICAgIC8vIE9mIHJlbWFpbmluZyBwb2x5Z29ucywgZmluZCBzb21lIHRoYXQgYXJlIGFkamFjZW50LlxyXG4gICAgcG9seS5wb2ludHMuZm9yRWFjaChmdW5jdGlvbihwMSwgaSwgcG9pbnRzKSB7XHJcbiAgICAgIC8vIE5leHQgcG9pbnQuXHJcbiAgICAgIHZhciBwMiA9IHBvaW50c1twb2x5LmdldE5leHRJKGkpXTtcclxuICAgICAgZm9yICh2YXIgcG9seUogPSBwb2x5SSArIDE7IHBvbHlKIDwgcG9seXMubGVuZ3RoOyBwb2x5SisrKSB7XHJcbiAgICAgICAgdmFyIHBvbHkyID0gcG9seXNbcG9seUpdO1xyXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBwb2ludHMgdW50aWwgbWF0Y2ggaXMgZm91bmQuXHJcbiAgICAgICAgcG9seTIucG9pbnRzLnNvbWUoZnVuY3Rpb24ocTEsIGosIHBvaW50czIpIHtcclxuICAgICAgICAgIHZhciBxMiA9IHBvaW50czJbcG9seTIuZ2V0TmV4dEkoaildO1xyXG4gICAgICAgICAgdmFyIG1hdGNoID0gcDEuZXEocTIpICYmIHAyLmVxKHExKTtcclxuICAgICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICB2YXIgZWRnZSA9IG5ldyBFZGdlKHAxLCBwMik7XHJcbiAgICAgICAgICAgIG5laWdoYm9ycy5nZXQocG9seSkucHVzaCh7IHBvbHk6IHBvbHkyLCBlZGdlOiBlZGdlIH0pO1xyXG4gICAgICAgICAgICBpZiAoIW5laWdoYm9ycy5oYXMocG9seTIpKSB7XHJcbiAgICAgICAgICAgICAgbmVpZ2hib3JzLnNldChwb2x5MiwgbmV3IEFycmF5KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5laWdoYm9ycy5nZXQocG9seTIpLnB1c2goeyBwb2x5OiBwb2x5LCBlZGdlOiBlZGdlIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChuZWlnaGJvcnMuZ2V0KHBvbHkpLmxlbmd0aCA9PSBwb2x5Lm51bXBvaW50cykgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG4gIHJldHVybiBuZWlnaGJvcnM7XHJcbn07XHJcbiJdfQ==
